using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Zero5;
using Zero5.Util;
using Zero5.Data;
using Zero5.IO;
using System.Globalization;
using System.IO;
using System.Security.Cryptography;
using System.Configuration;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Data;
using System.Net;
using System.Net.Sockets;
using System.Collections;
using System.Runtime.InteropServices;
using System.Threading;
using System.ComponentModel;
using Zero5.IO.File.Csv.Resources;
using Debug = System.Diagnostics.Debug;
using System.Data.Common;
using System.Runtime.Serialization;
using System.Security.Permissions;
using System.Net.NetworkInformation;
#if !MOBILE
using System.Collections.Generic;
using System.Threading;
using System;
using System.Linq;
using System.Text;
using System.Net;
using System.Net.NetworkInformation;
using Zero5.IO.Scs.Communication;
using Zero5.Threading;
using Zero5.IO.Scs.Communication.Messengers;
using Zero5.IO.Scs.Communication.Messages;
using Zero5.IO.Scs.Communication.Channels;
using Zero5.IO.Scs.Communication.Protocols;
using Zero5.IO.Scs.Communication.EndPoints;
using Zero5.IO.Scs.Communication.Channels.Tcp;
using Zero5.IO.Scs.Communication.EndPoints.Tcp;
using System.Runtime.Serialization;
using System.Net.Sockets;
using Zero5.IO.Scs.Client;
using Zero5.IO.Scs.Server;
using Zero5.IO.Scs.Client.Tcp;
using Zero5.IO.Scs.Server.Tcp;
using System.IO;
using Zero5.IO.Scs.Communication.Protocols.BinarySerialization;
using System.Runtime.Serialization.Formatters.Binary;
using Zero5.Collections;
using System.Threading.Tasks;
#endif
#if !MOBILE && !CORE
using System;
using System.ComponentModel;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Data;
using System.IO;
using System.Security;
using System.Security.Cryptography;
using System.Security.Principal;
using System.Diagnostics;
using SWF = System.Windows.Forms;
using System.Collections.ObjectModel;
using System.Xml;
using System.Globalization;
using System.Reflection;
using System.Runtime.Serialization;
using System.Xml.Schema;
using System.Collections;
using System.Drawing.Drawing2D;
using System.Drawing.Text;
using System.Drawing.Printing;
using System.Threading;
using Renci.SshNet.Common;
using System.Net.Sockets;
using Renci.SshNet.Messages.Transport;
using Renci.SshNet.Security.Cryptography;
using Renci.SshNet.Security;
using Renci.SshNet.Messages.Connection;
using Renci.SshNet.Messages.Authentication;
using Renci.SshNet.Security.Cryptography.Ciphers.Modes;
using Renci.SshNet.Security.Cryptography.Ciphers;
using System.Net;
using Renci.SshNet.Channels;
using Renci.SshNet.Sftp;
using Renci.SshNet.NetConf;
using Renci.SshNet.Messages;
using System.Diagnostics.CodeAnalysis;
using Renci.SshNet.Security.Cryptography.Ciphers.Paddings;
using Renci.SshNet.Compression;
using System.Threading.Tasks;
using Renci.SshNet.Sftp.Responses;
using Renci.SshNet.Sftp.Requests;
#endif
#if !CORE
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
#endif
#if SERVICE
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Windows.Forms;
#endif
#if !MONO && !MOBILE && !CORE
using System;
using System.Drawing;
using System.Drawing.Printing;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.IO;
#endif
// file ...\FileConfigurazione.cs

namespace CommonLibrary
{
    class FileConfigurazione : FileParametri
    {
        public FileConfigurazione() : base(Util.LocalPathFile("CommonLibrary.cfg"))
        {
            this.AbilitaTrace = this.AbilitaTrace;
        }

        public bool AbilitaTrace
        {
            get
            {
                return GetParametroAsInt("AbilitaTrace", 0) > 0;
            }
            set
            {
                SetParametro("AbilitaTrace", value ? 1 : 0);
            }
        }
    }
}
// file ...\Globalization.cs

namespace Zero5
{
    public class Globalization
    {

        // Need a calendar.  Culture's irrelevent since we specify start day of week
        private static Calendar cal = CultureInfo.InvariantCulture.Calendar;

        // This presumes that weeks start with Monday.
        // Week 1 is the 1st week of the year with a Thursday in it.
        public static int GetIso8601WeekOfYear(DateTime time)
        {
            // Seriously cheat.  If its Monday, Tuesday or Wednesday, then it'll 
            // be the same week# as whatever Thursday, Friday or Saturday are,
            // and we always get those right
            DayOfWeek day = cal.GetDayOfWeek(time);
            if (day >= DayOfWeek.Monday && day <= DayOfWeek.Wednesday)
            {
                time = time.AddDays(3);
            }

            // Return the week of our adjusted day
            return cal.GetWeekOfYear(time, CalendarWeekRule.FirstFourDayWeek, DayOfWeek.Monday);
        }
    }
}
// file ...\Mobile.cs
#if MOBILE
namespace Zero5.IO.Scs.Communication.Messengers { }
namespace Zero5.IO.Scs.Communication.Messages { }
namespace Zero5.IO.Scs.Communication.Channels { }
namespace Zero5.IO.Scs.Communication.Protocols { }
namespace Zero5.IO.Scs.Communication.EndPoints { }
namespace Zero5.IO.Scs.Communication.Channels.Tcp { }
namespace Zero5.IO.Scs.Communication.EndPoints.Tcp { }
namespace Zero5.IO.Scs.Client { }
namespace Zero5.IO.Scs.Server { }
namespace Zero5.IO.Scs.Client.Tcp { }
namespace Zero5.IO.Scs.Server.Tcp { }
namespace Zero5.IO.Scs.Communication.Protocols.BinarySerialization { }
namespace System.Runtime.Serialization.Formatters.Binary { }
namespace System.Drawing.Printing { }
namespace System.Threading.Tasks { }
namespace System.Security.Principal { }
namespace Zero5.Collections { }
namespace Zero5.Threading { }
namespace System.Drawing 
{
    public class SystemFonts
    {
        public static System.Drawing.Font DefaultFont = new System.Drawing.Font("Arial", 10, System.Drawing.FontStyle.Regular);
    }
}

namespace System.Net.NetworkInformation { }
namespace Renci.SshNet.Common { }
namespace Renci.SshNet.Messages.Transport { }
namespace Renci.SshNet.Security.Cryptography { }
namespace Renci.SshNet.Security { }
namespace Renci.SshNet.Messages.Connection { }
namespace Renci.SshNet.Messages.Authentication { }
namespace Renci.SshNet.Security.Cryptography.Ciphers.Modes { }
namespace Renci.SshNet.Security.Cryptography.Ciphers { }
namespace Renci.SshNet.Channels { }
namespace Renci.SshNet.Sftp { }
namespace Renci.SshNet.NetConf { }
namespace Renci.SshNet.Messages { }
namespace System.Diagnostics.CodeAnalysis { }
namespace Renci.SshNet.Security.Cryptography.Ciphers.Paddings { }
namespace Renci.SshNet.Compression { }
namespace Renci.SshNet.Sftp.Responses { }
namespace Renci.SshNet.Sftp.Requests { }
#endif
// file ...\TryParse.cs
namespace System
{
    public class intTryParse
    {
        public static bool TryParse(string s, out int result)
        {
#if !MOBILE && !CORE
            return int.TryParse(s, out result);
#else
            result = 0;
            try
            {
                result = int.Parse(s);
            }
            catch 
            {
                return false;
            }
            return true;
#endif
        }
    }

    public class byteTryParse
    {
        public static bool TryParse(string s, out byte result)
        {
#if !MOBILE && !CORE
            return byte.TryParse(s, out result);
#else
            result = 0;
            try
            {
                result = byte.Parse(s);
            }
            catch 
            {
                return false;
            }
            return true;
#endif
        }
    }
}
// file ...\Collections\ThreadSafeSortedList.cs
#if !MOBILE

namespace Zero5.Collections
{
    /// <summary>
    /// This class is used to store key-value based items in a thread safe manner.
    /// It uses System.Collections.Generic.SortedList internally.
    /// </summary>
    /// <typeparam name="TK">Key type</typeparam>
    /// <typeparam name="TV">Value type</typeparam> 
    public class ThreadSafeSortedList<TK, TV>
    {
        /// <summary>
        /// Gets/adds/replaces an item by key.
        /// </summary>
        /// <param name="key">Key to get/set value</param>
        /// <returns>Item associated with this key</returns>
        public TV this[TK key]
        {
            get
            {
                _lock.EnterReadLock();
                try
                {
                    return _items.ContainsKey(key) ? _items[key] : default(TV); 
                }
                finally
                {
                    _lock.ExitReadLock();
                }
            }

            set
            {
                _lock.EnterWriteLock();
                try
                {
                    _items[key] = value;
                }
                finally
                {
                    _lock.ExitWriteLock();
                }
            }
        }

        /// <summary>
        /// Gets count of items in the collection.
        /// </summary>
        public int Count
        {
            get
            {
                _lock.EnterReadLock();
                try
                {
                    return _items.Count;
                }
                finally
                {
                    _lock.ExitReadLock();
                }
            }
        }

        /// <summary>
        /// Internal collection to store items.
        /// </summary>
        protected readonly SortedList<TK, TV> _items;

        /// <summary>
        /// Used to synchronize access to _items list.
        /// </summary>
        protected readonly ReaderWriterLockSlim _lock;

        /// <summary>
        /// Creates a new ThreadSafeSortedList object.
        /// </summary>
        public ThreadSafeSortedList()
        {
            _items = new SortedList<TK, TV>();
            _lock = new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion);
        }

        /// <summary>
        /// Checks if collection contains spesified key.
        /// </summary>
        /// <param name="key">Key to check</param>
        /// <returns>True; if collection contains given key</returns>
        public bool ContainsKey(TK key)
        {
            _lock.EnterReadLock();
            try
            {
                return _items.ContainsKey(key);
            }
            finally
            {
                _lock.ExitReadLock();
            }
        }

        /// <summary>
        /// Checks if collection contains spesified item.
        /// </summary>
        /// <param name="item">Item to check</param>
        /// <returns>True; if collection contains given item</returns>
        public bool ContainsValue(TV item)
        {
            _lock.EnterReadLock();
            try
            {
                return _items.ContainsValue(item);
            }
            finally
            {
                _lock.ExitReadLock();
            }
        }

        /// <summary>
        /// Removes an item from collection.
        /// </summary>
        /// <param name="key">Key of item to remove</param>
        public bool Remove(TK key)
        {
            _lock.EnterWriteLock();
            try
            {
                if (!_items.ContainsKey(key))
                {
                    return false;
                }

                _items.Remove(key);
                return true;
            }
            finally
            {
                _lock.ExitWriteLock();
            }
        }

        /// <summary>
        /// Gets all items in collection.
        /// </summary>
        /// <returns>Item list</returns>
        public List<TV> GetAllItems()
        {
            _lock.EnterReadLock();
            try
            {
                return new List<TV>(_items.Values);
            }
            finally
            {
                _lock.ExitReadLock();
            }
        }

        /// <summary>
        /// Removes all items from list.
        /// </summary>
        public void ClearAll()
        {
            _lock.EnterWriteLock();
            try
            {
                _items.Clear();
            }
            finally
            {
                _lock.ExitWriteLock();
            }
        }

        /// <summary>
        /// Gets then removes all items in collection.
        /// </summary>
        /// <returns>Item list</returns>
        public List<TV> GetAndClearAllItems()
        {
            _lock.EnterWriteLock();
            try
            {
                var list = new List<TV>(_items.Values);
                _items.Clear();
                return list;
            }
            finally
            {
                _lock.ExitWriteLock();
            }
        }
    }
}
#endif
// file ...\Controls\Common.cs

namespace Zero5.Controls
{
    public class Common
    {
        public static int BorderSize = 2;
        public static System.Drawing.Color SelectedColor = System.Drawing.Color.FromArgb(255, 128, 0);
        public static int GridSize = 5;

        public static System.Drawing.Color ForeColor = System.Drawing.SystemColors.ControlText;
        public static System.Drawing.Color LineColor = System.Drawing.Color.Green;
        public static System.Drawing.Color BackColor = System.Drawing.Color.White;
        public static System.Drawing.Color BorderColor = System.Drawing.Color.White;
        public static System.Drawing.Color ButtonBorderColor = System.Drawing.Color.Green;


        public enum TextAlign
        {
            Center = 0,
            Left = 1,
            Right
        }

        public enum TextStyle
        {
            Normal = 0,
            Outline = 1,
            Shadow = 2
        }

        public static void DrawText(System.Drawing.Graphics g, string t, System.Drawing.Font f, System.Drawing.Brush b, System.Drawing.Brush bAlt, int x, int y, int w, int h, bool bShadow, bool bOutline, TextAlign alignText, bool autoSize)
        {
            DrawText(g, t, f, b, bAlt, x, y, w, h, bShadow, bOutline, 1, alignText, autoSize);
        }

        public static void DrawText(System.Drawing.Graphics g, string t, System.Drawing.Font f, System.Drawing.Brush b, System.Drawing.Brush bAlt, int x, int y, int w, int h, bool bShadow, bool bOutline, int outlineThickness, TextAlign alignText, bool autoSize)
        {

            int x_tmp;
            int y_tmp;
            System.Drawing.SizeF s;

            s = g.MeasureString(t, f);
            if (s.Width < w && s.Height < h)
            {
                //x_tmp = x;
                //if (alignText == Align.Center) x_tmp = (int)(x + (w / 2.0) - (s.Width / 2.0));
                switch (alignText)
                {
                    case TextAlign.Center:
                        x_tmp = (int)(x + (w / 2.0) - (s.Width / 2.0));
                        break;
                    case TextAlign.Right:
                        x_tmp = (int)(x + w - s.Width);
                        break;
                    default:
                        x_tmp = x;
                        break;
                }
                y_tmp = (int)(y + (h / 2.0) - (s.Height / 2.0));
                DrawText(g, t, f, b, bAlt, x_tmp, y_tmp, bShadow, bOutline, outlineThickness);
            }
            else
            {
                string[] t_todraw = null;
                if (t.IndexOf("\r\n") >= 0)
                {
                    t_todraw = t.Replace("\r", "").Split('\n');
                }
                else
                {
                    StringBuilder rows = SplitText(g, f, t, w);
                    t_todraw = rows.ToString().Split('\n');
                }
#if !MOBILE && !CORE
                if (autoSize)
                    while (f.Size > 3)
                    {
                        s = g.MeasureString(t_todraw[0].Trim(), f);
                        if (bOutline)
                        {
                            s.Height += outlineThickness;
                            s.Width += outlineThickness;
                        }
                        y_tmp = (int)(y + (h / 2.0) - (s.Height * (t_todraw.Length / 2.0)));
                        if (bOutline)
                            y_tmp += outlineThickness;
                        if (y_tmp > y) break;
                        f = new System.Drawing.Font(f.FontFamily, (float)(f.Size * 0.95));
                    }
#endif

                for (int i = 0; i < t_todraw.Length; i++)
                {
                    s = g.MeasureString(t_todraw[i].Trim(), f);
                    if (bOutline)
                    {
                        s.Height += outlineThickness;
                        s.Width += outlineThickness;
                    }
                    if (autoSize && s.Width > w)
                    {
                        while (f.Size > 3)
                        {
#if MOBILE || CORE
                            break;
#else
                            f = new System.Drawing.Font(f.FontFamily, (float)(f.Size * 0.95));
                            s = g.MeasureString(t_todraw[i].Trim(), f);
                            if (s.Width < w) break;
#endif

                        }
                    }
                    switch (alignText)
                    {
                        case TextAlign.Center:
                            x_tmp = (int)(x + (w / 2.0) - (s.Width / 2.0));
                            if (bOutline) x_tmp += outlineThickness;
                            break;
                        case TextAlign.Right:
                            x_tmp = (int)(x + w - s.Width);
                            if (bOutline) x_tmp -= outlineThickness;
                            break;
                        default:
                            x_tmp = x;
                            if (bOutline)
                                x_tmp += outlineThickness;
                            break;
                    }
                    //x_tmp = x;
                    //if (alignText == Align.Center) x_tmp = (int)(x + (w / 2.0) - (s.Width / 2.0));
                    y_tmp = (int)(y + (h / 2.0) - (s.Height * (t_todraw.Length / 2.0 - i)));

                    DrawText(g, t_todraw[i], f, b, bAlt, x_tmp, y_tmp, bShadow, bOutline, outlineThickness);
                }
            }
        }

        public static void DrawText(System.Drawing.Graphics g, string t, System.Drawing.Font f, System.Drawing.Brush b, System.Drawing.Brush bAlt, int x, int y, bool bShadow, bool bOutline)
        {
            DrawText(g, t, f, b, bAlt, x, y, bShadow, bOutline, 1);
        }
        public static void DrawText(System.Drawing.Graphics g, string t, System.Drawing.Font f, System.Drawing.Brush b, System.Drawing.Brush bAlt, int x, int y, bool bShadow, bool bOutline, int outlineWidth)
        {
#if !MOBILE && !CORE 
            if (bOutline) { DrawTextOutline(g, t, f, b, bAlt, x, y, outlineWidth); return; }
#endif
            if (bShadow) { DrawTextShadow(g, t, f, b, bAlt, x, y); return; }
            g.DrawString(t, f, b, x - outlineWidth, y - outlineWidth);
        }

        public static StringBuilder SplitText(System.Drawing.Graphics g, System.Drawing.Font f, string t, int w)
        {
            StringBuilder rows = new StringBuilder();
            string[] words;
            string temp;
            System.Drawing.SizeF s;

            words = t.Split(' ');
            temp = "";

            for (int i = 0; i < words.Length; i++)
            {
                s = g.MeasureString((temp + " " + words[i]).Trim(), f);
                if (s.Width > w)
                {
                    if (temp.Trim().Length > 0)
                    {
                        rows.Append(temp.Trim());
                        rows.Append('\n');
                    }
                    temp = words[i];
                }
                else
                {
                    temp += " " + words[i];
                }
            }
            if (temp.Trim().Length > 0)
            {
                rows.Append(temp.Trim());
            }
            return rows;
        }

#if !MOBILE && !CORE
        private static void DrawTextOutline(System.Drawing.Graphics g, string t, System.Drawing.Font f, System.Drawing.Brush b, System.Drawing.Brush bOut, int x, int y, int outlineWidth)
        {
            if (outlineWidth == 1)
            {
                g.DrawString(t, f, bOut, x - 1, y - 1);
                g.DrawString(t, f, bOut, x - 1, y);
                g.DrawString(t, f, bOut, x - 1, y + 1);
                g.DrawString(t, f, bOut, x + 1, y - 1);
                g.DrawString(t, f, bOut, x + 1, y);
                g.DrawString(t, f, bOut, x + 1, y + 1);
                g.DrawString(t, f, bOut, x, y - 1);
                g.DrawString(t, f, bOut, x, y + 1);
            }
            else if (outlineWidth > 1)
            {
                System.Drawing.Drawing2D.GraphicsPath p = new System.Drawing.Drawing2D.GraphicsPath();
                p.AddString(t, f.FontFamily, (int)f.Style, g.DpiY * f.SizeInPoints / 72, new System.Drawing.Point(x - 1, y - 1), new System.Drawing.StringFormat());

                System.Drawing.Pen pen;
                if (!dicPenByBrushAndSize.ContainsKey(bOut))
                    dicPenByBrushAndSize.Add(bOut, new Dictionary<int, System.Drawing.Pen>());

                if (dicPenByBrushAndSize[bOut].ContainsKey(outlineWidth))
                    pen = dicPenByBrushAndSize[bOut][outlineWidth];
                else
                {
                    pen = new System.Drawing.Pen(bOut, outlineWidth * 2);
                    dicPenByBrushAndSize[bOut].Add(outlineWidth, pen);
                }

                g.DrawPath(pen, p);
            }
            g.DrawString(t, f, b, x, y);
        }
#endif

        private static Dictionary<System.Drawing.Brush, Dictionary<int, System.Drawing.Pen>> dicPenByBrushAndSize = new Dictionary<System.Drawing.Brush, Dictionary<int, System.Drawing.Pen>>();

        private static void DrawTextShadow(System.Drawing.Graphics g, string t, System.Drawing.Font f, System.Drawing.Brush b, System.Drawing.Brush bShad, int x, int y)
        {
            g.DrawString(t, f, bShad, x + 1, y);
            //g.DrawString(t, f, bShad, x + 1, y + 1);
            //g.DrawString(t, f, bShad, x, y + 1);
            g.DrawString(t, f, b, x, y);
        }

        public static System.Drawing.Color Light(System.Drawing.Color c)
        {
#if MOBILE || CORE
            return c;
#else
            return System.Windows.Forms.ControlPaint.Light(c);
#endif
        }

        public static System.Drawing.Color LightLight(System.Drawing.Color c)
        {
#if MOBILE || CORE
            return c;
#else
            return System.Windows.Forms.ControlPaint.LightLight(c);
#endif
        }

        public static System.Drawing.Color Dark(System.Drawing.Color c)
        {
#if MOBILE || CORE
            return c;
#else
            return System.Windows.Forms.ControlPaint.Dark(c);
#endif
        }

        public static System.Drawing.Color DarkDark(System.Drawing.Color c)
        {
#if MOBILE || CORE
            return c;
#else
            return System.Windows.Forms.ControlPaint.DarkDark(c);
#endif
        }

        public static byte[] ImageToByte(System.Drawing.Image img)
        {
            try
            {
                System.IO.MemoryStream oStream = new System.IO.MemoryStream();
                img.Save(oStream, System.Drawing.Imaging.ImageFormat.Png);
                byte[] result = oStream.ToArray();
                oStream.Close();
                return result;
            }
            catch { return new byte[] { 0 }; }
        }

        public static byte[] PdfToByte(string pathToFile)
        {
            byte[] bytes = System.IO.File.ReadAllBytes(pathToFile);

            return bytes;
        }

        public static System.Drawing.Image ByteToImage(byte[] data)
        {
            try
            {

#if !MOBILE && !CORE
                System.IO.MemoryStream oStream = new System.IO.MemoryStream();
                oStream.Write(data, 0, data.Length);
                System.Drawing.Image img = System.Drawing.Image.FromStream(oStream);
                oStream.Close();
                return img;
#else
                System.IO.MemoryStream oStream = new System.IO.MemoryStream();
                oStream.Write(data, 0, data.Length);
                System.Drawing.Image img = new System.Drawing.Bitmap(oStream);
                oStream.Close();
                return img;
#endif
            }
            catch { return null; }
        }

        public static System.Drawing.Color GetForegroundColor(System.Drawing.Color BackgroundColor)
        {
            if (BackgroundColor == System.Drawing.Color.Empty || BackgroundColor == System.Drawing.Color.Transparent)
                return System.Drawing.Color.Black;

            int brightness = (int)Math.Sqrt(
                BackgroundColor.R * BackgroundColor.R * .241 +
                BackgroundColor.G * BackgroundColor.G * .691 +
                BackgroundColor.B * BackgroundColor.B * .068);

            if (brightness < 160)
                return System.Drawing.Color.White;
            else
                return System.Drawing.Color.Black;
        }

        public static byte[] GetThumbnail(byte[] baseImage)
        {
#if !MOBILE && !CORE
            if (FileIsImage(baseImage))
            {
                System.IO.MemoryStream imageStream = new System.IO.MemoryStream(baseImage);
                System.Drawing.Image img = System.Drawing.Image.FromStream(imageStream);
                System.Drawing.Image thumb = GetThumbnail(img);
                img.Dispose();
                imageStream.Close();
                return ImageToByte(thumb);
            }
#endif
            return new byte[0];
        }

        public static System.Drawing.Image GetThumbnail(System.Drawing.Image baseImg)
        {
#if !MOBILE && !CORE
            int sourceWidth = baseImg.Width;
            int sourceHeight = baseImg.Height;
            int finalWidth = 100;
            int finalHeight = 100;
            int destX = 0;
            int destY = 0;

            float nPercent = 0;
            float nPercentW = 0;
            float nPercentH = 0;

            nPercentW = ((float)finalWidth / (float)sourceWidth);
            nPercentH = ((float)finalHeight / (float)sourceHeight);
            if (nPercentH < nPercentW)
            {
                nPercent = nPercentH;
                destX = System.Convert.ToInt16((finalWidth -
                              (sourceWidth * nPercent)) / 2);
            }
            else
            {
                nPercent = nPercentW;
                destY = System.Convert.ToInt16((finalHeight -
                              (sourceHeight * nPercent)) / 2);
            }

            int destWidth = (int)(sourceWidth * nPercent);
            int destHeight = (int)(sourceHeight * nPercent);

            System.Drawing.Bitmap bmPhoto = new System.Drawing.Bitmap(finalWidth, finalHeight, System.Drawing.Imaging.PixelFormat.Format24bppRgb);
            bmPhoto.SetResolution(baseImg.HorizontalResolution,
                             baseImg.VerticalResolution);

            System.Drawing.Graphics grPhoto = System.Drawing.Graphics.FromImage(bmPhoto);
            grPhoto.Clear(System.Drawing.Color.WhiteSmoke);
            grPhoto.InterpolationMode =
                    System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;

            grPhoto.DrawImage(baseImg,
                new System.Drawing.Rectangle(destX, destY, destWidth, destHeight),
                new System.Drawing.Rectangle(0, 0, sourceWidth, sourceHeight),
                System.Drawing.GraphicsUnit.Pixel);

            grPhoto.Dispose();
            return bmPhoto;
#else
            return baseImg;
#endif
        }

        public static bool FileIsImage(byte[] Image)
        {
            System.IO.MemoryStream imageStream = new System.IO.MemoryStream(Image);
            if (imageStream.Length > 4)
            {
                byte[] header = new byte[4]; // Change size if needed.
                string[] imageHeaders = new[]{
                "\xFF\xD8", // JPEG
                "BM",       // BMP
                "GIF",      // GIF
                Encoding.ASCII.GetString(new byte[] { 137, 80, 78, 71 }, 0, 4), // PNG
                Encoding.ASCII.GetString(new byte[] { 73, 73, 42 }, 0, 3),         // TIFF
                Encoding.ASCII.GetString(new byte[] { 77, 77, 42 }, 0, 3),         // TIFF
                Encoding.ASCII.GetString(new byte[] { 255, 216, 255, 224 }, 0, 4), // jpeg
                Encoding.ASCII.GetString(new byte[] { 255, 216, 255, 225 }, 0, 4)}; // jpeg canon

                imageStream.Read(header, 0, header.Length);

                bool isImageHeader = false;
                for (int i = 0; i < imageHeaders.Length && !isImageHeader; i++)
                    isImageHeader = Encoding.ASCII.GetString(header, 0, header.Length).StartsWith(imageHeaders[i]);

                //if (isImageHeader == true) //Verifica opzionale
                //{
                //    try
                //    {
                //        System.Drawing.Image.FromStream(imageStream).Dispose();
                //        imageStream.Close();
                //        return true;
                //    }

                //    catch
                //    {

                //    }
                //}

                imageStream.Close();
                return isImageHeader;
            }
            imageStream.Close();
            return false;

        }
    }
}
// file ...\Controls\DropdownControl.cs
#if !MOBILE && !CORE
// Copyright © Serge Weinstock 2014.
//
// This library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this library.  If not, see <http://www.gnu.org/licenses/>.


namespace Zero5.Controls
{
    /// <summary>
    /// A dropdown window for combos.
    /// </summary>
    [ToolboxItem(false)]
    public class DropdownControl : ToolStripDropDown, IMessageFilter
    {
#region Properties
        /// <summary>
        /// Gets the content of the pop-up.
        /// </summary>
        public Control Content { get; private set; }
#endregion

#region Fields
        /// <summary>The toolstrip host</summary>
        private ToolStripControlHost m_host;
        /// <summary>The control for which we display this dropdown</summary>
        private Control m_opener;
#endregion
        
        /// <summary>
        /// Constructor
        /// </summary>
        public DropdownControl(Control content)
        {
            if (content == null)
            {
                throw new ArgumentNullException("content");
            }
            Content = content;
            Content.Location = Point.Empty;
            m_host = new ToolStripControlHost(Content);
            // NB: AutoClose must be set to false, because otherwise the ToolStripManager would steal keyboard events
            AutoClose = false;
            // we do ourselves the sizing
            AutoSize = false;
            DoubleBuffered = true;
            ResizeRedraw = false;
            Padding = Margin = m_host.Padding = m_host.Margin = Padding.Empty;
            // we adjust the size according to the contents
            MinimumSize = Content.MinimumSize;
            content.MinimumSize = Content.Size;
            MaximumSize = Content.MaximumSize;
            content.MaximumSize = Content.Size;
            Size = Content.Size;
            TabStop = Content.TabStop = true;
            // set up the content
            Items.Add(m_host);
            // we must listen to mouse events for "emulating" AutoClose
            Application.AddMessageFilter(this);
        }

        /// <summary>
        /// Display the dropdown and adjust its size and location
        /// </summary>
        public void Show(Control opener, Size preferredSize)
        {
            if (opener == null)
            {
                throw new ArgumentNullException("opener");
            }

            m_opener = opener;

            int w = preferredSize.Width == 0 ? ClientRectangle.Width : preferredSize.Width;
            int h = preferredSize.Height == 0 ? Content.Height : preferredSize.Height;
            h += Padding.Size.Height + Content.Margin.Size.Height;

            Rectangle screen = Screen.FromControl(m_opener).WorkingArea;

            // let's try first to place it below the opener control
            Rectangle loc = m_opener.RectangleToScreen(
                new Rectangle(m_opener.ClientRectangle.Left, m_opener.ClientRectangle.Bottom,
                    m_opener.ClientRectangle.Left + w, m_opener.ClientRectangle.Bottom + h));
            Point cloc = new Point(m_opener.ClientRectangle.Left, m_opener.ClientRectangle.Bottom);
            if (!screen.Contains(loc))
            {
                // let's try above the opener control
                loc = m_opener.RectangleToScreen(
                    new Rectangle(m_opener.ClientRectangle.Left, m_opener.ClientRectangle.Top - h,
                        m_opener.ClientRectangle.Left + w, m_opener.ClientRectangle.Top));
                if (screen.Contains(loc))
                {
                    cloc = new Point(m_opener.ClientRectangle.Left, m_opener.ClientRectangle.Top-h);
                }
            }
            Width = w;
            Height = h;
            Show(m_opener, cloc, ToolStripDropDownDirection.BelowRight);
        }

#region internals
        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (Content != null)
                {
                    Content.Dispose();
                    Content = null;
                }
                Application.RemoveMessageFilter(this);
            }
            base.Dispose(disposing);
        }

        /// <summary>
        /// On resizes, resize the contents
        /// </summary>
        protected override void OnSizeChanged(EventArgs e)
        {
            if (Content != null)
            {
                Content.MinimumSize = Size;
                Content.MaximumSize = Size;
                Content.Size = Size;
                Content.Location = Point.Empty;
            }
            base.OnSizeChanged(e);
        }
#endregion

#region IMessageFilter implementation
        private const int WM_LBUTTONDOWN = 0x0201;
        private const int WM_RBUTTONDOWN = 0x0204;
        private const int WM_MBUTTONDOWN = 0x0207;
        private const int WM_NCLBUTTONDOWN = 0x00A1;
        private const int WM_NCRBUTTONDOWN = 0x00A4;
        private const int WM_NCMBUTTONDOWN = 0x00A7;

        [DllImport("user32.dll", ExactSpelling = true, CharSet = CharSet.Auto)]
        public static extern int MapWindowPoints(IntPtr hWndFrom, IntPtr hWndTo, [In, Out] ref Point pt, int cPoints);

        /// <summary>
        /// We monitor all messages in order to detect when the users clicks outside the dropdown and the combo
        /// If this happens, we close the dropdown (as AutoClose is false)
        /// </summary>
        public bool PreFilterMessage(ref Message m)
        {
            if (Visible)
            {
                switch (m.Msg)
                {
                    case WM_LBUTTONDOWN:
                    case WM_RBUTTONDOWN:
                    case WM_MBUTTONDOWN:
                    case WM_NCLBUTTONDOWN:
                    case WM_NCRBUTTONDOWN:
                    case WM_NCMBUTTONDOWN:
                        int i = unchecked((int)(long)m.LParam);
                        short x = (short)(i & 0xFFFF);
                        short y = (short)((i >> 16) & 0xffff);
                        Point pt = new Point(x, y);
                        IntPtr srcWnd =
                            // client area: x, y are relative to the client area of the windows
                            (m.Msg == WM_LBUTTONDOWN) || (m.Msg == WM_RBUTTONDOWN) || (m.Msg == WM_MBUTTONDOWN) ?
                            m.HWnd :
                            // non-client area: x, y are relative to the desktop
                            IntPtr.Zero;
                        
                        MapWindowPoints(srcWnd, Handle, ref pt, 1);
                        if (!ClientRectangle.Contains(pt))
                        {
                            // the user has clicked outside the dropdown
                            pt = new Point(x, y);
                            MapWindowPoints(srcWnd, m_opener.Handle, ref pt, 1);
                            if (!m_opener.ClientRectangle.Contains(pt))
                            {
                                // the user has clicked outside the opener control
                                Close();
                            }
                        }
                        break;
                }
            }
            return false;
        }
#endregion
    }
}
#endif
// file ...\Controls\EasyCompletionComboBox.cs
#if !MOBILE && !CORE
// Copyright © Serge Weinstock 2014.
//
// This library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this library.  If not, see <http://www.gnu.org/licenses/>.


namespace Zero5.Controls
{
    /// <summary>
    /// This is a combobox with a suggestion list à la "Sublime Text"
    /// 
    /// Searches are made against the pattern in the combo textbox by matching
    /// all the characters in the pattern in the right order but not consecutively
    /// </summary>
    public class EasyCompletionComboBox : System.Windows.Forms.ComboBox
    {
#region fields and properties
        /// <summary>our custom drowp down control</summary>
        private readonly DropdownControl m_dropDown;
        /// <summary>the suggestion list inside the drop down control</summary>
        private readonly ListBox m_suggestionList;
        /// <summary>the bold font used for drawing strings in the listbox</summary>
        private Font m_boldFont;
        /// <summary>Allows to know if the last text change is triggered by the keyboard</summary>
        private bool m_fromKeyboard;
        /// <summary>How do we match user input to strings?</summary>
        private StringMatchingMethod m_matchingMethod;
#endregion

        /// <summary>
        /// constructor
        /// </summary>
        public EasyCompletionComboBox()
        {
            m_matchingMethod = StringMatchingMethod.ContainsCaseInsensitive;
            // we're overriding these
            DropDownStyle = ComboBoxStyle.DropDown;
            AutoCompleteMode = AutoCompleteMode.None;
            // let's build our suggestion list
            m_suggestionList = new ListBox
            {
                DisplayMember = "Text",
                TabStop = false, 
                Dock = DockStyle.Fill,
                DrawMode = DrawMode.OwnerDrawFixed,
                IntegralHeight = true,
                Sorted = Sorted,
            };
            m_suggestionList.Click += onSuggestionListClick;
            m_suggestionList.DrawItem += onSuggestionListDrawItem;
            FontChanged += onFontChanged;
            m_suggestionList.MouseMove += onSuggestionListMouseMove;
            m_dropDown = new DropdownControl(m_suggestionList);
            onFontChanged(null, null);
        }

        /// <summary>
        /// <see cref="ComboBox.Dispose(bool)"/>
        /// </summary>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (m_boldFont != null)
                {
                    m_boldFont.Dispose();
                }
                m_dropDown.Dispose();
            }
            base.Dispose(disposing);
        }

#region size and position of suggest box
        /// <summary>
        /// <see cref="ComboBox.OnLocationChanged(EventArgs)"/>
        /// </summary>
        protected override void OnLocationChanged(EventArgs e)
        {
            base.OnLocationChanged(e);
            hideDropDown();
        }

        /// <summary>
        /// <see cref="ComboBox.OnSizeChanged(EventArgs)"/>
        /// </summary>
        protected override void OnSizeChanged(EventArgs e)
        {
            base.OnSizeChanged(e);
            m_dropDown.Width = Width;
        }
#endregion

#region visibility of suggest box
        /// <summary>
        /// Shows the drop down.
        /// </summary>
        public void showDropDown()
        {
            if (DesignMode)
            {
                return;
            }
            // Hide the "standard" drop down if any
            if (base.DroppedDown)
            {
                BeginUpdate();
                // setting DroppedDown to false may select an item
                // so we save the editbox state
                string oText = Text;
                int selStart = SelectionStart;
                int selLen = SelectionLength;

                // close the "standard" dropdown
                base.DroppedDown = false;
                
                // and restore the contents of the editbox
                Text = oText;
                Select(selStart, selLen);
                EndUpdate();
            }
            // pop it up and resize it
            int h = Math.Min(MaxDropDownItems, m_suggestionList.Items.Count) * m_suggestionList.ItemHeight;
            m_dropDown.Show(this, new Size(DropDownWidth, h));
        }

        /// <summary>
        /// Hides the drop down.
        /// </summary>
        public void hideDropDown()
        {
            if (m_dropDown.Visible)
            {
                m_dropDown.Close();
            }
        }

        /// <summary>
        /// <see cref="ComboBox.OnLostFocus(EventArgs)"/>
        /// </summary>
        protected override void OnLostFocus(EventArgs e)
        {
            if (!m_dropDown.Focused && !m_suggestionList.Focused)
            {
                hideDropDown();
            }
            base.OnLostFocus(e);
        }

        /// <summary>
        /// <see cref="ComboBox.OnDropDown(EventArgs)"/>
        /// </summary>
        protected override void OnDropDown(EventArgs e)
        {
            hideDropDown();
            base.OnDropDown(e);
        }
#endregion

#region keystroke and mouse events
        /// <summary>
        /// Called when the user clicks on an item in the list
        /// </summary>
        private void onSuggestionListClick(object sender, EventArgs e)
        {
            m_fromKeyboard = false;
            StringMatch sel = (StringMatch)m_suggestionList.SelectedItem;
            Text = sel.Text;
            Select(0, Text.Length);
            Focus();
        }

        /// <summary>
        /// Process command keys
        /// </summary>
        protected override bool ProcessCmdKey(ref Message msg, Keys keyData)
        {
            if ((keyData == Keys.Tab) && (m_dropDown.Visible))
            {
                // we change the selection but will also allow the navigation to the next control
                if (m_suggestionList.Text.Length != 0)
                {
                    Text = m_suggestionList.Text;
                }
                Select(0, Text.Length);
                hideDropDown();
            }
            return base.ProcessCmdKey(ref msg, keyData);
        }

        /// <summary>
        /// if the dropdown is visible some keystrokes
        /// should behave in a custom way
        /// </summary>
        protected override void OnKeyDown(KeyEventArgs e)
        {
            m_fromKeyboard = true;

            if (!m_dropDown.Visible)
            {
                base.OnKeyDown(e);
                return;
            }
            switch (e.KeyCode)
            {
                case Keys.Down:
                    if (m_suggestionList.SelectedIndex < 0)
                    {
                        m_suggestionList.SelectedIndex = 0;
                    }
                    else if (m_suggestionList.SelectedIndex < m_suggestionList.Items.Count - 1)
                    {
                        m_suggestionList.SelectedIndex++;
                    }
                    break;
                case Keys.Up:
                    if (m_suggestionList.SelectedIndex > 0)
                    {
                        m_suggestionList.SelectedIndex--;
                    }
                    else if (m_suggestionList.SelectedIndex < 0)
                    {
                        m_suggestionList.SelectedIndex = m_suggestionList.Items.Count - 1;
                    }
                    break;
                case Keys.Enter:
                    if (m_suggestionList.Text.Length != 0)
                    {
                        Text = m_suggestionList.Text;
                    }
                    Select(0, Text.Length);
                    hideDropDown();
                    break;
                case Keys.Escape:
                    hideDropDown();
                    break;
                default:
                    base.OnKeyDown(e);
                    return;
            }
            e.Handled = true;
            e.SuppressKeyPress = true;
        }

        /// <summary>
        /// We need to know if the last text changed event was due to one of the dropdowns 
        /// or to the keyboard
        /// </summary>
        /// <param name="e"></param>
        protected override void OnDropDownClosed(EventArgs e)
        {
            m_fromKeyboard = false;
            base.OnDropDownClosed(e);
        }

        /// <summary>
        /// this were we can make suggestions
        /// </summary>
        /// <param name="e"></param>
        protected override void OnTextChanged(EventArgs e)
        {
            base.OnTextChanged(e);


            if (!m_fromKeyboard || !Focused)
            {
                return;
            }

            m_suggestionList.BeginUpdate();
            m_suggestionList.Items.Clear();
            StringMatcher matcher = new StringMatcher(MatchingMethod, Text);
            foreach (object item in Items)
            {
                StringMatch sm = matcher.Match(GetItemText(item));
                if (sm != null)
                {
                    m_suggestionList.Items.Add(sm);
                }
            }
            m_suggestionList.EndUpdate();

            bool visible = m_suggestionList.Items.Count != 0;

            if (m_suggestionList.Items.Count == 1 && ((StringMatch)m_suggestionList.Items[0]).Text.Length == Text.Trim().Length)
            {
                StringMatch sel = (StringMatch)m_suggestionList.Items[0];
                Text = sel.Text;
                Select(0, Text.Length);
                visible = false;
            }

            if (visible)
            {
                showDropDown();
            }
            else
            {
                hideDropDown();                
            }
            
            m_fromKeyboard = false;
        }

        /// <summary>
        /// We highlight the selection under the mouse in the suggestion listbox
        /// </summary>
        private void onSuggestionListMouseMove(object sender, MouseEventArgs e)
        {
            int idx = m_suggestionList.IndexFromPoint(e.Location);
            if ((idx >= 0) && (idx != m_suggestionList.SelectedIndex))
            {
                m_suggestionList.SelectedIndex = idx;
            }
        }
#endregion

#region owner drawn
        /// <summary>
        /// We keep track of system settings changes for the font
        /// </summary>
        private void onFontChanged(object sender, EventArgs e)
        {
            if (m_boldFont != null)
            {
                m_boldFont.Dispose();
            }
            m_suggestionList.Font = Font;
            m_boldFont = new Font(Font, FontStyle.Bold);
            m_suggestionList.ItemHeight = m_boldFont.Height + 2;
        }

        /// <summary>
        /// Draw a segment of a string and updates the bound rectangle for being used for the next segment drawing
        /// </summary>
        private static void DrawString(Graphics g, Color color, ref Rectangle rect, string text, Font font)
        {
            Size proposedSize = new Size(int.MaxValue, int.MaxValue);
            Size sz = TextRenderer.MeasureText(g, text, font, proposedSize, TextFormatFlags.NoPadding);
            TextRenderer.DrawText(g, text, font, rect, color, TextFormatFlags.Left | TextFormatFlags.VerticalCenter | TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
            rect.X += sz.Width;
            rect.Width -= sz.Width;
        }

        /// <summary>
        /// Draw an item in the suggestion listbox
        /// </summary>
        private void onSuggestionListDrawItem(object sender, DrawItemEventArgs e)
        {
            StringMatch sm = (StringMatch) m_suggestionList.Items[e.Index];

            e.DrawBackground();
            
            bool isBold = sm.StartsOnMatch;
            Rectangle rBounds = e.Bounds;

            foreach (string s in sm.Segments)
            {
                Font f = isBold ? m_boldFont : Font;
                DrawString(e.Graphics, e.ForeColor, ref rBounds, s, f);
                isBold = !isBold;
            }

            e.DrawFocusRectangle();
        }
#endregion
        
#region misc
        [Category("Behavior"), DefaultValue(false), Description("Specifies whether items in the list portion of the combobo are sorted.")]
        public new bool Sorted
        {
            get { return base.Sorted; }
            set
            {
                m_suggestionList.Sorted = value;
                base.Sorted = value;
            }
        }

        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public new bool DroppedDown
        {
            get { return base.DroppedDown || m_dropDown.Visible; }
            set 
            { 
                m_dropDown.Visible = false;
                base.DroppedDown = value;
            }
        }
#endregion

#region New properties
        [
            DefaultValue(StringMatchingMethod.NoWildcards),
            Description("How strings are matched against the user input"),
            Browsable(true),
            EditorBrowsable(EditorBrowsableState.Always),
            Category("Behavior")
        ]
        public StringMatchingMethod MatchingMethod
        {
            get { return m_matchingMethod;  }
            set
            {
                if (m_matchingMethod != value)
                {
                    m_matchingMethod = value;
                    if (m_dropDown.Visible)
                    {
                        // recalculate the matches
                        showDropDown();
                    }
                }
            }
        }
#endregion
        
#region Hidden inherited properties
        /// <summary>This property is not relevant for this class.</summary>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), EditorBrowsable(EditorBrowsableState.Never)]
        public new AutoCompleteSource AutoCompleteSource
        {
            get { return base.AutoCompleteSource; }
            set { base.AutoCompleteSource = value; }
        }
        /// <summary>This property is not relevant for this class.</summary>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), EditorBrowsable(EditorBrowsableState.Never)]
        public new AutoCompleteStringCollection AutoCompleteCustomSource 
        {
            get { return base.AutoCompleteCustomSource; }
            set { base.AutoCompleteCustomSource = value; }
        }
        /// <summary>This property is not relevant for this class.</summary>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), EditorBrowsable(EditorBrowsableState.Never)]
        public new AutoCompleteMode AutoCompleteMode
        {
            get { return base.AutoCompleteMode; }
            set { base.AutoCompleteMode = value; }
        }
        /// <summary>This property is not relevant for this class.</summary>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), EditorBrowsable(EditorBrowsableState.Never)]
        public new ComboBoxStyle DropDownStyle
        {
            get { return base.DropDownStyle; }
            set { base.DropDownStyle = value; }
        }
#endregion
    }
}
#endif
// file ...\Controls\ILightControl.cs
#if !CORE
namespace Zero5.Controls
{
    public interface ILightControl
    {
        Zero5.Controls.PanelBase ParentPanel { get; set; }

        bool Hit(int x, int y);
        bool HitCorner(int x, int y);

        int Left { get; set; }
        int Top { get; set; }
        int Height { get; set; }
        int Width { get; set; }

        System.Drawing.Color BackColor { get; set; }
        System.Drawing.Color BorderColor { get; set; }
        System.Drawing.Color ForeColor { get; set; }

        System.Drawing.Font Font { get; set; }

        bool Visible { get; set; }
        bool Selected { get; set; }

        void Draw(System.Drawing.Graphics g);

        byte[] Serialize();
        void Deserialize(byte[] data);
        
        int ObjectCodeNumber { get; }

        void DoMouseDown(System.Windows.Forms.MouseEventArgs e);
        void DoMouseUp(System.Windows.Forms.MouseEventArgs e);
        void DoMouseClick(System.Windows.Forms.MouseEventArgs e);

        void InternalFocus();

        bool ReadOnly { get; set; }
    }
}
#endif
// file ...\Controls\Panel.cs
#if !MOBILE && !CORE

namespace Zero5.Controls
{
    public class Panel : Zero5.Controls.PanelBase
    {
        public Panel()
        {

            this.SetStyle(System.Windows.Forms.ControlStyles.SupportsTransparentBackColor, true);
            this.SetStyle(System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer, true);
            this.SetStyle(System.Windows.Forms.ControlStyles.UserPaint, true);
            this.TabStop = true;
        }

        //public new bool CanFocus
        //{
        //    get { return true; }
        //}

        //protected override void OnGotFocus(EventArgs e)
        //{
        //    this.SelectNextControl();
        //}

        public void AddControl(ILightControl control)
        {
            if (LightControls.Contains(control)) return;

            LightControls.Add(control);
            if (control is System.Windows.Forms.Control)
            {
                System.Windows.Forms.Control c = (System.Windows.Forms.Control)control;
                this.Controls.Add(c);
                c.MouseDown += new System.Windows.Forms.MouseEventHandler(c_MouseDown);
                c.MouseMove += new System.Windows.Forms.MouseEventHandler(c_MouseMove);
                c.MouseUp += new System.Windows.Forms.MouseEventHandler(c_MouseUp);
            }
            if (control is Zero5.Controls.Field.FieldControl)
            {
                Zero5.Controls.Field.FieldControl fld = (Zero5.Controls.Field.FieldControl)control;
                fld.EnterKey += new Field.FieldControl.EnterKeyHandler(fld_EnterKey);
            }
            control.ParentPanel = this;
            this.Invalidate();
        }

        public bool ContainsField(Zero5.Data.Filter.Field field)
        {
            foreach (ILightControl control in LightControls)
            {
                if (control is Zero5.Controls.Field.FieldControl)
                {
                    Zero5.Controls.Field.FieldControl fld = (Zero5.Controls.Field.FieldControl)control;
                    if (fld.Field == field) return true;
                }
            }
            return false;
        }

        public void RemoveControl(ILightControl control)
        {
            if (LightControls.Contains(control)) LightControls.Remove(control);
            if (control is System.Windows.Forms.Control)
            {
                System.Windows.Forms.Control c = (System.Windows.Forms.Control)control;
                if (this.Controls.Contains(c))
                    this.Controls.Remove(c);
                c.MouseDown -= new System.Windows.Forms.MouseEventHandler(c_MouseDown);
                c.MouseMove -= new System.Windows.Forms.MouseEventHandler(c_MouseMove);
                c.MouseUp -= new System.Windows.Forms.MouseEventHandler(c_MouseUp);
            }
            if (control is Zero5.Controls.Field.FieldControl)
            {
                Zero5.Controls.Field.FieldControl fld = (Zero5.Controls.Field.FieldControl)control;
                fld.EnterKey -= new Field.FieldControl.EnterKeyHandler(fld_EnterKey);
            }
            control.ParentPanel = null;
            this.Invalidate();
        }


        void fld_EnterKey(Field.FieldControl sender)
        {
            DoSubmit();
        }

        public virtual void DoSubmit()
        {
            if (Submit != null) Submit();
        }
        public delegate void SubmitHandler();
        public event SubmitHandler Submit;

        void c_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
        {

            System.Windows.Forms.MouseEventArgs eRemap = new System.Windows.Forms.MouseEventArgs(e.Button, e.Clicks, e.X + ((System.Windows.Forms.Control)sender).Left, e.Y + ((System.Windows.Forms.Control)sender).Top, e.Delta);
            this.OnMouseUp(eRemap);
        }

        void c_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            System.Windows.Forms.MouseEventArgs eRemap = new System.Windows.Forms.MouseEventArgs(e.Button, e.Clicks, e.X + ((System.Windows.Forms.Control)sender).Left, e.Y + ((System.Windows.Forms.Control)sender).Top, e.Delta);
            this.OnMouseMove(eRemap);
        }

        void c_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            // e.X = ((System.Windows.Forms.Control)sender).Left;
            System.Windows.Forms.MouseEventArgs eRemap = new System.Windows.Forms.MouseEventArgs(e.Button, e.Clicks, e.X + ((System.Windows.Forms.Control)sender).Left, e.Y + ((System.Windows.Forms.Control)sender).Top, e.Delta);
            this.OnMouseDown(eRemap);
        }

        private System.Drawing.Bitmap DrawingBitmapBuffer;
        private System.Drawing.Graphics DrawingGraphicsBuffer;

        protected override void OnResize(EventArgs eventargs)
        {
            if (DrawingBitmapBuffer != null) DrawingGraphicsBuffer.Dispose();
            if (DrawingGraphicsBuffer != null) DrawingBitmapBuffer.Dispose();
            DrawingBitmapBuffer = null;
            DrawingGraphicsBuffer = null;
            base.OnResize(eventargs);
        }

        protected override void OnPaint(System.Windows.Forms.PaintEventArgs e)
        {
            if (this.DesignMode) return;

            OnResize(new EventArgs());

            if (DrawingBitmapBuffer == null)
            {
                DrawingBitmapBuffer = new System.Drawing.Bitmap(this.ClientSize.Width, this.ClientSize.Height);
            }

            if (DrawingGraphicsBuffer == null)
            {
                DrawingGraphicsBuffer = System.Drawing.Graphics.FromImage(DrawingBitmapBuffer);
                DrawingGraphicsBuffer.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;
            }


            DrawingGraphicsBuffer.FillRectangle(Cache.BrushCache.GetBrush(this.BackColor), this.ClientRectangle);

            DrawingGraphicsBuffer.Clear(BackColor);

            foreach (ILightControl c in LightControls)
            {
                c.Draw(DrawingGraphicsBuffer);
            }

            e.Graphics.DrawImage(DrawingBitmapBuffer, 0, 0, this.ClientRectangle, System.Drawing.GraphicsUnit.Pixel);


            base.OnPaint(e);
        }

        private ILightControl MouseDownControlToMove = null;
        private ILightControl MouseDownControlToResize = null;
        private System.Drawing.Point MouseDownPoint = new System.Drawing.Point();

        protected override void OnMouseDown(System.Windows.Forms.MouseEventArgs e)
        {
            MouseDownControlToMove = null;
            MouseDownControlToResize = null;

            ILightControl NewControlToSelect = null;


            foreach (ILightControl c in LightControls)
            {

                if (RunTimeDesign)
                {
                    if (c.HitCorner(e.X, e.Y))
                    {
                        MouseDownControlToResize = c;
                        MouseDownPoint = e.Location;
                        NewControlToSelect = c;
                        break;
                    }
                }
      
                if (c.Hit(e.X, e.Y))
                {

                    if (RunTimeDesign) MouseDownControlToMove = c;
                    MouseDownPoint = e.Location;
                    NewControlToSelect = c;
                    break;
                }
            }

            if (SelectedControl != null) SelectedControl.Selected = false;
            SelectedControl = NewControlToSelect;
            if (SelectedControl != null)
            {
                SelectedControl.Selected = true;
                SelectedControl.DoMouseDown(e);
            }

            if (SelectedControl == null)
            {
                InternalFocus();
            }
            else
            {
                if (SelectedControl is Zero5.Controls.Light.Control) InternalFocus();
            }
            base.OnMouseDown(e);

            this.Invalidate();
        }

        protected override void OnMouseMove(System.Windows.Forms.MouseEventArgs e)
        {
            if (MouseDownControlToMove != null)
            {
                int newX = MouseDownControlToMove.Left + e.X - MouseDownPoint.X;
                if (MouseDownControlToMove.Left / Common.GridSize != newX / Common.GridSize)
                {
                    MouseDownControlToMove.Left = newX / Common.GridSize * Common.GridSize;
                    MouseDownPoint.X = e.X + MouseDownControlToMove.Left - newX;
                }
                int newY = MouseDownControlToMove.Top + e.Y - MouseDownPoint.Y;
                if (MouseDownControlToMove.Top / Common.GridSize != newY / Common.GridSize)
                {
                    MouseDownControlToMove.Top = newY / Common.GridSize * Common.GridSize;
                    MouseDownPoint.Y = e.Y + MouseDownControlToMove.Top - newY;
                }
                if (MouseDownControlToMove.Top < 0) MouseDownControlToMove.Top = 0;
                if (MouseDownControlToMove.Left < 0) MouseDownControlToMove.Left = 0;

                this.Invalidate();
            }
            if (MouseDownControlToResize != null)
            {
                int newW = MouseDownControlToResize.Width + e.X - MouseDownPoint.X;
                if (MouseDownControlToResize.Width / Common.GridSize != newW / Common.GridSize)
                {
                    MouseDownControlToResize.Width = Math.Max(Common.GridSize, newW / Common.GridSize * Common.GridSize);
                    MouseDownPoint.X = e.X + MouseDownControlToResize.Width - newW; ;
                }

                int newH = MouseDownControlToResize.Height + e.Y - MouseDownPoint.Y;
                if (MouseDownControlToResize.Height / Common.GridSize != newH / Common.GridSize)
                {
                    MouseDownControlToResize.Height = Math.Max(Common.GridSize, newH / Common.GridSize * Common.GridSize);
                    MouseDownPoint.Y = e.Y + MouseDownControlToResize.Height - newH; ;
                }

                this.Invalidate();
            }
            base.OnMouseMove(e);
        }

        //private bool MouseIN = false;
        //protected override void OnMouseEnter(EventArgs e)
        //{
        //    MouseIN = true;
        //    base.OnMouseEnter(e);
        //}

        //protected override void OnMouseLeave(EventArgs e)
        //{
        //    MouseIN = false;
        //    base.OnMouseLeave(e);
        //}

        protected override void OnMouseUp(System.Windows.Forms.MouseEventArgs e)
        {
            if (SelectedControl != null)
            {
                SelectedControl.DoMouseUp(e);
            }
            MouseDownControlToMove = null;
            MouseDownControlToResize = null;
            base.OnMouseUp(e);

            this.Invalidate();
        }

        //protected override bool ProcessCmdKey(ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData)
        //{
        //    System.Diagnostics.Debug.WriteLine("ProcessCmdKey " + keyData.ToString());
        //    if (keyData == System.Windows.Forms.Keys.Tab) return false;
        //    return base.ProcessCmdKey(ref msg, keyData);
        //}

        protected override void OnKeyDown(System.Windows.Forms.KeyEventArgs e)
        {
            System.Diagnostics.Debug.WriteLine("Panel OnKeyDown: " + e.KeyCode.ToString());
            //e.SuppressKeyPress
            base.OnKeyDown(e);
        }
        protected override void OnKeyPress(System.Windows.Forms.KeyPressEventArgs e)
        {
            //if (SelectedControl is LightTextBox)
            //{
            //    ((LightTextBox)SelectedControl).KeyPress(e.KeyChar);
            //    this.Invalidate();
            //}
            if (RunTimeDesign && SelectedControl is Zero5.Controls.Light.Label)
            {
                ((Zero5.Controls.Light.Label)SelectedControl).KeyPress(e.KeyChar);
                this.Invalidate();
            }
            if (!RunTimeDesign && e.KeyChar == '\t')
            {
                SelectNextControl();
            }
            //base.OnKeyPress(e);
        }

        //protected override bool ProcessTabKey(bool forward)
        //{

        //    System.Diagnostics.Debug.WriteLine("ProcessTabKey");
        //    return base.ProcessTabKey(false);    
        //}

        //protected override void OnValidating(System.ComponentModel.CancelEventArgs e)
        //{
        //    e.Cancel = MouseIN;
        //    base.OnValidating(e);
        //}

        //protected override bool ProcessCmdKey(ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData)
        //{            
        //    return base.ProcessCmdKey(ref msg, keyData);
        //}
        
        //protected override void OnKeyDown(System.Windows.Forms.KeyEventArgs e)
        //{
        //    if (SelectedControl is TextBox)
        //    {
        //        ((TextBox)SelectedControl).KeyPress((char)e.KeyValue);
        //        this.Invalidate();
        //    }
        //    base.OnKeyDown(e);
        //}

        //protected override void OnKeyUp(System.Windows.Forms.KeyEventArgs e)
        //{
        //    //if (e.KeyCode == System.Windows.Forms.Keys.
        //    base.OnKeyUp(e);
        //}

        //protected override void OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs e)
        //{
        //    //e.IsInputKey = true;
        //    //base.OnPreviewKeyDown(e);
        //}

        //protected override bool IsInputKey(System.Windows.Forms.Keys keyData)
        //{
        //    return true;

        //    if (keyData == System.Windows.Forms.Keys.Up || keyData == System.Windows.Forms.Keys.Down) return true;
        //    if (keyData == System.Windows.Forms.Keys.Left || keyData == System.Windows.Forms.Keys.Right) return true;
        //    return base.IsInputKey(keyData);
        //}

        public byte[] Serialize()
        {

            System.IO.MemoryStream ms = new System.IO.MemoryStream();
            Zero5.IO.RawSerializer.RawSerializer raw = new Zero5.IO.RawSerializer.RawSerializer(ms);

            raw.Serialize(10); // version
            raw.Serialize(LightControls.Count);
            foreach (ILightControl c in LightControls)
            {
                raw.Serialize(c.ObjectCodeNumber);
                raw.Serialize(c.Serialize());
            }

            return ms.ToArray();
        }

        public virtual void Deserialize(byte[] data)
        {
            while(LightControls.Count > 0)
                RemoveControl(LightControls[0]);

            System.IO.MemoryStream ms = new System.IO.MemoryStream(data);
            ms.Position = 0;

            Zero5.IO.RawSerializer.RawDeserializer raw = new Zero5.IO.RawSerializer.RawDeserializer(ms);

            int version = raw.DeserializeInt();
            if (version == 10)
            {
                int objectCount = raw.DeserializeInt();
                for (int i = 0; i < objectCount; i++)
                {
                    ILightControl c;

                    int objectCodeNumber = raw.DeserializeInt();
                    switch (objectCodeNumber)
                    {
                        case 100: //FieldTextBox0
                            c = new Zero5.Controls.Field.FieldTextBox();
                            break;
                        case 101: //LightControl
                            c = new Zero5.Controls.Light.Control();
                            break;
                        case 102: //LightLabel
                            c = new Zero5.Controls.Light.Label();
                            break;
                        //case 103: //WinTextBox
                        //    c = new WinTextBox();
                        //    break;
                        case 104: //FieldControl
                            c = new Zero5.Controls.Field.FieldControl();
                            break;
                        case 105: //FieldButton
                            c = new Zero5.Controls.Field.FieldButton();
                            break;
                        case 106: //FieldComboBox
                            c = new Zero5.Controls.Field.FieldComboBox();
                            break;
                        case 107: //FieldTextBoxNumeric
                            c = new Zero5.Controls.Field.FieldTextBoxNumeric();
                            break;
                        case 108: //FieldDateTimePicker
                            c = new Zero5.Controls.Field.FieldDateTimePicker();
                            break;
                        case 109: //FieldCheckBox
                            c = new Zero5.Controls.Field.FieldCheckBox();
                            break;
                        case 110: //FieldTextBoxLookup
                            c = new Zero5.Controls.Field.FieldTextBoxLookup();
                            break;
#if CHART
                        case 111: //Chart
                            c = null;
                            //c = new Zero5.Controls.Chart.Chart();
                            //c.ParentPanel = this; //Required by Deserialize_InternalData
                            break;
                        case 112: //PieChart
                            c = new Zero5.Controls.Field.MultiFieldPieChart();
                            break;
                        case 113: //BarChart
                            c = new Zero5.Controls.Field.MultiFieldBarChart();
                            break;
#endif
                        case 114: //FieldColor
                            c = new Zero5.Controls.Field.FieldColor();
                            break;
                        case 115: //FieldComboBoxLookUp
                            c = new Zero5.Controls.Field.FieldComboBoxLookUp();
                            break;
                        case 116: //FieldBinaryTextBox
                            c = new Zero5.Controls.Field.FieldBinaryTextBox();
                            break;
                        case 117: //FieldImage
                            c = new Zero5.Controls.Field.FieldImage();
                            break;
                        case 118: //FieldTreeListBox
                            c = new Zero5.Controls.Field.FieldTreeListBox();
                            break;
                        case 119: //FieldTextBoxPath
                            c = new Zero5.Controls.Field.FieldTextBoxPath();
                            break;
                        default:
                            throw new Exception("Object Code Number Not Implemented");
                    }

                    c.Deserialize(raw.DeserializeBytes());

                    if (c is Field.FieldControl)
                        ((Field.FieldControl)c).UpdateControl();

                    this.AddControl(c);
                }

                ReassignControlsTabPositions();
            }
        }
        
        protected override void OnLayout(System.Windows.Forms.LayoutEventArgs e)
        {
            foreach (System.Windows.Forms.Control c in this.Controls)
            {
                if (c is ILightControl)
                    this.AddControl((ILightControl)c);
            }

            base.OnLayout(e);
        }
    }
}

#endif
// file ...\Controls\PanelBase.cs
#if !CORE

namespace Zero5.Controls
{
    public class PanelBase : System.Windows.Forms.ContainerControl
    {
        protected bool runTimeDesign = false;
        protected ILightControl SelectedControl = null;
        public List<ILightControl> LightControls = new List<ILightControl>();

        public void InternalFocus()
        {
            this.Focus();
        }

        public void DoKeyPress(System.Windows.Forms.KeyPressEventArgs e)
        {
            OnKeyPress(e);
        }


        public bool RunTimeDesign
        {
            get { return runTimeDesign; }
            set
            {
                runTimeDesign = value;

                foreach (ILightControl c in LightControls)
                {
                    if (runTimeDesign)
                        c.BorderColor = System.Drawing.Color.Gainsboro;
                    else
                        c.BorderColor = System.Drawing.Color.White;
                }
            }
        }

        public void SelectControl(ILightControl c)
        {
            if (SelectedControl != null) SelectedControl.Selected = false;
            SelectedControl = c;
            if (SelectedControl != null) SelectedControl.Selected = true;
            if (SelectedControl != null)
            {
                SelectedControl.InternalFocus();
                //if (SelectedControl is LightControl)
                //    InternalFocus();
                //else
                //    if (SelectedControl is System.Windows.Forms.Control)
                //        ((System.Windows.Forms.Control)SelectedControl).Focus();
            }
            this.Invalidate();
        }


        public void SelectNextControl()
        {
            bool foundPrev = false;
            bool foundNext = false;
            foreach (ILightControl c in LightControls)
            {
                if (foundPrev || SelectedControl == null)
                {
                    bool tabStoppable = false;
                    if (c is Zero5.Controls.Light.Control) tabStoppable = ((Zero5.Controls.Light.Control)c).TabStop;
                    if (c is System.Windows.Forms.Control) tabStoppable = ((System.Windows.Forms.Control)c).TabStop;

                    if (tabStoppable)
                    {
                        foundNext = true;
                        SelectControl(c);
                        break;
                    }
                }
                if (SelectedControl == c)
                {
                    foundPrev = true;
                }
            }
            if (foundPrev && !foundNext)
                foreach (ILightControl c in LightControls)
                {
                    bool tabStoppable = false;
                    if (c is Zero5.Controls.Light.Control) tabStoppable = ((Zero5.Controls.Light.Control)c).TabStop;
                    if (c is System.Windows.Forms.Control) tabStoppable = ((System.Windows.Forms.Control)c).TabStop;

                    if (tabStoppable)
                    {
                        SelectControl(c);
                        break;
                    }
                }
        }


        protected void ReassignControlsTabPositions()
        {
            SortedList<string, ILightControl> lightControlsSorted = new SortedList<string, ILightControl>();

            foreach (ILightControl c in LightControls)
            {
                string key = (c.Top / 10 * 10).ToString("0000000000") + "_" + c.Left.ToString("0000000000");
                if (!lightControlsSorted.ContainsKey(key))
                    lightControlsSorted.Add(key, c);
            }

            int iTabIndex = 1;
            foreach (ILightControl c in lightControlsSorted.Values)
            {
                if (c is System.Windows.Forms.Control)
                {
                    ((System.Windows.Forms.Control)c).TabIndex = iTabIndex++;
                }
            }
        }


        protected override void OnPaintBackground(System.Windows.Forms.PaintEventArgs pevent)
        {
            //base.OnPaintBackground(pevent);
        }
    }
}
#endif
// file ...\Controls\StringMatcher.cs
#if !MOBILE && !CORE
// Copyright © Serge Weinstock 2014.
//
// This library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this library.  If not, see <http://www.gnu.org/licenses/>.


namespace Zero5.Controls
{
    /// <summary>
    /// Possible ways of matching methods
    /// </summary>
    public enum StringMatchingMethod
    {
        ContainsCaseInsensitive,
        NoWildcards,
        UseWildcards,
        UseRegexs,
    }

    /// <summary>
    /// Allows to decompose a strings against a pattern
    /// </summary>
    public class StringMatcher
    {
        #region fields
        public delegate StringMatch MatchDelegate(string source);
        private readonly object m_pattern;
        #endregion

        /// <summary>
        /// Match against a string
        /// </summary>
        public MatchDelegate Match { get; private set; }

        /// <summary>
        /// Constructor
        /// </summary>
        public StringMatcher(StringMatchingMethod method, string pattern)
        {
            switch (method)
            {
                case StringMatchingMethod.ContainsCaseInsensitive:
                    m_pattern = pattern.ToLower();
                    Match = buildContainsCaseInsensitive;
                    break;
                case StringMatchingMethod.NoWildcards:
                    m_pattern = prepareNoWildcard(pattern);
                    Match = buildNoWildcard;
                    break;
                case StringMatchingMethod.UseWildcards:
                    m_pattern = prepareWithWildcards(pattern);
                    Match = buildWithWildcards;
                    break;
                case StringMatchingMethod.UseRegexs:
                    m_pattern = prepareRegex(pattern);
                    Match = buildRegex;
                    break;
                default:
                    throw new ArgumentException("Unknown StringMatchingMethod value");
            }
        }

        #region No wildcards
        /// <summary>
        /// Prepare the pattern for a "non wildcard" match
        /// </summary>
        private static object prepareNoWildcard(string pattern)
        {
            return pattern.ToLower();
        }

        /// <summary>
        /// Compare the source against the pattern and if successfull returns a StringMatch
        /// 
        /// There is a match if source contains all the characters of pattern in the right order
        /// but not consecutively
        /// </summary>
        private StringMatch buildNoWildcard(string source)
        {
            string pattern = (string)m_pattern;
            string lsource = source.ToLower();

            List<string> segments = new List<string>();
            int i = 0, j;
            int NP = pattern.Length, NS = source.Length;
            bool startsOnMatch = false, isMatch = false;
            for (j = 0; j < NP; j++)
            {
                int s = i;
                // skip characters until we have a match
                for (; i < NS; i++)
                {
                    if (lsource[i] == pattern[j])
                    {
                        isMatch = (j == NP - 1);
                        if (s != i)
                        {
                            segments.Add(source.Substring(s, i - s));
                            segments.Add(source.Substring(i, 1));
                        }
                        else
                        {
                            if (segments.Count == 0)
                            {
                                segments.Add(source.Substring(i, 1));
                                startsOnMatch = true;
                            }
                            else
                            {
                                segments[segments.Count - 1] += source[i];
                            }
                        }
                        i++;
                        break; // i loop
                    }
                }
                if (i >= NS)
                {
                    break; // j loop
                }
            }

            if (!isMatch)
            {
                return null;
            }
            if (i < NS)
            {
                segments.Add(source.Substring(i, NS - i));
            }
            return new StringMatch
            {
                Text = source,
                Segments = segments,
                StartsOnMatch = startsOnMatch,
            };
        }
        #endregion

        private StringMatch buildContainsCaseInsensitive(string source)
        {
            string pattern = (string)m_pattern;
            string lsource = source.ToLower();

            if (lsource.Contains(pattern))
            {
                List<string> segments = new List<string>();
                bool startOnMatch = false;
                int i = lsource.IndexOf(pattern);
                if (i == 0)
                {
                    startOnMatch = true;
                    segments.Add(source.Substring(0, pattern.Length));
                    segments.Add(source.Substring(pattern.Length));
                }
                else
                {
                    segments.Add(source.Substring(0, lsource.IndexOf(pattern)));
                    segments.Add(source.Substring(lsource.IndexOf(pattern), pattern.Length));
                    segments.Add(source.Substring(lsource.IndexOf(pattern) + pattern.Length));
                }

                return new StringMatch
                {
                    Text = source,
                    Segments = segments,
                    StartsOnMatch = startOnMatch,
                };
            }

            return null;

        }

        #region Wildcards
        /// <summary>
        /// Prepare the pattern for a "wildcard" match
        /// </summary>
        private static object prepareWithWildcards(string pattern)
        {
            // starts the match anywhere
            StringBuilder buf = new StringBuilder(pattern.StartsWith("*") ? "" : "*");

            // reduce consecutive '*'s into a single one
            int NP = pattern.Length;
            for (int i = 0; i < NP; i++)
            {
                char c = pattern[i];
                if (c == '*')
                {
                    // "****" == "*"
                    for (; (i < NP) && (pattern[i] == '*'); i++) {}
                    buf.Append('*');
                    // don't need to process a '*' at the end of the pattern
                    if (i < NP)
                    {
                        buf.Append(pattern[i]);
                    }
                }
                else
                {
                    buf.Append(c);
                }
            }
            return buf.ToString().ToLower();
        }

        /// <summary>
        /// Add a chunk to list of segments
        /// </summary>
        static void addChunkToStringMatch(StringMatch res, string txt, bool isMatch)
        {
            if (res.Segments.Count == 0)
            {
                res.StartsOnMatch = isMatch;
                res.Segments.Add(txt);
                return;
            }
            bool currentIsMatch = (((res.Segments.Count % 2) != 0) == res.StartsOnMatch);
            if (currentIsMatch == isMatch)
            {
                // we can add to the previous segment
                res.Segments[res.Segments.Count - 1] = res.Segments[res.Segments.Count - 1] + txt;
            }
            else
            {
                res.Segments.Add(txt);
            }
        }

        /// <summary>
        /// Compare the source against the pattern and if successfull returns a StringMatch
        /// 
        /// There match is done against the source which can contain the wildcard '*'
        /// </summary>
        private StringMatch buildWithWildcards(string source)
        {
            StringMatch res = new StringMatch
            {
                Text = source,
                Segments = new List<string>(),
                StartsOnMatch = false,
            };

            string pattern = (string)m_pattern;
            string lsource = source.ToLower();

            int iP = 0, iS = 0, icP = -1, icS = -1;
            int ioS1 = -1, ioS2 = -1;
            int NP = pattern.Length, NS = source.Length;

            // skip all the starting characters untils we either don't match or reach a '*'
            while ((iP != NP) && (iS != NS) && (pattern[iP] != '*'))
            {
                if (lsource[iS] != pattern[iP])
                {
                    // mismatch
                    return null;
                }
                iS++;
                iP++;
            }

            if (iS != 0)
            {
                addChunkToStringMatch(res, source.Substring(0, iS), true);
            }

            if (iP != NP)
            {
                // we have not finished parsing

                // now we start from a '*'
                // we try to get a sequence of matches to ('*', non '*'s), ('*', non '*'s), ....
                while (iS != NS)
                {
                    if (pattern[iP] == '*')
                    {
                        // we have reached a new '*', we will now compare against the next pattern character
                        iP++;
                        if (iP == NP)
                        {
                            //we have matched all the pattern
                            break; // while
                        }
                        if (icP != iP)
                        {
                            // this is the 1st time we try to process this '*'
                            if (icP >= 0)
                            {
                                // not the first run
                                // so we have successfully processed the previous '*'
                                if (ioS1 != ioS2)
                                {
                                    addChunkToStringMatch(res, source.Substring(ioS1, ioS2 - ioS1), false);
                                }
                                if (ioS2 != iS)
                                {
                                    addChunkToStringMatch(res, source.Substring(ioS2, iS - ioS2), true);
                                }
                            }
                            ioS1 = iS;
                            ioS2 = -1;
                        }
                        // we save the current position in case the '*' needs to match more characters
                        icP = iP;
                        icS = iS + 1;
                    }
                    else if (lsource[iS] == pattern[iP])
                    {
                        // if we were processing a '*', we now have a successfull match
                        // we are still matching sucessfully the pattern
                        if (ioS2 == -1)
                        {
                            ioS2 = iS;
                        }
                        iS++;
                        iP++;
                    }
                    else
                    {
                        // we have a mismatch
                        // let's try again with '*' matching one more character
                        iP = icP;
                        iS = icS++;
                    }
                    if (iP == NP)
                    {
                        //we have matched all the pattern
                        break; // while
                    }
                }
                // we have processed either the whole source or either the whole pattern
                // let's process any remaining '*' which here matches the empty string
                while ((iP != NP) && (pattern[iP] == '*'))
                {
                    iP++;
                }
            }
            if (iP == NP)
            {
                // we have a match!
                if (icP != iP)
                {
                    if (ioS1 != -1)
                    {
                        if (ioS2 == -1)
                        {
                            addChunkToStringMatch(res, source.Substring(ioS1, iS - ioS1), false);
                        }
                        else
                        {
                            if (ioS2 != ioS1)
                            {
                                addChunkToStringMatch(res, source.Substring(ioS1, ioS2 - ioS1), false);
                            }
                            if (ioS2 != iS)
                            {
                                addChunkToStringMatch(res, source.Substring(ioS2, iS - ioS2), true);
                            }
                        }
                    }
                }
                if (iS != NS)
                {
                    addChunkToStringMatch(res, source.Substring(iS, NS - iS), false);
                }
                return res;
            }
            return null;
        }
        #endregion

        #region Regexs
        /// <summary>
        /// Prepare the pattern for a "regex" match
        /// </summary>
        private static object prepareRegex(string pattern)
        {
            try
            {
                return new Regex(pattern, RegexOptions.IgnoreCase);
            }
            catch
            {
                // the user has entered an invalid regex, just ignore it
            }
            return null;
        }

        /// <summary>
        /// Compare the source against the pattern and if successfull returns a StringMatch
        /// 
        /// There is a match if source contains all the characters of pattern in the right order
        /// but not consecutively
        /// </summary>
        private StringMatch buildRegex(string source)
        {
            if (m_pattern == null)
            {
                return null;
            }

            Regex re = (Regex)m_pattern;
            List<string> segments = new List<string>();
            bool startsOnMatch = false, isMatch = false;
            int idx = 0;

            // we need only one match
            Match m = re.Match(source, idx);
            if (m.Success)
            {
                isMatch = true;
                if (m.Index == idx)
                {
                    if (m.Index == 0)
                    {
                        startsOnMatch = true;
                    }
                    segments.Add(source.Substring(m.Index, m.Length));
                }
                else
                {
                    segments.Add(source.Substring(idx, m.Index - idx));
                    segments.Add(source.Substring(m.Index, m.Length));
                }
                idx = m.Index + m.Length;
            }

            if (!isMatch)
            {
                return null;
            }

            if (idx < source.Length)
            {
                segments.Add(source.Substring(idx, source.Length - idx));
            }

            return new StringMatch
            {
                Text = source,
                Segments = segments,
                StartsOnMatch = startsOnMatch,
            };
        }
        #endregion
    }

    /// <summary>
    /// The result of a match
    /// There are the items we store in the suggestion listbox
    /// </summary>
    public class StringMatch
    {
        /// <summary>
        /// The original source
        /// </summary>
        public string Text { get; internal set; }
        /// <summary>
        /// The source decomposed on match/non matches against the pattern
        /// </summary>
        public List<string> Segments { get; internal set; }
        /// <summary>
        /// Is the first segment a match?
        /// </summary>
        public bool StartsOnMatch { get; internal set; }
    }
}
#endif
// file ...\Controls\TreeView.cs
#if !MOBILE && !CORE
// Copyright (CPOL) 2011 RikTheVeggie - see http://www.codeproject.com/info/cpol10.aspx
// Tri-State Tree View http://www.codeproject.com/script/Articles/ViewDownloads.aspx?aid=202435

namespace Zero5.Controls
{
	// <summary>
	// A Tri-State TreeView designed for on-demand populating of the tree
	// </summary>
	// <remarks>
	// 'Mixed' nodes retain their checked state, meaning they can be checked or unchecked according to their current state
	// Tree can be navigated by keyboard (cursor keys & space)
	// No need to do anything special in calling code
	// </remarks>
	public class TreeView : System.Windows.Forms.TreeView
	{
		// <remarks>
		// CheckedState is an enum of all allowable nodes states
		// </remarks>
		public enum CheckedState : int { UnInitialised = -1, UnChecked, Checked, Mixed };

		// <remarks>
		// IgnoreClickAction is used to ingore messages generated by setting the node.Checked flag in code
		// Do not set <c>e.Cancel = true</c> in <c>OnBeforeCheck</c> otherwise the Checked state will be lost
		// </remarks>
		int IgnoreClickAction = 0;
		// <remarks>

		// TriStateStyles is an enum of all allowable tree styles
		// All styles check children when parent is checked
		// Installer automatically checks parent if all children are checked, and unchecks parent if at least one child is unchecked
		// Standard never changes the checked status of a parent
		// </remarks>
		public enum TriStateStyles : int { Standard = 0, Installer };

		// Create a private member for the tree style, and allow it to be set on the property sheer
		private TriStateStyles TriStateStyle = TriStateStyles.Standard;

		//[System.ComponentModel.Category("Tri-State Tree View")]
		//[System.ComponentModel.DisplayName("Style")]
		//[System.ComponentModel.Description("Style of the Tri-State Tree View")]
		public TriStateStyles TriStateStyleProperty
		{
			get { return TriStateStyle; }
			set { TriStateStyle = value; } 
		}

        private System.Windows.Forms.ImageList checkboxesStateImageList;

		// <summary>
		// Constructor.  Create and populate an image list
		// </summary>
		public TreeView() : base()
		{
            checkboxesStateImageList = new System.Windows.Forms.ImageList();

			// populate the image list, using images from the System.Windows.Forms.CheckBoxRenderer class
			for (int i = 0; i < 3; i++)
			{
				// Create a bitmap which holds the relevent check box style
				// see http://msdn.microsoft.com/en-us/library/ms404307.aspx and http://msdn.microsoft.com/en-us/library/system.windows.forms.checkboxrenderer.aspx

				System.Drawing.Bitmap bmp = new System.Drawing.Bitmap(16, 16);
				System.Drawing.Graphics chkGraphics = System.Drawing.Graphics.FromImage(bmp);
				switch ( i )
				{
					// 0,1 - offset the checkbox slightly so it positions in the correct place
					case 0:
						System.Windows.Forms.CheckBoxRenderer.DrawCheckBox(chkGraphics, new System.Drawing.Point(0, 1), System.Windows.Forms.VisualStyles.CheckBoxState.UncheckedNormal);
						break;
					case 1:
						System.Windows.Forms.CheckBoxRenderer.DrawCheckBox(chkGraphics, new System.Drawing.Point(0, 1), System.Windows.Forms.VisualStyles.CheckBoxState.CheckedNormal);
						break;
					case 2:
						System.Windows.Forms.CheckBoxRenderer.DrawCheckBox(chkGraphics, new System.Drawing.Point(0, 1), System.Windows.Forms.VisualStyles.CheckBoxState.MixedNormal);
						break;
				}

                checkboxesStateImageList.Images.Add(bmp);
			}
		}

        private bool localCheckBoxes;

        public new bool CheckBoxes
        {
            get { return localCheckBoxes; }
            set { localCheckBoxes = value; if (localCheckBoxes) this.StateImageList = checkboxesStateImageList; else this.StateImageList = null; }
        }

		// <summary>
		// Called once before window displayed.  Disables default Checkbox functionality and ensures all nodes display an 'unchecked' image.
		// </summary>
		protected override void OnCreateControl()
		{
			base.OnCreateControl();
			base.CheckBoxes = false;			// Disable default CheckBox functionality if it's been enabled

            if (!localCheckBoxes) return;
			// Give every node an initial 'unchecked' image
			IgnoreClickAction++;	// we're making changes to the tree, ignore any other change requests
			UpdateChildState(this.Nodes, (int)CheckedState.UnChecked, false, true);
			IgnoreClickAction--;
		}

		// <summary>
		// Called after a node is checked.  Forces all children to inherit current state, and notifies parents they may need to become 'mixed'
		// </summary>
		protected override void OnAfterCheck(System.Windows.Forms.TreeViewEventArgs e)
		{
			base.OnAfterCheck(e);

			if (IgnoreClickAction > 0)
			{
				return;
			}

            if (!localCheckBoxes) return;
			IgnoreClickAction++;	// we're making changes to the tree, ignore any other change requests

			// the checked state has already been changed, we just need to update the state index

			// node is either ticked or unticked.  ignore mixed state, as the node is still only ticked or unticked regardless of state of children
			System.Windows.Forms.TreeNode tn = e.Node;
			tn.StateImageIndex = tn.Checked ? (int)CheckedState.Checked : (int)CheckedState.UnChecked;

			// force all children to inherit the same state as the current node
			UpdateChildState(e.Node.Nodes, e.Node.StateImageIndex, e.Node.Checked, false);

			// populate state up the tree, possibly resulting in parents with mixed state
			UpdateParentState(e.Node.Parent);

			IgnoreClickAction--;
		}

		// <summary>
		// Called after a node is expanded.  Ensures any new nodes display an 'unchecked' image
		// </summary>
		protected override void OnAfterExpand(System.Windows.Forms.TreeViewEventArgs e)
		{
			// If any child node is new, give it the same check state as the current node
			// So if current node is ticked, child nodes will also be ticked
			base.OnAfterExpand(e);

            if (!localCheckBoxes) return;
			IgnoreClickAction++;	// we're making changes to the tree, ignore any other change requests
			UpdateChildState(e.Node.Nodes, e.Node.StateImageIndex, e.Node.Checked, true);
			IgnoreClickAction--;
		}

		// <summary>
		// Helper function to replace child state with that of the parent
		// </summary>
		protected void UpdateChildState(System.Windows.Forms.TreeNodeCollection Nodes, int StateImageIndex, bool Checked, bool ChangeUninitialisedNodesOnly)
		{
            if (!localCheckBoxes) return;
			foreach (System.Windows.Forms.TreeNode tnChild in Nodes)
			{
                if (!ChangeUninitialisedNodesOnly || tnChild.StateImageIndex == -1)
                {
                    tnChild.StateImageIndex = StateImageIndex;
                    tnChild.Checked = Checked;	// override 'checked' state of child with that of parent

                    if (tnChild.Nodes.Count > 0)
                    {
                        UpdateChildState(tnChild.Nodes, StateImageIndex, Checked, ChangeUninitialisedNodesOnly);
                    }
                }
			}
		}

		// <summary>
		// Helper function to notify parent it may need to use 'mixed' state
		// </summary>
		protected void UpdateParentState(System.Windows.Forms.TreeNode tn)
		{
            if (!localCheckBoxes) return;

			// Node needs to check all of it's children to see if any of them are ticked or mixed
			if (tn == null)
				return;

			int OrigStateImageIndex = tn.StateImageIndex;

			int UnCheckedNodes = 0, CheckedNodes = 0, MixedNodes = 0;

			// The parent needs to know how many of it's children are Checked or Mixed
			foreach (System.Windows.Forms.TreeNode tnChild in tn.Nodes)
			{
				if (tnChild.StateImageIndex == (int)CheckedState.Checked)
					CheckedNodes++;
				else if (tnChild.StateImageIndex == (int)CheckedState.Mixed)
				{
					MixedNodes++;
					break;
				}
				else
					UnCheckedNodes++;
			}

			if (TriStateStyle == TriStateStyles.Installer)
			{
				// In Installer mode, if all child nodes are checked then parent is checked
				// If at least one child is unchecked, then parent is unchecked
				if (MixedNodes == 0)
				{
					if (UnCheckedNodes == 0)
					{
						// all children are checked, so parent must be checked
						tn.Checked = true;
					}
					else
					{
						// at least one child is unchecked, so parent must be unchecked
						tn.Checked = false;
					}
				}
			}

			// Determine the parent's new Image State
			if (MixedNodes > 0)
			{
				// at least one child is mixed, so parent must be mixed
				tn.StateImageIndex = (int)CheckedState.Mixed;
			}
			else if (CheckedNodes > 0 && UnCheckedNodes == 0)
			{
				// all children are checked
				if (tn.Checked)
					tn.StateImageIndex = (int)CheckedState.Checked;
				else
					tn.StateImageIndex = (int)CheckedState.Checked;
			}
			else if (CheckedNodes > 0)
			{
				// some children are checked, the rest are unchecked
				tn.StateImageIndex = (int)CheckedState.Mixed;
			}
			else
			{
				// all children are unchecked
				if (tn.Checked)
					tn.StateImageIndex = (int)CheckedState.UnChecked;
				else
					tn.StateImageIndex = (int)CheckedState.UnChecked;
			}

			if (OrigStateImageIndex != tn.StateImageIndex && tn.Parent != null)
			{
				// Parent's state has changed, notify the parent's parent
				UpdateParentState(tn.Parent);
			}
		}

        // <summary>
        // Called on keypress.  Used to change node state when Space key is pressed
        // Invokes OnAfterCheck to do the real work
        // </summary>
        protected override void OnKeyDown(System.Windows.Forms.KeyEventArgs e)
        {
            base.OnKeyDown(e);

            // is the keypress a space?  If not, discard it
            if (e.KeyCode == System.Windows.Forms.Keys.Space && SelectedNode != null)
            {
                // toggle the node's checked status.  This will then fire OnAfterCheck
                SelectedNode.Checked = !SelectedNode.Checked;
            }
        }

		// <summary>
		// Called when node is clicked by the mouse.  Does nothing unless the image was clicked
		// Invokes OnAfterCheck to do the real work
		// </summary>
		protected override void OnNodeMouseClick(System.Windows.Forms.TreeNodeMouseClickEventArgs e)
		{
			base.OnNodeMouseClick(e);

			// is the click on the checkbox?  If not, discard it
			System.Windows.Forms.TreeViewHitTestInfo info = HitTest(e.X, e.Y);
			if (info == null || info.Location != System.Windows.Forms.TreeViewHitTestLocations.StateImage)
			{
				return;
			}
			
			// toggle the node's checked status.  This will then fire OnAfterCheck
			System.Windows.Forms.TreeNode tn = e.Node;
			tn.Checked = !tn.Checked;
        }

#region DragAndDrop

        System.Windows.Forms.TreeNode draggedTreeNode = null;
        protected override void OnItemDrag(System.Windows.Forms.ItemDragEventArgs e)
        {
            base.OnItemDrag(e);
            draggedTreeNode = (System.Windows.Forms.TreeNode)e.Item;
            string strItem = e.Item.ToString();
            DoDragDrop(draggedTreeNode, System.Windows.Forms.DragDropEffects.Copy | System.Windows.Forms.DragDropEffects.Move);
        }
        protected override void OnDragEnter(System.Windows.Forms.DragEventArgs drgevent)
        {
            base.OnDragEnter(drgevent);
            if (drgevent.Data.GetDataPresent(typeof(System.Windows.Forms.TreeNode)))
                drgevent.Effect = System.Windows.Forms.DragDropEffects.Move;
            else
                drgevent.Effect = System.Windows.Forms.DragDropEffects.None;
        }
        protected override void OnDragOver(System.Windows.Forms.DragEventArgs drgevent)
        {
            base.OnDragOver(drgevent);
            System.Drawing.Point pos = new System.Drawing.Point(drgevent.X, drgevent.Y);
            pos = this.PointToClient(pos);
            System.Windows.Forms.TreeNode dropTreeNode = this.GetNodeAt(pos);
            if (dropTreeNode != null)
            {
                this.SelectedNode = dropTreeNode;
            }
        }
        protected override void OnDragDrop(System.Windows.Forms.DragEventArgs drgevent)
        {
            base.OnDragDrop(drgevent);

            System.Drawing.Point pos = new System.Drawing.Point(drgevent.X, drgevent.Y);
            pos = this.PointToClient(pos);
            System.Windows.Forms.TreeNode dropTreeNode = this.GetNodeAt(pos);
            if (dropTreeNode != null)
            {
                if (draggedTreeNode != dropTreeNode)
                {
                    bool dropOnSubTree = false;

                    System.Windows.Forms.TreeNode testNode = dropTreeNode;

                    while (testNode.Parent != null)
                    {
                        if (testNode.Parent == draggedTreeNode) dropOnSubTree = true;
                        testNode = testNode.Parent;
                    }
                    if (!dropOnSubTree)
                    {
                        draggedTreeNode.Parent.Nodes.Remove(draggedTreeNode);
                        dropTreeNode.Nodes.Insert(dropTreeNode.Index + 1, draggedTreeNode);
                    }

                    SelectedNode = draggedTreeNode;
                }
            }
        }

        //public delegate void OnTreeNodeMouseDoubleClickHandler(System.Windows.Forms.TreeNodeMouseClickEventArgs e);
        //public event OnTreeNodeMouseDoubleClickHandler OnTreeNodeMouseDoubleClick;
        protected override void OnNodeMouseDoubleClick(System.Windows.Forms.TreeNodeMouseClickEventArgs e)
        {
            base.OnNodeMouseDoubleClick(e);
            //if (OnTreeNodeMouseDoubleClick != null) OnTreeNodeMouseDoubleClick(e);
        }


#endregion
    }
}
#endif
// file ...\Controls\WaitCursor.cs
#if !MOBILE && !CORE

namespace Zero5.Controls
{
    class WaitCursor : IDisposable
    {
        System.Windows.Forms.Form form;
        
        public WaitCursor()
            :this(null)
        {
        }

        public WaitCursor(System.Windows.Forms.Form formOnWait)
        {
            form = formOnWait;

            if (formOnWait != null)
                form.Cursor = System.Windows.Forms.Cursors.WaitCursor;
            else
                System.Windows.Forms.Cursor.Current = System.Windows.Forms.Cursors.WaitCursor;
        }

        public void Dispose()
        {
            if (form != null) 
                form.Cursor = System.Windows.Forms.Cursors.Default;
            else
                System.Windows.Forms.Cursor.Current = System.Windows.Forms.Cursors.Default;
        }
    }
}

#endif
// file ...\Controls\Cache\BrushCache.cs

namespace Zero5.Controls.Cache
{
    public class BrushCache
    {

        private static Dictionary<string, System.Drawing.Brush> mBrushsBuffer = new Dictionary<string, System.Drawing.Brush>();
        public static void ClearBrushBuffers()
        {
            mBrushsBuffer.Clear();
        }
        public static System.Drawing.Brush GetBrush(System.Drawing.Color c)
        {
            return GetBrush(c, 255, "");
        }
        public static System.Drawing.Brush GetBrush(System.Drawing.Color c, string texture)
        {
            return GetBrush(c, 255, texture);
        }
        public static System.Drawing.Brush GetBrush(System.Drawing.Color c, int alpha)
        {
            return GetBrush(c, alpha, "");
        }
        public static System.Drawing.Brush GetBrush(System.Drawing.Color c, int alpha, string texture)
        {
            lock (mBrushsBuffer)
            {
                string k = c.ToArgb().ToString() + "_" + alpha.ToString() + "_" + texture;

                if (!mBrushsBuffer.ContainsKey(k))
                {
#if !MOBILE && !CORE
                    if (texture == "")
                        mBrushsBuffer.Add(k, new System.Drawing.SolidBrush(System.Drawing.Color.FromArgb(alpha, c)));
                    else if (texture == "BD")
                        mBrushsBuffer.Add(k, new System.Drawing.Drawing2D.HatchBrush(System.Drawing.Drawing2D.HatchStyle.BackwardDiagonal, System.Drawing.Color.FromArgb(alpha, c), System.Drawing.Color.White)); //ControlPaint.LightLight(c)                       
                    else
                        throw new Exception("Texture " + texture + " non defined");
#else
                    mBrushsBuffer.Add(k, new System.Drawing.SolidBrush(c));
#endif

                }

                return mBrushsBuffer[k];
            }
        }

    }
}
// file ...\Controls\Cache\PenCache.cs

namespace Zero5.Controls.Cache
{
    public class PenCache
    {
        private static Dictionary<string, System.Drawing.Pen> mPensBuffer = new Dictionary<string, System.Drawing.Pen>();
        public static void ClearPenBuffers()
        {
            mPensBuffer.Clear();
        }
        public static System.Drawing.Pen GetPen(System.Drawing.Color c)
        {
            return GetPen(c, 255, 1);
        }
        public static System.Drawing.Pen GetPen(System.Drawing.Color c, int size)
        {
            return GetPen(c, 255, size);
        }
        public static System.Drawing.Pen GetPenArrow(System.Drawing.Color c, int size)
        {
            return GetPenArrow(c, 255, size);
        }
        public static System.Drawing.Pen GetPenArrowDot(System.Drawing.Color c, int size)
        {
            return GetPenArrowDot(c, 255, size);
        }

        public static System.Drawing.Pen GetPen(System.Drawing.Color c, int alpha, int size)
        {
            return GetPen(c, alpha, size, false, false);
        }

        public static System.Drawing.Pen GetPenArrow(System.Drawing.Color c, int alpha, int size)
        {
            return GetPen(c, alpha, size, true, false);
        }

        public static System.Drawing.Pen GetPenArrowDot(System.Drawing.Color c, int alpha, int size)
        {
            return GetPen(c, alpha, size, true, true);
        }

        public static System.Drawing.Pen GetPenDashed(System.Drawing.Color c, int alpha, int size)
        {
            return GetPen(c, alpha, size, false, false, true);
        }

#if !MOBILE && !CORE
        private static System.Drawing.Drawing2D.CustomLineCap m_arrowCap;
#endif
        public static System.Drawing.Pen GetPen(System.Drawing.Color c, int alpha, int size, bool arrow, bool dotted)
        {
            return GetPen(c, alpha, size, arrow, dotted, false);
        }

        public static System.Drawing.Pen GetPen(System.Drawing.Color c, int alpha, int size, bool arrow, bool dotted, bool dashed)
        {
            lock (mPensBuffer)
            {
                string k = c.ToArgb().ToString() + "_" + alpha.ToString() + "_" + size.ToString() + "_" + arrow.ToString() + "_" + dotted.ToString() + "_" + dashed.ToString();

                if (!mPensBuffer.ContainsKey(k))
                {
#if !MOBILE && !CORE
                    if (!arrow && !dotted && !dashed)
                        mPensBuffer.Add(k, new System.Drawing.Pen(System.Drawing.Color.FromArgb(alpha, c), (float)size));
                    else
                    {
                        System.Drawing.Pen p = new System.Drawing.Pen(System.Drawing.Color.FromArgb(alpha, c), (float)size);

                        if (m_arrowCap == null && arrow)
                        {
                            System.Drawing.Drawing2D.GraphicsPath hPath = new System.Drawing.Drawing2D.GraphicsPath();
                            hPath.AddLine(new System.Drawing.Point(0, 0), new System.Drawing.Point(3, -4));
                            hPath.AddLine(new System.Drawing.Point(0, 0), new System.Drawing.Point(-3, -4));
                            m_arrowCap = new System.Drawing.Drawing2D.CustomLineCap(null, hPath);
                            m_arrowCap.SetStrokeCaps(System.Drawing.Drawing2D.LineCap.Triangle, System.Drawing.Drawing2D.LineCap.Triangle);
                            p.CustomEndCap = m_arrowCap;
                        }

                        if (dotted) p.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;
                        if (dashed) p.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;

                        mPensBuffer.Add(k, p);
                    }
#else
                    mPensBuffer.Add(k, new System.Drawing.Pen(c, (float)size));
#endif
                }

                return mPensBuffer[k];
            }
        }
    }
}
// file ...\Controls\Cache\RectangleCache.cs

namespace Zero5.Controls.Cache
{
    public class RectangleCache
    {
        private static Dictionary<string, System.Drawing.Rectangle> mRectangleBuffer = new Dictionary<string, System.Drawing.Rectangle>();
        public static void ClearRectangleBuffers()
        {
            mRectangleBuffer.Clear();
        }

        public static System.Drawing.Rectangle GetRectangle(int x, int y, int w, int h)
        {
            lock (mRectangleBuffer)
            {
                string k = x.ToString() + "_" + y.ToString() + "_" + w.ToString() + "_" + h.ToString();

                if (!mRectangleBuffer.ContainsKey(k))
                {
                    mRectangleBuffer.Add(k, new System.Drawing.Rectangle(x, y, w, h));
                }

                return mRectangleBuffer[k];
            }
        }

    }
}
// file ...\Controls\Chart\Chart.cs
#if !MOBILE && !CORE
#if CHART

namespace Zero5.Controls.Chart
{
    public partial class Chart : System.Windows.Forms.DataVisualization.Charting.Chart
    {
        private List<string> listNameChartArea = new List<string>();
        private string sDefaultChartAreaName = "Default";

        public void AddChartArea(string areaName)
        {
            if (!listNameChartArea.Contains(areaName))
            {
                listNameChartArea.Add(areaName);
                this.ChartAreas.Add(areaName);
            }
        }


        public void Clear()
        {
            this.listNameChartArea.Clear();
            this.ChartAreas.Clear();
            AddChartArea(sDefaultChartAreaName);
            this.Series.Clear();
        }

        //#region keyboard

        //private bool keyCTRLdown = false;
        //void Chart_KeyUp(object sender, System.Windows.Forms.KeyEventArgs e)
        //{
        //    keyCTRLdown = e.Control;
        //}

        //void Chart_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e)
        //{
        //    keyCTRLdown = e.Control;
        //    if (keyCTRLdown)
        //        if (e.KeyCode == System.Windows.Forms.Keys.D0)
        //        {
        //            if (this.ChartAreas.Count > 0)
        //            {
        //                double maxSize = this.ChartAreas[0].AxisX.Maximum - this.ChartAreas[0].AxisX.Minimum;
        //                this.ChartAreas[0].AxisX.ScaleView.Size = maxSize;
        //                this.ChartAreas[0].AxisX.ScaleView.Position = this.ChartAreas[0].AxisX.Minimum;
        //            }
        //        }
        //    System.Diagnostics.Debug.WriteLine(e.Control.ToString() + "  " + e.KeyCode.ToString());
        //}

        //#endregion

        //#region mouse
        //void Chart_MouseLeave(object sender, EventArgs e)
        //{
        //    try
        //    {
        //        if (this.Focused) this.Parent.Focus();
        //    }
        //    catch { }
        //}

        //void Chart_MouseEnter(object sender, EventArgs e)
        //{
        //    try
        //    {
        //        if (!this.Focused) this.Focus();
        //    }
        //    catch { }
        //}

        //void Chart_MouseWheel(object sender, System.Windows.Forms.MouseEventArgs e)
        //{
        //    try
        //    {
        //        if (this.ChartAreas.Count > 0)
        //        {
        //            double maxSize = this.ChartAreas[0].AxisX.Maximum - this.ChartAreas[0].AxisX.Minimum;
        //            if (keyCTRLdown)
        //            {
        //                if (double.IsNaN(this.ChartAreas[0].AxisX.ScaleView.Size)) this.ChartAreas[0].AxisX.ScaleView.Size = maxSize;

        //                double currentSize = this.ChartAreas[0].AxisX.ScaleView.Size;
        //                this.ChartAreas[0].AxisX.ScaleView.Size -= (this.ChartAreas[0].AxisX.ScaleView.Size * 30 / e.Delta);
        //                this.ChartAreas[0].AxisX.ScrollBar.Enabled = false;
        //            }

        //            else
        //            {
        //                if (double.IsNaN(this.ChartAreas[0].AxisX.ScaleView.Position)) this.ChartAreas[0].AxisX.ScaleView.Position = this.ChartAreas[0].AxisX.Minimum;
        //                this.ChartAreas[0].AxisX.ScaleView.Position += (this.ChartAreas[0].AxisX.ScaleView.Size / this.ChartAreas[0].AxisX.ScaleView.SmallScrollMinSize) * 10 / e.Delta;
        //            }
        //        }
        //    }
        //    catch (Exception ex)
        //    {
        //        Zero5.Util.Log.WriteLog("Graph on UtilizzoMacchine error: " + ex.Message);
        //    }
        //}
        //#endregion


        //#region context

        //System.Windows.Forms.MenuItem mnuToggleRunTimeDesign;
        //System.Windows.Forms.MenuItem mnuAggiungiControllo;
        //System.Windows.Forms.MenuItem mnuRimuoviControllo;
        //System.Windows.Forms.MenuItem mnuRinominaGrafico;
        //System.Windows.Forms.MenuItem mnuRimuoviGrafico;

        //new System.Windows.Forms.ContextMenu ContextMenu;

        //private void AggiornaMenuCampi()
        //{
        //    if (ContextMenu == null)
        //    {
        //        ContextMenu = new System.Windows.Forms.ContextMenu();

        //        mnuToggleRunTimeDesign = new System.Windows.Forms.MenuItem("Abilita Modifica Grafico", new EventHandler(mnuToggleRunTimeDesign_Click));
        //        ContextMenu.MenuItems.Add(mnuToggleRunTimeDesign);

        //        ContextMenu.MenuItems.Add("-");

        //        mnuRinominaGrafico = new System.Windows.Forms.MenuItem("Rinomina Grafico", new EventHandler(mnuRinominaGrafico_Click));
        //        ContextMenu.MenuItems.Add(mnuRinominaGrafico);
        //        mnuRinominaGrafico.Visible = false;

        //        mnuAggiungiControllo = new System.Windows.Forms.MenuItem("Aggiungi Controllo");
        //        ContextMenu.MenuItems.Add(mnuAggiungiControllo);
        //        mnuAggiungiControllo.Visible = false;

        //        mnuRimuoviControllo = new System.Windows.Forms.MenuItem("Rimuovi Controllo");
        //        ContextMenu.MenuItems.Add(mnuRimuoviControllo);
        //        mnuRimuoviControllo.Visible = false;

        //        mnuRimuoviGrafico = new System.Windows.Forms.MenuItem("Elimina Grafico", new EventHandler(mnuRimuoviGrafico_Click));
        //        ContextMenu.MenuItems.Add(mnuRimuoviGrafico);
        //        mnuRimuoviGrafico.Visible = false;
        //    }

        //    if (mnuAggiungiControllo.Visible)
        //        mnuToggleRunTimeDesign.Text = "Blocca Grafico";
        //    else
        //        mnuToggleRunTimeDesign.Text = "Abilita Modifica Grafico";

        //    this.RunTimeDesign = mnuAggiungiControllo.Visible;


        //    List<Data.Filter.Field> lstFieldShowed = new List<Data.Filter.Field>();
        //    List<Data.Filter.Field> lstFieldNotShowed = new List<Data.Filter.Field>();

        //    Zero5.Data.BrowsableDataObject dataObj;
        //    if (this.ParentPanel is PanelDataBind)
        //    {
        //        dataObj = ((PanelDataBind)ParentPanel).DataLayerObject;

        //        foreach (Zero5.Data.Filter.Field fld in dataObj.FieldsList.Items)
        //            if (fld.FieldType == typeof(int) || fld.FieldType == typeof(double))
        //            {
        //                if (FieldToShow.Contains(fld.FieldName))
        //                    lstFieldShowed.Add(fld);
        //                else
        //                    lstFieldNotShowed.Add(fld);
        //            }
        //    }

        //    if (mnuRimuoviControllo.Visible)
        //    {
        //        mnuRimuoviControllo.MenuItems.Clear();
        //        foreach (Zero5.Data.Filter.Field fld in lstFieldShowed)
        //        {
        //            System.Windows.Forms.MenuItem mnu = new System.Windows.Forms.MenuItem(fld.FieldNameLocalized, new EventHandler(mnuRimuoviControllo_Click));
        //            mnu.Tag = fld.FieldName;
        //            mnuRimuoviControllo.MenuItems.Add(mnu);
        //        }
        //    }

        //    if (mnuAggiungiControllo.Visible)
        //    {
        //        mnuAggiungiControllo.MenuItems.Clear();

        //        foreach (Zero5.Data.Filter.Field fld in lstFieldNotShowed)
        //        {
        //            System.Windows.Forms.MenuItem mnu = new System.Windows.Forms.MenuItem(fld.FieldNameLocalized, new EventHandler(mnuAggiungiControllo_Click));
        //            mnu.Tag = fld.FieldName;
        //            mnuAggiungiControllo.MenuItems.Add(mnu);
        //        }
        //    }
        //}

        //private void mnuToggleRunTimeDesign_Click(object sender, EventArgs e)
        //{
        //    mnuAggiungiControllo.Visible = !mnuAggiungiControllo.Visible;

        //    mnuRimuoviControllo.Visible = mnuAggiungiControllo.Visible;
        //    mnuRinominaGrafico.Visible = mnuAggiungiControllo.Visible;

        //    this.Width++; this.Width--;
        //    AggiornaMenuCampi();

        //    if (mnuAggiungiControllo.Visible)
        //        this.ContextMenu.Show(this, mouseUpLocationRightButton);
        //}

        //private void mnuAggiungiControllo_Click(object sender, EventArgs e)
        //{
        //    System.Windows.Forms.MenuItem mnu = (System.Windows.Forms.MenuItem)sender;
        //    this.FieldToShow.Add((string)mnu.Tag);
        //    AggiornaMenuCampi();
        //    UpdateChart();
        //}

        //private void mnuRimuoviControllo_Click(object sender, EventArgs e)
        //{
        //    System.Windows.Forms.MenuItem mnu = (System.Windows.Forms.MenuItem)sender;
        //    this.FieldToShow.Remove((string)mnu.Tag);
        //    AggiornaMenuCampi();
        //    UpdateChart();
        //}

        //private void mnuRinominaGrafico_Click(object sender, EventArgs e)
        //{
        //    if (sender is System.Windows.Forms.MenuItem)
        //    {
        //        string newValue = "";
        //        if (Zero5.Controls.Dialogs.InputBox.Show("Titolo Grafico", this.Title, out newValue) == System.Windows.Forms.DialogResult.OK)
        //        {
        //            this.Title = newValue;
        //            UpdateChart();
        //        }
        //    }
        //}

        //private void mnuRimuoviGrafico_Click(object sender, EventArgs e)
        //{
        //    ParentPanel.RemoveControl(this);
        //}

        //private System.Drawing.Point mouseUpLocationRightButton = new System.Drawing.Point(0, 0);
        //private bool RunTimeDesign;

        //protected override void OnMouseUp(System.Windows.Forms.MouseEventArgs e)
        //{
        //    if (e.Button == System.Windows.Forms.MouseButtons.Right)
        //    {
        //        mouseUpLocationRightButton.X = e.X;
        //        mouseUpLocationRightButton.Y = e.Y;

        //        AggiornaMenuCampi();
        //        ContextMenu.Show(this, e.Location);

        //        System.Diagnostics.Debug.WriteLine("Click on Chart");
        //    }
        //    else
        //    {
        //        base.OnMouseUp(e);
        //    }
        //}

        //#endregion

        public virtual void UpdateChart() { }

        //public void QuickDrawPieChart(string title, Zero5.Data.BrowsableDataObject dataObj, IEnumerable<Zero5.Data.Filter.Field> fieldToPlot, Color[] listColori)
        //{
        //    List<string> fieldNames = new List<string>();
        //    foreach (Zero5.Data.Filter.Field fld in fieldToPlot)
        //        fieldNames.Add(fld.FieldName);
        //    QuickDrawPieChart(title, dataObj, fieldNames.ToArray(), listColori);
        //}

        public void QuickDrawPieChart(string title, string[] labels, double[] values, Color[] colors)
        {
            this.Clear();
            System.Windows.Forms.DataVisualization.Charting.Series serie = new System.Windows.Forms.DataVisualization.Charting.Series();
            serie.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Pie;

            serie.Points.DataBindXY(labels, values);

            for (int i = 0; i < colors.Length; i++)
            {
                if (!colors[i].IsEmpty)
                    serie.Points[i].Color = colors[i];

                serie.Points[i].BorderColor = System.Windows.Forms.ControlPaint.Dark(serie.Points[i].BorderColor);
                serie.Points[i].BorderWidth = 1;
            }

            serie["PieLabelStyle"] = "Outside";
            serie.SmartLabelStyle.Enabled = false;
            serie.SmartLabelStyle.IsMarkerOverlappingAllowed = true;
            serie.SmartLabelStyle.CalloutLineWidth = 2;
            serie.SmartLabelStyle.CalloutStyle = System.Windows.Forms.DataVisualization.Charting.LabelCalloutStyle.Box;
            serie.SmartLabelStyle.CalloutLineDashStyle = System.Windows.Forms.DataVisualization.Charting.ChartDashStyle.Solid;
            serie.SmartLabelStyle.CalloutLineColor = Color.Black;
            serie.SmartLabelStyle.IsOverlappedHidden = true;
            serie.SmartLabelStyle.AllowOutsidePlotArea = System.Windows.Forms.DataVisualization.Charting.LabelOutsidePlotAreaStyle.Partial;
            serie.SmartLabelStyle.CalloutLineAnchorCapStyle = System.Windows.Forms.DataVisualization.Charting.LineAnchorCapStyle.Arrow;
            //serie.SmartLabelStyle.MaxMovingDistance = 20;
            //serie.SmartLabelStyle.MinMovingDistance = 3;

            serie["CollectedThreshold"] = "0,01";
            serie["CollectedThresholdUsePercent"] = "false";
            serie["CollectedLabel"] = " ";
            serie["CollectedLegendText"] = " ";
            serie["CollectedSliceExploded"] = "false";
            serie["CollectedColor"] = "Transparent";

            serie.Label = "#VALY{0.0} (#PERCENT)\n#VALX";
            serie.LegendText = "#VALX";

            serie["PieLabelStyle"] = "Outside";
            serie["DoughnutRadius"] = "60";
            serie["PieDrawingStyle"] = "Concave";

            // Set Border Width
            this.BorderWidth = Common.BorderSize;

            this.BorderlineDashStyle = System.Windows.Forms.DataVisualization.Charting.ChartDashStyle.Solid;

            this.Titles.Clear();
            this.Titles.Add(new System.Windows.Forms.DataVisualization.Charting.Title(title, System.Windows.Forms.DataVisualization.Charting.Docking.Top));
            this.Titles[0].Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.Titles[0].ForeColor = System.Drawing.Color.Green;

            this.Legends.Clear();
            this.Legends.Add(new System.Windows.Forms.DataVisualization.Charting.Legend());

            //this.ChartAreas[0].Position.X = 1;
            //this.ChartAreas[0].Position.Y = 1;
            //this.ChartAreas[0].Position.Width = 100;
            //this.ChartAreas[0].Position.Height = 100;

            this.Legends[0].IsDockedInsideChartArea = false;
            this.Legends[0].TableStyle = System.Windows.Forms.DataVisualization.Charting.LegendTableStyle.Auto;
            this.Legends[0].Docking = System.Windows.Forms.DataVisualization.Charting.Docking.Bottom;
            this.Legends[0].Alignment = StringAlignment.Center;

            this.Series.Add(serie);
            this.Invalidate();
            this.Show();
        }

        //public void QuickDrawBarChart(string title, Zero5.Data.BrowsableDataObject dataObj, IEnumerable<Zero5.Data.Filter.Field> fieldToPlot, Color[] listColori)
        //{
        //    List<string> fieldNames = new List<string>();
        //    foreach (Zero5.Data.Filter.Field fld in fieldToPlot)
        //        fieldNames.Add(fld.FieldName);
        //    QuickDrawBarChart(title, dataObj, fieldNames.ToArray(), listColori);
        //}

        public void QuickDrawBarChart(string title, string[] labels, double[] values, Color[] colors, bool percent)
        {
            QuickDrawBarChart(title, labels, values, colors, percent, false);
        }
        public void QuickDrawBarChart(string title, string[] labels, double[] values, Color[] colors, bool percent, bool clear)
        {
            if (clear)  this.Clear();
            System.Windows.Forms.DataVisualization.Charting.Series serie = new System.Windows.Forms.DataVisualization.Charting.Series();
            serie.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Bar;

            serie.Points.DataBindXY(labels, values);

            for (int i = 0; i < colors.Length; i++)
            {
                if (!colors[i].IsEmpty)
                    serie.Points[i].Color = colors[i];

                serie.Points[i].BorderColor = System.Windows.Forms.ControlPaint.Dark(serie.Points[i].BorderColor);
                serie.Points[i].BorderWidth = 1;
            }

            if (serie.Points.Count() > 0)
                if (serie.Points.FindMaxByValue().YValues[0] < 100)
                    this.ChartAreas[0].AxisY.Maximum = 100;

            serie.IsValueShownAsLabel = true;
            serie.SmartLabelStyle.Enabled = false;
            //serie.SmartLabelStyle.IsMarkerOverlappingAllowed = false;
            //serie.SmartLabelStyle.CalloutLineWidth = 2;
            //serie.SmartLabelStyle.MaxMovingDistance = 10;
            //serie.SmartLabelStyle.MinMovingDistance = 3;
            //serie.SmartLabelStyle.CalloutStyle = LabelCalloutStyle.Underlined;
            //serie.SmartLabelStyle.CalloutLineColor = Color.Black;
            //serie.SmartLabelStyle.CalloutLineAnchorCapStyle = LineAnchorCapStyle.Arrow;
            //serie.SmartLabelStyle.AllowOutsidePlotArea = LabelOutsidePlotAreaStyle.No;

            if (percent)
                serie.LabelFormat = "{0.0}%";
            else
                serie.LabelFormat = "{0.0}";

            serie.ChartArea = sDefaultChartAreaName;

            // Set Border Width
            this.BorderWidth = 1;

            this.BorderlineDashStyle = System.Windows.Forms.DataVisualization.Charting.ChartDashStyle.Solid;

            this.ChartAreas[0].AxisX.Minimum = 0;
            this.ChartAreas[0].AxisX.MinorGrid.Enabled = false;
            this.ChartAreas[0].AxisX.MajorTickMark.Enabled = true;
            this.ChartAreas[0].AxisX.MajorGrid.Enabled = false;
            this.ChartAreas[0].AxisX.MajorGrid.Interval = 25;
            this.ChartAreas[0].AxisX.MajorTickMark.Interval = 25;
            this.ChartAreas[0].AxisX.IsLabelAutoFit = true;
            this.ChartAreas[0].AxisX.LabelAutoFitStyle = System.Windows.Forms.DataVisualization.Charting.LabelAutoFitStyles.DecreaseFont | System.Windows.Forms.DataVisualization.Charting.LabelAutoFitStyles.IncreaseFont | System.Windows.Forms.DataVisualization.Charting.LabelAutoFitStyles.WordWrap;

            this.ChartAreas[0].Position.X = 1;
            this.ChartAreas[0].Position.Y = 1;
            this.ChartAreas[0].Position.Width = 100;
            this.ChartAreas[0].Position.Height = 100;

            this.Titles.Clear();
            this.Titles.Add(new System.Windows.Forms.DataVisualization.Charting.Title(title, System.Windows.Forms.DataVisualization.Charting.Docking.Top));

            this.Titles[0].Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.Titles[0].ForeColor = System.Drawing.Color.Green;

            this.Legends.Clear();

            this.Series.Add(serie);

            this.Invalidate();
        }

        public void QuickDrawStackedBarChart(string title, List<string> labels, List<List<double>> values, List<Color> colors, bool percentStacked, bool showAxes, bool legendVisible)
        {
            this.Clear();
            for (int i = 0; i < values.Count; i++)
            {
                System.Windows.Forms.DataVisualization.Charting.Series serie = new System.Windows.Forms.DataVisualization.Charting.Series(labels[i]);
                if (percentStacked)
                    serie.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.StackedBar100;
                else
                    serie.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.StackedBar;

                foreach (double yval in values[i])
                    serie.Points.AddY(yval);

                if (!colors[i].IsEmpty)
                    serie.Color = colors[i];

                serie.BorderColor = System.Windows.Forms.ControlPaint.Dark(serie.BorderColor);
                serie.BorderWidth = 1;

                serie.ChartArea = sDefaultChartAreaName;

                this.BorderWidth = 1;

                this.BorderlineDashStyle = System.Windows.Forms.DataVisualization.Charting.ChartDashStyle.Solid;
                serie.LegendText = labels[i];
                //serie.Legend = labels[i];

                this.Series.Add(serie);
            }

            if (showAxes)
            {
                this.ChartAreas[0].AxisX.Minimum = 0;
                this.ChartAreas[0].AxisX.MinorGrid.Enabled = false;
                this.ChartAreas[0].AxisX.MajorTickMark.Enabled = true;
                this.ChartAreas[0].AxisX.MajorGrid.Enabled = false;
                this.ChartAreas[0].AxisX.MajorGrid.Interval = 25;
                this.ChartAreas[0].AxisX.MajorTickMark.Interval = 25;
                this.ChartAreas[0].AxisX.IsLabelAutoFit = true;
                this.ChartAreas[0].AxisX.LabelAutoFitStyle = System.Windows.Forms.DataVisualization.Charting.LabelAutoFitStyles.DecreaseFont | System.Windows.Forms.DataVisualization.Charting.LabelAutoFitStyles.IncreaseFont | System.Windows.Forms.DataVisualization.Charting.LabelAutoFitStyles.WordWrap;
            }
            else
            {
                this.ChartAreas[0].AxisX.Enabled = System.Windows.Forms.DataVisualization.Charting.AxisEnabled.False;
                this.ChartAreas[0].AxisY.Enabled = System.Windows.Forms.DataVisualization.Charting.AxisEnabled.False;
            }

            //this.ChartAreas[0].Position.X = 1;
            //this.ChartAreas[0].Position.Y = 1;
            //this.ChartAreas[0].Position.Width = 100;
            //this.ChartAreas[0].Position.Height = 100;

            this.Titles.Clear();
            if (title.Length > 0)
            {
                this.Titles.Add(new System.Windows.Forms.DataVisualization.Charting.Title(title, System.Windows.Forms.DataVisualization.Charting.Docking.Top));

                this.Titles[0].Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
                this.Titles[0].ForeColor = System.Drawing.Color.Green;
            }

            if (!legendVisible)
                Legends[0].Enabled = false;
            else
            {
                this.Legends.Clear();
                this.Legends.Add(new System.Windows.Forms.DataVisualization.Charting.Legend());

                this.Legends[0].IsDockedInsideChartArea = false;
                this.Legends[0].TableStyle = System.Windows.Forms.DataVisualization.Charting.LegendTableStyle.Auto;
                this.Legends[0].Docking = System.Windows.Forms.DataVisualization.Charting.Docking.Bottom;
                this.Legends[0].Alignment = StringAlignment.Center;
            }

            this.Invalidate();
        }

        public void QuickDrawLines(string serieName, object[] labels, double[] values, Color[] colors, bool percent, bool clear)
        {
            if (clear) this.Clear();
            System.Windows.Forms.DataVisualization.Charting.Series serie = new System.Windows.Forms.DataVisualization.Charting.Series();
            serie.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Column;

            serie.Name = serieName;
            serie.Points.DataBindXY(labels, values);

            for (int i = 0; i < colors.Length; i++)
            {
                if (!colors[i].IsEmpty)
                    serie.Points[i].Color = colors[i];

                serie.Points[i].BorderColor = System.Windows.Forms.ControlPaint.Dark(serie.Points[i].BorderColor);
                serie.Points[i].BorderWidth = 1;
            }
            if (labels[0] is DateTime)
                serie.XValueType = System.Windows.Forms.DataVisualization.Charting.ChartValueType.DateTime;

            if (serie.Points.Count() > 0)
                if (serie.Points.FindMaxByValue().YValues[0] < 100)
                    this.ChartAreas[0].AxisY.Maximum = 110;

            serie.IsValueShownAsLabel = false;
            serie.SmartLabelStyle.Enabled = false;
            //serie.SmartLabelStyle.IsMarkerOverlappingAllowed = false;
            //serie.SmartLabelStyle.CalloutLineWidth = 2;
            //serie.SmartLabelStyle.MaxMovingDistance = 10;
            //serie.SmartLabelStyle.MinMovingDistance = 3;
            //serie.SmartLabelStyle.CalloutStyle = LabelCalloutStyle.Underlined;
            //serie.SmartLabelStyle.CalloutLineColor = Color.Black;
            //serie.SmartLabelStyle.CalloutLineAnchorCapStyle = LineAnchorCapStyle.Arrow;
            //serie.SmartLabelStyle.AllowOutsidePlotArea = LabelOutsidePlotAreaStyle.No;



            if (percent)
                serie.LabelFormat = "{0.0}%";
            else
                serie.LabelFormat = "{0.0}";

            serie.ChartArea = sDefaultChartAreaName;

            // Set Border Width
            this.BorderWidth = 1;

            this.BorderlineDashStyle = System.Windows.Forms.DataVisualization.Charting.ChartDashStyle.Solid;

            //this.ChartAreas[0].AxisX.Minimum = 0;
            this.ChartAreas[0].AxisX.MinorGrid.Enabled = false;
            this.ChartAreas[0].AxisX.MajorTickMark.Enabled = true;
            this.ChartAreas[0].AxisX.MajorGrid.Enabled = false;
            //this.ChartAreas[0].AxisX.MajorGrid.Interval = 25;
            //this.ChartAreas[0].AxisX.MajorTickMark.Interval = 25;
            this.ChartAreas[0].AxisX.IsLabelAutoFit = true;
            this.ChartAreas[0].AxisX.LabelAutoFitStyle = System.Windows.Forms.DataVisualization.Charting.LabelAutoFitStyles.DecreaseFont | System.Windows.Forms.DataVisualization.Charting.LabelAutoFitStyles.IncreaseFont | System.Windows.Forms.DataVisualization.Charting.LabelAutoFitStyles.WordWrap;

            this.ChartAreas[0].AxisY.IntervalAutoMode = System.Windows.Forms.DataVisualization.Charting.IntervalAutoMode.FixedCount;
            this.ChartAreas[0].AxisY.IsLabelAutoFit = true;
            this.ChartAreas[0].AxisY.LabelAutoFitStyle = System.Windows.Forms.DataVisualization.Charting.LabelAutoFitStyles.DecreaseFont | System.Windows.Forms.DataVisualization.Charting.LabelAutoFitStyles.IncreaseFont | System.Windows.Forms.DataVisualization.Charting.LabelAutoFitStyles.LabelsAngleStep90;
           
    
            this.ChartAreas[0].Position.X = 1;
            this.ChartAreas[0].Position.Y = 1;
            this.ChartAreas[0].Position.Width = 100;
            this.ChartAreas[0].Position.Height = 100;

            this.Titles.Clear();
            //if (title != "")
            //{
            //    this.Titles.Add(new System.Windows.Forms.DataVisualization.Charting.Title(title, System.Windows.Forms.DataVisualization.Charting.Docking.Top));

            //    this.Titles[0].Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            //    this.Titles[0].ForeColor = System.Drawing.Color.Green;
            //}
            
            this.Series.Add(serie);

            this.Legends.Clear();
            this.Legends.Add("");

            this.Invalidate();
        }

    }
}
#endif
#endif
// file ...\Controls\Dialogs\InputBox.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Dialogs
{
    public partial class InputBox : Form
    {
        public InputBox()
        {
            InitializeComponent();
            this.Shown += new EventHandler(InputBox_Shown);
        }

        void InputBox_Shown(object sender, EventArgs e)
        {
            fldInput.Focus();
        }

        private string _value = "";
        public static string TestoOK;
        public static string TestoANNULLA;

        public static DialogResult Show(string label, string value, out string newValue)
        {
            Zero5.Controls.Dialogs.InputBox ibox = new Zero5.Controls.Dialogs.InputBox();
            ibox.fldInput.LabelText = label.ToUpper();
            ibox.fldInput.Text = value;
            
            ibox.btnRight.Visible = true;
            ibox.btnLeft.Visible = true;
            
            ibox.btnRight.Text = TestoOK;
            ibox.btnLeft.Text = TestoANNULLA;

            ibox.fldInput.TabIndex = 0;

            DialogResult res = ibox.ShowDialog();

            newValue = ibox._value;
            
            return res;
        }

        private void btnRight_Click(object sender, EventArgs e)
        {
            DialogResult = System.Windows.Forms.DialogResult.OK;
            _value = fldInput.Text;
            this.Close();
        }

        private void btnLeft_Click(object sender, EventArgs e)
        {
            DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.Close();
        }
    }
}

#endif
// file ...\Controls\Dialogs\InputBox.Designer.cs
#if !MOBILE && !CORE
namespace Zero5.Controls.Dialogs
{
    partial class InputBox
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

#region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(InputBox));
            this.pictureBox1 = new System.Windows.Forms.PictureBox();
            this.btnRight = new Zero5.Controls.Field.FieldButton();
            this.panel1 = new Zero5.Controls.Panel();
            this.fldInput = new Zero5.Controls.Field.FieldTextBox();
            this.btnLeft = new Zero5.Controls.Field.FieldButton();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
            this.panel1.SuspendLayout();
            this.SuspendLayout();
            // 
            // pictureBox1
            // 
            this.pictureBox1.Image = Zero5.Resources.phase_logo_icona_piccolo;
            this.pictureBox1.Location = new System.Drawing.Point(6, 6);
            this.pictureBox1.Name = "pictureBox1";
            this.pictureBox1.Size = new System.Drawing.Size(30, 30);
            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
            this.pictureBox1.TabIndex = 10;
            this.pictureBox1.TabStop = false;
            // 
            // btnRight
            // 
            this.btnRight.BackColor = System.Drawing.Color.White;
            this.btnRight.BorderColor = System.Drawing.Color.White;
            this.btnRight.FilterOperator = Zero5.Data.Filter.FilterExpression.Operators.Equal;
            this.btnRight.ForeColor = System.Drawing.SystemColors.ControlText;
            this.btnRight.ImageButton = Zero5.Resources.big_accept;
            this.btnRight.LabelFont = new System.Drawing.Font("Microsoft Sans Serif", 7.25F);
            this.btnRight.LabelText = null;
            this.btnRight.LineColor = System.Drawing.Color.Green;
            this.btnRight.Location = new System.Drawing.Point(353, 141);
            this.btnRight.Margin = new System.Windows.Forms.Padding(10, 10, 0, 0);
            this.btnRight.Name = "btnRight";
            this.btnRight.ParentPanel = this.panel1;
            this.btnRight.Selected = false;
            this.btnRight.SerializeFieldValue = false;
            this.btnRight.SerializeFieldValueIcon = Zero5.Resources.bullet_star_micro;
            this.btnRight.Size = new System.Drawing.Size(89, 57);
            this.btnRight.TabIndex = 13;
            this.btnRight.TabStop = false;
            this.btnRight.Text = "OK";
            this.btnRight.Click += new System.EventHandler(this.btnRight_Click);
            // 
            // panel1
            // 
            this.panel1.Controls.Add(this.fldInput);
            this.panel1.Location = new System.Drawing.Point(42, 18);
            this.panel1.Name = "panel1";
            this.panel1.RunTimeDesign = false;
            this.panel1.Size = new System.Drawing.Size(400, 117);
            this.panel1.TabIndex = 12;
            this.panel1.TabStop = false;
            this.panel1.Text = "panel1";
            // 
            // fldInput
            // 
            this.fldInput.BackColor = System.Drawing.Color.White;
            this.fldInput.BorderColor = System.Drawing.Color.White;
            this.fldInput.FilterOperator = Zero5.Data.Filter.FilterExpression.Operators.Equal;
            this.fldInput.ImageButton = null;
            this.fldInput.LabelFont = new System.Drawing.Font("Microsoft Sans Serif", 7.25F);
            this.fldInput.LabelText = null;
            this.fldInput.LineColor = System.Drawing.Color.Green;
            this.fldInput.Location = new System.Drawing.Point(3, 21);
            this.fldInput.Margin = new System.Windows.Forms.Padding(10, 10, 0, 0);
            this.fldInput.Multiline = false;
            this.fldInput.Name = "fldInput";
            this.fldInput.ParentPanel = this.panel1;
            this.fldInput.PasswordChar = '\0';
            this.fldInput.Selected = false;
            this.fldInput.SerializeFieldValue = false;
            this.fldInput.SerializeFieldValueIcon = Zero5.Resources.bullet_star_micro;
            this.fldInput.Size = new System.Drawing.Size(376, 37);
            this.fldInput.TabIndex = 1;
            this.fldInput.TabStop = false;
            // 
            // btnLeft
            // 
            this.btnLeft.BackColor = System.Drawing.Color.White;
            this.btnLeft.BorderColor = System.Drawing.Color.White;
            this.btnLeft.FilterOperator = Zero5.Data.Filter.FilterExpression.Operators.Equal;
            this.btnLeft.ForeColor = System.Drawing.SystemColors.ControlText;
            this.btnLeft.ImageButton = Zero5.Resources.big_cross;
            this.btnLeft.LabelFont = new System.Drawing.Font("Microsoft Sans Serif", 7.25F);
            this.btnLeft.LabelText = null;
            this.btnLeft.LineColor = System.Drawing.Color.Green;
            this.btnLeft.Location = new System.Drawing.Point(235, 141);
            this.btnLeft.Margin = new System.Windows.Forms.Padding(10, 10, 0, 0);
            this.btnLeft.Name = "btnLeft";
            this.btnLeft.ParentPanel = null;
            this.btnLeft.Selected = false;
            this.btnLeft.SerializeFieldValue = false;
            this.btnLeft.SerializeFieldValueIcon = Zero5.Resources.bullet_star_micro;
            this.btnLeft.Size = new System.Drawing.Size(112, 57);
            this.btnLeft.TabIndex = 11;
            this.btnLeft.TabStop = false;
            this.btnLeft.Text = "NO";
            this.btnLeft.Visible = false;
            this.btnLeft.Click += new System.EventHandler(this.btnLeft_Click);
            // 
            // InputBox
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.White;
            this.ClientSize = new System.Drawing.Size(454, 210);
            this.Controls.Add(this.btnRight);
            this.Controls.Add(this.panel1);
            this.Controls.Add(this.btnLeft);
            this.Controls.Add(this.pictureBox1);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.Icon = Zero5.Resources.phase_logo_icona_eseguibile;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "InputBox";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
            this.panel1.ResumeLayout(false);
            this.ResumeLayout(false);

        }

#endregion

        private Field.FieldButton btnRight;
        public Zero5.Controls.Field.FieldTextBox fldInput;
        private System.Windows.Forms.PictureBox pictureBox1;
        private Field.FieldButton btnLeft;
        private Panel panel1;
    }
}
#endif
// file ...\Controls\Dialogs\MessageBox.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Dialogs
{
    public partial class MessageBox : Form
    {
        public MessageBox()
        {
            InitializeComponent();
        }

        public enum eCustomButtons
        {
            OK = 0,
            OKCancel = 1,
            AbortRetryIgnore = 2,
            YesNoCancel = 3,
            YesNo = 4,
            RetryCancel = 5,
            YesNoYesToAll = 6
        }

        public static string TestoOK;
        public static string TestoNO;
        public static string TestoSI;
        public static string TestoSITUTTI;
        public static string TestoANNULLA;

        private eCustomButtons buttons;

        public string Message
        {
            get { return lblMessaggio.Text; }
            set { lblMessaggio.Text = value; }
        }

        public static DialogResult Show(string message)
        {
            return Show(message, eCustomButtons.OK);
        }

        public static DialogResult Show(string message, System.Windows.Forms.MessageBoxButtons buttons)
        {
            return Show(message, (eCustomButtons)(int)buttons);
        }

        public static DialogResult Show(string message, eCustomButtons buttons)
        {
            Zero5.Controls.Dialogs.MessageBox mbox = new Zero5.Controls.Dialogs.MessageBox();
            mbox.Message = message;
            mbox.buttons = buttons;

            if (mbox.buttons == eCustomButtons.OK)
            {
                mbox.btnRight.Text = TestoOK;
                mbox.btnRight.Visible = true;
                mbox.btnLeft.Visible = false;
            }
            else if (mbox.buttons == eCustomButtons.OKCancel)
            {
                mbox.btnRight.Text = TestoOK;
                mbox.btnLeft.Text = TestoANNULLA;
                mbox.btnRight.Visible = true;
                mbox.btnLeft.Visible = true;
            }
            else if (mbox.buttons == eCustomButtons.YesNo)
            {
                mbox.btnRight.Text = TestoSI;
                mbox.btnLeft.Text = TestoNO;
                mbox.btnRight.Visible = true;
                mbox.btnLeft.Visible = true;
            }
            else if (mbox.buttons == eCustomButtons.YesNoCancel)
            {
                mbox.btnRight.Text = TestoSI;
                mbox.btnLeft.Text = TestoNO;
                mbox.btnRight.Visible = true;
                mbox.btnLeft.Visible = true;
                mbox.btnOther.Visible = true;
                mbox.btnOther.ImageButton = mbox.btnLeft.ImageButton;
            }
            else if (mbox.buttons == eCustomButtons.YesNoYesToAll)
            {
                mbox.btnRight.Text = TestoSI;
                mbox.btnLeft.Text = TestoNO;
                mbox.btnOther.Text = TestoSITUTTI;
                mbox.btnRight.Visible = true;
                mbox.btnLeft.Visible = true;
                mbox.btnOther.Visible = true;
                mbox.btnOther.ImageButton = mbox.btnRight.ImageButton;
            }

            return mbox.ShowDialog();
        }

        private void btnRight_Click(object sender, EventArgs e)
        {
            if (buttons == eCustomButtons.OK || buttons == eCustomButtons.OKCancel)
                DialogResult = System.Windows.Forms.DialogResult.OK;
            else if (buttons == eCustomButtons.YesNo || buttons == eCustomButtons.YesNoCancel || buttons == eCustomButtons.YesNoYesToAll)
                DialogResult = System.Windows.Forms.DialogResult.Yes;
            this.Close();
        }

        private void btnLeft_Click(object sender, EventArgs e)
        {
            if (buttons == eCustomButtons.YesNo || buttons == eCustomButtons.YesNoCancel || buttons == eCustomButtons.YesNoYesToAll)
                DialogResult = System.Windows.Forms.DialogResult.No;
            else if (buttons == eCustomButtons.OKCancel)
                DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.Close();
        }

        private void btnOther_Click(object sender, EventArgs e)
        {
            if (buttons == eCustomButtons.YesNoYesToAll)
                DialogResult = System.Windows.Forms.DialogResult.OK;
            else
                DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.Close();
        }
    }
}

#endif
// file ...\Controls\Dialogs\MessageBox.designer.cs
#if !MOBILE && !CORE
namespace Zero5.Controls.Dialogs
{
    partial class MessageBox
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MessageBox));
            this.btnRight = new Zero5.Controls.Field.FieldButton();
            this.lblMessaggio = new System.Windows.Forms.Label();
            this.pictureBox1 = new System.Windows.Forms.PictureBox();
            this.btnLeft = new Zero5.Controls.Field.FieldButton();
            this.btnOther = new Zero5.Controls.Field.FieldButton();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
            this.SuspendLayout();
            // 
            // btnRight
            // 
            this.btnRight.BackColor = System.Drawing.Color.White;
            this.btnRight.BorderColor = System.Drawing.Color.White;
            this.btnRight.FilterOperator = Zero5.Data.Filter.FilterExpression.Operators.Equal;
            this.btnRight.ForeColor = System.Drawing.SystemColors.ControlText;
            this.btnRight.ImageButton = Zero5.Resources.big_accept;
            this.btnRight.LabelFont = new System.Drawing.Font("Microsoft Sans Serif", 7.25F);
            this.btnRight.LabelText = null;
            this.btnRight.LineColor = System.Drawing.Color.Green;
            this.btnRight.Location = new System.Drawing.Point(353, 141);
            this.btnRight.Margin = new System.Windows.Forms.Padding(10, 10, 0, 0);
            this.btnRight.Name = "btnRight";
            this.btnRight.ParentPanel = null;
            this.btnRight.Selected = false;
            this.btnRight.SerializeFieldValue = false;
            this.btnRight.SerializeFieldValueIcon = Zero5.Resources.bullet_star_micro;
            this.btnRight.Size = new System.Drawing.Size(89, 57);
            this.btnRight.TabIndex = 0;
            this.btnRight.TabStop = false;
            this.btnRight.Text = "OK";
            this.btnRight.Click += new System.EventHandler(this.btnRight_Click);
            // 
            // lblMessaggio
            // 
            this.lblMessaggio.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblMessaggio.ForeColor = System.Drawing.Color.Green;
            this.lblMessaggio.Location = new System.Drawing.Point(12, 39);
            this.lblMessaggio.Name = "lblMessaggio";
            this.lblMessaggio.Size = new System.Drawing.Size(430, 99);
            this.lblMessaggio.TabIndex = 1;
            this.lblMessaggio.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            // 
            // pictureBox1
            // 
            this.pictureBox1.Image = Zero5.Resources.phase_logo_icona_piccolo;
            this.pictureBox1.Location = new System.Drawing.Point(6, 6);
            this.pictureBox1.Name = "pictureBox1";
            this.pictureBox1.Size = new System.Drawing.Size(30, 30);
            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
            this.pictureBox1.TabIndex = 10;
            this.pictureBox1.TabStop = false;
            // 
            // btnLeft
            // 
            this.btnLeft.BackColor = System.Drawing.Color.White;
            this.btnLeft.BorderColor = System.Drawing.Color.White;
            this.btnLeft.FilterOperator = Zero5.Data.Filter.FilterExpression.Operators.Equal;
            this.btnLeft.ForeColor = System.Drawing.SystemColors.ControlText;
            this.btnLeft.ImageButton = Zero5.Resources.big_cross;
            this.btnLeft.LabelFont = new System.Drawing.Font("Microsoft Sans Serif", 7.25F);
            this.btnLeft.LabelText = null;
            this.btnLeft.LineColor = System.Drawing.Color.Green;
            this.btnLeft.Location = new System.Drawing.Point(258, 141);
            this.btnLeft.Margin = new System.Windows.Forms.Padding(10, 10, 0, 0);
            this.btnLeft.Name = "btnLeft";
            this.btnLeft.ParentPanel = null;
            this.btnLeft.Selected = false;
            this.btnLeft.SerializeFieldValue = false;
            this.btnLeft.SerializeFieldValueIcon = Zero5.Resources.bullet_star_micro;
            this.btnLeft.Size = new System.Drawing.Size(89, 57);
            this.btnLeft.TabIndex = 11;
            this.btnLeft.TabStop = false;
            this.btnLeft.Text = "NO";
            this.btnLeft.Visible = false;
            this.btnLeft.Click += new System.EventHandler(this.btnLeft_Click);
            // 
            // btnOther
            // 
            this.btnOther.BackColor = System.Drawing.Color.White;
            this.btnOther.BorderColor = System.Drawing.Color.White;
            this.btnOther.FilterOperator = Zero5.Data.Filter.FilterExpression.Operators.Equal;
            this.btnOther.ForeColor = System.Drawing.SystemColors.ControlText;
            this.btnOther.ImageButton = Zero5.Resources.big_cross;
            this.btnOther.LabelFont = new System.Drawing.Font("Microsoft Sans Serif", 7.25F);
            this.btnOther.LabelText = null;
            this.btnOther.LineColor = System.Drawing.Color.Green;
            this.btnOther.Location = new System.Drawing.Point(15, 141);
            this.btnOther.Margin = new System.Windows.Forms.Padding(10, 10, 0, 0);
            this.btnOther.Name = "btnOther";
            this.btnOther.ParentPanel = null;
            this.btnOther.Selected = false;
            this.btnOther.SerializeFieldValue = false;
            this.btnOther.SerializeFieldValueIcon = Zero5.Resources.bullet_star_micro;
            this.btnOther.Size = new System.Drawing.Size(112, 57);
            this.btnOther.TabIndex = 12;
            this.btnOther.TabStop = false;
            this.btnOther.Text = "Interrompi";
            this.btnOther.Visible = false;
            this.btnOther.Click += new System.EventHandler(this.btnOther_Click);
            // 
            // MessageBox
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.White;
            this.ClientSize = new System.Drawing.Size(454, 210);
            this.Controls.Add(this.btnOther);
            this.Controls.Add(this.btnLeft);
            this.Controls.Add(this.pictureBox1);
            this.Controls.Add(this.lblMessaggio);
            this.Controls.Add(this.btnRight);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.Icon = Zero5.Resources.phase_logo_icona_eseguibile;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "MessageBox";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
            this.ResumeLayout(false);

        }

        #endregion

        private Field.FieldButton btnRight;
        private System.Windows.Forms.Label lblMessaggio;
        private System.Windows.Forms.PictureBox pictureBox1;
        private Field.FieldButton btnLeft;
        private Field.FieldButton btnOther;
    }
}
#endif
// file ...\Controls\Dialogs\TreeListBox.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Dialogs
{
    public partial class TreeListBox : Form
    {
        //attribute
        private List<int> lastDataChecked = new List<int>();

        //constructors
        public TreeListBox(): this(new List<Data.Filter.Field.TreeLookUpItem>(), "Phase - TreeListBox", "") {}
        public TreeListBox(List<Zero5.Data.Filter.Field.TreeLookUpItem> treeItems) : this(treeItems, "Phase - TreeListBox", "") { }
        public TreeListBox(List<Zero5.Data.Filter.Field.TreeLookUpItem> treeItems, string formTitle) : this(treeItems, formTitle, "") { }
        public TreeListBox(List<Zero5.Data.Filter.Field.TreeLookUpItem> treeItems, string formTitle, string treeTitle)
        {
            InitializeComponent();
            this.Text = formTitle;

            treeLstBox.SetKeyValues(treeItems);
            treeLstBox.LabelText = treeTitle;
        }

        public static string TestoOK;
        public static string TestoANNULLA;

        //properties
        public List<int> CheckedItems
        {
            set
            {
                treeLstBox.Values = value;
                lastDataChecked = value;
            }
            get
            {
                return treeLstBox.Values;
            }
        }
        public bool CheckedChanged
        {
            get 
            {
                if (treeLstBox.ShowAsList) return false;

                List<int> currentDataChecked = treeLstBox.Values;
                if (currentDataChecked.Count != lastDataChecked.Count)
                {
                    return true;
                }
                else
                {
                    for (int i = 0; i < lastDataChecked.Count; i++)
                    {
                        if (lastDataChecked[i] != currentDataChecked[i])
                        {
                            return true;
                        }
                    }
                    return false;
                }
            }
        }
        public bool ShowAsList
        {
            set
            {
                treeLstBox.ShowAsList = value;
            }
            get
            {
                return treeLstBox.ShowAsList;
            }
        }

        //event handler
        public new DialogResult ShowDialog()
        {
            return ShowDialog(null);
        }
        public DialogResult ShowDialog(List<int> lstCheckedItems)
        {

            if (lstCheckedItems != null)
            {
                treeLstBox.Values = lstCheckedItems;
                lastDataChecked = lstCheckedItems;
            }

            btnOk.Visible = true;
            btnNo.Visible = true;
            btnOk.Text = TestoOK;
            btnNo.Text = TestoANNULLA;

            return base.ShowDialog();
        }
        private void btnNo_Click(object sender, EventArgs e)
        {
            DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.Close();
        }
        private void btnOk_Click(object sender, EventArgs e)
        {
            DialogResult = System.Windows.Forms.DialogResult.OK;
            this.Close();
        }
    }
}

#endif
// file ...\Controls\Dialogs\TreeListBox.Designer.cs
#if !MOBILE && !CORE
namespace Zero5.Controls.Dialogs
{
    partial class TreeListBox
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

#region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(TreeListBox));
            this.btnOk = new Zero5.Controls.Field.FieldButton();
            this.pictureBox1 = new System.Windows.Forms.PictureBox();
            this.btnNo = new Zero5.Controls.Field.FieldButton();
            this.treeLstBox = new Zero5.Controls.Field.FieldTreeListBox();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
            this.SuspendLayout();
            // 
            // btnOk
            // 
            this.btnOk.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.btnOk.BackColor = System.Drawing.Color.White;
            this.btnOk.BorderColor = System.Drawing.Color.White;
            this.btnOk.FilterOperator = Zero5.Data.Filter.FilterExpression.Operators.Equal;
            this.btnOk.ForeColor = System.Drawing.SystemColors.ControlText;
            this.btnOk.ImageButton = Zero5.Resources.big_accept;
            this.btnOk.LabelFont = new System.Drawing.Font("Microsoft Sans Serif", 7.25F);
            this.btnOk.LabelText = null;
            this.btnOk.LineColor = System.Drawing.Color.Green;
            this.btnOk.Location = new System.Drawing.Point(361, 353);
            this.btnOk.Margin = new System.Windows.Forms.Padding(10, 10, 0, 0);
            this.btnOk.Name = "btnOk";
            this.btnOk.ParentPanel = null;
            this.btnOk.Selected = false;
            this.btnOk.SerializeFieldValue = false;
            this.btnOk.SerializeFieldValueIcon = Zero5.Resources.bullet_star_micro;
            this.btnOk.Size = new System.Drawing.Size(89, 57);
            this.btnOk.TabIndex = 0;
            this.btnOk.TabStop = false;
            this.btnOk.Text = "OK";
            this.btnOk.Click += new System.EventHandler(this.btnOk_Click);
            // 
            // pictureBox1
            // 
            this.pictureBox1.Image = Zero5.Resources.phase_logo_icona_piccolo;
            this.pictureBox1.Location = new System.Drawing.Point(6, 6);
            this.pictureBox1.Name = "pictureBox1";
            this.pictureBox1.Size = new System.Drawing.Size(30, 30);
            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
            this.pictureBox1.TabIndex = 10;
            this.pictureBox1.TabStop = false;
            // 
            // btnNo
            // 
            this.btnNo.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.btnNo.BackColor = System.Drawing.Color.White;
            this.btnNo.BorderColor = System.Drawing.Color.White;
            this.btnNo.FilterOperator = Zero5.Data.Filter.FilterExpression.Operators.Equal;
            this.btnNo.ForeColor = System.Drawing.SystemColors.ControlText;
            this.btnNo.ImageButton = Zero5.Resources.big_cross;
            this.btnNo.LabelFont = new System.Drawing.Font("Microsoft Sans Serif", 7.25F);
            this.btnNo.LabelText = null;
            this.btnNo.LineColor = System.Drawing.Color.Green;
            this.btnNo.Location = new System.Drawing.Point(266, 353);
            this.btnNo.Margin = new System.Windows.Forms.Padding(10, 10, 0, 0);
            this.btnNo.Name = "btnNo";
            this.btnNo.ParentPanel = null;
            this.btnNo.Selected = false;
            this.btnNo.SerializeFieldValue = false;
            this.btnNo.SerializeFieldValueIcon = Zero5.Resources.bullet_star_micro;
            this.btnNo.Size = new System.Drawing.Size(89, 57);
            this.btnNo.TabIndex = 11;
            this.btnNo.TabStop = false;
            this.btnNo.Text = "NO";
            this.btnNo.Visible = false;
            this.btnNo.Click += new System.EventHandler(this.btnNo_Click);
            // 
            // treeLstBox
            // 
            this.treeLstBox.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
            this.treeLstBox.BackColor = System.Drawing.Color.White;
            this.treeLstBox.BorderColor = System.Drawing.Color.White;
            this.treeLstBox.FilterOperator = Zero5.Data.Filter.FilterExpression.Operators.Equal;
            this.treeLstBox.ForeColor = System.Drawing.SystemColors.ControlText;
            this.treeLstBox.ImageButton = null;
            this.treeLstBox.LabelFont = new System.Drawing.Font("Microsoft Sans Serif", 7.25F);
            this.treeLstBox.LabelText = "";
            this.treeLstBox.LineColor = System.Drawing.Color.Green;
            this.treeLstBox.Location = new System.Drawing.Point(19, 40);
            this.treeLstBox.Margin = new System.Windows.Forms.Padding(10, 10, 0, 0);
            this.treeLstBox.Name = "treeLstBox";
            this.treeLstBox.ParentPanel = null;
            this.treeLstBox.Selected = false;
            this.treeLstBox.SerializeFieldValue = false;
            this.treeLstBox.SerializeFieldValueIcon = Zero5.Resources.bullet_star_micro;
            this.treeLstBox.Size = new System.Drawing.Size(431, 303);
            this.treeLstBox.TabIndex = 12;
            this.treeLstBox.TabStop = false;
            this.treeLstBox.Text = null;
            // 
            // TreeListBox
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.White;
            this.ClientSize = new System.Drawing.Size(462, 422);
            this.Controls.Add(this.treeLstBox);
            this.Controls.Add(this.btnNo);
            this.Controls.Add(this.pictureBox1);
            this.Controls.Add(this.btnOk);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.Icon = Zero5.Resources.phase_logo_icona_eseguibile;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "TreeListBox";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
            this.ResumeLayout(false);

        }

#endregion

        private Field.FieldButton btnOk;
        private System.Windows.Forms.PictureBox pictureBox1;
        private Field.FieldButton btnNo;
        private Field.FieldTreeListBox treeLstBox;
    }
}
#endif
// file ...\Controls\Field\FieldBinaryTextBox.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Field
{
    public class FieldBinaryTextBox : FieldControl, ILightControl
    {
        protected TextFileEdit.ucHexParam textBox = new TextFileEdit.ucHexParam();

        public FieldBinaryTextBox(int left, int top, int width, int height, string text)
            : this(left, top, width, height, text, 0)
        { }

        public FieldBinaryTextBox(int left, int top, int width, int height, string labelText, float fontSizeText)
            : this()
        {
            this.Left = left;
            this.Top = top;
            this.Width = width;
            this.Height = height;
            this.LabelText = labelText;
            if (fontSizeText != this.Font.SizeInPoints && fontSizeText != 0)
            {
                this.Font = new System.Drawing.Font(this.Font.FontFamily, 20, System.Drawing.FontStyle.Regular);
            }
            this.CanSerializeFieldValue = true;
        }

        public FieldBinaryTextBox()
            : base()
        {
            this.Width = 50;
            this.Height = 40;
            textBox.Location = new System.Drawing.Point(Common.BorderSize * 2, Common.BorderSize);
            textBox.Size = new System.Drawing.Size(this.Width - Common.BorderSize * 4, this.Height - Common.BorderSize * 2 + 1);
            textBox.Anchor = System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right | System.Windows.Forms.AnchorStyles.Top;
            textBox.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.Controls.Add(textBox);
            textBox.Invalidate();
            textBox.GotFocus += new EventHandler(textBox_GotFocus);
            textBox.LostFocus += new EventHandler(textBox_LostFocus);
            textBox.PreviewKeyDown += new System.Windows.Forms.PreviewKeyDownEventHandler(textBox_PreviewKeyDown);
            textBox.MouseDown += new System.Windows.Forms.MouseEventHandler(textBox_MouseDown);
            textBox.Leave += new EventHandler(textBox_Leave);
            textBox.KeyDown += new System.Windows.Forms.KeyEventHandler(textBox_KeyDown);
            textBox.KeyUp += new System.Windows.Forms.KeyEventHandler(textBox_KeyUp);
            textBox.TextChanged += new EventHandler(OnTextChanged);

            this.CanSerializeFieldValue = true;
            this.TabStop = false;
        }


        void textBox_KeyUp(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == System.Windows.Forms.Keys.Enter && lastKeyDown == System.Windows.Forms.Keys.Enter)
            {
                DoEnterKey();
            }
            //lastKeyDown = System.Windows.Forms.Keys.None;
            if (e.KeyCode == System.Windows.Forms.Keys.Enter)
                e.SuppressKeyPress = true;            
        }

        private System.Windows.Forms.Keys lastKeyDown = System.Windows.Forms.Keys.None;

        void textBox_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == System.Windows.Forms.Keys.Tab)
            {
                e.SuppressKeyPress = true;
                if (ParentPanel != null) ParentPanel.DoKeyPress(new System.Windows.Forms.KeyPressEventArgs('\t'));
            }
            lastKeyDown = e.KeyCode;
        }



        void textBox_Leave(object sender, EventArgs e)
        {
            //ParentPanel.Focus();
            //ParentPanel.SelectNextControl();
        }

        void textBox_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            //    ParentPanel.SelectControl(this);
            //    textBox.Focus();
        }

        void textBox_PreviewKeyDown(object sender, System.Windows.Forms.PreviewKeyDownEventArgs e)
        {
            //if (e.KeyData == System.Windows.Forms.Keys.Tab)
            //{ 
            //    ParentPanel.SelectNextControl();
            //}
        }

        void textBox_LostFocus(object sender, EventArgs e)
        {
            if (ParentPanel != null) ParentPanel.SelectControl(null);
            lastKeyDown = System.Windows.Forms.Keys.None;
        }

        void textBox_GotFocus(object sender, EventArgs e)
        {
            if (ParentPanel != null) ParentPanel.SelectControl(this);
        }

        public override string Text
        {
            get { return textBox.Text; }
            set { textBox.Text = value; }
        }

        public byte[] ByteArrayValue
        {
            get { return textBox.ByteArrayValue; }
            set { textBox.ByteArrayValue = value; }
        }

        public void OnTextChanged(object sender, EventArgs e)
        {
            base.OnTextChanged(e);
        }

        protected override void OnResize(EventArgs e)
        {
            base.OnResize(e);
            if (textBox != null) textBox.Invalidate();
        }

        public override System.Drawing.Color ForeColor
        {
            get { return textBox.ForeColor; }
            set { textBox.ForeColor = value; }
        }

        public override void InternalFocus()
        {
            //if (!textBox.Focused) textBox.Focus();
        }

        protected override void OnPaint(System.Windows.Forms.PaintEventArgs e)
        {
            if (!Visible) return;

            System.Drawing.Size sz = e.Graphics.MeasureString(" ", this.LabelFont).ToSize();

            int internalControlTop = sz.Height + 3 + Common.BorderSize + 1;

            textBox.Top = internalControlTop + 1;
            textBox.Height = this.Height - Common.BorderSize * 2 + 1 - internalControlTop;

            if (ImageButton != null)
            {
                textBox.Width = this.Width - Common.BorderSize * 4 - ImageButton.Width;
            }

            base.OnPaint(e);
        }

        public override int ObjectCodeNumber
        {
            get { return 116; }
        }

        public override void DoMouseDown(System.Windows.Forms.MouseEventArgs e)
        {
            textBox.Focus();
            base.DoMouseDown(e);
        }

        protected override void OnClick(EventArgs e)
        {
            //lastKeyDown = System.Windows.Forms.Keys.None;
            base.OnClick(e);
        }

        protected override void Serialize_InternalData()
        {
            base.Serialize_InternalData();

            //v1
            rawSerialize.Serialize(Text);

        }

        protected override int Deserialize_InternalData()
        {
            int serializedVersion = base.Deserialize_InternalData();
            if (serializedVersion >= 1)
            {
                string value = rawDeserialize.DeserializeString();
                if (SerializeFieldValue)
                    this.Text = value;
            }
            return serializedVersion;
        }
    }
}
#endif
// file ...\Controls\Field\FieldButton.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Field
{
    public class FieldButton : FieldControl, ILightControl
    {
        public class InternalButton : System.Windows.Forms.Button
        {
            private System.Drawing.Color HoverBackcolor;
            private System.Drawing.Color PressedBackcolor;

            public new System.Drawing.Color ForeColor
            {
                get { return base.ForeColor; }
                set { 
                    base.ForeColor = value;
                    this.PressedBackcolor = Common.Light(base.ForeColor);
                    this.HoverBackcolor = Common.LightLight(Common.LightLight(this.PressedBackcolor));
                }
            }

            protected override void OnPaint(System.Windows.Forms.PaintEventArgs pevent)
            {
                if (HoverBackcolor == null) HoverBackcolor = this.BackColor;
                if (PressedBackcolor == null) PressedBackcolor = this.BackColor;

                if (Press)
                    pevent.Graphics.Clear(this.PressedBackcolor);
                else if (OnOn)
                    pevent.Graphics.Clear(this.HoverBackcolor);
                else
                    pevent.Graphics.Clear(this.BackColor);

                int x = Common.BorderSize * 2;
                int y = Common.BorderSize;
                //System.Drawing.Color cShadow = Common.LightLight(this.ForeColor); //System.Drawing.Color.LightGray; // Common.DarkDark(this.BackColor); // 

                //x--; y--;
                //System.Windows.Forms.TextRenderer.DrawText(pevent.Graphics, this.Text, this.Font, Cache.RectangleCache.GetRectangle(x, y, this.Width - x, this.Height - y), cShadow, System.Windows.Forms.TextFormatFlags.WordBreak);
                //y++;
                //System.Windows.Forms.TextRenderer.DrawText(pevent.Graphics, this.Text, this.Font, Cache.RectangleCache.GetRectangle(x, y, this.Width - x, this.Height - y), cShadow, System.Windows.Forms.TextFormatFlags.WordBreak);
                //y++;
                //System.Windows.Forms.TextRenderer.DrawText(pevent.Graphics, this.Text, this.Font, Cache.RectangleCache.GetRectangle(x, y, this.Width - x, this.Height - y), cShadow, System.Windows.Forms.TextFormatFlags.WordBreak);
                
                //x+=2; y-=2;
                //System.Windows.Forms.TextRenderer.DrawText(pevent.Graphics, this.Text, this.Font, Cache.RectangleCache.GetRectangle(x, y, this.Width - x, this.Height - y), cShadow, System.Windows.Forms.TextFormatFlags.WordBreak);
                //y++;
                //System.Windows.Forms.TextRenderer.DrawText(pevent.Graphics, this.Text, this.Font, Cache.RectangleCache.GetRectangle(x, y, this.Width - x, this.Height - y), cShadow, System.Windows.Forms.TextFormatFlags.WordBreak);
                //y++;
                //System.Windows.Forms.TextRenderer.DrawText(pevent.Graphics, this.Text, this.Font, Cache.RectangleCache.GetRectangle(x, y, this.Width - x, this.Height - y), cShadow, System.Windows.Forms.TextFormatFlags.WordBreak);

                //x--;
                //System.Windows.Forms.TextRenderer.DrawText(pevent.Graphics, this.Text, this.Font, Cache.RectangleCache.GetRectangle(x, y, this.Width - x, this.Height - y), cShadow, System.Windows.Forms.TextFormatFlags.WordBreak);
                //y-=2;
                //System.Windows.Forms.TextRenderer.DrawText(pevent.Graphics, this.Text, this.Font, Cache.RectangleCache.GetRectangle(x, y, this.Width - x, this.Height - y), cShadow, System.Windows.Forms.TextFormatFlags.WordBreak);

                //y++;

                System.Windows.Forms.TextRenderer.DrawText(pevent.Graphics, this.Text, this.Font, Cache.RectangleCache.GetRectangle(x, y, this.Width - x * 2 - 1, this.Height - y * 2 - 1), this.ForeColor, System.Windows.Forms.TextFormatFlags.WordBreak | System.Windows.Forms.TextFormatFlags.VerticalCenter);

                int lineLen = 6;
                int borderDistance = 1; //Common.BorderSize
                int lineX1 = borderDistance;
                int lineY1 = borderDistance;
                int lineX2 = this.Width - borderDistance * 2;
                int lineY2 = this.Height - borderDistance * 2;
                //pevent.Graphics.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), Common.BorderSize, lineX, this.Width - Common.BorderSize * 2, lineX);
                pevent.Graphics.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), lineX1, lineY1, lineX1 + lineLen, lineY1);
                pevent.Graphics.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), lineX1, lineY1, lineX1, lineY1 + lineLen);

                pevent.Graphics.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), lineX2 - lineLen, lineY1, lineX2, lineY1);
                pevent.Graphics.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), lineX2, lineY1, lineX2, lineY1 + lineLen);
             
                pevent.Graphics.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), lineX1, lineY2, lineX1 + lineLen, lineY2);
                pevent.Graphics.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), lineX1, lineY2, lineX1, lineY2 - lineLen);

                if (this.Image != null)
                {
                    //pevent.Graphics.DrawRectangle(Cache.PenCache.GetPen(System.Drawing.Color.Black, 1), lineX2 - this.Image.Width, lineY2 - this.Image.Height, this.Image.Width, this.Image.Height);
                    pevent.Graphics.DrawImage(this.Image, lineX2 - this.Image.Width + 1, lineY2 - this.Image.Height + 1);
                    //pevent.Graphics.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), Common.BorderSize, lineX, this.Width - this.Image.Width - Common.BorderSize * 2, lineX);
                }
                else
                {
                    //pevent.Graphics.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), Common.BorderSize, lineX, this.Width, lineX);
                }

                //pevent.Graphics.DrawRectangle(Cache.PenCache.GetPen(System.Drawing.Color.Red, 1), Cache.RectangleCache.GetRectangle(x, y, this.Width - x * 2 - 1, this.Height - y * 2 - 1));
           
                //base.OnPaint(pevent);
            }

            bool OnOn = false;
            bool Press = false;

            protected override void OnMouseEnter(EventArgs e)
            {
                OnOn = true;
                base.OnMouseEnter(e);
            }
            protected override void OnMouseLeave(EventArgs e)
            {
                OnOn = false;
                Press = false;
                base.OnMouseLeave(e);
            }
            protected override void OnMouseDown(System.Windows.Forms.MouseEventArgs mevent)
            {
                Press = true;
                base.OnMouseDown(mevent);
            }
            protected override void OnMouseUp(System.Windows.Forms.MouseEventArgs mevent)
            {
                Press = false;
                base.OnMouseUp(mevent);
            }
            protected override void OnKeyPress(System.Windows.Forms.KeyPressEventArgs e)
            {
                if (e.KeyChar == ' ') Press = true;
                base.OnKeyPress(e);
            }
            protected override void OnKeyUp(System.Windows.Forms.KeyEventArgs kevent)
            {
                Press = false;
                base.OnKeyUp(kevent);
            }
            protected override void OnClick(EventArgs e)
            {
                base.OnClick(e);
            }
        }

        InternalButton button = new InternalButton();

        public FieldButton(int left, int top, int width, int height, string text, System.Drawing.Image image)
            : this(left, top, width, height, text, image, 0)
        { }

        public FieldButton(int left, int top, int width, int height, string text, System.Drawing.Image image, float fontSizeText)
            : this()
        {
            this.Left = left;
            this.Top = top;
            this.Width = width;
            this.Height = height;
            this.Text = text;
            this.ImageButton = image;
            if (fontSizeText != this.Font.SizeInPoints && fontSizeText != 0)
                this.Font = new System.Drawing.Font(this.Font.FontFamily, 20, System.Drawing.FontStyle.Regular);
        }

        public FieldButton()
            : base()
        {           

            this.Width = 100;
            this.Height = 40;
            button.Location = new System.Drawing.Point(Common.BorderSize, Common.BorderSize);
            button.Size = new System.Drawing.Size(this.Width - Common.BorderSize * 2 + 1, this.Height - Common.BorderSize * 2 + 1);
            button.Anchor = System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right | System.Windows.Forms.AnchorStyles.Top;
            button.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            button.UseVisualStyleBackColor = false;
            button.Padding = new System.Windows.Forms.Padding(5);
            button.GotFocus += new EventHandler(button_GotFocus);
            button.LostFocus += new EventHandler(button_LostFocus);
            //button.PreviewKeyDown += new System.Windows.Forms.PreviewKeyDownEventHandler(button_PreviewKeyDown);
            //button.MouseDown += new System.Windows.Forms.MouseEventHandler(button_MouseDown);
            //button.Leave += new EventHandler(button_Leave);

            button.Click += new EventHandler(button_Click);

            button.KeyDown += new System.Windows.Forms.KeyEventHandler(button_KeyDown);
            button.KeyUp += new System.Windows.Forms.KeyEventHandler(button_KeyUp);
            button.ImageAlign = System.Drawing.ContentAlignment.BottomRight;
            button.TextAlign = System.Drawing.ContentAlignment.TopLeft;
            button.TextImageRelation = System.Windows.Forms.TextImageRelation.TextBeforeImage;

            button.BackColor = Common.BackColor;
            button.ForeColor = Common.LineColor;
            this.BackColor = Common.BackColor;
            this.BorderColor = Common.BackColor;

            //button.Font = new System.Drawing.Font(this.Font.FontFamily, this.Font.SizeInPoints, System.Drawing.FontStyle.Bold);
            //this.BorderColor = Common.BackColor;

            this.button.TabStop = true;
            this.TabStop = false;

            this.Controls.Add(button);
            button.Invalidate();
            
            this.LabelVisible = false;
        }

        void button_KeyUp(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == System.Windows.Forms.Keys.Enter && lastKeyDown == System.Windows.Forms.Keys.Enter)
            {
                DoEnterKey();
            }
            lastKeyDown = System.Windows.Forms.Keys.None;
        }

        void button_Click(object sender, EventArgs e)
        {
            this.OnClick(e);
        }

        private System.Windows.Forms.Keys lastKeyDown = System.Windows.Forms.Keys.None;

        void button_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == System.Windows.Forms.Keys.Tab)
            {
                e.SuppressKeyPress = true;
                if (ParentPanel != null) ParentPanel.DoKeyPress(new System.Windows.Forms.KeyPressEventArgs('\t'));
            }
            lastKeyDown = e.KeyCode;
        }

        //void button_Leave(object sender, EventArgs e)
        //{
        //    //ParentPanel.Focus();
        //    //ParentPanel.SelectNextControl();
        //}

        //void button_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        //{
        ////    ParentPanel.SelectControl(this);
        ////    textBox.Focus();
        //}

        //void button_PreviewKeyDown(object sender, System.Windows.Forms.PreviewKeyDownEventArgs e)
        //{
        //    //if (e.KeyData == System.Windows.Forms.Keys.Tab)
        //    //{ 
        //    //    ParentPanel.SelectNextControl();
        //    //}
        //}

        void button_LostFocus(object sender, EventArgs e)
        {
            if (ParentPanel != null) ParentPanel.SelectControl(null);
            lastKeyDown = System.Windows.Forms.Keys.None;
        }

        void button_GotFocus(object sender, EventArgs e)
        {
            if (ParentPanel != null) ParentPanel.SelectControl(this);            
        }

        public override System.Drawing.Color LineColor
        {
            get { return base.LineColor; }
            set
            {
                base.LineColor = value;
                button.ForeColor = value;
            }
        }

        public override string Text
        {
            get
            {
                return button.Text;
            }
            set
            {
                button.Text = value;
            }
        }

        public new System.Drawing.Font Font
        {
            get { return this.button.Font; }
            set { this.button.Font = value; }
        }

        protected override void OnResize(EventArgs e)
        {
            base.OnResize(e);
            if (button != null) button.Invalidate();
        }
        
        public override System.Drawing.Image ImageButton
        {
            get { return this.button.Image; }
            set { this.button.Image = value; }
        }

        public override void InternalFocus()
        {
            //if (!textBox.Focused) textBox.Focus();
        }

        public override int ObjectCodeNumber
        {
            get { return 105; }
        }

        protected override void Serialize_InternalData()
        {
            base.Serialize_InternalData();
            rawSerialize.Serialize(this.Text);
        }

        protected override int Deserialize_InternalData()
        {
            int serializedVersion = base.Deserialize_InternalData();            
            this.Text = rawDeserialize.DeserializeString();
            return serializedVersion;
        }

        public override void DoMouseDown(System.Windows.Forms.MouseEventArgs e)
        {
            button.Focus();
            base.DoMouseDown(e);
        }

        protected override void OnPaint(System.Windows.Forms.PaintEventArgs e)
        {
            base.OnPaint(e);
            //RenderInternalBorder(e.Graphics, 1, 1, this.Width, this.Height, Cache.PenCache.GetPen(this.BorderColor, 1), Cache.PenCache.GetPen(Common.LightLight(this.BorderColor), 1), Cache.PenCache.GetPen(Common.DarkDark(this.BorderColor), 1));
        }

        private void RenderInternalBorder(System.Drawing.Graphics g, int x, int y, int w, int h, System.Drawing.Pen pNatural, System.Drawing.Pen pDarker, System.Drawing.Pen pLighter)
        {
            g.DrawLine(pNatural, x + 1, y + 2, x + 2, y + 2);
            g.DrawLine(pLighter, x + 1, y + 2, x + 2, y + 1);
            g.DrawLine(pNatural, x + 3, y + 1, x + w - 4, y + 1);
            g.DrawLine(pNatural, x + w - 3, y + 2, x + w - 2, y + 2);
            g.DrawLine(pLighter, x + w - 3, y + 1, x + w - 2, y + 2);
            g.DrawLine(pNatural, x + w - 2, y + 3, x + w - 2, y + h - 4);
            g.DrawLine(pNatural, x + w - 2, y + h - 3, x + w - 3, y + h - 3);
            g.DrawLine(pLighter, x + w - 2, y + h - 3, x + w - 3, y + h - 2);
            g.DrawLine(pNatural, x + 3, y + h - 2, x + w - 4, y + h - 2);
            g.DrawLine(pNatural, x + 2, y + h - 2, x + 2, y + h - 3);
            g.DrawLine(pLighter, x + 2, y + h - 2, x + 1, y + h - 3);
            g.DrawLine(pNatural, x + 1, y + 3, x + 1, y + h - 4);
        }
    }
}

#endif
// file ...\Controls\Field\FieldCheckBox.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Field
{
    public class FieldCheckBox : FieldControl, ILightControl
    {
        protected System.Windows.Forms.CheckBox checkBox = new System.Windows.Forms.CheckBox();

        //[Description("Occurres when the chacked state changed")]
        public event EventHandler CheckedChanged;

        public FieldCheckBox(int left, int top, int width, int height, string text)
            : this(left, top, width, height, text, 0)
        { }

        public FieldCheckBox(int left, int top, int width, int height, string labelText, float fontSizeText)
            : this()
        {
            this.Left = left;
            this.Top = top;
            this.Width = width;
            this.Height = height;
            this.LabelText = labelText;
            if (fontSizeText != this.Font.SizeInPoints && fontSizeText != 0)
            {
                this.Font = new System.Drawing.Font(this.Font.FontFamily, 20, System.Drawing.FontStyle.Regular);
            }
        }

        public FieldCheckBox()
            : base()
        {

            this.Width = 50;
            this.Height = 40;
            checkBox.Location = new System.Drawing.Point(Common.BorderSize * 2, Common.BorderSize);
            checkBox.Size = new System.Drawing.Size(this.Width - Common.BorderSize * 4, this.Height - Common.BorderSize * 2 + 1);
            checkBox.Anchor = System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right | System.Windows.Forms.AnchorStyles.Top;
            this.Controls.Add(checkBox);
            checkBox.Invalidate();
            checkBox.GotFocus += new EventHandler(checkBox_GotFocus);
            checkBox.LostFocus += new EventHandler(checkBox_LostFocus);
            //checkBox.PreviewKeyDown += new System.Windows.Forms.PreviewKeyDownEventHandler(checkBox_PreviewKeyDown);
            //checkBox.MouseDown += new System.Windows.Forms.MouseEventHandler(checkBox_MouseDown);
            //checkBox.Leave += new EventHandler(checkBox_Leave);
            checkBox.KeyDown += new System.Windows.Forms.KeyEventHandler(checkBox_KeyDown);
            checkBox.KeyUp += new System.Windows.Forms.KeyEventHandler(checkBox_KeyUp);
            checkBox.CheckedChanged += new EventHandler(checkBox_CheckedChanged);

            this.TabStop = false;
            CanSerializeFieldValue = true;
        }

        void checkBox_CheckedChanged(object sender, EventArgs e)
        {
            if (CheckedChanged != null)
                CheckedChanged(this, EventArgs.Empty);
        }


        void checkBox_KeyUp(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == System.Windows.Forms.Keys.Enter && lastKeyDown == System.Windows.Forms.Keys.Enter)
            {
                DoEnterKey();
            }
            //lastKeyDown = System.Windows.Forms.Keys.None;
            if (e.KeyCode == System.Windows.Forms.Keys.Enter)
                e.SuppressKeyPress = true;
        }

        private System.Windows.Forms.Keys lastKeyDown = System.Windows.Forms.Keys.None;

        void checkBox_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == System.Windows.Forms.Keys.Tab)
            {
                e.SuppressKeyPress = true;
                if (ParentPanel != null) ParentPanel.DoKeyPress(new System.Windows.Forms.KeyPressEventArgs('\t'));
            }
            lastKeyDown = e.KeyCode;
            if (e.KeyCode == System.Windows.Forms.Keys.Enter)
                e.SuppressKeyPress = true;

        }

        //void checkBox_Leave(object sender, EventArgs e)
        //{
        //    //ParentPanel.Focus();
        //    //ParentPanel.SelectNextControl();
        //}

        //void checkBox_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        //{
        //    //    ParentPanel.SelectControl(this);
        //    //    textBox.Focus();
        //}

        //void checkBox_PreviewKeyDown(object sender, System.Windows.Forms.PreviewKeyDownEventArgs e)
        //{
        //    //if (e.KeyData == System.Windows.Forms.Keys.Tab)
        //    //{ 
        //    //    ParentPanel.SelectNextControl();
        //    //}
        //}

        void checkBox_LostFocus(object sender, EventArgs e)
        {
            if (ParentPanel != null) ParentPanel.SelectControl(null);
            lastKeyDown = System.Windows.Forms.Keys.None;
        }

        void checkBox_GotFocus(object sender, EventArgs e)
        {
            if (ParentPanel != null) ParentPanel.SelectControl(this);
        }

        public bool Checked
        {
            get { return checkBox.Checked; }
            set { checkBox.Checked = value; }
        }

        public override string Text
        {
            get { return checkBox.Text; }
            set { checkBox.Text = value; }
        }

        public override bool ReadOnly
        {
            get
            {
                return !checkBox.Enabled;
            }
            set
            {
                checkBox.Enabled = !value;
            }
        }

        protected override void OnResize(EventArgs e)
        {
            base.OnResize(e);
            if (checkBox != null) checkBox.Invalidate();
        }

        public override System.Drawing.Color ForeColor
        {
            get { return checkBox.ForeColor; }
            set { checkBox.ForeColor = value; }
        }

        public override void InternalFocus()
        {
            //if (!textBox.Focused) textBox.Focus();
        }

        protected override void OnPaint(System.Windows.Forms.PaintEventArgs e)
        {
            if (!Visible) return;

            System.Drawing.Size sz = e.Graphics.MeasureString(" ", this.LabelFont).ToSize();

            int internalControlTop = sz.Height + 3 + Common.BorderSize + 1;

            checkBox.Top = internalControlTop + 1;
            checkBox.Height = this.Height - Common.BorderSize * 2 + 1 - internalControlTop;

            if (ImageButton != null)
            {
                checkBox.Width = this.Width - Common.BorderSize * 4 - ImageButton.Width;
            }

            base.OnPaint(e);
        }

        public override int ObjectCodeNumber
        {
            get { return 109; }
        }

        public override void DoMouseDown(System.Windows.Forms.MouseEventArgs e)
        {
            checkBox.Focus();
            base.DoMouseDown(e);
        }

        protected override void OnClick(EventArgs e)
        {
            //lastKeyDown = System.Windows.Forms.Keys.None;
            base.OnClick(e);
        }

        protected override void Serialize_InternalData()
        {
            base.Serialize_InternalData();

            //v3
            rawSerialize.Serialize(this.Checked);
        }

        protected override int Deserialize_InternalData()
        {
            int serializedVersion = base.Deserialize_InternalData();
            if (serializedVersion >= 3)
            {
                bool value = rawDeserialize.DeserializeBool();
                if (SerializeFieldValue)
                    this.Checked = value;
            }
            return serializedVersion;
        }
    }
}

#endif
// file ...\Controls\Field\FieldColor.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Field
{
    public class FieldColor : FieldControl, ILightControl
    {
        public FieldColor(int left, int top, int width, int height, string text)
            : this(left, top, width, height, text, 0)
        { }

        public FieldColor(int left, int top, int width, int height, string labelText, float fontSizeText)
            : this()
        {
            this.Left = left;
            this.Top = top;
            this.Width = width;
            this.Height = height;
            this.LabelText = labelText;
            if (fontSizeText != this.Font.SizeInPoints && fontSizeText != 0)
            {
                this.Font = new System.Drawing.Font(this.Font.FontFamily, 20, System.Drawing.FontStyle.Regular);
            }
        }

        public FieldColor()
            : base()
        {
            this.Width = 50;
            this.Height = 40;

            this.TabStop = false;

            this.ImageButton = Zero5.Resources.color_swatch;
        }

        protected override void OnMouseClick(System.Windows.Forms.MouseEventArgs e)
        {
            base.OnMouseClick(e);
            if (ImageButtonHitTest(e.Location))
            {
                System.Windows.Forms.ColorDialog cd = new System.Windows.Forms.ColorDialog();
                if (cd.ShowDialog() == System.Windows.Forms.DialogResult.OK)
                {
                    this.Color = cd.Color;
                    this.Invalidate();
                }
            }
        }
        
        private System.Drawing.Color _internalColor = System.Drawing.Color.Empty;

        public System.Drawing.Color Color
        {
            get { return _internalColor; }
            set
            {
                _internalColor = value;
                Invalidate();
            }
        }
        
        protected override void OnPaint(System.Windows.Forms.PaintEventArgs e)
        {
            if (!Visible) return;
            
            base.OnPaint(e);

            System.Drawing.Size sz = e.Graphics.MeasureString(" ", this.LabelFont).ToSize();

            int internalControlTop = sz.Height + 3 + Common.BorderSize + 1;

            int imageWidth = 0;
            if (ImageButton != null)
                imageWidth = ImageButton.Width + Common.BorderSize * 4;
            
            e.Graphics.FillRectangle(Cache.BrushCache.GetBrush(this.Color),
                Common.BorderSize * 2, 
                internalControlTop, 
                this.Width - ((Common.BorderSize * 1) + imageWidth), 
                this.Height - ((Common.BorderSize * 2) + internalControlTop));
        }

        public override int ObjectCodeNumber
        {
            get { return 114; }
        }

        protected override void Serialize_InternalData()
        {
            base.Serialize_InternalData(); 
        }

        protected override int Deserialize_InternalData()
        {
            return base.Deserialize_InternalData();
        }

    }
}

#endif
// file ...\Controls\Field\FieldComboBox.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Field
{
    public class FieldComboBox : FieldControl, ILightControl, IControlWithKeyValue
    {
        public event ItemChangedEventHandler SelectedIndexChanged;
        public delegate void ItemChangedEventHandler(object sender, EventArgs e);

        public class InternalComboBox : System.Windows.Forms.ComboBox
        {
            private System.Drawing.Color _borderColor = System.Drawing.Color.White;

            private System.Windows.Forms.ButtonBorderStyle _borderStyle = System.Windows.Forms.ButtonBorderStyle.Solid;
            private static int WM_PAINT = 0x000F;
            
            protected override void WndProc(ref System.Windows.Forms.Message m)
            {

                base.WndProc(ref m);

                if (m.Msg == WM_PAINT)
                {
                    System.Drawing.Graphics g = System.Drawing.Graphics.FromHwnd(Handle);
                    System.Drawing.Rectangle bounds = new System.Drawing.Rectangle(0, 0, Width, Height);
                    System.Windows.Forms.ControlPaint.DrawBorder(g, bounds, _borderColor, _borderStyle);
                    //g.DrawLine(System.Drawing.Pens.Green, 0, 0, Width, 0);

                    //if (Parent != null)
                    //    if (Parent.Width == this.Top + this.Height)
                    //        g.DrawLine(Zero5.Controls.Common.SelectedColorPen, 0, 0, Width, 0);

                }
            }

            public System.Drawing.Color BorderColor
            {
                get { return _borderColor; }
                set
                {
                    _borderColor = value;
                    Invalidate(); // causes control to be redrawn
                }
            }

            public System.Windows.Forms.ButtonBorderStyle BorderStyle
            {
                get { return _borderStyle; }
                set
                {
                    _borderStyle = value;
                    Invalidate();
                }
            }

        }

        protected EasyCompletionComboBox comboBox = new EasyCompletionComboBox();

        public FieldComboBox(int left, int top, int width, int height, string text)
            : this(left, top, width, height, text, 0)
        { }

        public FieldComboBox(int left, int top, int width, int height, string labelText, float fontSizeText)
            : this()
        {
            this.Left = left;
            this.Top = top;
            this.Width = width;
            this.Height = height;
            this.LabelText = labelText;
            if (fontSizeText != this.Font.SizeInPoints && fontSizeText != 0)
            {
                this.Font = new System.Drawing.Font(this.Font.FontFamily, 20, System.Drawing.FontStyle.Regular);
            }
        }

        public FieldComboBox()
            : base()
        {

            this.Width = 50;
            this.Height = 40;
            comboBox.Location = new System.Drawing.Point(Common.BorderSize * 2, Common.BorderSize);
            comboBox.Size = new System.Drawing.Size(this.Width - Common.BorderSize * 4, this.Height - Common.BorderSize * 2 + 1);
            comboBox.Anchor = System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right | System.Windows.Forms.AnchorStyles.Top;
            //comboBox.BorderStyle = System.Windows.Forms.BorderStyle.None;
            //comboBox.Multiline = false;
            //comboBox.AcceptsTab = false;
            this.Controls.Add(comboBox);
            comboBox.Invalidate();
            comboBox.GotFocus += new EventHandler(comboBox_GotFocus);
            comboBox.LostFocus += new EventHandler(comboBox_LostFocus);
            //comboBox.PreviewKeyDown += new System.Windows.Forms.PreviewKeyDownEventHandler(comboBox_PreviewKeyDown);
            //comboBox.MouseDown += new System.Windows.Forms.MouseEventHandler(comboBox_MouseDown);
            //comboBox.Leave += new EventHandler(comboBox_Leave);
            comboBox.KeyDown += new System.Windows.Forms.KeyEventHandler(comboBox_KeyDown);
            comboBox.KeyUp += new System.Windows.Forms.KeyEventHandler(comboBox_KeyUp);
            comboBox.SelectedIndexChanged += new EventHandler(comboBox_SelectedIndexChanged);
            comboBox.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDown;
            comboBox.AutoCompleteSource = System.Windows.Forms.AutoCompleteSource.None;
            comboBox.AutoCompleteMode = System.Windows.Forms.AutoCompleteMode.None;
            comboBox.FlatStyle = FlatStyle.Flat;

            //comboBox.DrawMode = System.Windows.Forms.DrawMode.OwnerDrawVariable;
            //comboBox.DrawItem += new System.Windows.Forms.DrawItemEventHandler(comboBox_DrawItem);
            //comboBox.MeasureItem += new System.Windows.Forms.MeasureItemEventHandler(comboBox_MeasureItem);
            this.TabStop = false;
            this.CanSerializeFieldValue = true;
        }

        public void comboBox_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (SelectedIndexChanged != null) { SelectedIndexChanged(sender, e); }
        }

        //void comboBox_MeasureItem(object sender, System.Windows.Forms.MeasureItemEventArgs e)
        //{
        //    e.ItemHeight = comboBox.Height;
        //    e.ItemHeight = comboBox.Width;
        //}

        //void comboBox_DrawItem(object sender, System.Windows.Forms.DrawItemEventArgs e)
        //{
        //    // Draw the background of the item.
        //    e.DrawBackground();
        //    e.Graphics.DrawString(comboBox.Text, comboBox.Font, System.Drawing.Brushes.Black, comboBox.Left, comboBox.Top);
        //}


        void comboBox_KeyUp(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == System.Windows.Forms.Keys.Enter && lastKeyDown == System.Windows.Forms.Keys.Enter)
            {
                DoEnterKey();
            }
        }

        private System.Windows.Forms.Keys lastKeyDown = System.Windows.Forms.Keys.None;

        void comboBox_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == System.Windows.Forms.Keys.Tab)
            {
                e.SuppressKeyPress = true;
                if (ParentPanel != null) ParentPanel.DoKeyPress(new System.Windows.Forms.KeyPressEventArgs('\t'));
            }
            lastKeyDown = e.KeyCode;
        }

        //void comboBox_Leave(object sender, EventArgs e)
        //{
        //    //ParentPanel.Focus();
        //    //ParentPanel.SelectNextControl();
        //}

        //void comboBox_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        //{
        //    //    ParentPanel.SelectControl(this);
        //    //    comboBox.Focus();
        //}

        //void comboBox_PreviewKeyDown(object sender, System.Windows.Forms.PreviewKeyDownEventArgs e)
        //{
        //    //if (e.KeyData == System.Windows.Forms.Keys.Tab)
        //    //{ 
        //    //    ParentPanel.SelectNextControl();
        //    //}
        //}

        void comboBox_LostFocus(object sender, EventArgs e)
        {
            if (ParentPanel != null) ParentPanel.SelectControl(null);
        }

        void comboBox_GotFocus(object sender, EventArgs e)
        {
            if (ParentPanel != null) ParentPanel.SelectControl(this);
        }

        public override string Text
        {
            get { return comboBox.Text; }
            set { comboBox.Text = value; }
        }

        public override bool ReadOnly
        {
            get
            {
                return !comboBox.Enabled;
            }
            set
            {
                comboBox.Enabled = !value;
            }
        }

        public int Value
        {
            get
            {
                try
                {
                    //string tmp = comboBox.Text;
                    //comboBox.Text = "";
                    //comboBox.Text = tmp;
                    //comboBox.SelectedValue = comboBox.SelectedValue;

                    if (comboBox.SelectedValue == null) return -1000;
                    return (int)comboBox.SelectedValue;
                }
                catch { }
                return -1000;
            }
            set
            {
                try
                {
                    comboBox.SelectedValue = value;
                }
                catch { }
            }
        }

        protected override void OnResize(EventArgs e)
        {
            base.OnResize(e);
            if (comboBox != null) comboBox.Invalidate();
        }

        public override System.Drawing.Color ForeColor
        {
            get { return comboBox.ForeColor; }
            set { comboBox.ForeColor = value; }
        }

        public override void InternalFocus()
        {
            //if (!comboBox.Focused) comboBox.Focus();
        }

        protected override void OnPaint(System.Windows.Forms.PaintEventArgs e)
        {
            if (!Visible) return;

            System.Drawing.Size sz = e.Graphics.MeasureString(" ", this.LabelFont).ToSize();

            int internalControlTop = sz.Height + 3 + Common.BorderSize + 1;

            comboBox.Top = internalControlTop - 2;
            comboBox.Height = this.Height - Common.BorderSize * 2 + 1 - internalControlTop;

            if (ImageButton != null)
            {
                comboBox.Width = this.Width - Common.BorderSize * 4 - ImageButton.Width;
            }

            base.OnPaint(e);
        }

        public override int ObjectCodeNumber
        {
            get { return 106; }
        }

        public override void DoMouseDown(System.Windows.Forms.MouseEventArgs e)
        {
            comboBox.Focus();
            base.DoMouseDown(e);
        }

        public System.Windows.Forms.ComboBox.ObjectCollection Items
        {
            get { return comboBox.Items; }
        }

        private int DeserializedSelectedValue = -1000;

        public void SetKeyValues(Dictionary<int, string> keyValues, int iDefault)
        {
            comboBox.DisplayMember = "Value";
            comboBox.ValueMember = "Key";
            if (keyValues == null || keyValues.Count == 0) return;
            comboBox.DataSource = new System.Windows.Forms.BindingSource(keyValues, null);
            comboBox.SelectedValue = iDefault;
            if (DeserializedSelectedValue != -1000)
                comboBox.SelectedValue = DeserializedSelectedValue;
        }

        protected override void Serialize_InternalData()
        {
            base.Serialize_InternalData();

            //v3
            rawSerialize.Serialize(this.Value);
        }

        protected override int Deserialize_InternalData()
        {
            int serializedVersion = base.Deserialize_InternalData();
            if (serializedVersion >= 3)
            {
                int value = rawDeserialize.DeserializeInt();
                if (SerializeFieldValue) this.DeserializedSelectedValue = value;
            }
            return serializedVersion;
        }

        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);

            comboBox.DataSource = null;
            comboBox = null;
        }
    }
}

#endif
// file ...\Controls\Field\FieldComboBoxLookUp.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Field
{
    public class FieldComboBoxLookUp : FieldComboBox
    {
        public FieldComboBoxLookUp(int left, int top, int width, int height, string text)
            : this(left, top, width, height, text, 0)
        {
            Init();
        }

        public FieldComboBoxLookUp(int left, int top, int width, int height, string labelText, float fontSizeText)
            : base(left, top, width, height, labelText, fontSizeText)
        {
            Init();
        }

        public FieldComboBoxLookUp()
            : base()
        {
            Init();
        }

        private void Init()
        {
            this.ImageButton = Zero5.Resources.application_view_columns;
            this.comboBox.KeyDown += new System.Windows.Forms.KeyEventHandler(comboBox_KeyUp);
        }

        protected virtual void comboBox_KeyUp(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == System.Windows.Forms.Keys.F3)
            {
                OnImageButtonClick(null);
            }
        }

        public override int ObjectCodeNumber
        {
            get { return 115; }
        }

    }
}

#endif
// file ...\Controls\Field\FieldControl.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Field
{

    [DesignerAttribute(typeof(DemoControlDesigner))]
    public class FieldControl : System.Windows.Forms.Control, ILightControl
    {
        private const int CurrentSerializationVersion = 4;

        public FieldControl()
        {
            this.SetStyle(System.Windows.Forms.ControlStyles.SupportsTransparentBackColor, true);
            this.SetStyle(System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer, true);
            this.SetStyle(System.Windows.Forms.ControlStyles.UserPaint, true);
            this.BackColor = Common.BackColor;
            this.ForeColor = Common.ForeColor;
        }

        private int cornerHitSize = 7;

        //private string fieldName = "";
        protected string FieldName
        {
            get { return field.FieldName; } //OneCodeTODO: Giorgio, fix memory leak usando private string fieldname. Dopo verificare PanelDataBind.cs, map lookup dei FieldDateTimePicker. Non trova il fieldname
            set { field.FieldName = value; }
        }

        private Zero5.Data.Filter.Field field = new Data.Filter.Field("", "", typeof(string), "", Data.Filter.eFieldVisibility.ReadWrite, Data.Filter.eFieldRequired.Required, null);
        public Zero5.Data.Filter.Field Field
        {
            get { return field; }
            set { field = value; }
        }

        private Zero5.Data.Filter.FilterExpression.Operators filterOperator = Data.Filter.FilterExpression.Operators.Equal;
        public Zero5.Data.Filter.FilterExpression.Operators FilterOperator
        {
            get { return filterOperator; }
            set { filterOperator = value; }
        }


        private System.Drawing.Color borderColor = Common.BorderColor;
        public System.Drawing.Color BorderColor
        {
            get { return borderColor; }
            set { borderColor = value; }
        }

        private System.Drawing.Color lineColor = Common.LineColor;
        public virtual System.Drawing.Color LineColor
        {
            get { return lineColor; }
            set { lineColor = value; }
        }

        private bool selected = false;
        public virtual bool Selected
        {
            get { return selected; }
            set
            {
                if (!value) this.InternalFocus();
                selected = value; this.Invalidate();
            }
        }

        public new int Height
        {
            get { return base.Height; }
            set { base.Height = value; this.Invalidate(); }
        }

        public new int Width
        {
            get { return base.Width; }
            set { base.Width = value; this.Invalidate(); }
        }

        private string labelText;

        public string LabelText
        {
            get { return labelText; }
            set { labelText = value; }
        }

        protected bool readOnly = false;
        public virtual bool ReadOnly
        {
            get
            {
                return readOnly;
            }
            set
            {
                readOnly = value;
            }
        }

        public bool CanSerializeFieldValue = false;

        private bool serializeFieldValue = false;
        public bool SerializeFieldValue
        {
            get { return serializeFieldValue; }
            set
            {
                serializeFieldValue = value;
                Invalidate();
            }
        }

        private System.Drawing.Font labelFont = new System.Drawing.Font(
                                                        System.Drawing.SystemFonts.DefaultFont.FontFamily,
                                                        System.Drawing.SystemFonts.DefaultFont.SizeInPoints - 1, System.Drawing.FontStyle.Regular);

        public System.Drawing.Font LabelFont
        {
            get { return labelFont; }
            set { labelFont = value; }
        }

        private System.Drawing.Image iconSerializeFieldValue = Zero5.Resources.bullet_star_micro;
        public virtual System.Drawing.Image SerializeFieldValueIcon
        {
            get { return iconSerializeFieldValue; }
            set { iconSerializeFieldValue = value; }
        }

        private System.Drawing.Image imageButton = null;
        public virtual System.Drawing.Image ImageButton
        {
            get { return imageButton; }
            set { imageButton = value; }
        }

        private int ImageButtonTop = 0;
        private int ImageButtonLeft = 0;
        private int ImageButtonHeight = 0;
        private int ImageButtonWidth = 0;

        protected bool ImageButtonHitTest(System.Drawing.Point mouseLocation)
        {
            if (mouseLocation.X >= ImageButtonLeft)
                if (mouseLocation.Y >= ImageButtonTop)
                    if (mouseLocation.X <= ImageButtonLeft + ImageButtonWidth)
                        if (mouseLocation.Y <= ImageButtonTop + ImageButtonHeight)
                            return true;
            return false;
        }

        public delegate void ImageButtonClickHandler(FieldControl sender, System.Windows.Forms.MouseEventArgs e);
        public event ImageButtonClickHandler ImageButtonClick;

        protected virtual void OnImageButtonClick(System.Windows.Forms.MouseEventArgs e)
        {
            if (ImageButtonClick != null)
            {
                ImageButtonClick(this, e);
            }
        }

        protected override void OnMouseClick(System.Windows.Forms.MouseEventArgs e)
        {
            base.OnMouseClick(e);

            if (ImageButtonHitTest(e.Location))
                OnImageButtonClick(e);
        }

        private Zero5.Controls.PanelBase parentPanel;
        public Zero5.Controls.PanelBase ParentPanel
        {
            get { return parentPanel; }
            set { parentPanel = value; }
        }

        public void Draw(System.Drawing.Graphics g)
        {
            if (!Visible) return;

            System.Drawing.Rectangle rectClip = Cache.RectangleCache.GetRectangle(this.Left, this.Top, this.Width + 1, this.Height + 1);
            System.Drawing.Rectangle rectSize = Cache.RectangleCache.GetRectangle(this.Left, this.Top, this.Width, this.Height);
            //g.SetClip(rectClip);
            //g.FillRectangle(Cache.BrushCache.GetBrush(BackColor), rectSize);
            g.DrawRectangle(Cache.PenCache.GetPen(BorderColor, Common.BorderSize), rectSize);

            if (selected) g.DrawRectangle(Cache.PenCache.GetPen(Common.SelectedColor, Common.BorderSize), rectSize);
        }

        protected bool LabelVisible = true;
        protected override void OnPaint(System.Windows.Forms.PaintEventArgs e)
        {
            if (!Visible) return;

            System.Drawing.Size sz = e.Graphics.MeasureString(" ", this.LabelFont).ToSize();

            e.Graphics.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;
            e.Graphics.Clear(this.BackColor);

            System.Drawing.Rectangle rectSize = Cache.RectangleCache.GetRectangle(0, 0, this.Width, this.Height);
            e.Graphics.FillRectangle(Cache.BrushCache.GetBrush(this.BackColor), rectSize);

            int lineX = sz.Height + 3;
            int internalControlTop = lineX + Common.BorderSize + 1;

            //textBox.Top = controlTop;
            //textBox.Height = this.Height - Common.BorderSize * 2 + 1 - textBox.Top;

            e.Graphics.DrawRectangle(Cache.PenCache.GetPen(BorderColor, Common.BorderSize), rectSize);

            if (LabelVisible)
            {
                int margineMemoIcon = 0;
                if (SerializeFieldValueIcon != null && serializeFieldValue && CanSerializeFieldValue)
                {
                    e.Graphics.DrawImage(SerializeFieldValueIcon, Common.BorderSize, Common.BorderSize + 1);
                    margineMemoIcon = SerializeFieldValueIcon.Width;
                }

                e.Graphics.DrawLine(Cache.PenCache.GetPen(LineColor, 1), 0, lineX, this.Width, lineX);
                e.Graphics.DrawString(this.LabelText, this.LabelFont, Cache.BrushCache.GetBrush(this.LineColor), Common.BorderSize - 1 + margineMemoIcon, 1);
                if (ImageButton != null)
                {
                    //textBox.Width = this.Width - Common.BorderSize * 4 - ImageButton.Width;
                    e.Graphics.DrawImage(ImageButton, this.Width - imageButton.Width - Common.BorderSize, internalControlTop);

                    ImageButtonLeft = this.Width - imageButton.Width - Common.BorderSize;
                    ImageButtonTop = internalControlTop;
                    ImageButtonWidth = imageButton.Width;
                    ImageButtonHeight = imageButton.Height;
                }

            }

            if (Selected) e.Graphics.DrawRectangle(Cache.PenCache.GetPen(Common.SelectedColor, Common.BorderSize), rectSize);

            if (parentPanel != null)
                if (parentPanel.RunTimeDesign)
                {
                    if (selected)
                        e.Graphics.FillRectangle(Cache.BrushCache.GetBrush(Common.SelectedColor), this.Width - cornerHitSize, this.Height - cornerHitSize, cornerHitSize, cornerHitSize);
                    else
                        e.Graphics.FillRectangle(Cache.BrushCache.GetBrush(this.BorderColor), this.Width - cornerHitSize, this.Height - cornerHitSize, cornerHitSize, cornerHitSize);
                }

            base.OnPaint(e);
        }

        protected override void OnPaintBackground(System.Windows.Forms.PaintEventArgs pevent)
        {
            //
        }
        public bool Hit(int x, int y)
        {
            if (x >= this.Left)
                if (y >= this.Top)
                    if (x <= this.Left + this.Width)
                        if (y <= this.Top + this.Height)
                            return true;
            return false;
        }

        public bool HitCorner(int x, int y)
        {
            if (!Hit(x, y)) return false;

            if (x >= this.Left + this.Width - cornerHitSize && y >= this.Top + this.Height - cornerHitSize) return true;
            return false;
        }

        public virtual int ObjectCodeNumber
        {
            get { return 104; }
        }

        private System.IO.MemoryStream msSerialize;
        protected Zero5.IO.RawSerializer.RawSerializer rawSerialize;

        public byte[] Serialize()
        {
            msSerialize = new System.IO.MemoryStream();
            rawSerialize = new Zero5.IO.RawSerializer.RawSerializer(msSerialize);

            Serialize_InternalData();

            return msSerialize.ToArray();
        }

        protected virtual void Serialize_InternalData()
        {
            rawSerialize.Serialize(CurrentSerializationVersion.ToString());

            rawSerialize.Serialize(this.FieldName);
            rawSerialize.Serialize((int)this.FilterOperator);
            rawSerialize.Serialize(this.Top);
            rawSerialize.Serialize(this.Left);
            rawSerialize.Serialize(this.Width);
            rawSerialize.Serialize(this.Height);
            rawSerialize.Serialize(this.LabelText);

            rawSerialize.Serialize(new Byte[0]); //ignore image button

            //v1
            rawSerialize.Serialize(new Byte[0]); //ignore image star
            rawSerialize.Serialize(this.SerializeFieldValue);
        }

        private System.IO.MemoryStream msDeserialize;
        protected Zero5.IO.RawSerializer.RawDeserializer rawDeserialize;

        public void Deserialize(byte[] data)
        {
            msDeserialize = new System.IO.MemoryStream(data);
            msDeserialize.Position = 0;
            rawDeserialize = new Zero5.IO.RawSerializer.RawDeserializer(msDeserialize);

            Deserialize_InternalData();
        }

        protected virtual int Deserialize_InternalData()
        {
            int serializedVersion = 0;
            string tmp = rawDeserialize.DeserializeString();

            if (intTryParse.TryParse(tmp, out serializedVersion))
                this.FieldName = rawDeserialize.DeserializeString();
            else
                this.FieldName = tmp;

            if (serializedVersion >= 0)
            {
                this.FilterOperator = (Zero5.Data.Filter.FilterExpression.Operators)rawDeserialize.DeserializeInt();
                this.Top = rawDeserialize.DeserializeInt();
                this.Left = rawDeserialize.DeserializeInt();
                this.Width = rawDeserialize.DeserializeInt();
                this.Height = rawDeserialize.DeserializeInt();
                this.LabelText = rawDeserialize.DeserializeString();
                byte[] deserialized = rawDeserialize.DeserializeBytes(); //ignore image button
            }

            if (serializedVersion >= 1)
            {
                byte[] deserialized = rawDeserialize.DeserializeBytes(); //ignore image start
                this.SerializeFieldValue = rawDeserialize.DeserializeBool();
            }

            return serializedVersion;
        }

        public virtual void DoMouseDown(System.Windows.Forms.MouseEventArgs e) { this.InternalFocus(); }
        public virtual void DoMouseUp(System.Windows.Forms.MouseEventArgs e) { }
        public virtual void DoMouseClick(System.Windows.Forms.MouseEventArgs e) { }

        public virtual void InternalFocus()
        {
            //this.Focus();
        }

        public void DoEnterKey()
        {
            if (EnterKey != null) EnterKey(this);
        }
        public delegate void EnterKeyHandler(FieldControl sender);
        public event EnterKeyHandler EnterKey;

        public virtual void UpdateControl()
        { }
    }

    [System.Security.Permissions.PermissionSet(System.Security.Permissions.SecurityAction.Demand, Name = "FullTrust")]
    public class DemoControlDesigner : System.Windows.Forms.Design.ControlDesigner
    {

        // This method is where the designer initializes its state when 
        // it is created. 
        public override void Initialize(IComponent component)
        {
            base.Initialize(component);

            Control ctrl = (Control)component;
            ctrl.Margin = new Padding(10, 10, 0, 0);
        }

    }
}

#endif
// file ...\Controls\Field\FieldDateTimePicker.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Field
{
    public class FieldDateTimePicker : FieldControl, ILightControl
    {
        public class InternalDateTimePicker : System.Windows.Forms.DateTimePicker
        {
            private System.Drawing.Color _borderColor = System.Drawing.Color.White;
            private System.Windows.Forms.ButtonBorderStyle _borderStyle = System.Windows.Forms.ButtonBorderStyle.Solid;
            private static int WM_PAINT = 0x000F;

            protected override void WndProc(ref System.Windows.Forms.Message m)
            {

                base.WndProc(ref m);

                if (m.Msg == WM_PAINT)
                {
                    System.Drawing.Graphics g = System.Drawing.Graphics.FromHwnd(Handle);
                    System.Drawing.Rectangle bounds = new System.Drawing.Rectangle(0, 0, Width, Height);
                    System.Windows.Forms.ControlPaint.DrawBorder(g, bounds, _borderColor, _borderStyle);
                    //g.DrawLine(System.Drawing.Pens.Green, 0, 0, Width, 0);

                    //if (Parent != null)
                    //    if (Parent.Width == this.Top + this.Height)
                    //        g.DrawLine(Zero5.Controls.Common.SelectedColorPen, 0, 0, Width, 0);

                }
            }

            public System.Drawing.Color BorderColor
            {
                get { return _borderColor; }
                set
                {
                    _borderColor = value;
                    Invalidate(); // causes control to be redrawn
                }
            }

            public System.Windows.Forms.ButtonBorderStyle BorderStyle
            {
                get { return _borderStyle; }
                set
                {
                    _borderStyle = value;
                    Invalidate();
                }
            }
        }

        private InternalDateTimePicker dateTimePicker = new InternalDateTimePicker();

        public FieldDateTimePicker(int left, int top, int width, int height, string text)
            : this(left, top, width, height, text, 0)
        { }

        public FieldDateTimePicker(int left, int top, int width, int height, string labelText, float fontSizeText)
            : this()
        {
            this.Left = left;
            this.Top = top;
            this.Width = width;
            this.Height = height;
            this.LabelText = labelText;
            if (fontSizeText != this.Font.SizeInPoints && fontSizeText != 0)
            {
                this.Font = new System.Drawing.Font(this.Font.FontFamily, 20, System.Drawing.FontStyle.Regular);
            }
            this.CanSerializeFieldValue = true;
        }

        public FieldDateTimePicker()
            : base()
        {

            this.Width = 50;
            this.Height = 40;
            dateTimePicker.Location = new System.Drawing.Point(Common.BorderSize * 2, Common.BorderSize);
            dateTimePicker.Size = new System.Drawing.Size(this.Width - Common.BorderSize * 4, this.Height - Common.BorderSize * 2 + 1);
            dateTimePicker.Anchor = System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right | System.Windows.Forms.AnchorStyles.Top;

            this.Controls.Add(dateTimePicker);
            dateTimePicker.Invalidate();
            dateTimePicker.GotFocus += new EventHandler(dateTimePicker_GotFocus);
            dateTimePicker.LostFocus += new EventHandler(dateTimePicker_LostFocus);
            //dateTimePicker.PreviewKeyDown += new System.Windows.Forms.PreviewKeyDownEventHandler(dateTimePicker_PreviewKeyDown);
            //dateTimePicker.MouseDown += new System.Windows.Forms.MouseEventHandler(dateTimePicker_MouseDown);
            //dateTimePicker.Leave += new EventHandler(dateTimePicker_Leave);
            dateTimePicker.KeyDown += new System.Windows.Forms.KeyEventHandler(dateTimePicker_KeyDown);
            dateTimePicker.KeyUp += new System.Windows.Forms.KeyEventHandler(dateTimePicker_KeyUp);

            dateTimePicker.Format = System.Windows.Forms.DateTimePickerFormat.Long;
            dateTimePicker.ShowCheckBox = true;
            dateTimePicker.Checked = false;

            dateTimePicker.Format = System.Windows.Forms.DateTimePickerFormat.Custom;

            this.TabStop = false;
            this.CanSerializeFieldValue = true;
        }

        //void dateTimePicker_MeasureItem(object sender, System.Windows.Forms.MeasureItemEventArgs e)
        //{
        //    e.ItemHeight = dateTimePicker.Height;
        //    e.ItemHeight = dateTimePicker.Width;
        //}

        //void dateTimePicker_DrawItem(object sender, System.Windows.Forms.DrawItemEventArgs e)
        //{
        //    // Draw the background of the item.
        //    e.DrawBackground();
        //    e.Graphics.DrawString(dateTimePicker.Text, dateTimePicker.Font, System.Drawing.Brushes.Black, dateTimePicker.Left, dateTimePicker.Top);
        //}


        void dateTimePicker_KeyUp(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == System.Windows.Forms.Keys.Enter && lastKeyDown == System.Windows.Forms.Keys.Enter)
            {
                DoEnterKey();
            }
        }

        private System.Windows.Forms.Keys lastKeyDown = System.Windows.Forms.Keys.None;

        void dateTimePicker_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == System.Windows.Forms.Keys.Tab)
            {
                e.SuppressKeyPress = true;
                if (ParentPanel != null) ParentPanel.DoKeyPress(new System.Windows.Forms.KeyPressEventArgs('\t'));
            }
            lastKeyDown = e.KeyCode;
        }

        public enum eFormatoPredefinito
        {
            HMS,
            DDMMAA,
            DDMMAA_HMS
        }

        private Dictionary<eFormatoPredefinito, string> dicPredefinedFormats = new Dictionary<eFormatoPredefinito, string> { 
            {eFormatoPredefinito.HMS,"HH:mm:ss"},
            {eFormatoPredefinito.DDMMAA,"dd-MM-yyyy"},
            {eFormatoPredefinito.DDMMAA_HMS,"dd-MM-yyyy HH:mm:ss"}
        };

        private eFormatoPredefinito formatoPredefinito = eFormatoPredefinito.DDMMAA_HMS;
        public eFormatoPredefinito FormatAS
        {
            get
            {
                return formatoPredefinito;
            }
            set
            {
                formatoPredefinito = value;
                CustomFormat = dicPredefinedFormats[value];
            }
        }

        //void dateTimePicker_Leave(object sender, EventArgs e)
        //{
        //    //ParentPanel.Focus();
        //    //ParentPanel.SelectNextControl();
        //}

        //void dateTimePicker_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        //{
        //    //    ParentPanel.SelectControl(this);
        //    //    comboBox.Focus();
        //}

        //void dateTimePicker_PreviewKeyDown(object sender, System.Windows.Forms.PreviewKeyDownEventArgs e)
        //{
        //    //if (e.KeyData == System.Windows.Forms.Keys.Tab)
        //    //{ 
        //    //    ParentPanel.SelectNextControl();
        //    //}
        //}

        void dateTimePicker_LostFocus(object sender, EventArgs e)
        {
            if (ParentPanel != null) ParentPanel.SelectControl(null);
        }

        void dateTimePicker_GotFocus(object sender, EventArgs e)
        {
            if (ParentPanel != null) ParentPanel.SelectControl(this);
        }

        public override string Text
        {
            get { return dateTimePicker.Text; }
            set { try { dateTimePicker.Text = value; } catch { } }
        }

        public bool Checked
        {
            get { return dateTimePicker.Checked; }
            set { dateTimePicker.Checked = value; }
        }

        public bool ShowCheckBox
        {
            get { return dateTimePicker.ShowCheckBox; }
            set { dateTimePicker.ShowCheckBox = value; }
        }

        public override bool ReadOnly
        {
            get
            {
                return !dateTimePicker.Enabled;
            }
            set
            {
                dateTimePicker.Enabled = !value;
                if (dateTimePicker.Enabled)
                    dateTimePicker.ShowCheckBox = true;
                else
                    dateTimePicker.ShowCheckBox = false;
            }
        }

        public DateTime Value
        {
            get
            {
                try
                {
                    if (dateTimePicker.Checked) return dateTimePicker.Value;
                }
                catch { }
                return DateTime.MinValue;
            }
            set
            {
                if (value == DateTime.MinValue)
                {
                    dateTimePicker.Checked = false;
                    dateTimePicker.Visible = !this.ReadOnly;
                }
                else
                {
                    dateTimePicker.Checked = true;
                    dateTimePicker.Value = value;
                    dateTimePicker.Visible = true;
                }
            }
        }

        public string CustomFormat
        {
            get { return dateTimePicker.CustomFormat; }
            set { dateTimePicker.CustomFormat = value; }
        }

        protected override void OnResize(EventArgs e)
        {
            base.OnResize(e);
            if (dateTimePicker != null) dateTimePicker.Invalidate();
        }

        public override System.Drawing.Color ForeColor
        {
            get { return dateTimePicker.ForeColor; }
            set { dateTimePicker.ForeColor = value; }
        }

        public override void InternalFocus()
        {
            //if (!comboBox.Focused) comboBox.Focus();
        }

        protected override void OnPaint(System.Windows.Forms.PaintEventArgs e)
        {
            if (!Visible) return;

            System.Drawing.Size sz = e.Graphics.MeasureString(" ", this.LabelFont).ToSize();

            int internalControlTop = sz.Height + 3 + Common.BorderSize + 1;

            dateTimePicker.Top = internalControlTop - 2;
            dateTimePicker.Height = this.Height - Common.BorderSize * 2 + 1 - internalControlTop;

            if (ImageButton != null)
            {
                dateTimePicker.Width = this.Width - Common.BorderSize * 4 - ImageButton.Width;
            }

            base.OnPaint(e);
        }

        public override int ObjectCodeNumber
        {
            get { return 108; }
        }

        public override void DoMouseDown(System.Windows.Forms.MouseEventArgs e)
        {
            dateTimePicker.Focus();
            base.DoMouseDown(e);
        }

        protected override void Serialize_InternalData()
        {
            base.Serialize_InternalData();

            //v0
            if (this.CustomFormat == null)
                this.CustomFormat = "";
            rawSerialize.Serialize(this.CustomFormat);

            //v1
            rawSerialize.Serialize(Value);
        }

        protected override int Deserialize_InternalData()
        {
            int serializedVersion = base.Deserialize_InternalData();
            if (serializedVersion >= 0)
            {
                try
                {
                    this.CustomFormat = rawDeserialize.DeserializeString();
                }
                catch (Exception)
                {
                }
            }
            if (serializedVersion >= 1)
            {
                DateTime value = rawDeserialize.DeserializeDateTime();
                if (SerializeFieldValue)
                    this.Value = value;
            }
            return serializedVersion;
        }
    }
}

#endif
// file ...\Controls\Field\FieldImage.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Field
{
    public class FieldImage : FieldControl, ILightControl
    {
        public FieldImage(int left, int top, int width, int height, string text)
            : this(left, top, width, height, text, 0)
        { }

        public FieldImage(int left, int top, int width, int height, string labelText, float fontSizeText)
            : this()
        {
            this.Left = left;
            this.Top = top;
            this.Width = width;
            this.Height = height;
            this.LabelText = labelText;
            if (fontSizeText != this.Font.SizeInPoints && fontSizeText != 0)
            {
                this.Font = new System.Drawing.Font(this.Font.FontFamily, 20, System.Drawing.FontStyle.Regular);
            }
        }

        public FieldImage()
            : base()
        {
            this.Width = 50;
            this.Height = 40;

            this.TabStop = false;

            this.ImageButton = Zero5.Resources.pencil;
        }

        protected override void OnMouseClick(System.Windows.Forms.MouseEventArgs e)
        {
            base.OnMouseClick(e);
            if (ImageButtonHitTest(e.Location))
            {
                System.Windows.Forms.OpenFileDialog ofd = new System.Windows.Forms.OpenFileDialog();
                if (ofd.ShowDialog() == System.Windows.Forms.DialogResult.OK)
                {
                    try
                    {
                        this.Image = System.Drawing.Image.FromFile(ofd.FileName);
                    }
                    catch (Exception ex)
                    {
                        Zero5.Controls.Dialogs.MessageBox.Show("L'immagine non è valida.\r\n" + ex.Message, System.Windows.Forms.MessageBoxButtons.OK);
                    }
                    this.Invalidate();
                }
            }

        }

        private System.Drawing.Image image = null;

        public System.Drawing.Image Image
        {
            get { return image; }
            set
            {
                image = value;
                if (image != null)
                {
                    this.LabelText = this.LabelText.Split('[')[0].Trim();
                    this.LabelText += " [" + image.Width.ToString() + "x" + image.Height.ToString() + "]";
                }
                Invalidate();
            }
        }

        protected override void OnPaint(System.Windows.Forms.PaintEventArgs e)
        {
            if (!Visible) return;

            base.OnPaint(e);

            System.Drawing.Size sz = e.Graphics.MeasureString(" ", this.LabelFont).ToSize();

            int internalControlTop = sz.Height + 3 + Common.BorderSize + 1;

            int imageWidth = 0;
            if (ImageButton != null)
                imageWidth = ImageButton.Width + Common.BorderSize * 4;

            System.Drawing.Rectangle clip = Cache.RectangleCache.GetRectangle(Common.BorderSize * 2,
                internalControlTop,
                this.Width - ((Common.BorderSize * 1) + imageWidth) + 1,
                this.Height - ((Common.BorderSize * 2) + internalControlTop) + 1);

            System.Drawing.Rectangle rect = Cache.RectangleCache.GetRectangle(Common.BorderSize * 2,
                               internalControlTop,
                               this.Width - ((Common.BorderSize * 1) + imageWidth),
                               this.Height - ((Common.BorderSize * 2) + internalControlTop));

            e.Graphics.SetClip(clip, System.Drawing.Drawing2D.CombineMode.Replace);
            if (image != null) e.Graphics.DrawImage(image, Common.BorderSize * 2, internalControlTop);
            e.Graphics.DrawRectangle(Cache.PenCache.GetPen(System.Drawing.Color.Black), rect);
            if (image != null)
            {
                e.Graphics.CompositingMode = System.Drawing.Drawing2D.CompositingMode.SourceOver;

               //System.Drawing.Drawing2D.GraphicsPath gp = new System.Drawing.Drawing2D.GraphicsPath();
               // gp.AddString(image.Width.ToString() + "x" + image.Height.ToString(), 
               //              this.LabelFont.FontFamily, (int)this.LabelFont.Style, 48, 
               //              new System.Drawing.Point(Common.BorderSize * 2, internalControlTop),
               //              System.Drawing.StringFormat.GenericTypographic);
               // e.Graphics.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;
               // e.Graphics.SetClip(gp, System.Drawing.Drawing2D.CombineMode.Replace);
               // e.Graphics.FillRectangle(Cache.BrushCache.GetBrush(System.Drawing.Color.Black), rect);

                //e.Graphics.DrawString(image.Width.ToString() + "x" + image.Height.ToString(),
                //    this.LabelFont, Cache.BrushCache.GetBrush(LineColor),
                //    Common.BorderSize * 2, internalControlTop);
            }
        }

        public override int ObjectCodeNumber
        {
            get { return 117; }
        }

        protected override void Serialize_InternalData()
        {
            base.Serialize_InternalData();
        }

        protected override int Deserialize_InternalData()
        {
            return base.Deserialize_InternalData();
        }

    }
}

#endif
// file ...\Controls\Field\FieldTextBox.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Field
{
    public class FieldTextBox : FieldControl, ILightControl
    {
        protected System.Windows.Forms.TextBox textBox = new System.Windows.Forms.TextBox();

        public FieldTextBox(int left, int top, int width, int height, string text)
            : this(left, top, width, height, text, 0)
        { }

        public FieldTextBox(int left, int top, int width, int height, string labelText, float fontSizeText)
            : this()
        {
            this.Left = left;
            this.Top = top;
            this.Width = width;
            this.Height = height;
            this.LabelText = labelText;
            if (fontSizeText != this.Font.SizeInPoints && fontSizeText != 0)
                this.Font = new System.Drawing.Font(this.Font.FontFamily, 20, System.Drawing.FontStyle.Regular);
            this.CanSerializeFieldValue = true;
        }

        public FieldTextBox()
            : base()
        {
            this.Width = 50;
            this.Height = 40;
            textBox.Location = new System.Drawing.Point(Common.BorderSize * 2, Common.BorderSize);
            textBox.Size = new System.Drawing.Size(this.Width - Common.BorderSize * 4, this.Height - Common.BorderSize * 2 + 1);
            textBox.Anchor = System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right | System.Windows.Forms.AnchorStyles.Top;
            textBox.BorderStyle = System.Windows.Forms.BorderStyle.None;
            textBox.Multiline = false;
            textBox.AcceptsTab = false;
            this.Controls.Add(textBox);
            textBox.Invalidate();
            textBox.GotFocus += new EventHandler(textBox_GotFocus);
            textBox.LostFocus += new EventHandler(textBox_LostFocus);
            //textBox.PreviewKeyDown += new System.Windows.Forms.PreviewKeyDownEventHandler(textBox_PreviewKeyDown);
            //textBox.MouseDown += new System.Windows.Forms.MouseEventHandler(textBox_MouseDown);
            //textBox.Leave += new EventHandler(textBox_Leave);
            textBox.KeyDown += new System.Windows.Forms.KeyEventHandler(textBox_KeyDown);
            textBox.KeyUp += new System.Windows.Forms.KeyEventHandler(textBox_KeyUp);
            textBox.TextChanged += new EventHandler(OnTextChanged);

            this.CanSerializeFieldValue = true;
            this.TabStop = false;
        }


        void textBox_KeyUp(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == System.Windows.Forms.Keys.Enter && lastKeyDown == System.Windows.Forms.Keys.Enter)
            {
                DoEnterKey();
            }
            //lastKeyDown = System.Windows.Forms.Keys.None;
            if (e.KeyCode == System.Windows.Forms.Keys.Enter && !textBox.Multiline)
                e.SuppressKeyPress = true;
            
            if (textBox.ReadOnly)
                if (e.KeyValue == 46) //canc key
                {
                    Text = "";
                }
        }

        private System.Windows.Forms.Keys lastKeyDown = System.Windows.Forms.Keys.None;

        void textBox_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == System.Windows.Forms.Keys.Tab)
            {
                e.SuppressKeyPress = true;
                if (ParentPanel != null) ParentPanel.DoKeyPress(new System.Windows.Forms.KeyPressEventArgs('\t'));
            }
            lastKeyDown = e.KeyCode;
            if (e.KeyCode == System.Windows.Forms.Keys.Enter && !textBox.Multiline)
                e.SuppressKeyPress = true;

        }



        //void textBox_Leave(object sender, EventArgs e)
        //{
        //    //ParentPanel.Focus();
        //    //ParentPanel.SelectNextControl();
        //}

        //void textBox_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        //{
        //    //    ParentPanel.SelectControl(this);
        //    //    textBox.Focus();
        //}

        //void textBox_PreviewKeyDown(object sender, System.Windows.Forms.PreviewKeyDownEventArgs e)
        //{
        //    //if (e.KeyData == System.Windows.Forms.Keys.Tab)
        //    //{ 
        //    //    ParentPanel.SelectNextControl();
        //    //}
        //}

        void textBox_LostFocus(object sender, EventArgs e)
        {
            if (ParentPanel != null) ParentPanel.SelectControl(null);
            lastKeyDown = System.Windows.Forms.Keys.None;
        }

        void textBox_GotFocus(object sender, EventArgs e)
        {
            if (ParentPanel != null) ParentPanel.SelectControl(this);
        }

        public override string Text
        {
            get { return textBox.Text; }
            set { textBox.Text = value; }
        }

        public override bool ReadOnly
        {
            get
            {
                return !textBox.Enabled;
            }
            set
            {
                textBox.Enabled = !value;
            }
        }

        public void OnTextChanged(object sender, EventArgs e)
        {
            base.OnTextChanged(e);
        }

        public char PasswordChar
        {
            get { return textBox.PasswordChar; }
            set { textBox.PasswordChar = value; }
        }

        protected override void OnResize(EventArgs e)
        {
            base.OnResize(e);
            if (textBox != null)
            {
                if (this.Height > 40 * this.FontHeight / 13)
                    this.Multiline = true;
                else
                    this.Multiline = false;
                textBox.Invalidate();
            }
        }

        public override System.Drawing.Color ForeColor
        {
            get { return textBox.ForeColor; }
            set { textBox.ForeColor = value; }
        }

        public override void InternalFocus()
        {
            //if (!textBox.Focused) textBox.Focus();
        }

        protected override void OnPaint(System.Windows.Forms.PaintEventArgs e)
        {
            if (!Visible) return;

            System.Drawing.Size sz = e.Graphics.MeasureString(" ", this.LabelFont).ToSize();

            int internalControlTop = sz.Height + 3 + Common.BorderSize + 1;

            textBox.Top = internalControlTop + 1;
            textBox.Height = this.Height - Common.BorderSize * 2 + 1 - internalControlTop;

            if (ImageButton != null)
            {
                textBox.Width = this.Width - Common.BorderSize * 4 - ImageButton.Width;
            }

            base.OnPaint(e);
        }

        public override int ObjectCodeNumber
        {
            get { return 100; }
        }

        public override void DoMouseDown(System.Windows.Forms.MouseEventArgs e)
        {
            textBox.Focus();
            base.DoMouseDown(e);
        }

        public bool Multiline
        {
            get { return textBox.Multiline; }
            set { textBox.Multiline = value; }
        }

        protected override void OnClick(EventArgs e)
        {
            //lastKeyDown = System.Windows.Forms.Keys.None;
            base.OnClick(e);
        }

        protected override void Serialize_InternalData()
        {
            base.Serialize_InternalData();

            //v2
            rawSerialize.Serialize(Text);
        }

        protected override int Deserialize_InternalData()
        {
            int serializedVersion = base.Deserialize_InternalData();
            if (serializedVersion >= 2)
            {
                string value = rawDeserialize.DeserializeString();
                if (SerializeFieldValue)
                    this.Text = value;
            }
            return serializedVersion;
        }
    }
}

#endif
// file ...\Controls\Field\FieldTextBoxLookup.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Field
{
    class FieldTextBoxLookup : FieldTextBox, IControlWithKeyValue
    {

        public FieldTextBoxLookup(int left, int top, int width, int height, string text)
            : this(left, top, width, height, text, 0)
        {
        }

        public FieldTextBoxLookup(int left, int top, int width, int height, string labelText, float fontSizeText)
            : base(left, top, width, height, labelText, fontSizeText)
        {
            Init();
        }

        public FieldTextBoxLookup()
            : base()
        {
            Init();
        }

        private void Init()
        {
            this.textBox.ReadOnly = true;
            this.CanSerializeFieldValue = false; //OneCodeTODO: implement serialization of values
            this.ImageButton = Zero5.Resources.application_view_columns;
            this.textBox.KeyDown += new System.Windows.Forms.KeyEventHandler(textBox_KeyUp);
        }

        public override int ObjectCodeNumber
        {
            get { return 110; }
        }

        public override string Text
        {
            get { return textBox.Text; }
            set
            {
                textBox.Text = value;
                //OneCodeTODO: set right value
                Value = 0;
            }
        }
        
        private int valueInt = 0;
        public int Value
        {
            get
            {
                return valueInt;
            }
            set
            {
                valueInt = value;
                textBox.Text = "";
                if (this.Field.DynamicLookUp)
                    textBox.Text = this.Field.GetDynamicLookUpValue(valueInt);
                else if (this.Field.ValuesLookUp != null)
                {
                    if (this.Field.ValuesLookUp.ContainsKey(valueInt))
                        textBox.Text = this.Field.ValuesLookUp[valueInt];
                    else
                        if (valueInt != 0)
                            textBox.Text = valueInt.ToString() + "???";
                }
                else
                    if (valueInt != 0)
                        textBox.Text = valueInt.ToString() + "???";
            }
        }

        protected virtual void textBox_KeyUp(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == System.Windows.Forms.Keys.F3)
            {
                OnImageButtonClick(null);
            }
        }
    }
}

#endif
// file ...\Controls\Field\FieldTextBoxNumeric.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Field
{
    class FieldTextBoxNumeric : FieldTextBox
    {

        public FieldTextBoxNumeric(int left, int top, int width, int height, string text)
            : this(left, top, width, height, text, 0)
        { }

        public FieldTextBoxNumeric(int left, int top, int width, int height, string labelText, float fontSizeText)
            : base(left, top, width, height, labelText, fontSizeText)
        {
            this.textBox.KeyPress += new System.Windows.Forms.KeyPressEventHandler(textBox_KeyPress);
        }

        public FieldTextBoxNumeric()
            : base()
        {
            this.textBox.KeyPress += new System.Windows.Forms.KeyPressEventHandler(textBox_KeyPress);
        }

        public override int ObjectCodeNumber
        {
            get { return 107; }
        }

        void textBox_KeyPress(object sender, System.Windows.Forms.KeyPressEventArgs e)
        {
            System.Globalization.NumberFormatInfo numberFormatInfo = System.Globalization.CultureInfo.CurrentCulture.NumberFormat;
            string decimalSeparator = numberFormatInfo.NumberDecimalSeparator;
            string groupSeparator = numberFormatInfo.NumberGroupSeparator;
            string negativeSign = numberFormatInfo.NegativeSign;

            string keyInput = e.KeyChar.ToString();

            if (Char.IsDigit(e.KeyChar))
            {
                // Digits are OK
            }
            else if ((keyInput.Equals(groupSeparator) || keyInput.Equals(decimalSeparator)) && this.allowDecimals)
            {
                // Decimal separator is OK
            }
            else if (keyInput.Equals(negativeSign))
            {
                // ... is OK
            }
            else if (e.KeyChar == '\b')
            {
                // Backspace key is OK
            }
            else if ((ModifierKeys & (System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Alt)) != 0)
            {
                // Let the edit control handle control and alt key combinations
            }
            else if (this.allowSpace && e.KeyChar == ' ')
            {

            }
            else
            {
                // Consume this invalid key and beep
                e.Handled = true;
                //    MessageBeep();
            }
        }

        private bool formatAsTime = false;
        public bool FormatAsTime
        {
            set
            {
                this.formatAsTime = value;
            }

            get
            {
                return this.formatAsTime;
            }
        }

        private bool allowSpace = false;
        public bool AllowSpace
        {
            set
            {
                this.allowSpace = value;
            }

            get
            {
                return this.allowSpace;
            }
        }

        private bool allowDecimals = false;
        public bool AllowDecimals
        {
            set
            {
                this.allowDecimals = value;
            }

            get
            {
                return this.allowDecimals;
            }
        }

        public double Value
        {
            get
            {
                if (textBox.Text.Length == 0) return 0;

                if (this.Field.FormatString == "HMS" || FormatAsTime || this.Field.FormatString == "HMSF")
                {
                    string value = textBox.Text;
                    if (value.Contains(":"))
                    {
                        string[] values = value.Split(':');

                        int iMilliseconds = 0;
                        int iSeconds = 0;
                        int iMinutes = 0;
                        int iHours = 0;
                        if (values.Length == 1) int.TryParse(values[0], out iMinutes);
                        if (values.Length == 2) { int.TryParse(values[0], out iMinutes); int.TryParse(values[1], out iSeconds); }
                        if (values.Length == 3 && this.Field.FormatString == "HMS") { int.TryParse(values[0], out iHours); int.TryParse(values[1], out iMinutes); int.TryParse(values[2], out iSeconds); }
                        else if (values.Length == 3 && this.Field.FormatString == "HMSF")
                        {
                            int.TryParse(values[0], out iHours);
                            int.TryParse(values[1], out iMinutes);

                            if (values[2].Contains("."))
                            {
                                string[] secondsSplitted = values[2].Split('.');
                                int.TryParse(secondsSplitted[0], out iSeconds);
                                int.TryParse(secondsSplitted[1], out iMilliseconds);
                            }
                            else
                                int.TryParse(values[2], out iSeconds);
                        }
                        TimeSpan ts = new TimeSpan(0, iHours, iMinutes, iSeconds, iMilliseconds);
                        return ts.TotalMinutes;
                    }
                    else
                    {
                        return double.Parse(value, System.Globalization.CultureInfo.CurrentCulture);
                    }
                }
                else
                {
                    return double.Parse(textBox.Text, System.Globalization.CultureInfo.CurrentCulture);
                }
            }
            set
            {
                if (this.Field.FormatString == "HMS" || formatAsTime || this.Field.FormatString == "HMSF")
                {
                    double minute = 0.0;
                    minute = Convert.ToDouble(value);

                    textBox.Text = Zero5.Util.StringTools.FormatMinute(minute, this.Field.FormatString == "HMSF");
                }
                else
                {
                    textBox.Text = value.ToString(this.Field.FormatString, System.Globalization.CultureInfo.CurrentCulture);
                }
            }
        }

        protected override void Serialize_InternalData()
        {
            base.Serialize_InternalData();
            rawSerialize.Serialize(this.AllowDecimals);
        }

        protected override int Deserialize_InternalData()
        {
            int serializedVersion = base.Deserialize_InternalData();
            this.AllowDecimals = rawDeserialize.DeserializeBool();
            return serializedVersion;
        }
    }
}

#endif
// file ...\Controls\Field\FieldTextBoxPath.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Field
{
    class FieldTextBoxPath : FieldTextBox
    {
        public FieldTextBoxPath(int left, int top, int width, int height, string text)
            : this(left, top, width, height, text, 0)
        { }

        public FieldTextBoxPath(int left, int top, int width, int height, string labelText, float fontSizeText)
            : base(left, top, width, height, labelText, fontSizeText)
        {
            this.textBox.KeyPress += new System.Windows.Forms.KeyPressEventHandler(textBox_KeyPress);

            this.ImageButton = Zero5.Resources.folder_search;
        }

        public FieldTextBoxPath()
            : base()
        {
            this.textBox.KeyPress += new System.Windows.Forms.KeyPressEventHandler(textBox_KeyPress);

            this.ImageButton = Zero5.Resources.folder_search;
        }

        public override int ObjectCodeNumber
        {
            get { return 119; }
        }

        void textBox_KeyPress(object sender, System.Windows.Forms.KeyPressEventArgs e)
        {
            List<char> lstCaratteriNonValidi = new List<char>(System.IO.Path.GetInvalidPathChars());

            if (lstCaratteriNonValidi.Contains(e.KeyChar))
                e.Handled = true;
        }

        private bool directoryMode = false;
        public bool DirectoryMode
        {
            get
            {
                return directoryMode;
            }
            set
            {
                this.directoryMode = value;
            }
        }

        protected override void OnMouseClick(System.Windows.Forms.MouseEventArgs e)
        {
            base.OnMouseClick(e);
            if (ImageButtonHitTest(e.Location))
            {
                if (this.Field.FormatString == "DIRECTORY_PATH" || DirectoryMode)
                {
                    System.Windows.Forms.FolderBrowserDialog dlg = new System.Windows.Forms.FolderBrowserDialog();
                    if (this.Text.Length > 0)
                        if (System.IO.Directory.Exists(this.Text))
                            dlg.SelectedPath = this.Text;

                    if (dlg.ShowDialog() == System.Windows.Forms.DialogResult.OK)
                    {
                        this.Text = dlg.SelectedPath;
                        this.Invalidate();
                    }
                }
                else
                {
                    System.Windows.Forms.OpenFileDialog dlg = new System.Windows.Forms.OpenFileDialog();
                    if (this.Text.Length > 0)
                        if (System.IO.File.Exists(this.Text))
                            dlg.FileName = this.Text;

                    if (dlg.ShowDialog() == System.Windows.Forms.DialogResult.OK)
                    {
                        this.Text = dlg.FileName;
                        this.Invalidate();
                    }
                }
            }
        }

        protected override void Serialize_InternalData()
        {
            base.Serialize_InternalData();
            rawSerialize.Serialize(this.DirectoryMode);
        }

        protected override int Deserialize_InternalData()
        {
            int serializedVersion = base.Deserialize_InternalData();
            this.DirectoryMode = rawDeserialize.DeserializeBool();
            return serializedVersion;
        }
    }
}

#endif
// file ...\Controls\Field\FieldTreeListBox.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Field
{
    public class FieldTreeListBox : FieldControl, ILightControl
    {
        private List<int> DeserializedCheckedValues = new List<int>();

        public bool ShowAsList = false;

        private class InternalTreeView : TreeView
        {
            public InternalTreeView()
                : base()
            {
                this.CheckBoxes = true;
                this.BorderStyle = System.Windows.Forms.BorderStyle.None;
            }

            public List<int> GetCheckedValues()
            {
                List<int> lstChecked = new List<int>();
                foreach (TreeNode child in Nodes)
                    lstChecked.AddRange(GetCheckedValueRecursive(child));
                return lstChecked;
            }

            private List<int> GetCheckedValueRecursive(TreeNode node)
            {
                List<int> lstChecked = new List<int>();
                if (node.Checked)
                {
                    if (node.Tag is int)
                        lstChecked.Add((int)node.Tag);
                    else if (node.Tag is Zero5.Data.Filter.Field.TreeLookUpItem)
                    {
                        Zero5.Data.Filter.Field.TreeLookUpItem item = (Zero5.Data.Filter.Field.TreeLookUpItem)node.Tag;
                        if (item.Selectable)
                            lstChecked.Add(item.Value);
                    }
                }

                if (node.Nodes.Count > 0)
                    foreach (TreeNode child in node.Nodes)
                        lstChecked.AddRange(GetCheckedValueRecursive(child));

                return lstChecked;
            }

            public void SetCheckedValues(List<int> values)
            {
                foreach (TreeNode child in Nodes)
                    SetCheckedValueRecursive(child, values);
            }

            private void SetCheckedValueRecursive(TreeNode node, List<int> values)
            {
                if (node.Nodes.Count > 0)
                {
                    foreach (TreeNode child in node.Nodes)
                        SetCheckedValueRecursive(child, values);
                    UpdateParentState(node);
                }
                else
                {
                    int value = 0;
                    if (node.Tag is int)
                    {
                        if (values.Contains((int)node.Tag))
                            node.Checked = true;
                        else
                            node.Checked = false;
                    }
                    else if (node.Tag is Zero5.Data.Filter.Field.TreeLookUpItem)
                    {
                        Zero5.Data.Filter.Field.TreeLookUpItem item = (Zero5.Data.Filter.Field.TreeLookUpItem)node.Tag;
                        if (item.Selectable)
                        {
                            value = item.Value;
                            if (values.Contains(value))
                                node.Checked = true;
                            else
                                node.Checked = false;
                        }
                    }
                }
            }

            public void SetDisabledValue(int value)
            {
                foreach (TreeNode child in Nodes)
                    SetDisabledValueRecursive(child, value);
            }

            private void SetDisabledValueRecursive(TreeNode node, int value)
            {
                if (node.Nodes.Count > 0)
                {
                    foreach (TreeNode child in node.Nodes)
                        SetDisabledValueRecursive(child, value);
                    UpdateParentState(node);
                }
                else
                {
                    if (node.Tag is int)
                    {
                        if (value == (int)node.Tag)
                            node.ForeColor = System.Drawing.SystemColors.GrayText;
                        //else
                        //    node.ForeColor = Color.Transparent;
                    }
                    else if (node.Tag is Zero5.Data.Filter.Field.TreeLookUpItem)
                    {
                        Zero5.Data.Filter.Field.TreeLookUpItem item = (Zero5.Data.Filter.Field.TreeLookUpItem)node.Tag;
                        if (item.Selectable)
                        {
                            if (value == item.Value)
                                node.ForeColor = System.Drawing.SystemColors.GrayText;
                            //else
                            //    node.ForeColor = Color.Transparent;
                        }
                    }
                }
            }

            public List<string> GetCheckedKeys()
            {
                return GetCheckedKeys(true);
            }

            public List<string> GetCheckedKeys(bool onlySelectableItems)
            {
                List<string> lstChecked = new List<string>();
                foreach (TreeNode child in Nodes)
                    lstChecked.AddRange(GetCheckedKeysRecursive(child, onlySelectableItems));
                return lstChecked;
            }

            private List<string> GetCheckedKeysRecursive(TreeNode node, bool onlySelectableItems)
            {
                List<string> lstChecked = new List<string>();
                if (node.Checked)
                {
                    if (node.Tag is Zero5.Data.Filter.Field.TreeLookUpItem)
                    {
                        Zero5.Data.Filter.Field.TreeLookUpItem item = (Zero5.Data.Filter.Field.TreeLookUpItem)node.Tag;
                        if (item.Selectable || !onlySelectableItems)
                            lstChecked.Add(item.Key);
                    }
                }

                if (node.Nodes.Count > 0)
                    foreach (TreeNode child in node.Nodes)
                        lstChecked.AddRange(GetCheckedKeysRecursive(child, onlySelectableItems));

                return lstChecked;
            }


            public void SetCheckedKeys(List<string> keys)
            {
                foreach (TreeNode child in Nodes)
                    SetCheckedKeysRecursive(child, keys);
            }

            private void SetCheckedKeysRecursive(TreeNode node, List<string> keys)
            {
                if (node.Nodes.Count > 0)
                {
                    foreach (TreeNode child in node.Nodes)
                        SetCheckedKeysRecursive(child, keys);
                    UpdateParentState(node);
                }
                else
                {
                    string key = "";
                    if (node.Tag is Zero5.Data.Filter.Field.TreeLookUpItem)
                    {
                        Zero5.Data.Filter.Field.TreeLookUpItem item = (Zero5.Data.Filter.Field.TreeLookUpItem)node.Tag;
                        //if (item.Selectable)
                        {
                            key = item.Key;
                            if (keys.Contains(key))
                                node.Checked = true;
                            else
                                node.Checked = false;
                        }
                    }
                }
            }


            internal void LoadItemFromDictionary(Dictionary<int, string> keyValues, int iDefault)
            {
                Nodes.Clear();
                if (keyValues == null) return;

                foreach (KeyValuePair<int, string> kvp in keyValues)
                {
                    TreeNode nodeTmp = Nodes.Add(kvp.Key.ToString(), kvp.Value);
                    nodeTmp.Tag = kvp.Key;
                    if (iDefault == kvp.Key)
                        nodeTmp.Checked = true;
                }
            }

            internal void LoadItemFromDictionary(List<Zero5.Data.Filter.Field.TreeLookUpItem> keyValues)
            {
                Nodes.Clear();
                if (keyValues == null) return;

                Dictionary<string, TreeNode> nodesInTree = new Dictionary<string, TreeNode>();
                bool nodeAdded = true;
                while (nodeAdded)
                {
                    nodeAdded = false;
                    foreach (Zero5.Data.Filter.Field.TreeLookUpItem item in keyValues)
                        if (!nodesInTree.ContainsKey(item.Key))
                            if (item.ParentKey == "root" || nodesInTree.ContainsKey(item.ParentKey))
                            {
                                TreeNodeCollection parent = Nodes;
                                if (item.ParentKey != "root")
                                    parent = nodesInTree[item.ParentKey].Nodes;
                                TreeNode node = parent.Add(item.Key, item.Text);
                                node.Tag = item;
                                nodesInTree.Add(item.Key, node);
                                nodeAdded = true;
                            }
                }

                if (keyValues.Count != nodesInTree.Count)
                { //gestisco gli orfani 
                    TreeNode altro = Nodes.Add("-1", "...");
                    foreach (Zero5.Data.Filter.Field.TreeLookUpItem item in keyValues)
                        if (!nodesInTree.ContainsKey(item.Key))
                            altro.Nodes.Add(item.Key, item.Text).Tag = item;
                }
            }

            internal void UncheckAll()
            {
                foreach (TreeNode child in Nodes)
                    UncheckAllRecursive(child);
            }

            private void UncheckAllRecursive(TreeNode node)
            {
                if (node.Nodes.Count > 0)
                    foreach (TreeNode child in node.Nodes)
                        UncheckAllRecursive(child);
                node.Checked = false;
            }
        }

        private InternalTreeView tv = new InternalTreeView();

        public FieldTreeListBox(int left, int top, int width, int height, string text)
            : this(left, top, width, height, text, 0)
        { }

        public FieldTreeListBox(int left, int top, int width, int height, string labelText, float fontSizeText)
            : this()
        {
            this.Left = left;
            this.Top = top;
            this.Width = width;
            this.Height = height;
            this.LabelText = labelText;
            if (fontSizeText != this.Font.SizeInPoints && fontSizeText != 0)
            {
                this.Font = new System.Drawing.Font(this.Font.FontFamily, 20, System.Drawing.FontStyle.Regular);
            }
        }

        public FieldTreeListBox()
            : base()
        {
            this.Width = 50;
            this.Height = 40;
            tv.Location = new System.Drawing.Point(Common.BorderSize * 2, Common.BorderSize);
            tv.Size = new System.Drawing.Size(this.Width - Common.BorderSize * 4, this.Height - Common.BorderSize * 2 + 1);
            tv.Anchor = System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right | System.Windows.Forms.AnchorStyles.Top;
            //comboBox.BorderStyle = System.Windows.Forms.BorderStyle.None;
            //comboBox.Multiline = false;
            //comboBox.AcceptsTab = false;
            this.Controls.Add(tv);
            tv.Invalidate();
            tv.GotFocus += new EventHandler(treeView_GotFocus);
            tv.LostFocus += new EventHandler(treeView_LostFocus);
            tv.PreviewKeyDown += new System.Windows.Forms.PreviewKeyDownEventHandler(treeView_PreviewKeyDown);
            tv.MouseDown += new System.Windows.Forms.MouseEventHandler(treeView_MouseDown);
            tv.Leave += new EventHandler(treeView_Leave);
            tv.KeyDown += new System.Windows.Forms.KeyEventHandler(treeView_KeyDown);
            tv.KeyUp += new System.Windows.Forms.KeyEventHandler(treeView_KeyUp);

            //comboBox.DrawMode = System.Windows.Forms.DrawMode.OwnerDrawVariable;
            //comboBox.DrawItem += new System.Windows.Forms.DrawItemEventHandler(comboBox_DrawItem);
            //comboBox.MeasureItem += new System.Windows.Forms.MeasureItemEventHandler(comboBox_MeasureItem);
            this.TabStop = false;

            this.CanSerializeFieldValue = true;
        }

        private string _text;
        public override string Text
        {
            get { return _text; }
            set { _text = value; }
        }

        void treeView_MeasureItem(object sender, System.Windows.Forms.MeasureItemEventArgs e)
        {
            e.ItemHeight = tv.Height;
            e.ItemHeight = tv.Width;
        }

        void treeView_KeyUp(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == System.Windows.Forms.Keys.Enter && lastKeyDown == System.Windows.Forms.Keys.Enter)
            {
                DoEnterKey();
            }
            else if (e.KeyCode == System.Windows.Forms.Keys.Cancel && lastKeyDown == System.Windows.Forms.Keys.Cancel)
            {
                tv.UncheckAll();
            }
        }

        private System.Windows.Forms.Keys lastKeyDown = System.Windows.Forms.Keys.None;

        void treeView_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == System.Windows.Forms.Keys.Tab)
            {
                e.SuppressKeyPress = true;
                if (ParentPanel != null) ParentPanel.DoKeyPress(new System.Windows.Forms.KeyPressEventArgs('\t'));
            }
            lastKeyDown = e.KeyCode;
        }

        void treeView_Leave(object sender, EventArgs e)
        {
            //ParentPanel.Focus();
            //ParentPanel.SelectNextControl();
        }

        void treeView_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            //    ParentPanel.SelectControl(this);
            //    comboBox.Focus();
        }

        void treeView_PreviewKeyDown(object sender, System.Windows.Forms.PreviewKeyDownEventArgs e)
        {
            //if (e.KeyData == System.Windows.Forms.Keys.Tab)
            //{ 
            //    ParentPanel.SelectNextControl();
            //}
        }

        void treeView_LostFocus(object sender, EventArgs e)
        {
            if (ParentPanel != null) ParentPanel.SelectControl(null);
        }

        void treeView_GotFocus(object sender, EventArgs e)
        {
            if (ParentPanel != null) ParentPanel.SelectControl(this);
        }

        public List<int> Values
        {
            get
            {
                return tv.GetCheckedValues();
            }
            set
            {
                tv.SetCheckedValues(value);
            }
        }

        public List<string> CheckedKeys
        {
            get
            {
                return tv.GetCheckedKeys(true);
            }
            set
            {
                tv.SetCheckedKeys(value);
            }
        }

        public void disabledValue(int value)
        {
            tv.SetDisabledValue(value);
        }

        public List<string> CheckedKeysWithUnselectableKeys
        {
            get
            {
                return tv.GetCheckedKeys(false);
            }
            set
            {
                tv.SetCheckedKeys(value);
            }
        }

        protected override void OnResize(EventArgs e)
        {
            base.OnResize(e);
            if (tv != null) tv.Invalidate();
        }

        protected override void OnPaint(System.Windows.Forms.PaintEventArgs e)
        {
            if (!Visible) return;

            System.Drawing.Size sz = e.Graphics.MeasureString(" ", this.LabelFont).ToSize();

            int internalControlTop = sz.Height + 3 + Common.BorderSize + 1;

            tv.Top = internalControlTop - 2;
            tv.Height = this.Height - Common.BorderSize * 2 + 1 - internalControlTop;

            if (ImageButton != null)
            {
                tv.Width = this.Width - Common.BorderSize * 4 - ImageButton.Width;
            }

            base.OnPaint(e);
        }

        public override int ObjectCodeNumber
        {
            get { return 118; }
        }

        public override void DoMouseDown(System.Windows.Forms.MouseEventArgs e)
        {
            tv.Focus();
            base.DoMouseDown(e);
        }

        public void SetKeyValues(Dictionary<int, string> keyValues, int iDefault)
        {
            if (keyValues == null) return;
            tv.LoadItemFromDictionary(keyValues, iDefault);
            tv.SetCheckedValues(DeserializedCheckedValues);
            DeserializedCheckedValues.Clear();
        }

        public void SetKeyValues(List<Zero5.Data.Filter.Field.TreeLookUpItem> keyValues)
        {
            if (keyValues == null) return;
            tv.LoadItemFromDictionary(keyValues);
            tv.SetCheckedValues(DeserializedCheckedValues);
            DeserializedCheckedValues.Clear();
        }

        protected override void Serialize_InternalData()
        {
            base.Serialize_InternalData();

            //v1
            if (SerializeFieldValue)
                rawSerialize.Serialize(string.Join(";", tv.GetCheckedValues()));
            else
                rawSerialize.Serialize("");

            //v4
            rawSerialize.Serialize(ShowAsList);
        }

        protected override int Deserialize_InternalData()
        {
            int serializedVersion = base.Deserialize_InternalData();
            if (serializedVersion >= 1)
            {
                string raw = rawDeserialize.DeserializeString();
                if (SerializeFieldValue)
                {
                    List<int> lstValues = new List<int>();
                    string[] splitted = raw.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
                    int tmp = 0;
                    for (int i = 0; i < splitted.Length; i++)
                        if (int.TryParse(splitted[i], out tmp))
                            lstValues.Add(tmp);
                    DeserializedCheckedValues = lstValues;
                }
            }
            if (serializedVersion >= 4)
            {
                ShowAsList = rawDeserialize.DeserializeBool();
            }
            return serializedVersion;
        }
    }
}

#endif
// file ...\Controls\Field\IControlWithKeyValue.cs
#if !MOBILE && !CORE
namespace Zero5.Controls.Field
{
    public interface IControlWithKeyValue
    {
        int Value { get; set; }
        Zero5.Data.Filter.Field Field { get; set; }
    }
}

#endif
// file ...\Controls\Field\MultiFieldBarChart.cs
#if !MOBILE && !CORE
#if CHART

namespace Zero5.Controls.Field
{
    class MultiFieldBarChart : MultiFieldControl
    {
        protected Zero5.Controls.Chart.Chart chart = new Chart.Chart();

        public MultiFieldBarChart(int left, int top, int width, int height, string labelText)
              : this()
        {
            this.Left = left;
            this.Top = top;
            this.Width = width;
            this.Height = height;
            this.LabelText = labelText;
        }

        public MultiFieldBarChart()
            : base()
        {
            this.LabelText = "Grafico Barre";
            this.Width = 50;
            this.Height = 40;
            chart.Location = new System.Drawing.Point(Common.BorderSize * 2, Common.BorderSize * 8);
            chart.Size = new System.Drawing.Size(this.Width - Common.BorderSize * 4, this.Height - Common.BorderSize * 12 + 1);
            chart.Anchor = System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right | System.Windows.Forms.AnchorStyles.Top;

            chart.MouseUp += new System.Windows.Forms.MouseEventHandler(chart_MouseUp);
            
            this.Controls.Add(chart);

            this.TabStop = false;
        }

        void chart_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            base.OnMouseUp(e);
        }

        public override int ObjectCodeNumber
        {
            get { return 113; }
        }

        public string Title
        {
            get { return LabelText; }
            set { LabelText = value.ToUpper(); }
        }

        protected override void Serialize_InternalData()
        {
            base.Serialize_InternalData();
            rawSerialize.Serialize(Title);
        }

        protected override int Deserialize_InternalData()
        {
            int serializedVersion = base.Deserialize_InternalData();
            Title = rawDeserialize.DeserializeString();
            return serializedVersion;
        }
        
        public List<double> Values = new List<double>();
        public List<System.Drawing.Color> Colors = new List<System.Drawing.Color>();

        public override void UpdateControl()
        {
            string[] labels = new string[Fields.Count];

            for (int i = 0; i < labels.Length; i++)
                labels[i] = Fields[i].FieldNameLocalized;

            bool percent = false;
            if (Fields.Count > 0) if (Fields[0].FormatString.StartsWith("PB")) percent = true;
            chart.QuickDrawBarChart("", labels, this.Values.ToArray(), this.Colors.ToArray(), percent);
            base.UpdateControl();
        }
    }
}
#endif
#endif
// file ...\Controls\Field\MultiFieldControl.cs
#if !MOBILE && !CORE

namespace Zero5.Controls.Field
{
    public class MultiFieldControl : FieldControl
    {
        public MultiFieldControl()
            : base()
        {
            LabelText = "";
        }

        public List<string> FieldsNames = new List<string>();
        public List<Zero5.Data.Filter.Field> Fields = new List<Data.Filter.Field>();

        public override int ObjectCodeNumber
        {
            get { return 104; }
        }

        protected override void Serialize_InternalData()
        {
            base.Serialize_InternalData();
            rawSerialize.Serialize(this.FieldsNames.Count());
            foreach (string fieldName in this.FieldsNames)
                rawSerialize.Serialize(fieldName);
        }

        protected override int Deserialize_InternalData()
        {
            int serializedVersion = base.Deserialize_InternalData();
            int fieldCount = rawDeserialize.DeserializeInt();
            FieldsNames = new List<string>();
            for (int i = 0; i < fieldCount; i++)
                FieldsNames.Add(rawDeserialize.DeserializeString());
            return serializedVersion;
        }

    }
}

#endif
// file ...\Controls\Field\MultiFieldPieChart.cs
#if !MOBILE && !CORE
#if CHART

namespace Zero5.Controls.Field
{
    class MultiFieldPieChart : MultiFieldControl
    {
        protected Zero5.Controls.Chart.Chart chart = new Chart.Chart();

        public MultiFieldPieChart(int left, int top, int width, int height, string labelText)
              : this()
        {
            this.Left = left;
            this.Top = top;
            this.Width = width;
            this.Height = height;
            this.LabelText = labelText;
        }

        public MultiFieldPieChart()
            : base()
        {
            this.LabelText = "Grafico Torta";
            this.Width = 50;
            this.Height = 40;
            chart.Location = new System.Drawing.Point(Common.BorderSize * 2, Common.BorderSize * 8);
            chart.Size = new System.Drawing.Size(this.Width - Common.BorderSize * 4, this.Height - Common.BorderSize * 12 + 1);
            chart.Anchor = System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right | System.Windows.Forms.AnchorStyles.Top;

            chart.MouseUp += new System.Windows.Forms.MouseEventHandler(chart_MouseUp);
            chart.MouseDown += new System.Windows.Forms.MouseEventHandler(chart_MouseDown);
            chart.MouseClick += new System.Windows.Forms.MouseEventHandler(chart_MouseClick);

            this.Controls.Add(chart);

            this.TabStop = false;
        }

        void chart_MouseClick(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            base.OnMouseClick(e);
        }

        void chart_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            base.OnMouseDown(e);
        }

        void chart_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            base.OnMouseUp(e);
        }

        public override int ObjectCodeNumber
        {
            get { return 112; }
        }

        public string Title
        {
            get { return LabelText; }
            set { LabelText = value.ToUpper(); }
        }

        protected override void Serialize_InternalData()
        {
            base.Serialize_InternalData();
            rawSerialize.Serialize(Title);
        }

        protected override int Deserialize_InternalData()
        {
            int serializedVersion = base.Deserialize_InternalData();
            Title = rawDeserialize.DeserializeString();
            return serializedVersion;
        }

        public List<double> Values = new List<double>();
        public List<System.Drawing.Color> Colors = new List<System.Drawing.Color>();

        public override void UpdateControl()
        {
            string[] labels = new string[Fields.Count];

            for (int i = 0; i < labels.Length; i++)
                labels[i] = Fields[i].FieldNameLocalized;

            chart.QuickDrawPieChart("", labels, this.Values.ToArray(), this.Colors.ToArray());
            base.UpdateControl();
        }

    }
}
#endif
#endif
// file ...\Controls\Light\Button.cs
#if !CORE

namespace Zero5.Controls.Light
{
    public class Button : Zero5.Controls.Light.Control
    {
        private bool Pressed = false;

        private System.Drawing.Color PressedBackcolor;
        public new System.Drawing.Color ForeColor
        {
            get { return base.ForeColor; }
            set
            {
                base.ForeColor = value;
                this.PressedBackcolor = Common.Light(base.ForeColor);
                this.PressedBackcolor = System.Drawing.Color.FromArgb(
                    (int)(Math.Min(base.ForeColor.R * 1.6, 255)),
                    (int)(Math.Min(base.ForeColor.G * 1.6, 255)),
                    (int)(Math.Min(base.ForeColor.B * 1.6, 255)));

            }
        }

        public Button()
        {
            BackColor = Common.BackColor;
            BorderColor = Common.ButtonBorderColor;
            ForeColor = Common.LineColor;
        }

        public Button(int left, int top, int width, int height, string text, System.Drawing.Image image, EventHandler clickEvent)
            : this()
        {
            this.Left = left;
            this.Top = top;
            this.Width = width;
            this.Height = height;
            this.Text = text;
            this.Image = image;
            if (clickEvent != null) this.ButtonClick += clickEvent;   
        }

         public override void Draw(System.Drawing.Graphics g)
        {
            if (PressedBackcolor == null) PressedBackcolor = this.BackColor;

            System.Drawing.Rectangle rectSize = Cache.RectangleCache.GetRectangle(this.Left, this.Top, this.Width, this.Height);

            if (Pressed)
                g.FillRectangle(Cache.BrushCache.GetBrush(this.PressedBackcolor), rectSize);
            else
                g.FillRectangle(Cache.BrushCache.GetBrush(BackColor), rectSize);


            int x = Common.BorderSize * 2 + Left;
            int y = Common.BorderSize + Top;

            System.Drawing.Size sz = g.MeasureString(" ", this.LabelFont).ToSize();

            g.DrawString(this.Text, this.Font, Cache.BrushCache.GetBrush(this.LineColor), x, y + (Height / 2 - sz.Height) + 5);

            int lineLen = 6;
            int borderDistance = 2; //Common.BorderSize
            int lineX1 = borderDistance + Left;
            int lineY1 = borderDistance + Top;
            int lineX2 = this.Width - borderDistance + Left;
            int lineY2 = this.Height - borderDistance + Top;
            //g.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), Common.BorderSize, lineX, this.Width - Common.BorderSize * 2, lineX);
            g.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), lineX1, lineY1, lineX1 + lineLen, lineY1);
            g.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), lineX1, lineY1, lineX1, lineY1 + lineLen);

            g.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), lineX2 - lineLen, lineY1, lineX2, lineY1);
            g.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), lineX2, lineY1, lineX2, lineY1 + lineLen);

            g.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), lineX1, lineY2, lineX1 + lineLen, lineY2);
            g.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), lineX1, lineY2, lineX1, lineY2 - lineLen);

            if (this.Image != null)
            {
                //g.DrawRectangle(Cache.PenCache.GetPen(System.Drawing.Color.Black, 1), lineX2 - this.Image.Width, lineY2 - this.Image.Height, this.Image.Width, this.Image.Height);
                g.DrawImage(this.Image, lineX2 - this.Image.Width + 1, lineY2 - this.Image.Height + 1);
                //g.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), Common.BorderSize, lineX, this.Width - this.Image.Width - Common.BorderSize * 2, lineX);
            }
            else
            {
                //g.DrawLine(Cache.PenCache.GetPen(this.ForeColor, 1), Common.BorderSize, lineX, this.Width, lineX);
            }

            if (Selected) g.DrawRectangle(Cache.PenCache.GetPen(Common.SelectedColor, Common.BorderSize), rectSize);

            //g.DrawRectangle(Cache.PenCache.GetPen(System.Drawing.Color.Red, 1), Cache.RectangleCache.GetRectangle(x, y, this.Width - x * 2 - 1, this.Height - y * 2 - 1));

            //base.OnPaint(pevent);
        }

        public void KeyPress(char keyChar)
        {
            if (keyChar == '\r' || keyChar == ' ')
            {
                if (ButtonClick != null)
                    ButtonClick(this, new EventArgs());
            }
        }

        public event EventHandler ButtonClick;

        public override int ObjectCodeNumber
        {
            get { return 102; }
        }

        protected override void Serialize_InternalData()
        {
            base.Serialize_InternalData();
            rawSerialize.Serialize(this.Text);
        }

        protected override void Deserialize_InternalData()
        {
            base.Deserialize_InternalData();
            this.Text = rawDeserialize.DeserializeString();
        }

        public override void DoMouseDown(System.Windows.Forms.MouseEventArgs e)
        {
            Pressed = true;
            base.DoMouseDown(e);
        }

        public override void DoMouseUp(System.Windows.Forms.MouseEventArgs e)
        {
            Pressed = false;
            base.DoMouseUp(e);

            if (ButtonClick != null)
                ButtonClick(this, new EventArgs());
        }
    }
}
#endif
// file ...\Controls\Light\CheckBox.cs
#if !CORE

namespace Zero5.Controls.Light
{
    public class CheckBox : System.Windows.Forms.CheckBox
    {
        public CheckBox()
            : base()
        { }
    }
}

#endif
// file ...\Controls\Light\ComboBox.cs
#if !CORE

namespace Zero5.Controls.Light
{
    public class ComboBox : System.Windows.Forms.ComboBox
    {
        public ComboBox()
            : base()
        { }
    }
}

#endif
// file ...\Controls\Light\Control.cs
#if !CORE

namespace Zero5.Controls.Light
{
    public class Control : ILightControl
    {
        public enum TextPositionEnum
        {
            MiddleCenter = 1,
            MiddleLeft = 2,
        }
        public TextPositionEnum TextPosition = TextPositionEnum.MiddleLeft;
        public TextPositionEnum LabelTextPosition = TextPositionEnum.MiddleLeft;

        public bool TabStop = true;

        public Control()
        {
            this.BackColor = Common.BackColor;
            this.ForeColor = Common.ForeColor;
        }

        private int cornerHitSize = 7;

        private int left = 0;
        public int Left
        {
            get { return left; }
            set { left = value; }
        }

        private int top = 0;
        public int Top
        {
            get { return top; }
            set { top = value; }
        }

        private int height = 20;
        public int Height
        {
            get { return height; }
            set { height = value; }
        }

        private int width = 50;
        public int Width
        {
            get { return width; }
            set { width = value; }
        }

        private bool visible = true;
        public bool Visible
        {
            get { return visible; }
            set { visible = value; }
        }

        private bool selected = false;
        public bool Selected
        {
            get { return selected; }
            set { selected = value; }
        }

        private System.Drawing.Color backColor = Common.BackColor;
        public System.Drawing.Color BackColor
        {
            get { return backColor; }
            set { backColor = value; }
        }

        private System.Drawing.Color borderColor = Common.BorderColor;
        public System.Drawing.Color BorderColor
        {
            get { return borderColor; }
            set { borderColor = value; }
        }

        private System.Drawing.Color foreColor = Common.ForeColor;
        public System.Drawing.Color ForeColor
        {
            get { return foreColor; }
            set { foreColor = value; }
        }

        private System.Drawing.Color lineColor = Common.LineColor;
        public virtual System.Drawing.Color LineColor
        {
            get { return lineColor; }
            set { lineColor = value; }
        }

        private System.Drawing.Font font = System.Drawing.SystemFonts.DefaultFont;
        public System.Drawing.Font Font
        {
            get { return font; }
            set { font = value; }
        }

        private System.Drawing.Font labelFont = new System.Drawing.Font(
                                                System.Drawing.SystemFonts.DefaultFont.Name,
                                                System.Drawing.SystemFonts.DefaultFont.Size - 1, System.Drawing.FontStyle.Regular);
        public System.Drawing.Font LabelFont
        {
            get { return labelFont; }
            set { labelFont = value; }
        }

        private string text;
        public string Text
        {
            get { return text; }
            set { text = value; }
        }

        private string labelText;
        public string LabelText
        {
            get { return labelText; }
            set { labelText = value; }
        }

        private Zero5.Controls.PanelBase parentPanel;
        public Zero5.Controls.PanelBase ParentPanel
        {
            get { return parentPanel; }
            set { parentPanel = value; }
        }

        public virtual void InternalFocus()
        {
            this.parentPanel.InternalFocus();
        }

        protected bool readOnly = false;
        public virtual bool ReadOnly
        {
            get
            {
                return readOnly;
            }
            set
            {
                readOnly = value;
            }
        }

        private System.Drawing.Image iconLabel = Zero5.Resources.bullet_star_micro;
        public virtual System.Drawing.Image IconLabel
        {
            get { return iconLabel; }
            set { iconLabel = value; }
        }
        public bool IconLabelVisible = false;

        private System.Drawing.Image image = null;
        public virtual System.Drawing.Image Image
        {
            get { return image; }
            set { image = value; }
        }

        private int ImageButtonTop = 0;
        private int ImageButtonLeft = 0;
        private int ImageButtonHeight = 0;
        private int ImageButtonWidth = 0;

        protected bool ImageButtonHitTest(System.Drawing.Point mouseLocation)
        {
            if (mouseLocation.X >= ImageButtonLeft)
                if (mouseLocation.Y >= ImageButtonTop)
                    if (mouseLocation.X <= ImageButtonLeft + ImageButtonWidth)
                        if (mouseLocation.Y <= ImageButtonTop + ImageButtonHeight)
                            return true;
            return false;
        }

        protected bool LabelVisible = true;
        public virtual void Draw(System.Drawing.Graphics g)
        {
            if (!visible) return;

            System.Drawing.Rectangle rectSize = Cache.RectangleCache.GetRectangle(this.Left, this.Top, this.Width, this.Height);

            g.FillRectangle(Cache.BrushCache.GetBrush(backColor), rectSize);

            g.DrawRectangle(Cache.PenCache.GetPen(borderColor, Common.BorderSize), rectSize);
            if (selected) g.DrawRectangle(Cache.PenCache.GetPen(Common.SelectedColor, Common.BorderSize), rectSize);

            System.Drawing.Size sz = g.MeasureString(" ", this.LabelFont).ToSize();

            int lineTop = sz.Height + 1;
            int internalControlTop = lineTop + Common.BorderSize + 1;

            g.DrawRectangle(Cache.PenCache.GetPen(BorderColor, Common.BorderSize), rectSize);

            if (LabelVisible)
            {
                int margineMemoIcon = 0;
                if (IconLabel != null && IconLabelVisible)
                {
                    g.DrawImage(IconLabel, Common.BorderSize + left, Common.BorderSize + top);
                    margineMemoIcon = IconLabel.Width + 3;
                }

                g.DrawLine(Cache.PenCache.GetPen(LineColor, 1), 0 + left, lineTop + top, width + left, lineTop + top);

                int x = Common.BorderSize - 1 + margineMemoIcon + left;
                if (this.LabelTextPosition == TextPositionEnum.MiddleCenter)
                {
                    System.Drawing.Size szLabelText = g.MeasureString(this.labelText, this.LabelFont).ToSize();
                    x = this.Width / 2 - Math.Min(this.Width, szLabelText.Width) / 2;
                }
                g.DrawString(this.LabelText, this.LabelFont, Cache.BrushCache.GetBrush(this.LineColor), x, top);
                if (Image != null)
                {
                    //textBox.Width = this.Width - Common.BorderSize * 4 - ImageButton.Width;
                    g.DrawImage(Image, this.Width - image.Width - Common.BorderSize + left, internalControlTop + top);

                    ImageButtonLeft = this.Width - image.Width - Common.BorderSize + left;
                    ImageButtonTop = internalControlTop + top;
                    ImageButtonWidth = image.Width;
                    ImageButtonHeight = image.Height;
                }

            }

            if (Selected) g.DrawRectangle(Cache.PenCache.GetPen(Common.SelectedColor, Common.BorderSize), rectSize);

            if (parentPanel != null)
                if (parentPanel.RunTimeDesign)
                {
                    if (selected)
                        g.FillRectangle(Cache.BrushCache.GetBrush(Common.SelectedColor), this.Width - cornerHitSize + left, this.Height - cornerHitSize + top, cornerHitSize, cornerHitSize);
                    else
                        g.FillRectangle(Cache.BrushCache.GetBrush(this.BorderColor), this.Width - cornerHitSize + left, this.Height - cornerHitSize + top, cornerHitSize, cornerHitSize);
                }

        }

        public bool Hit(int x, int y)
        {
            if (x >= this.Left)
                if (y >= this.Top)
                    if (x <= this.Left + this.Width)
                        if (y <= this.Top + this.Height)
                            return true;
            return false;
        }

        public bool HitCorner(int x, int y)
        {
            if (!Hit(x, y)) return false;

            int cornerHitSize = 2;

            if (x >= this.Left + this.Width - cornerHitSize && y >= this.Top + this.Height - cornerHitSize) return true;
            return false;
        }

        public virtual void DoMouseClick(int x, int y)
        {

        }

        public virtual int ObjectCodeNumber
        {
            get { return 101; }
        }

        private System.IO.MemoryStream msSerialize;
        protected Zero5.IO.RawSerializer.RawSerializer rawSerialize;

        public byte[] Serialize()
        {
            msSerialize = new System.IO.MemoryStream();
            rawSerialize = new Zero5.IO.RawSerializer.RawSerializer(msSerialize);

            Serialize_InternalData();

            return msSerialize.ToArray();
        }

        protected virtual void Serialize_InternalData()
        {
            rawSerialize.Serialize(this.Top);
            rawSerialize.Serialize(this.Left);
            rawSerialize.Serialize(this.Width);
            rawSerialize.Serialize(this.Height);
        }

        private System.IO.MemoryStream msDeserialize;
        protected Zero5.IO.RawSerializer.RawDeserializer rawDeserialize;

        public virtual void Deserialize(byte[] data)
        {
            msDeserialize = new System.IO.MemoryStream(data);
            msDeserialize.Position = 0;
            rawDeserialize = new Zero5.IO.RawSerializer.RawDeserializer(msDeserialize);

            Deserialize_InternalData();
        }

        protected virtual void Deserialize_InternalData()
        {
            this.Top = rawDeserialize.DeserializeInt();
            this.Left = rawDeserialize.DeserializeInt();
            this.Width = rawDeserialize.DeserializeInt();
            this.Height = rawDeserialize.DeserializeInt();
        }

        public virtual void DoMouseDown(System.Windows.Forms.MouseEventArgs e) { }
        public virtual void DoMouseUp(System.Windows.Forms.MouseEventArgs e) { }
        public virtual void DoMouseClick(System.Windows.Forms.MouseEventArgs e) { }
    }
}
#endif
// file ...\Controls\Light\Label.cs
#if !CORE

namespace Zero5.Controls.Light
{
    public class Label : Zero5.Controls.Light.Control
    {
        public Label():base()
        {
            TabStop = false;
        }

        public Label(int left, int top, int width, int height, string labelText, string text, Zero5.Controls.Light.Control.TextPositionEnum labelTextPosition, Zero5.Controls.Light.Control.TextPositionEnum textPosition, System.Drawing.Image iconLabel)
            : this()
        {
            this.Left = left;
            this.Top = top;
            this.Width = width;
            this.Height = height;
            this.LabelText = labelText;
            this.Text = text;
            this.TextPosition = textPosition;
            this.LabelTextPosition = labelTextPosition;
            if (iconLabel == null)
            {
                this.IconLabelVisible = false;
            }
            else
            {
                this.IconLabel = iconLabel;
                this.IconLabelVisible = true;
            }
        }

        public override void Draw(System.Drawing.Graphics g)
        {
            base.Draw(g);

            System.Drawing.Size sz = g.MeasureString(" ", this.LabelFont).ToSize();
            int x = Common.BorderSize - 1;
            int y = (int)sz.Height + 3;

            if (this.TextPosition == TextPositionEnum.MiddleCenter)
            {
                System.Drawing.Size szText = g.MeasureString(this.Text, this.Font).ToSize();
                x = this.Width / 2 - Math.Min(this.Width, szText.Width) / 2;
            }
            g.DrawString(this.Text, this.Font, Cache.BrushCache.GetBrush(this.ForeColor), x + Left, y + Top);
        }

        public void KeyPress(char keyChar)
        {
            if (keyChar == '\b')
            {
                if (this.Text.Length > 0)
                    this.Text = this.Text.Substring(0, this.Text.Length - 1);
            }
            else if (keyChar == '\r')
            {
                this.Text += "\n";
            }
            else
            {
                this.Text += keyChar.ToString();
            }
        }

        public override int ObjectCodeNumber
        {
            get { return 102; }
        }

        protected override void Serialize_InternalData()
        {
            base.Serialize_InternalData();
            rawSerialize.Serialize(this.Text);
        }

        protected override void Deserialize_InternalData()
        {
            base.Deserialize_InternalData();
            this.Text = rawDeserialize.DeserializeString();
        }

    }
}
#endif
// file ...\Controls\Light\list.cs
#if !CORE

namespace Zero5.Controls.Light
{
    public class ListView : System.Windows.Forms.ListView
    {
        public ListView()
            : base()
        { }
    }
}
#endif

// file ...\Controls\Light\Panel.cs
#if !CORE

namespace Zero5.Controls.Light
{
    public class Panel : Zero5.Controls.PanelBase
    {
        public Panel()
        {
            this.TabStop = true;
        }

        public void AddControl(ILightControl control)
        {
            if (LightControls.Contains(control)) return;

            LightControls.Add(control);
            if (control is System.Windows.Forms.Control)
            {
                System.Windows.Forms.Control c = (System.Windows.Forms.Control)control;
                this.Controls.Add(c);
                c.MouseDown += new System.Windows.Forms.MouseEventHandler(c_MouseDown);
                c.MouseMove += new System.Windows.Forms.MouseEventHandler(c_MouseMove);
                c.MouseUp += new System.Windows.Forms.MouseEventHandler(c_MouseUp);
            }
            control.ParentPanel = this;
            this.Invalidate();
        }

        public void RemoveControl(ILightControl control)
        {
            if (LightControls.Contains(control)) LightControls.Remove(control);
            if (control is System.Windows.Forms.Control)
            {
                System.Windows.Forms.Control c = (System.Windows.Forms.Control)control;
                if (this.Controls.Contains(c))
                    this.Controls.Remove(c);
                c.MouseDown -= new System.Windows.Forms.MouseEventHandler(c_MouseDown);
                c.MouseMove -= new System.Windows.Forms.MouseEventHandler(c_MouseMove);
                c.MouseUp -= new System.Windows.Forms.MouseEventHandler(c_MouseUp);
            }
            control.ParentPanel = null;
            this.Invalidate();
        }

        public virtual void DoSubmit()
        {
            if (Submit != null) Submit();
        }
        public delegate void SubmitHandler();
        public event SubmitHandler Submit;

        void c_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            System.Windows.Forms.MouseEventArgs eRemap = new System.Windows.Forms.MouseEventArgs(e.Button, 1, e.X + ((System.Windows.Forms.Control)sender).Left, e.Y + ((System.Windows.Forms.Control)sender).Top, 0);
            this.OnMouseUp(eRemap);
        }

        void c_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            System.Windows.Forms.MouseEventArgs eRemap = new System.Windows.Forms.MouseEventArgs(e.Button, 0, e.X + ((System.Windows.Forms.Control)sender).Left, e.Y + ((System.Windows.Forms.Control)sender).Top, 0);
            this.OnMouseMove(eRemap);
        }

        void c_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            // e.X = ((System.Windows.Forms.Control)sender).Left;
            System.Windows.Forms.MouseEventArgs eRemap = new System.Windows.Forms.MouseEventArgs(e.Button, 0, e.X + ((System.Windows.Forms.Control)sender).Left, e.Y + ((System.Windows.Forms.Control)sender).Top, 0);
            this.OnMouseDown(eRemap);
        }

        private System.Drawing.Bitmap DrawingBitmapBuffer;
        private System.Drawing.Graphics DrawingGraphicsBuffer;

        protected override void OnResize(EventArgs eventargs)
        {
            if (DrawingBitmapBuffer != null) DrawingGraphicsBuffer.Dispose();
            if (DrawingGraphicsBuffer != null) DrawingBitmapBuffer.Dispose();
            DrawingBitmapBuffer = null;
            DrawingGraphicsBuffer = null;
            base.OnResize(eventargs);
        }

        protected override void OnPaint(System.Windows.Forms.PaintEventArgs e)
        {
            OnResize(new EventArgs());

            if (DrawingBitmapBuffer == null)
            {
                DrawingBitmapBuffer = new System.Drawing.Bitmap(this.ClientSize.Width, this.ClientSize.Height);
            }

            if (DrawingGraphicsBuffer == null)
            {
                DrawingGraphicsBuffer = System.Drawing.Graphics.FromImage(DrawingBitmapBuffer);
            }


            DrawingGraphicsBuffer.FillRectangle(Cache.BrushCache.GetBrush(this.BackColor), this.ClientRectangle);

            DrawingGraphicsBuffer.Clear(BackColor);

            foreach (ILightControl c in LightControls)
            {
                c.Draw(DrawingGraphicsBuffer);
            }

            e.Graphics.DrawImage(DrawingBitmapBuffer, 0, 0, this.ClientRectangle, System.Drawing.GraphicsUnit.Pixel);


            base.OnPaint(e);
        }

        private ILightControl MouseDownControlToMove = null;
        private ILightControl MouseDownControlToResize = null;
        private System.Drawing.Point MouseDownPoint = new System.Drawing.Point();

        protected override void OnMouseDown(System.Windows.Forms.MouseEventArgs e)
        {
            MouseDownControlToMove = null;
            MouseDownControlToResize = null;

            ILightControl NewControlToSelect = null;

            foreach (ILightControl c in LightControls)
            {
                if (RunTimeDesign)
                {
                    if (c.HitCorner(e.X, e.Y))
                    {
                        MouseDownControlToResize = c;
                        MouseDownPoint = new System.Drawing.Point(e.X, e.Y);
                        NewControlToSelect = c;
                        break;
                    }
                }

                if (c.Hit(e.X, e.Y))
                {
                    if (RunTimeDesign) MouseDownControlToMove = c;
                    MouseDownPoint = new System.Drawing.Point(e.X, e.Y);
                    NewControlToSelect = c;
                    break;
                }
            }

            if (SelectedControl != null) SelectedControl.Selected = false;
            SelectedControl = NewControlToSelect;
            if (SelectedControl != null)
            {
                SelectedControl.Selected = true;
                SelectedControl.DoMouseDown(e);
            }

            if (SelectedControl == null)
            {
                InternalFocus();
            }
            else
            {
                if (SelectedControl is Zero5.Controls.Light.Control) InternalFocus();
            }
            base.OnMouseDown(e);

            this.Invalidate();
        }

        protected override void OnMouseMove(System.Windows.Forms.MouseEventArgs e)
        {
            if (MouseDownControlToMove != null)
            {
                int newX = MouseDownControlToMove.Left + e.X - MouseDownPoint.X;
                if (MouseDownControlToMove.Left / Common.GridSize != newX / Common.GridSize)
                {
                    MouseDownControlToMove.Left = newX / Common.GridSize * Common.GridSize;
                    MouseDownPoint.X = e.X + MouseDownControlToMove.Left - newX;
                }
                int newY = MouseDownControlToMove.Top + e.Y - MouseDownPoint.Y;
                if (MouseDownControlToMove.Top / Common.GridSize != newY / Common.GridSize)
                {
                    MouseDownControlToMove.Top = newY / Common.GridSize * Common.GridSize;
                    MouseDownPoint.Y = e.Y + MouseDownControlToMove.Top - newY;
                }
                if (MouseDownControlToMove.Top < 0) MouseDownControlToMove.Top = 0;
                if (MouseDownControlToMove.Left < 0) MouseDownControlToMove.Left = 0;

                this.Invalidate();
            }
            if (MouseDownControlToResize != null)
            {
                int newW = MouseDownControlToResize.Width + e.X - MouseDownPoint.X;
                if (MouseDownControlToResize.Width / Common.GridSize != newW / Common.GridSize)
                {
                    MouseDownControlToResize.Width = Math.Max(Common.GridSize, newW / Common.GridSize * Common.GridSize);
                    MouseDownPoint.X = e.X + MouseDownControlToResize.Width - newW; ;
                }

                int newH = MouseDownControlToResize.Height + e.Y - MouseDownPoint.Y;
                if (MouseDownControlToResize.Height / Common.GridSize != newH / Common.GridSize)
                {
                    MouseDownControlToResize.Height = Math.Max(Common.GridSize, newH / Common.GridSize * Common.GridSize);
                    MouseDownPoint.Y = e.Y + MouseDownControlToResize.Height - newH; ;
                }

                this.Invalidate();
            }
            base.OnMouseMove(e);
        }

        protected override void OnMouseUp(System.Windows.Forms.MouseEventArgs e)
        {
            if (SelectedControl != null)
            {
                SelectedControl.DoMouseUp(e);
            }
            MouseDownControlToMove = null;
            MouseDownControlToResize = null;
            base.OnMouseUp(e);

            this.Invalidate();
        }

        //protected override bool ProcessCmdKey(ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData)
        //{
        //    System.Diagnostics.Debug.WriteLine("ProcessCmdKey " + keyData.ToString());
        //    if (keyData == System.Windows.Forms.Keys.Tab) return false;
        //    return base.ProcessCmdKey(ref msg, keyData);
        //}


        protected override void OnKeyDown(System.Windows.Forms.KeyEventArgs e)
        {
            System.Diagnostics.Debug.WriteLine("Panel OnKeyDown: " + e.KeyCode.ToString());
            //e.SuppressKeyPress
            base.OnKeyDown(e);
        }
        protected override void OnKeyPress(System.Windows.Forms.KeyPressEventArgs e)
        {
            if (RunTimeDesign)
            {
                if (RunTimeDesign && SelectedControl is Zero5.Controls.Light.Label)
                {
                    ((Zero5.Controls.Light.Label)SelectedControl).KeyPress(e.KeyChar);
                    this.Invalidate();
                }
            }
            else
            {
                if (e.KeyChar == '\r')
                {
                    if (SelectedControl is Zero5.Controls.Light.Button)
                        ((Zero5.Controls.Light.Button)SelectedControl).KeyPress(e.KeyChar);
                    else if (SelectedControl is Zero5.Controls.Light.TextBox && ((Zero5.Controls.Light.TextBox)SelectedControl).AutoConfirmButton != null)
                        ((Zero5.Controls.Light.Button)((Zero5.Controls.Light.TextBox)SelectedControl).AutoConfirmButton).DoMouseUp(new System.Windows.Forms.MouseEventArgs(System.Windows.Forms.MouseButtons.Left, 1, 0, 0, 0));
                    else
                        SelectNextControl();
                }
                else
                {
                    if (e.KeyChar == '\t')
                    {
                        SelectNextControl();
                    }
                    else
                    {
                        if (SelectedControl is Zero5.Controls.Light.TextBox)
                            ((Zero5.Controls.Light.TextBox)SelectedControl).KeyPress(e.KeyChar);

                        if (SelectedControl is Zero5.Controls.Light.Button)
                            ((Zero5.Controls.Light.Button)SelectedControl).KeyPress(e.KeyChar);
                    }
                }
                this.Invalidate();
            }
            //base.OnKeyPress(e);
        }
    }
}
#endif
// file ...\Controls\Light\TextBox.cs
#if !CORE

namespace Zero5.Controls.Light
{
    public class TextBox : Zero5.Controls.Light.Control
    {
        public TextBox()
            : base()
        { }

        public TextBox(int left, int top, int width, int height, string labelText, string text, Button autoConfirmButton)
            : this()
        {
            this.Left = left;
            this.Top = top;
            this.Width = width;
            this.Height = height;
            this.LabelText = labelText;
            this.Text = text;
            this.IconLabelVisible = false;
            AutoConfirmButton = autoConfirmButton;
        }

        public Button AutoConfirmButton = null;
        
        public override void Draw(System.Drawing.Graphics g)
        {
            base.Draw(g);

            System.Drawing.Size sz = g.MeasureString(" ", this.LabelFont).ToSize();
            int x = Common.BorderSize - 1;
            int y = (int)sz.Height + 3;
            g.DrawString(this.Text, this.Font, Cache.BrushCache.GetBrush(this.ForeColor), x + Left, y + Top);
        }

        public void KeyPress(char keyChar)
        {
            if (keyChar == '\b')
            {
                if (this.Text.Length > 0)
                    this.Text = this.Text.Substring(0, this.Text.Length - 1);
            }
            else if (keyChar == '\r')
            {
                this.Text += "\n";
            }
            else
            {
                this.Text += keyChar.ToString();
            }
        }

        public override int ObjectCodeNumber
        {
            get { return 102; }
        }

        protected override void Serialize_InternalData()
        {
            base.Serialize_InternalData();
            rawSerialize.Serialize(this.Text);
        }

        protected override void Deserialize_InternalData()
        {
            base.Deserialize_InternalData();
            this.Text = rawDeserialize.DeserializeString();
        }

    }
}

#endif
// file ...\Data\Filter\Field.cs

namespace Zero5.Data.Filter
{
    public enum eIntervalType
    {
        Incluso_Escluso = 0,
        Escluso_Incluso = 1,
        Incluso_Incluso = 2,
        Escluso_Escluso = 3
    }

    public enum eFieldVisibility
    {
        ReadWrite = 0,
        ReadOnly = 1,
        Hidden = 2,
        Obsolete = 3
    }

    public enum eFieldRequired
    {
        NotRequired = 0,
        Required = 1
    }

    public enum eJoinType
    {
        Inner = 0,
        Left = 1,
        Right = 2
    }

    public partial class Field : IEquatable<Field>
    {
        private static int paramCounterValue = 0;
        private static StringBuilder syncParamCounter = new StringBuilder();
        protected static int ParamCounter
        {
            get
            {
                lock (syncParamCounter)
                {
                    paramCounterValue++;
                    if (paramCounterValue > 10000) paramCounterValue = 1;
                    return paramCounterValue;
                }
            }
        }

        protected string _fieldGroup = "";
        public string FieldGroup
        {
            get { return _fieldGroup; }
            set { _fieldGroup = value; }
        }
        protected string _fieldGroupLocalized = "";
        public string FieldGroupLocalized
        {
            get
            {
                if (_fieldGroupLocalized.Length > 0)
                    return _fieldGroupLocalized;
                else
                    return _fieldGroup;
            }
            set { _fieldGroupLocalized = value; }
        }

        protected string _fieldName = "";
        public string FieldName
        {
            get { return _fieldName; }
            set { _fieldName = value; }
        }

        private string _fieldNameLocalized = "";
        public string FieldNameLocalized
        {
            get
            {
                if (_fieldNameLocalized.Length > 0)
                    return _fieldNameLocalized;
                else return _fieldName;
            }
            set { _fieldNameLocalized = value; }
        }

        public string FieldMask
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "$>").ToUpper(); }
        }

        public Field Parent = null;
        public string TableName = "";

        public string FieldNameLocalizedSpaced
        {
            get
            {
                string result = FieldNameLocalized[0].ToString();
                string group = "";

                for (int i = 1; i < FieldNameLocalized.Length - 1; i++)
                {
                    if (FieldNameLocalized[i] < 'a' && FieldNameLocalized.Substring(i - 1, 2) != "ID" && FieldNameLocalized.Substring(i, 2) != "ID") result += " ";
                    result += FieldNameLocalized[i].ToString();
                }
                result += FieldNameLocalized[FieldNameLocalized.Length - 1].ToString();

                result = result.Trim();

                if (this.FieldGroup != "Principale")
                    result = this.FieldGroupLocalized + "_" + result;

                string[] words = result.Split('_');
                if (words.Length > 1)
                {
                    result = "";
                    for (int i = 0; i < words.Length; i++)
                    {
                        words[i] = words[i].Trim();

                        if (i > 0)
                            if (words[i - 1] == words[i] && words.Length > 2)
                                continue;

                        if (i < words.Length - 1)
                            group = " (" + words[i] + ")";
                        else
                            result = result + " " + words[i];
                    }
                }

                result = result.Trim() + group;

                return result.Trim(); //.Replace("ID", "");
            }
        }

        protected Type fieldType = typeof(Object);
        public Type FieldType
        {
            get { return fieldType; }
            set { fieldType = value; }
        }

#if !CORE
        protected System.Drawing.Color fieldColor = System.Drawing.Color.Empty;
        public System.Drawing.Color FieldColor
        {
            get
            {
                if (Parent != null)
                {
                    Field topMostParent = this.Parent;
                    for (int i = 0; i < 10 && topMostParent.Parent != null; i++)
                        topMostParent = topMostParent.Parent;

                    return topMostParent.FieldColor;
                }
                else return fieldColor;
            }
            set { fieldColor = value; }
        }
#endif

        protected bool _multiLine = false;
        public bool MultiLine
        {
            get
            {
                if (Parent != null)
                {
                    Field topMostParent = this.Parent;
                    for (int i = 0; i < 10 && topMostParent.Parent != null; i++)
                        topMostParent = topMostParent.Parent;

                    return topMostParent.MultiLine;
                }
                else return _multiLine;
            }
            set { _multiLine = value; }
        }

        private bool _disabled = false;
        public bool Disabled
        {
            get
            {
                if (Parent != null)
                {
                    Field topMostParent = this.Parent;
                    for (int i = 0; i < 10 && topMostParent.Parent != null; i++)
                        topMostParent = topMostParent.Parent;

                    return topMostParent.Disabled;
                }
                else return _disabled;
            }
            set { _disabled = value; }
        }


        protected eFieldVisibility _visibility;
        public eFieldVisibility Visibility
        {
            get
            {
                if (Parent != null)
                {
                    Field topMostParent = this.Parent;
                    for (int i = 0; i < 10 && topMostParent.Parent != null; i++)
                        topMostParent = topMostParent.Parent;

                    return topMostParent.Visibility;
                }
                else return _visibility;
            }
            set { _visibility = value; }
        }

        protected eFieldRequired _required;
        public eFieldRequired Required
        {
            get { return _required; }
            set { _required = value; }
        }

        public bool IsVisible
        {
            get { return Visibility == eFieldVisibility.ReadOnly || Visibility == eFieldVisibility.ReadWrite; }
        }

        public Field(string sTableName, string sFieldName, Type tyFieldType, string sFieldGroup, eFieldVisibility access, Field parent)
            : this(sTableName, sFieldName, tyFieldType, sFieldGroup, access, eFieldRequired.Required, parent)
        {
        }

        public Field(string sTableName, string sFieldName, Type tyFieldType, string sFieldGroup, eFieldVisibility access, eFieldRequired required, Field parent)
        {
            _visibility = access;
            _fieldName = sFieldName;
            _fieldNameLocalized = sFieldName;
            fieldType = tyFieldType;
            _fieldGroup = sFieldGroup;
            Parent = parent;
            TableName = sTableName;
            Required = required;
        }

        private Dictionary<int, string> _valuesLookUp = null;
        public Dictionary<int, string> ValuesLookUp
        {
            get { if (Parent != null) return Parent.ValuesLookUp; else return _valuesLookUp; }
            set { if (Parent != null) Parent.ValuesLookUp = value; else _valuesLookUp = value; }
        }

        //Utilizzato per i contains su list e dictionary
        public bool Equals(Zero5.Data.Filter.Field obj)
        {
            if (obj == null)
            {
                return false;
            }

            Field b = (Field)obj;
            if (this.FieldName == b.FieldName &&
                    this.FieldType == b.FieldType &&
                    this._visibility == b._visibility &&
                    this._fieldGroup == b._fieldGroup)
                return true;
            return false;
        }

        public class TreeLookUpItem
        {
            public string Key;
            public string Text;
            public int Value;
            public string ParentKey;
            public bool Selectable;

            public TreeLookUpItem(string key, string text, int value, string parentKey, bool selectable)
            {
                Key = key;
                Text = text;
                Value = value;
                ParentKey = parentKey;
                Selectable = selectable;
            }
        }

        private List<TreeLookUpItem> _valuesLookUpTree = null;
        public List<TreeLookUpItem> ValuesLookUpTree
        {
            get { if (Parent != null) return Parent.ValuesLookUpTree; else return _valuesLookUpTree; }
            set { if (Parent != null) Parent.ValuesLookUpTree = value; else _valuesLookUpTree = value; }
        }

#if !CORE
        private Dictionary<int, System.Drawing.Image> _imagesLookUp = null;
        public Dictionary<int, System.Drawing.Image> ImagesLookUp
        {
            get { if (Parent != null) return Parent.ImagesLookUp; else return _imagesLookUp; }
            set { if (Parent != null) Parent.ImagesLookUp = value; else _imagesLookUp = value; }
        }
#endif

        private string _formatString = "";
        public string FormatString
        {
            get { if (Parent != null) return Parent.FormatString; else return _formatString; }
            set { if (Parent != null) Parent.FormatString = value; else _formatString = value; }
        }

        public bool DynamicLookUp = false;
        public delegate string GetDynamicLookUpValueDelegate(int key);
        public GetDynamicLookUpValueDelegate GetDynamicLookUpValue;

        public FilterExpression FilterIsNull()
        {
            return new FilterExpression(_fieldName, FilterExpression.Operators.IsNull, _fieldName + ParamCounter.ToString(), "");
        }

        public FilterExpression FilterNotIsNull()
        {
            return new FilterExpression(_fieldName, FilterExpression.Operators.NotIsNull, _fieldName + ParamCounter.ToString(), "");
        }

        public FilterExpression GenericFieldFilter(FilterExpression.Operators oper, object value)
        {
            return new FilterExpression(_fieldName, oper, _fieldName + ParamCounter.ToString(), value);
        }

        protected FilterExpression GenericFieldFilterEqualTo(object value)
        {
            return new FilterExpression(_fieldName, FilterExpression.Operators.Equal, _fieldName + ParamCounter.ToString(), value);
        }

        protected FilterExpression GenericFieldFilterNotEqualTo(object value)
        {
            return new FilterExpression(_fieldName, FilterExpression.Operators.NotEqual, _fieldName + ParamCounter.ToString(), value);
        }

        protected FilterExpression GenericFieldFilterLikeTo(object value)
        {
            return new FilterExpression(_fieldName, FilterExpression.Operators.Like, _fieldName + ParamCounter.ToString(), value);
        }

        protected FilterExpression GenericFieldFilterGreaterThan(object value)
        {
            return new FilterExpression(_fieldName, FilterExpression.Operators.Greater, _fieldName + ParamCounter.ToString(), value);
        }

        protected FilterExpression GenericFieldFilterGreaterEqualThan(object value)
        {
            return new FilterExpression(_fieldName, FilterExpression.Operators.GreaterEqual, _fieldName + ParamCounter.ToString(), value);
        }

        protected FilterExpression GenericFieldFilterLesserThan(object value)
        {
            return new FilterExpression(_fieldName, FilterExpression.Operators.Lesser, _fieldName + ParamCounter.ToString(), value);
        }

        protected FilterExpression GenericFieldFilterLesserEqualThan(object value)
        {
            return new FilterExpression(_fieldName, FilterExpression.Operators.LesserEqual, _fieldName + ParamCounter.ToString(), value);
        }

        protected List<FilterItem> GenericFieldFilterBetween(object valueA, object valueB, eIntervalType intervaltype)
        {
            FilterExpression.Operators leftOperator = FilterExpression.Operators.Greater;
            if (intervaltype == eIntervalType.Incluso_Escluso || intervaltype == eIntervalType.Incluso_Incluso)
                leftOperator = FilterExpression.Operators.GreaterEqual;
            FilterExpression.Operators rightOperator = FilterExpression.Operators.Lesser;
            if (intervaltype == eIntervalType.Escluso_Incluso || intervaltype == eIntervalType.Incluso_Incluso)
                leftOperator = FilterExpression.Operators.LesserEqual;

            List<FilterItem> items = new List<FilterItem>();
            items.Add(new FilterOpenBracket());
            items.Add(new FilterExpression(_fieldName, leftOperator, _fieldName + ParamCounter.ToString(), valueA));
            items.Add(new FilterAND());
            items.Add(new FilterExpression(_fieldName, rightOperator, _fieldName + ParamCounter.ToString(), valueB));
            items.Add(new FilterCloseBracket());

            return items;
        }

        protected List<FilterItem> GenericFieldFilterIn(List<string> values)
        {
            List<FilterItem> items = new List<FilterItem>();
            if (values.Count == 0)
                return items;
            else if (values.Count == 1)
            {
                items.Add(new FilterExpression(_fieldName, FilterExpression.Operators.Equal, _fieldName + ParamCounter.ToString(), values[0]));
                return items;
            }

            items.Add(new FilterOpenBracket());
            foreach (object value in values)
            {
                items.Add(new FilterExpression(_fieldName, FilterExpression.Operators.Equal, _fieldName + ParamCounter.ToString(), value));
                items.Add(new FilterOR());
            }
            items.RemoveAt(items.Count - 1);
            items.Add(new FilterCloseBracket());

            return items;
        }

        protected List<FilterItem> GenericFieldFilterIn(List<int> values)
        {
            List<int> tmpVal = new List<int>(values.ToArray());

            tmpVal.Sort();

            List<FilterItem> items = new List<FilterItem>();
            if (tmpVal.Count == 0)
                return items;
            else if (tmpVal.Count == 1)
            {
                items.Add(new FilterExpression(_fieldName, FilterExpression.Operators.Equal, _fieldName + ParamCounter.ToString(), tmpVal[0]));
                return items;
            }

            items.Add(new FilterOpenBracket());
            foreach (object value in tmpVal)
            {
                items.Add(new FilterExpression(_fieldName, FilterExpression.Operators.Equal, _fieldName + ParamCounter.ToString(), value));
                items.Add(new FilterOR());
            }
            items.RemoveAt(items.Count - 1);
            items.Add(new FilterCloseBracket());

            return items;
        }

        protected List<FilterItem> GenericFieldFilterIn(List<long> values)
        {
            List<long> tmpVal = new List<long>(values.ToArray());

            tmpVal.Sort();

            List<FilterItem> items = new List<FilterItem>();
            if (tmpVal.Count == 0)
                return items;
            else if (tmpVal.Count == 1)
            {
                items.Add(new FilterExpression(_fieldName, FilterExpression.Operators.Equal, _fieldName + ParamCounter.ToString(), tmpVal[0]));
                return items;
            }

            items.Add(new FilterOpenBracket());
            foreach (object value in tmpVal)
            {
                items.Add(new FilterExpression(_fieldName, FilterExpression.Operators.Equal, _fieldName + ParamCounter.ToString(), value));
                items.Add(new FilterOR());
            }
            items.RemoveAt(items.Count - 1);
            items.Add(new FilterCloseBracket());

            return items;
        }

        protected List<FilterItem> GenericFieldFilterNotIn(List<string> values)
        {
            List<FilterItem> items = new List<FilterItem>();
            if (values.Count == 0)
                return items;
            else if (values.Count == 1)
            {
                items.Add(new FilterExpression(_fieldName, FilterExpression.Operators.NotEqual, _fieldName + ParamCounter.ToString(), values[0]));
                return items;
            }

            items.Add(new FilterOpenBracket());
            foreach (object value in values)
            {
                items.Add(new FilterExpression(_fieldName, FilterExpression.Operators.NotEqual, _fieldName + ParamCounter.ToString(), value));
                items.Add(new FilterAND());
            }
            items.RemoveAt(items.Count - 1);
            items.Add(new FilterCloseBracket());

            return items;
        }

        protected List<FilterItem> GenericFieldFilterNotIn(List<int> values)
        {
            List<int> tmpVal = new List<int>(values.ToArray());

            tmpVal.Sort();

            List<FilterItem> items = new List<FilterItem>();
            if (tmpVal.Count == 0)
                return items;
            else if (tmpVal.Count == 1)
            {
                items.Add(new FilterExpression(_fieldName, FilterExpression.Operators.NotEqual, _fieldName + ParamCounter.ToString(), tmpVal[0]));
                return items;
            }

            items.Add(new FilterOpenBracket());
            foreach (object value in tmpVal)
            {
                items.Add(new FilterExpression(_fieldName, FilterExpression.Operators.NotEqual, _fieldName + ParamCounter.ToString(), value));
                items.Add(new FilterAND());
            }
            items.RemoveAt(items.Count - 1);
            items.Add(new FilterCloseBracket());

            return items;
        }

        protected List<FilterItem> GenericFieldFilterNotIn(List<long> values)
        {
            List<long> tmpVal = new List<long>(values.ToArray());

            tmpVal.Sort();

            List<FilterItem> items = new List<FilterItem>();
            if (tmpVal.Count == 0)
                return items;
            else if (tmpVal.Count == 1)
            {
                items.Add(new FilterExpression(_fieldName, FilterExpression.Operators.NotEqual, _fieldName + ParamCounter.ToString(), tmpVal[0]));
                return items;
            }

            items.Add(new FilterOpenBracket());
            foreach (object value in tmpVal)
            {
                items.Add(new FilterExpression(_fieldName, FilterExpression.Operators.NotEqual, _fieldName + ParamCounter.ToString(), value));
                items.Add(new FilterAND());
            }
            items.RemoveAt(items.Count - 1);
            items.Add(new FilterCloseBracket());

            return items;
        }

        public List<FilterItem> GenericFieldFilterEqualToZeroORIsNull()
        {
            List<FilterItem> items = new List<FilterItem>();
            items.Add(new FilterOpenBracket());
            items.Add(new FilterExpression(_fieldName, FilterExpression.Operators.Equal, _fieldName + ParamCounter.ToString(), 0));
            items.Add(new FilterOR());
            items.Add(new FilterExpression(_fieldName, FilterExpression.Operators.IsNull, _fieldName + ParamCounter.ToString(), null));
            items.Add(new FilterCloseBracket());

            return items;
        }

    }

    public class StringField : Field
    {
        public StringField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, Field parent)
            : this(sTableName, sFieldName, sFieldGroup, visibility, eFieldRequired.Required, parent)
        {
        }

        public StringField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, eFieldRequired required, Field parent)
            : base(sTableName, sFieldName, typeof(string), sFieldGroup, visibility, required, parent)
        {
        }

        public StringField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, string format, Field parent)
            : this(sTableName, sFieldName, sFieldGroup, visibility, eFieldRequired.Required, format, parent)
        {
        }

        public StringField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, eFieldRequired required, string format, Field parent)
            : base(sTableName, sFieldName, typeof(string), sFieldGroup, visibility, required, parent)
        {
            this.FormatString = format;
        }

        public FilterExpression FilterEqualTo(string value)
        {
            return GenericFieldFilterEqualTo(value);
        }

        public FilterExpression FilterNotEqualTo(string value)
        {
            return GenericFieldFilterNotEqualTo(value);
        }

        public FilterExpression FilterLikeTo(string value)
        {
            return GenericFieldFilterLikeTo(value);
        }

        public List<FilterItem> FilterIn(List<string> values)
        {
            return GenericFieldFilterIn(values);
        }

        public List<FilterItem> FilterNotIn(List<string> values)
        {
            return GenericFieldFilterNotIn(values);
        }

        public List<FilterItem> FilterIn(string opt1, string opt2)
        {
            return FilterIn(new List<string> { opt1, opt2 });
        }

        public List<FilterItem> FilterIn(string opt1, string opt2, string opt3)
        {
            return FilterIn(new List<string> { opt1, opt2, opt3 });
        }
        public List<FilterItem> FilterIn(string opt1, string opt2, string opt3, string opt4)
        {
            return FilterIn(new List<string> { opt1, opt2, opt3, opt4 });
        }
        public List<FilterItem> FilterIn(string opt1, string opt2, string opt3, string opt4, string opt5)
        {
            return FilterIn(new List<string> { opt1, opt2, opt3, opt4, opt5 });
        }

        public static FilterExpression operator ==(StringField f, string value)
        {
            return f.FilterEqualTo(value);
        }

        public static FilterExpression operator !=(StringField f, string value)
        {
            return f.FilterNotEqualTo(value);
        }

        public string FieldMaskNL
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_NL$>").ToUpper(); }
        }

        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }

    public class EncryptedStringField : Field
    {
        public EncryptedStringField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, Field parent)
            : this(sTableName, sFieldName, sFieldGroup, visibility, eFieldRequired.Required, parent)
        {
        }

        public EncryptedStringField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, eFieldRequired required, Field parent)
            : base(sTableName, sFieldName, typeof(string), sFieldGroup, visibility, required, parent)
        {
        }
    }

    public class ByteArrayField : Field
    {
        public ByteArrayField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, Field parent)
            : this(sTableName, sFieldName, sFieldGroup, visibility, eFieldRequired.Required, parent)
        {
        }

        public ByteArrayField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, eFieldRequired required, Field parent)
            : base(sTableName, sFieldName, typeof(byte[]), sFieldGroup, visibility, required, parent)
        {
        }

        public FilterExpression FilterEqualTo(byte[] value)
        {
            return GenericFieldFilterEqualTo(value);
        }

        public FilterExpression FilterNotEqualTo(byte[] value)
        {
            return GenericFieldFilterNotEqualTo(value);
        }
    }

    public class ImageField : Field
    {
        public ImageField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, Field parent)
            : this(sTableName, sFieldName, sFieldGroup, visibility, eFieldRequired.Required, parent)
        {
        }
#if CORE
        public ImageField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, eFieldRequired required, Field parent)
            : base(sTableName, sFieldName, typeof(byte[]), sFieldGroup, visibility, required, parent)
        {
        }
#endif

#if !CORE
        public ImageField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, eFieldRequired required, Field parent)
            : base(sTableName, sFieldName, typeof(System.Drawing.Image), sFieldGroup, visibility, required, parent)
        {
        }
#endif
    }

    public class IntegerField : Field
    {
        public IntegerField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, Field parent)
            : this(sTableName, sFieldName, sFieldGroup, visibility, eFieldRequired.Required, parent)
        {
        }

        public IntegerField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, eFieldRequired required, Field parent)
            : base(sTableName, sFieldName, typeof(int), sFieldGroup, visibility, required, parent)
        {
        }

        public FilterExpression FilterEqualTo(int value)
        {
            return GenericFieldFilterEqualTo(value);
        }

        public FilterExpression FilterNotEqualTo(int value)
        {
            return GenericFieldFilterNotEqualTo(value);
        }

        public FilterExpression FilterGreaterThan(int value)
        {
            return GenericFieldFilterGreaterThan(value);
        }

        public FilterExpression FilterGreaterEqualThan(int value)
        {
            return GenericFieldFilterGreaterEqualThan(value);
        }

        public FilterExpression FilterLesserThan(int value)
        {
            return GenericFieldFilterLesserThan(value);
        }

        public FilterExpression FilterLesserEqualThan(int value)
        {
            return GenericFieldFilterLesserEqualThan(value);
        }

        public List<FilterItem> FilterBetween(int valueA, int valueB, eIntervalType intervaltype)
        {
            return GenericFieldFilterBetween(valueA, valueB, intervaltype);
        }

        public List<FilterItem> FilterIn(List<int> values)
        {
            return GenericFieldFilterIn(values);
        }

        public List<FilterItem> FilterNotIn(List<int> values)
        {
            return GenericFieldFilterNotIn(values);
        }

        public List<FilterItem> FilterIn(int opt1, int opt2)
        {
            return FilterIn(new List<int> { opt1, opt2 });
        }

        public List<FilterItem> FilterIn(int opt1, int opt2, int opt3)
        {
            return FilterIn(new List<int> { opt1, opt2, opt3 });
        }
        public List<FilterItem> FilterIn(int opt1, int opt2, int opt3, int opt4)
        {
            return FilterIn(new List<int> { opt1, opt2, opt3, opt4 });
        }
        public List<FilterItem> FilterIn(int opt1, int opt2, int opt3, int opt4, int opt5)
        {
            return FilterIn(new List<int> { opt1, opt2, opt3, opt4, opt5 });
        }


        public static FilterExpression operator <(IntegerField f, int value)
        {
            return f.FilterLesserThan(value);
        }

        public static FilterExpression operator >(IntegerField f, int value)
        {
            return f.FilterGreaterThan(value);
        }

        public static FilterExpression operator <=(IntegerField f, int value)
        {
            return f.FilterLesserEqualThan(value);
        }

        public static FilterExpression operator >=(IntegerField f, int value)
        {
            return f.FilterGreaterEqualThan(value);
        }

        public static FilterExpression operator ==(IntegerField f, int value)
        {
            return f.FilterEqualTo(value);
        }

        public static FilterExpression operator !=(IntegerField f, int value)
        {
            return f.FilterNotEqualTo(value);
        }

        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }


    public class LongField : Field
    {
        public LongField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, Field parent)
            : this(sTableName, sFieldName, sFieldGroup, visibility, eFieldRequired.Required, parent)
        {
        }

        public LongField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, eFieldRequired required, Field parent)
            : base(sTableName, sFieldName, typeof(long), sFieldGroup, visibility, required, parent)
        {
        }

        public string FieldMaskInvariant
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_INVARIANT$>").ToUpper(); }
        }

        public FilterExpression FilterEqualTo(long value)
        {
            return GenericFieldFilterEqualTo(value);
        }

        public FilterExpression FilterNotEqualTo(long value)
        {
            return GenericFieldFilterNotEqualTo(value);
        }

        public FilterExpression FilterGreaterThan(long value)
        {
            return GenericFieldFilterGreaterThan(value);
        }

        public FilterExpression FilterGreaterEqualThan(long value)
        {
            return GenericFieldFilterGreaterEqualThan(value);
        }

        public FilterExpression FilterLesserThan(long value)
        {
            return GenericFieldFilterLesserThan(value);
        }

        public FilterExpression FilterLesserEqualThan(long value)
        {
            return GenericFieldFilterLesserEqualThan(value);
        }

        public List<FilterItem> FilterBetween(long valueA, long valueB, eIntervalType intervaltype)
        {
            return GenericFieldFilterBetween(valueA, valueB, intervaltype);
        }

        public List<FilterItem> FilterIn(List<long> values)
        {
            return GenericFieldFilterIn(values);
        }

        public List<FilterItem> FilterNotIn(List<long> values)
        {
            return GenericFieldFilterNotIn(values);
        }

        public static FilterExpression operator <(LongField f, long value)
        {
            return f.FilterLesserThan(value);
        }

        public static FilterExpression operator >(LongField f, long value)
        {
            return f.FilterGreaterThan(value);
        }

        public static FilterExpression operator <=(LongField f, long value)
        {
            return f.FilterLesserEqualThan(value);
        }

        public static FilterExpression operator >=(LongField f, long value)
        {
            return f.FilterGreaterEqualThan(value);
        }

        public static FilterExpression operator ==(LongField f, long value)
        {
            return f.FilterEqualTo(value);
        }

        public static FilterExpression operator !=(LongField f, long value)
        {
            return f.FilterNotEqualTo(value);
        }

        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }

    public class ColorField : Field
    {
        public ColorField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, Field parent)
            : this(sTableName, sFieldName, sFieldGroup, visibility, eFieldRequired.Required, parent)
        {
        }

#if CORE
        public ColorField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, eFieldRequired required, Field parent)
            : base(sTableName, sFieldName, typeof(int), sFieldGroup, visibility, required, parent)
        {
        }
#endif

#if !CORE
        public ColorField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, eFieldRequired required, Field parent)
            : base(sTableName, sFieldName, typeof(System.Drawing.Color), sFieldGroup, visibility, required, parent)
        {
        }

        public FilterExpression FilterEqualTo(System.Drawing.Color value)
        {
            return GenericFieldFilterEqualTo(value.ToArgb());
        }

        public FilterExpression FilterNotEqualTo(System.Drawing.Color value)
        {
            return GenericFieldFilterNotEqualTo(value.ToArgb());
        }

        public static FilterExpression operator ==(ColorField f, System.Drawing.Color value)
        {
            return f.FilterEqualTo(value);
        }

        public static FilterExpression operator !=(ColorField f, System.Drawing.Color value)
        {
            return f.FilterNotEqualTo(value);
        }
#endif

        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }


    public class DoubleField : Field
    {
        public DoubleField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, Field parent)
            : this(sTableName, sFieldName, sFieldGroup, visibility, eFieldRequired.Required, parent)
        {
        }

        public DoubleField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, eFieldRequired required, Field parent)
            : base(sTableName, sFieldName, typeof(double), sFieldGroup, visibility, required, parent)
        {
        }

        public string FieldMaskInvariant
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_INVARIANT$>").ToUpper(); }
        }

        public string FieldMask1Digit
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_1DIGIT$>").ToUpper(); }
        }

        public string FieldMask2Digit
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_2DIGIT$>").ToUpper(); }
        }

        public string FieldMask3Digit
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_3DIGIT$>").ToUpper(); }
        }

        public string FieldMaskHM
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_HM$>").ToUpper(); }
        }

        public string FieldMaskHMS
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_HMS$>").ToUpper(); }
        }

        public string FieldMaskHMSF
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_HMSF$>").ToUpper(); }
        }

        public string FieldMaskTotalSeconds
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_TOTALSECONDS$>").ToUpper(); }
        }

        public string FieldMaskCountPerHour
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_COUNTPERHOUR$>").ToUpper(); }
        }

        public string FieldMaskINT
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_INT$>").ToUpper(); }
        }

        public string FieldMaskTotalHours
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_TOTALHOURS$>").ToUpper(); }
        }

        public string FieldMaskSEP
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_SEP$>").ToUpper(); }
        }
        public string FieldMask1DigitSEP
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_1DIGIT_SEP$>").ToUpper(); }
        }

        public string FieldMask2DigitSEP
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_2DIGIT_SEP$>").ToUpper(); }
        }

        public string FieldMask3DigitSEP
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_3DIGIT_SEP$>").ToUpper(); }
        }

        public DoubleField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, eFieldRequired required, string format, Field parent)
            : this(sTableName, sFieldName, sFieldGroup, visibility, required, parent)
        {
            this.FormatString = format;
        }

        public FilterExpression FilterEqualTo(double value)
        {
            return GenericFieldFilterEqualTo(value);
        }

        public FilterExpression FilterNotEqualTo(double value)
        {
            return GenericFieldFilterNotEqualTo(value);
        }

        public FilterExpression FilterGreaterThan(double value)
        {
            return GenericFieldFilterGreaterThan(value);
        }

        public FilterExpression FilterGreaterEqualThan(double value)
        {
            return GenericFieldFilterGreaterEqualThan(value);
        }

        public FilterExpression FilterLesserThan(double value)
        {
            return GenericFieldFilterLesserThan(value);
        }

        public FilterExpression FilterLesserEqualThan(double value)
        {
            return GenericFieldFilterLesserEqualThan(value);
        }

        public List<FilterItem> FilterBetween(double valueA, double valueB, eIntervalType intervaltype)
        {
            return GenericFieldFilterBetween(valueA, valueB, intervaltype);
        }

        public static FilterExpression operator <(DoubleField f, double value)
        {
            return f.FilterLesserThan(value);
        }

        public static FilterExpression operator >(DoubleField f, double value)
        {
            return f.FilterGreaterThan(value);
        }

        public static FilterExpression operator <=(DoubleField f, double value)
        {
            return f.FilterLesserEqualThan(value);
        }

        public static FilterExpression operator >=(DoubleField f, double value)
        {
            return f.FilterGreaterEqualThan(value);
        }

        public static FilterExpression operator ==(DoubleField f, double value)
        {
            return f.FilterEqualTo(value);
        }

        public static FilterExpression operator !=(DoubleField f, double value)
        {
            return f.FilterNotEqualTo(value);
        }

        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }

    public class DateTimeField : Field
    {
        public DateTimeField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, Field parent)
            : this(sTableName, sFieldName, sFieldGroup, visibility, eFieldRequired.Required, parent)
        {
        }

        public DateTimeField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, eFieldRequired required, Field parent)
            : base(sTableName, sFieldName, typeof(DateTime), sFieldGroup, visibility, required, parent)
        {
        }

        public DateTimeField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, string format, Field parent)
            : this(sTableName, sFieldName, sFieldGroup, visibility, eFieldRequired.Required, parent)
        {

        }

        public DateTimeField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, eFieldRequired required, string format, Field parent)
            : this(sTableName, sFieldName, sFieldGroup, visibility, required, parent)
        {
            this.FormatString = format;
        }

        public string FieldMaskYear
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_YEAR$>").ToUpper(); }
        }

        public string FieldMaskMonth
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_MONTH$>").ToUpper(); }
        }

        public string FieldMaskDay
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_DAY$>").ToUpper(); }
        }

        public string FieldMaskShortDate
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_SHORTDATE$>").ToUpper(); }
        }

        public string FieldMaskShortTime
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_SHORTTIME$>").ToUpper(); }
        }

        public string FieldMaskHMSFromNow
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_HMSFN$>").ToUpper(); }
        }

        public string FieldMaskHMSFromNowPositive
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_HMSFNP$>").ToUpper(); }
        }

        public string FieldMaskHMSToNow
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_HMSTN$>").ToUpper(); }
        }

        public string FieldMaskHMFromNow
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_HMFN$>").ToUpper(); }
        }

        public string FieldMaskHMFromNowPositive
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_HMFNP$>").ToUpper(); }
        }

        public string FieldMaskHMToNow
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_HMTN$>").ToUpper(); }
        }

        public string FieldMaskMinutesToNow
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_MTN$>").ToUpper(); }
        }

        public string FieldMaskMinutesFromNow
        {
            get { return ("<$" + this.TableName + "_" + this._fieldName + "_MFN$>").ToUpper(); }
        }

        public FilterExpression FilterEqualTo(DateTime value)
        {
            return GenericFieldFilterEqualTo(value);
        }

        public FilterExpression FilterNotEqualTo(DateTime value)
        {
            return GenericFieldFilterNotEqualTo(value);
        }

        public FilterExpression FilterGreaterThan(DateTime value)
        {
            return GenericFieldFilterGreaterThan(value);
        }

        public FilterExpression FilterGreaterEqualThan(DateTime value)
        {
            return GenericFieldFilterGreaterEqualThan(value);
        }

        public FilterExpression FilterLesserThan(DateTime value)
        {
            return GenericFieldFilterLesserThan(value);
        }

        public FilterExpression FilterLesserEqualThan(DateTime value)
        {
            return GenericFieldFilterLesserEqualThan(value);
        }

        public List<FilterItem> FilterBetween(DateTime valueA, DateTime valueB, eIntervalType intervaltype)
        {
            return GenericFieldFilterBetween(valueA, valueB, intervaltype);
        }

        public static FilterExpression operator <(DateTimeField f, DateTime value)
        {
            return f.FilterLesserThan(value);
        }

        public static FilterExpression operator >(DateTimeField f, DateTime value)
        {
            return f.FilterGreaterThan(value);
        }

        public static FilterExpression operator <=(DateTimeField f, DateTime value)
        {
            return f.FilterLesserEqualThan(value);
        }

        public static FilterExpression operator >=(DateTimeField f, DateTime value)
        {
            return f.FilterGreaterEqualThan(value);
        }

        public static FilterExpression operator ==(DateTimeField f, DateTime value)
        {
            return f.FilterEqualTo(value);
        }

        public static FilterExpression operator !=(DateTimeField f, DateTime value)
        {
            return f.FilterNotEqualTo(value);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }
    }

    public class BooleanField : Field
    {
        public BooleanField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, Field parent)
            : this(sTableName, sFieldName, sFieldGroup, visibility, eFieldRequired.Required, parent)
        {
        }

        public BooleanField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, eFieldRequired required, Field parent)
            : base(sTableName, sFieldName, typeof(bool), sFieldGroup, visibility, required, parent)
        {
        }

        public FilterExpression FilterEqualTo(bool value)
        {
            return GenericFieldFilterEqualTo(value);
        }

        public FilterExpression FilterNotEqualTo(bool value)
        {
            return GenericFieldFilterNotEqualTo(value);
        }

        public static FilterExpression operator ==(BooleanField f, bool value)
        {
            return f.FilterEqualTo(value);
        }

        public static FilterExpression operator !=(BooleanField f, bool value)
        {
            return f.FilterNotEqualTo(value);
        }

        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }

    public class EnumField<T> : Field where T : struct, IConvertible
    {
        public EnumField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, Field parent)
            : this(sTableName, sFieldName, sFieldGroup, visibility, eFieldRequired.Required, parent)
        {
        }

        public EnumField(string sTableName, string sFieldName, string sFieldGroup, eFieldVisibility visibility, eFieldRequired required, Field parent)
            : base(sTableName, sFieldName, typeof(T), sFieldGroup, visibility, required, parent)
        {
            if (!typeof(T).IsEnum)
            {
                throw new Exception("Impossibile generare un EnumField per un campo di tipo " + typeof(T).ToString());
            }
        }

        public FilterExpression FilterEqualTo(T value)
        {
            return GenericFieldFilterEqualTo((int)(object)value);
        }

        public FilterExpression FilterEqualTo(int value)
        {
            return GenericFieldFilterEqualTo(value);
        }

        public FilterExpression FilterNotEqualTo(T value)
        {
            return GenericFieldFilterNotEqualTo((int)(object)value);
        }

        public FilterExpression FilterNotEqualTo(int value)
        {
            return GenericFieldFilterNotEqualTo(value);
        }

        public List<FilterItem> FilterIn(List<int> values)
        {
            return GenericFieldFilterIn(values);
        }

        public static FilterExpression operator ==(EnumField<T> f, T value)
        {
            return f.FilterEqualTo(value);
        }

        public static FilterExpression operator !=(EnumField<T> f, T value)
        {
            return f.FilterNotEqualTo(value);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }
    }
}
// file ...\Data\Filter\Filter.cs

namespace Zero5.Data.Filter
{
    public class Filter
    {
        public System.Collections.Generic.SortedList<int, FilterItem> FilterItems = new System.Collections.Generic.SortedList<int, FilterItem>();
        public Sorter Sorter = new Sorter();

#if PHASE
        public Filter()
        { }

        public Filter(FilterItem item)
        {
            this.Add(item);
        }

        public Filter(FilterItem[] items)
        {
            for (int i = 0; i < items.Length; i++)
                this.Add(items[i]);
        }

        public Filter(List<FilterItem> items)
        {
            this.Add(items);
        }
#endif

        public void Clear()
        {
            lock (FilterItems)
            {
                FilterItems.Clear();
#if !MOBILE
                Sorter.Clear();
#endif
            }
        }

        public Filter Clone()
        {
            Zero5.Data.Filter.Filter fil = new Filter();
            foreach (FilterItem item in FilterItems.Values)
                fil.Add(item.Clone());
#if !MOBILE
            fil.Sorter = Sorter.Clone();
#endif
            return fil;
        }

        public void AddOrderBy(Field field)
        {
#if !MOBILE
            AddOrderBy(field, eSortOrder.ASC);
#endif
        }

        public void AddOrderBy(Field field, eSortOrder sort)
        {
#if !MOBILE
            Sorter.Add(field, sort);
#endif
        }

        public void AddOpenBracket()
        {
            Add(new FilterOpenBracket());
        }

        public void AddCloseBracket()
        {
            Add(new FilterCloseBracket());
        }

        public void AddOR()
        {
            Add(new FilterOR());
        }

        public void Add(FilterItem item)
        {
            lock (FilterItems)
            {
                FilterItems.Add(FilterItems.Count, item);
            }
        }

        public void Add(List<FilterItem> items)
        {
            lock (FilterItems)
            {
                for (int i = 0; i < items.Count; i++)
                    FilterItems.Add(FilterItems.Count, items[i]);
            }
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            lock (FilterItems)
            {
                FilterAND fAND = new FilterAND();
                FilterItem previousFilterItem = null;
                foreach (FilterItem item in FilterItems.Values)
                {
                    if ((previousFilterItem is FilterExpression && item is FilterExpression)
                        ||
                        (previousFilterItem is FilterCloseBracket && item is FilterExpression)
                        ||
                        (previousFilterItem is FilterExpression && item is FilterOpenBracket)
                        ||
                        (previousFilterItem is FilterCloseBracket && item is FilterOpenBracket))
                    {
                        sb.Append(fAND.ToString() + " ");
                    }

                    sb.Append(item.ToString() + " ");

                    previousFilterItem = item;
                }
            }
            return sb.ToString().Trim();
        }

        public string ToStringHumanized()
        {
            StringBuilder sb = new StringBuilder();
            lock (FilterItems)
            {
                FilterAND fAND = new FilterAND();
                FilterItem previousFilterItem = null;
                foreach (FilterItem item in FilterItems.Values)
                {
                    if ((previousFilterItem is FilterExpression && item is FilterExpression)
                        ||
                        (previousFilterItem is FilterCloseBracket && item is FilterExpression)
                        ||
                        (previousFilterItem is FilterExpression && item is FilterOpenBracket)
                        ||
                        (previousFilterItem is FilterCloseBracket && item is FilterOpenBracket))
                    {
                        sb.Append(fAND.ToString() + " ");
                    }

                    sb.Append(item.ToStringHumanized() + " ");

                    previousFilterItem = item;
                }
            }
            return sb.ToString().Trim();
        }

        public string ToStringHumanizedBoldPreFilter()
        {
            StringBuilder sb = new StringBuilder();
            lock (FilterItems)
            {
                FilterAND fAND = new FilterAND();
                FilterItem previousFilterItem = null;
                foreach (FilterItem item in FilterItems.Values)
                {
                    if (item != null)
                    {

                        if ((previousFilterItem is FilterExpression && item is FilterExpression)
                            ||
                            (previousFilterItem is FilterCloseBracket && item is FilterExpression)
                            ||
                            (previousFilterItem is FilterExpression && item is FilterOpenBracket)
                            ||
                            (previousFilterItem is FilterCloseBracket && item is FilterOpenBracket))
                        {
                            sb.Append(fAND.ToString() + " ");
                        }

                        if (item is FilterExpression)
                            sb.Append(((FilterExpression)item).ToStringHumanizedBoldPreFilter() + " ");
                        else
                            sb.Append(item.ToStringHumanized() + " ");

                        previousFilterItem = item;
                    }
                }
            }
            return sb.ToString().Trim();
        }

        public virtual Filter Deserialize(byte[] bytes)
        {
            //Create a MemoryStream to convert bytes to a stream
            using (MemoryStream deserializeMemoryStream = new MemoryStream(bytes))
            {
                //Go to head of the stream
                deserializeMemoryStream.Position = 0;

                Filter filter = this;
                filter.Clear();

                Zero5.IO.RawSerializer.RawDeserializer rawDeserializer = new Zero5.IO.RawSerializer.RawDeserializer(deserializeMemoryStream);

                int filterItemCount = rawDeserializer.DeserializeInt();

                for (int i = 0; i < filterItemCount; i++)
                {
                    int filterType = rawDeserializer.DeserializeInt();

                    if (filterType == 0) filter.Add(new FilterAND());
                    if (filterType == 1) filter.Add(new FilterCloseBracket());
                    if (filterType == 2) filter.Add(new FilterCustom(rawDeserializer.DeserializeString()));
                    if (filterType == 3)
                    {
                        string field = rawDeserializer.DeserializeString();
                        int oper = rawDeserializer.DeserializeInt();
                        string parameter = rawDeserializer.DeserializeString();
                        string typeName = rawDeserializer.DeserializeString();
                        object value = rawDeserializer.Deserialize(Type.GetType(typeName));

                        filter.Add(new FilterExpression(field, (FilterExpression.Operators)oper, parameter, value));
                    }
                    if (filterType == 4) filter.Add(new FilterOpenBracket());
                    if (filterType == 5) filter.Add(new FilterOR());
                }

                return filter;
            }
        }

        public virtual byte[] Serialize()
        {
            using (MemoryStream memoryStream = new MemoryStream())
            {
                Zero5.IO.RawSerializer.RawSerializer rawSerializer = new Zero5.IO.RawSerializer.RawSerializer(memoryStream);

                Filter filter = this;
                rawSerializer.Serialize(filter.FilterItems.Count);

                foreach (FilterItem item in filter.FilterItems.Values)
                {
                    if (item is FilterAND) rawSerializer.Serialize((int)0);
                    if (item is FilterCloseBracket) rawSerializer.Serialize((int)1);
                    if (item is FilterCustom)
                    {
                        rawSerializer.Serialize((int)2);
                        rawSerializer.Serialize(((FilterCustom)item).ToString());
                    }
                    if (item is FilterExpression)
                    {
                        rawSerializer.Serialize((int)3);
                        rawSerializer.Serialize(((FilterExpression)item).FieldName);
                        rawSerializer.Serialize((int)((FilterExpression)item).Oper);
                        rawSerializer.Serialize(((FilterExpression)item).Parameter);
                        rawSerializer.Serialize(((FilterExpression)item).Value.GetType().ToString());
                        rawSerializer.Serialize(((FilterExpression)item).Value);
                    }
                    if (item is FilterOpenBracket) rawSerializer.Serialize((int)4);
                    if (item is FilterOR) rawSerializer.Serialize((int)5);
                }
                return memoryStream.ToArray();
            }
        }

        public void RaggruppaInORCondizioniSimilari(Data.Filter.Filter filtroDiPartenza)
        {
            string campo = "";
            string operatore = "";
            foreach (System.Collections.Generic.KeyValuePair<int, Zero5.Data.Filter.FilterItem> item in filtroDiPartenza.FilterItems)
            {
                campo = item.Value.ToString().Split(' ')[0];
                if (item.Value.ToString().Split(' ').Length > 1)
                    operatore = item.Value.ToString().Split(' ')[1];

                if (ContaOccorrenze(filtroDiPartenza, campo, operatore) > 1)
                {
                    if (ContaOccorrenze(this, campo, operatore) == 0)
                        CreaGruppoFiltro(this, TrovaOccorrenze(filtroDiPartenza, campo, operatore));
                }
                else
                    this.Add(item.Value);
            }
        }

        public void CreaGruppoFiltro(Data.Filter.Filter filtroDoveInserire, List<Data.Filter.FilterItem> lstItems)
        {
            for (int i = 0; i < lstItems.Count; i++)
            {
                if (i == 0)
                    filtroDoveInserire.Add(new Data.Filter.FilterOpenBracket());
                filtroDoveInserire.Add(lstItems[i]);

                if (i < lstItems.Count - 1)
                    filtroDoveInserire.Add(new Data.Filter.FilterOR());
                else
                    filtroDoveInserire.Add(new Data.Filter.FilterCloseBracket());
            }
        }

        public int ContaOccorrenze(Data.Filter.Filter filtroDaControllare, string nomeFiltro, string operatore)
        {
            int i = 0;
            string campo = "";
            string operatoreItem = "";
            foreach (System.Collections.Generic.KeyValuePair<int, Zero5.Data.Filter.FilterItem> item in filtroDaControllare.FilterItems)
            {
                campo = item.Value.ToString().Split(' ')[0];
                if (item.Value.ToString().Split(' ').Length > 1)
                    operatoreItem = item.Value.ToString().Split(' ')[1];
                if (campo == nomeFiltro && operatoreItem == operatore)
                    i++;
            }

            return i;
        }

        public List<Data.Filter.FilterItem> TrovaOccorrenze(Data.Filter.Filter filtroDaControllare, string nomeFiltro, string operatore)
        {
            List<Data.Filter.FilterItem> itemsTrovati = new List<Data.Filter.FilterItem>();
            string campo = "";
            string operatoreItem = "";
            foreach (System.Collections.Generic.KeyValuePair<int, Zero5.Data.Filter.FilterItem> item in filtroDaControllare.FilterItems)
            {
                campo = item.Value.ToString().Split(' ')[0];
                if (item.Value.ToString().Split(' ').Length > 1)
                    operatoreItem = item.Value.ToString().Split(' ')[1];
                if (campo == nomeFiltro && operatoreItem == operatore)
                    itemsTrovati.Add(item.Value);
            }

            return itemsTrovati;
        }
    }
}
// file ...\Data\Filter\FilterAND.cs

namespace Zero5.Data.Filter
{
    public class FilterAND : FilterItem
    {
        public override string ToString()
        {
            return "AND";
        }

        public override FilterItem Clone()
        {
            return new FilterAND();
        }
    }
}
// file ...\Data\Filter\FilterCloseBracket.cs

namespace Zero5.Data.Filter
{
    public class FilterCloseBracket : FilterItem
    {
        public override string ToString()
        {
            return ")";
        }

        public override FilterItem Clone()
        {
            return new FilterCloseBracket();
        }
    }
}
// file ...\Data\Filter\FilterCustom.cs

namespace Zero5.Data.Filter
{
    public class FilterCustom : FilterItem
    {
        private string _customString;
        public FilterCustom(string customString)
        {
            _customString = customString;
        }

        public override string ToString()
        {
            return _customString;
        }

        public override FilterItem Clone()
        {
            return new FilterCustom(_customString);
        }
    }
}
// file ...\Data\Filter\FilterExpression.cs

namespace Zero5.Data.Filter
{
    public class FilterExpression : FilterItem
    {
        public enum Operators
        {
            Nothing = 0,
            Equal = 1,
            Lesser = 2,
            LesserEqual = 3,
            Greater = 4,
            GreaterEqual = 5,
            Like = 6,
            IsNull = 7,
            NotIsNull = 8,
            NotEqual = 9
        }

        private string ParamPrefix = "@";

        public string FieldName;
        public Operators Oper;
        public string Parameter;
        public object Value;
        public bool preFilter;

        public string ToStringHumanizedBoldPreFilter()
        {
            if (preFilter)
            {
                return @"\b " + ToStringHumanized() + @"\b0 ";
            }
            else
                return ToStringHumanized();
        }

        public string ParameterWithPrefix
        {
            get
            {
                if (this.Parameter == "")
                    return this.Parameter;
                else
                    return this.ParamPrefix + this.Parameter;
            }
        }

        public FilterExpression(string fieldName, Operators oper, string parameter, object value)
        {
            this.FieldName = fieldName;
            this.Oper = oper;
            this.Parameter = parameter;
            this.Value = value;

            // fix per serializzazione
            if (oper == Operators.IsNull || oper == Operators.NotIsNull) this.Value = "";
        }

        public override string ToString()
        {
            string oper = "";
            switch (this.Oper)
            {
                case Operators.Equal: oper = "="; break;
                case Operators.Lesser: oper = "<"; break;
                case Operators.LesserEqual: oper = "<="; break;
                case Operators.Greater: oper = ">"; break;
                case Operators.GreaterEqual: oper = ">="; break;
                case Operators.Like: oper = "LIKE"; break;
                case Operators.IsNull: oper = "IS NULL"; this.Parameter = ""; break;
                case Operators.NotIsNull: oper = "IS NOT NULL"; this.Parameter = ""; break;
                case Operators.NotEqual: oper = "<>"; break;
            }

            return this.FieldName + " " + oper + " " + this.ParameterWithPrefix;
        }

        public override string ToStringHumanized()
        {
            string oper = "";
            switch (this.Oper)
            {
                case Operators.Equal: oper = "="; break;
                case Operators.Lesser: oper = "<"; break;
                case Operators.LesserEqual: oper = "<="; break;
                case Operators.Greater: oper = ">"; break;
                case Operators.GreaterEqual: oper = ">="; break;
                case Operators.Like: oper = "LIKE"; break;
                case Operators.IsNull: oper = "IS NULL"; this.Parameter = ""; break;
                case Operators.NotIsNull: oper = "IS NOT NULL"; this.Parameter = ""; break;
                case Operators.NotEqual: oper = "<>"; break;
            }

            return this.FieldName + " " + oper + " " + this.Value.ToString();
        }

        public override FilterItem Clone()
        {
            FilterExpression fe = new FilterExpression(this.FieldName, this.Oper, this.Parameter, this.Value);
            fe.preFilter = this.preFilter;
            return fe;
        }
    }
}
// file ...\Data\Filter\FilterItem.cs

namespace Zero5.Data.Filter
{
    public abstract class FilterItem
    {
        public virtual string ToStringHumanized()
        {
            return ToString();
        }

        public abstract FilterItem Clone();
    }
}
// file ...\Data\Filter\FilterOpenBracket.cs

namespace Zero5.Data.Filter
{
    public class FilterOpenBracket:FilterItem
    {
        public override string ToString()
        {
            return "(";
        }

        public override FilterItem Clone()
        {
            return new FilterOpenBracket();
        }
    }
}
// file ...\Data\Filter\FilterOR.cs

namespace Zero5.Data.Filter
{
    public class FilterOR : FilterItem
    {
        public override string ToString()
        {
            return "OR";
        }

        public override FilterItem Clone()
        {
            return new FilterOR();
        }
    }
}
// file ...\Data\Filter\Sorter.cs

namespace Zero5.Data.Filter
{
    public enum eSortOrder
    {
        ASC = 0,
        DESC = 1
    }


    public class Sorter
    {
        private class SorterItem
        {
            public Field fld;
            public eSortOrder ord;
            public SorterItem(Field field, eSortOrder order)
            {
                fld = field;
                ord = order;
            }
        }

        private List<SorterItem> Items = new List<SorterItem>();
#if !MOBILE
        private HashSet<Field> HashInsertedFields = new HashSet<Field>();
#endif
        public void Add(Field field, eSortOrder sortOrder)
        {
            lock (Items)
            {
				#if !MOBILE
                if (!HashInsertedFields.Contains(field))
                {
                    Items.Add(new SorterItem(field, sortOrder));
                    HashInsertedFields.Add(field);
                }
				#else
	                Items.Add(new SorterItem(field, sortOrder));
				#endif
            }
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            lock (Items)
            {
                foreach (SorterItem sortItem in Items)
                {
                    string order = "ASC";
                    if (sortItem.ord == eSortOrder.DESC)
                        order = "DESC";
                    sb.Append(sortItem.fld.FieldName + " " + order + ",");
                }
                if (sb.Length > 0)
                    sb.Remove(sb.Length - 1, 1);
            }
            return sb.ToString().Trim();
        }

         public List<string> GetSortedFields()
        {
            List<string> res = new List<string>();
            foreach (SorterItem item in Items)
                res.Add(item.fld.FieldName);
            return res;
        }


        public void Clear()
        {
            lock (Items)
            {
                Items.Clear();
				#if !MOBILE
					HashInsertedFields.Clear();
				#endif

            }
        }

        public Sorter Clone()
        {
            lock (Items)
            {
                Sorter srt = new Sorter();
                foreach (SorterItem item in Items)
                    srt.Add(item.fld, item.ord);
                return srt;
            }
        }
    }
}
// file ...\Data\Grouper\Grouper.cs

namespace Zero5.Data.Grouper
{
    public class Grouper
    {
        public System.Collections.Generic.SortedList<int, GrouperItem> GrouperItems = new System.Collections.Generic.SortedList<int, GrouperItem>();

        public void Clear()
        {
            lock (GrouperItems)
            {
                GrouperItems.Clear();
            }
        }

        public void Add(GrouperItem item)
        {
            lock (GrouperItems)
            {
                GrouperItems.Add(GrouperItems.Count, item);
            }
        }

        public string SelectFields(System.Data.DataTable dt)
        {
            string result = "";

            for (int i = 0; i < dt.Columns.Count; i++)
            {
                bool fieldToGroup = true;
                string columnName = dt.Columns[i].ColumnName;
                foreach (GrouperItem grpItem in GrouperItems.Values)
                {
                    if (grpItem.FieldName == columnName)
                    {
                        fieldToGroup = false;
                        if (grpItem.IncludeOnSelect)
                        {
                            if (result != "") result += ", ";
                            result += grpItem.ToString();
                        }
                        break;
                    }
                }
                if (fieldToGroup)
                {
                    if (result != "") result += ", ";
                    result += columnName;
                }
            }

            return result;
        }

        public string SelectFields(System.Data.DataTable dt, Filter.Filter havingFilter)
        {
            string result = "";

            for (int i = 0; i < dt.Columns.Count; i++)
            {
                string columnName = dt.Columns[i].ColumnName;
                foreach (GrouperItem grpItem in GrouperItems.Values)
                {
                    if (grpItem.FieldName == columnName)
                    {
                        if (grpItem.IncludeOnSelect)
                        {
                            if (result != "") result += ", ";
                            result += grpItem.ToString();
                        }
                        break;
                    }
                }
                if (havingFilter != null)
                    foreach (Filter.FilterItem filterItem in havingFilter.FilterItems.Values)
                    {
                        if (filterItem is Filter.FilterExpression)
                        {
                            Filter.FilterExpression fe = (Filter.FilterExpression)filterItem;
                            if (fe.FieldName == columnName)
                            {
                                if (result != "") result += ", ";
                                result += fe.FieldName.ToString();
                                break;
                            }
                        }
                    }
            }

            return result;
        }

        public string GroupByFields(System.Data.DataTable dt, Filter.Filter havingFilter)
        {
            string result = "";

            for (int i = 0; i < dt.Columns.Count; i++)
            {
                string columnName = dt.Columns[i].ColumnName;
                foreach (GrouperItem grpItem in GrouperItems.Values)
                {
                    if (grpItem.FieldName == columnName)
                    {
                        if (grpItem.IncludeOnGroupBy)
                        {
                            if (result != "") result += ", ";
                            result += grpItem.ToString().Replace(" AS " + grpItem.FieldName, "");
                        }
                        break;
                    }
                }
                if (havingFilter != null)
                    foreach (Filter.FilterItem filterItem in havingFilter.FilterItems.Values)
                    {
                        if (filterItem is Filter.FilterExpression)
                        {
                            Filter.FilterExpression fe = (Filter.FilterExpression)filterItem;
                            if (fe.FieldName == columnName)
                            {
                                if (result != "") result += ", ";
                                result += fe.FieldName.ToString();
                                break;
                            }
                        }
                    }
            }

            return result;
        }

        public string GroupByFields(System.Data.DataTable dt)
        {
            string result = "";

            for (int i = 0; i < dt.Columns.Count; i++)
            {
                bool fieldToGroup = true;
                string columnName = dt.Columns[i].ColumnName;
                foreach (GrouperItem grpItem in GrouperItems.Values)
                {
                    if (grpItem.FieldName == columnName)
                    {
                        fieldToGroup = false;
                        if (grpItem.IncludeOnGroupBy)
                        {
                            if (result != "") result += ", ";
                            result += grpItem.ToString().Replace(" AS " + grpItem.FieldName, "");
                        }
                        break;
                    }
                }
                if (fieldToGroup)
                {
                    if (result != "") result += ", ";
                    result += columnName;
                }
            }

            return result;
        }

        public virtual Grouper Deserialize(byte[] bytes)
        {
            //Create a MemoryStream to convert bytes to a stream
            using (MemoryStream deserializeMemoryStream = new MemoryStream(bytes))
            {
                //Go to head of the stream
                deserializeMemoryStream.Position = 0;

                Grouper grouper = this;
                grouper.Clear();

                Zero5.IO.RawSerializer.RawDeserializer rawDeserializer = new Zero5.IO.RawSerializer.RawDeserializer(deserializeMemoryStream);

                int GrouperItemCount = rawDeserializer.DeserializeInt();

                for (int i = 0; i < GrouperItemCount; i++)
                {
                    int grouperType = rawDeserializer.DeserializeInt();

                    if (grouperType == 0) grouper.Add(new GrouperCOUNT(rawDeserializer.DeserializeString()));
                    if (grouperType == 1) grouper.Add(new GrouperDATE(rawDeserializer.DeserializeString()));
                    if (grouperType == 2) grouper.Add(new GrouperExclude(rawDeserializer.DeserializeString()));
                    if (grouperType == 3) grouper.Add(new GrouperMAX(rawDeserializer.DeserializeString()));
                    if (grouperType == 4) grouper.Add(new GrouperMIN(rawDeserializer.DeserializeString()));
                    if (grouperType == 5) grouper.Add(new GrouperSUM(rawDeserializer.DeserializeString()));
                    if (grouperType == 6) grouper.Add(new GrouperGROUPBY(rawDeserializer.DeserializeString()));
                    if (grouperType == 7) grouper.Add(new GrouperMONTH(rawDeserializer.DeserializeString()));
                    if (grouperType == 8) grouper.Add(new GrouperHOUR(rawDeserializer.DeserializeString()));
                }

                return grouper;
            }
        }

        public virtual byte[] Serialize()
        {
            using (MemoryStream memoryStream = new MemoryStream())
            {
                Zero5.IO.RawSerializer.RawSerializer rawSerializer = new Zero5.IO.RawSerializer.RawSerializer(memoryStream);

                Grouper grouper = this;
                rawSerializer.Serialize(grouper.GrouperItems.Count);

                foreach (GrouperItem item in grouper.GrouperItems.Values)
                {
                    if (item is GrouperCOUNT) rawSerializer.Serialize((int)0);
                    if (item is GrouperDATE) rawSerializer.Serialize((int)1);
                    if (item is GrouperExclude) rawSerializer.Serialize((int)2);
                    if (item is GrouperMAX) rawSerializer.Serialize((int)3);
                    if (item is GrouperMIN) rawSerializer.Serialize((int)4);
                    if (item is GrouperSUM) rawSerializer.Serialize((int)5);
                    if (item is GrouperGROUPBY) rawSerializer.Serialize((int)6);
                    if (item is GrouperMONTH) rawSerializer.Serialize((int)7);
                    if (item is GrouperHOUR) rawSerializer.Serialize((int)8);

                    rawSerializer.Serialize((string)item.FieldName);
                }
                return memoryStream.ToArray();
            }
        }
    }
}
// file ...\Data\Grouper\GrouperCOUNT.cs

namespace Zero5.Data.Grouper
{
    public class GrouperCOUNT : GrouperItem
    {
        public GrouperCOUNT(Zero5.Data.Filter.Field field)
            : this(field.FieldName)
        { }

        public GrouperCOUNT(string fieldName) : base(fieldName) { }

        public override string ToString()
        {
            return "COUNT(" + this.FieldName + ") AS " + this.FieldName;
        }
    }
}
// file ...\Data\Grouper\GrouperDATE.cs

namespace Zero5.Data.Grouper
{
    public class GrouperDATE : GrouperItem
    {
        public GrouperDATE(Zero5.Data.Filter.Field field)
            : this(field.FieldName)
        { }
        
        public GrouperDATE(string fieldName) : base(fieldName) 
        {
            this.IncludeOnGroupBy = true;
        }

        public override string ToString()
        {
            return "DATE(" + this.FieldName + ") AS " + this.FieldName;
        }
    }
}
// file ...\Data\Grouper\GrouperExclude.cs

namespace Zero5.Data.Grouper
{
    public class GrouperExclude : GrouperItem
    {
        public GrouperExclude(Zero5.Data.Filter.Field field)
            : this(field.FieldName)
        { }
        
        public GrouperExclude(string fieldName) : base(fieldName) 
        {
            this.IncludeOnSelect = false;
        }
        
        public override string ToString()
        {
            return this.FieldName;
        }
    }
}
// file ...\Data\Grouper\GrouperFIELD.cs

namespace Zero5.Data.Grouper
{
    public class GrouperFIELD : GrouperItem
    {
        public GrouperFIELD(Zero5.Data.Filter.Field field)
            : this(field.FieldName)
        { }

        public GrouperFIELD(string fieldName) : base(fieldName) { }

        public override string ToString()
        {
            return this.FieldName;
        }
    }
}
// file ...\Data\Grouper\GrouperGROUPBY.cs

namespace Zero5.Data.Grouper
{
    public class GrouperGROUPBY : GrouperItem
    {
        public GrouperGROUPBY(Zero5.Data.Filter.Field field)
            : this(field.FieldName)
        { }

        public GrouperGROUPBY(string fieldName)
            : base(fieldName) 
        {
            this.IncludeOnGroupBy = true;
        }
        
        public override string ToString()
        {
            return this.FieldName;
        }
    }
}
// file ...\Data\Grouper\GrouperHOUR.cs

namespace Zero5.Data.Grouper
{
    public class GrouperHOUR : GrouperItem
    {
        public GrouperHOUR(Zero5.Data.Filter.Field field)
            : this(field.FieldName)
        { }
        
        public GrouperHOUR(string fieldName) : base(fieldName) 
        {
            this.IncludeOnGroupBy = true;
            this.IncludeOnSelect = true;
        }

        public override string ToString()
        {
            return "PHASEDATEHOUR(" + this.FieldName + ") AS " + FieldName; 
        }
    }
}
// file ...\Data\Grouper\GrouperItem.cs

namespace Zero5.Data.Grouper
{
    public class GrouperItem
    {
        public string FieldName = "";

        public bool IncludeOnSelect = true;
        public bool IncludeOnGroupBy = false;

        public GrouperItem(string fieldName)
        {
            this.FieldName = fieldName;
        }

    }
}
// file ...\Data\Grouper\GrouperMAX.cs

namespace Zero5.Data.Grouper
{
    public class GrouperMAX : GrouperItem
    {
        public GrouperMAX(Zero5.Data.Filter.Field field)
            : this(field.FieldName)
        { }
        
        public GrouperMAX(string fieldName) : base(fieldName) { }

        public override string ToString()
        {
            return "MAX(" + this.FieldName + ") AS " + this.FieldName;
        }
    }
}
// file ...\Data\Grouper\GrouperMIN.cs

namespace Zero5.Data.Grouper
{
    public class GrouperMIN : GrouperItem
    {
        public GrouperMIN(Zero5.Data.Filter.Field field)
            : this(field.FieldName)
        { }
        
        public GrouperMIN(string fieldName) : base(fieldName) { }

        public override string ToString()
        {
            return "MIN(" + this.FieldName + ") AS " + this.FieldName;
        }
    }
}
// file ...\Data\Grouper\GrouperMONTH.cs

namespace Zero5.Data.Grouper
{
    public class GrouperMONTH : GrouperItem
    {
        public GrouperMONTH(Zero5.Data.Filter.Field field)
            : this(field.FieldName)
        { }
        
        public GrouperMONTH(string fieldName) : base(fieldName) 
        {
            this.IncludeOnGroupBy = true;
        }

        public override string ToString()
        {
            //return ""; 

            return "PHASEFIRSTDAYOFMONTH("+this.FieldName+") AS "+FieldName;
        }
    }
}
// file ...\Data\Grouper\GrouperSUM.cs

namespace Zero5.Data.Grouper
{
    public class GrouperSUM : GrouperItem
    {
        public GrouperSUM(Zero5.Data.Filter.Field field)
            : this(field.FieldName)
        { }
        
        public GrouperSUM(string fieldName) : base(fieldName) { }

        public override string ToString()
        {
            return "SUM(" + this.FieldName + ") AS " + this.FieldName;
        }
    }
}
// file ...\Data\Rule\ColorRule.cs


namespace Zero5.Data.Rule
{
    public class ColorRule
    {
        public System.Collections.Generic.List<ColorRuleItem> filterItems = new System.Collections.Generic.List<ColorRuleItem>();

        public ColorRule()
        { }

        public ColorRule(ColorRuleItem item)
        {
            this.Add(item);
        }

        public ColorRule(ColorRuleItem[] items)
        {
            for (int i = 0; i < items.Length; i++)
                this.Add(items[i]);
        }

        public ColorRule(List<ColorRuleItem> items)
        {
            this.Add(items);
        }

        public void Clear()
        {
            lock (filterItems)
            {
                filterItems.Clear();
            }
        }

        public void Add(ColorRuleItem item)
        {
            lock (filterItems)
            {
                filterItems.Add(item);
            }
        }

        public void Add(List<ColorRuleItem> items)
        {
            lock (filterItems)
            {
                for (int i = 0; i < items.Count; i++)
                    filterItems.Add(items[i]);
            }
        }

    }    
}
// file ...\Data\Rule\ColorRuleItem.cs

namespace Zero5.Data.Rule
{
    /// <summary>
    /// Se valorizzato filter allora per il filtro impostato viene utilizzato il colore indicato;
    /// altrimenti per il campo indicato viene utilizzato il colore corrispondete ricavato dal dictionary
    /// </summary>
    public class ColorRuleItem
    {

        private Zero5.Data.Filter.FilterExpression filter;
        private System.Drawing.Color colorFilter;
        private Dictionary<string, System.Drawing.Color> dicColor;
        private Zero5.Data.Filter.Field colorField;

        public ColorRuleItem(Zero5.Data.Filter.FilterExpression filter, System.Drawing.Color colorFilter)
        {
            this.filter = filter;
            this.colorFilter = colorFilter;
        }

        public ColorRuleItem(Dictionary<string, System.Drawing.Color> dicColor, Zero5.Data.Filter.Field colorField)
        {
            this.colorField = colorField;
            this.dicColor = dicColor;
            if (!dicColor.ContainsKey("0"))
                dicColor.Add("0", System.Drawing.Color.White);     // Valore default
        }

        public Zero5.Data.Filter.FilterExpression Filter
        {
            get { return filter; }
        }

        public System.Drawing.Color ColorFilter
        {
            get { return colorFilter; }
        }

        public Dictionary<string, System.Drawing.Color> DicColor
        {
            get { return dicColor; }
        }

        public Zero5.Data.Filter.Field ColorField
        {
            get { return colorField; }
        }
    }

}
// file ...\Data\Util\DBCSV.cs
#if !MOBILE

namespace Zero5.Data.Util
{
    class DBCSV
    {

        public static System.Data.DataSet LoadDataSet(string filename, bool primaRigaHeader)
        {
            return LoadDataSet(filename, primaRigaHeader, '\t');
        }

        public static System.Data.DataSet LoadDataSet(string filename, bool primaRigaHeader, char separatoreColonna)
        {
            using (Zero5.IO.File.Csv.CsvReader csv =
                               new Zero5.IO.File.Csv.CsvReader(new System.IO.StreamReader(filename), primaRigaHeader, separatoreColonna))
            {
                System.Data.DataSet ds = new System.Data.DataSet();
                System.Data.DataTable dt = new System.Data.DataTable();
                
                int fieldCount = csv.FieldCount;
                string[] headers = csv.GetFieldHeaders();
                for (int i = 0; i < headers.Length; i++)
                    dt.Columns.Add(new System.Data.DataColumn(headers[i]));

                if (dt.Columns.Count == 0)
                    for (int i = 0; i < fieldCount; i++)
                        dt.Columns.Add();

                while (csv.ReadNextRecord())
                {
                    string[] row = new string[fieldCount];
                    csv.CopyCurrentRecordTo(row);
                    dt.Rows.Add(row);
                }
                ds.Tables.Add(dt);
                return ds;
            }
        }

        public static void SaveDataSet(string filename, System.Data.DataSet ds, bool primaRigaHeader)
        {
            SaveDataSet(filename, ds, primaRigaHeader, '\t');
        }

        public static void SaveDataSet(string filename, System.Data.DataSet ds, bool primaRigaHeader, char separatoreColonna)
        {
            StringBuilder sb = new StringBuilder();

            if (primaRigaHeader)
            {
                //nomi colonne
                for (int i = 0; i < ds.Tables[0].Columns.Count; i++)
                {
                    sb.Append(StringSafeCast(ds.Tables[0].Columns[i].ColumnName));
                    if (i < ds.Tables[0].Columns.Count - 1) sb.Append(separatoreColonna.ToString());
                }
                sb.Append("\r\n");
            }

            //righe dati
            for (int j = 0; j < ds.Tables[0].Rows.Count; j++)
            {
                for (int i = 0; i < ds.Tables[0].Columns.Count; i++)
                {
                    string dati = StringSafeCast(ds.Tables[0].Rows[j][i]);
                    //if (dati.IndexOf("\"") != dati.IndexOf("\""))
                    {
                        dati = dati.Replace("\"", "");
                    }
                    sb.Append(dati);
                    if (i < ds.Tables[0].Columns.Count - 1) sb.Append(separatoreColonna.ToString());
                }
                sb.Append("\r\n");
            }
//#if !MOBILE
            System.IO.File.WriteAllText(filename, sb.ToString(), System.Text.Encoding.UTF8);
//#else
//            using (System.IO.StreamWriter streamWriter = new System.IO.StreamWriter(filename, false))
//            {
//                streamWriter.Write(sb.ToString());
//            }
//#endif
        }

        private static string StringSafeCast(object o)
        {
            try
            {
                return o.ToString();
            }
            catch
            {

                return "";
            }
        } 
    }
}
#endif
// file ...\Data\Util\DBCSVFixed.cs
#if !MOBILE
namespace Zero5.Data.Util
{
    partial class DBCSVFixed
    {
        public static System.Data.DataSet LoadDataSet(string filename, bool primaRigaHeader, int[] posizioneCampi)
        {
            return LoadDataSet(filename, primaRigaHeader, posizioneCampi, null);
        }

        public static System.Data.DataSet LoadDataSet(string filename, bool primaRigaHeader, int[] posizioneCampi, System.Text.Encoding tipoEncoding)
        {
//#if MOBILE
//            List<string> list = new List<string>();
//            using (StreamReader streamReader = new StreamReader(filename))
//            {
//                string item;
//                while ((item = streamReader.ReadLine()) != null)
//                {
//                    list.Add(item);
//                }
//            }
//            string[] righe = list.ToArray(); 
//#else
            string[] righe;
            if (tipoEncoding == null)
                righe = System.IO.File.ReadAllLines(filename);
            else
                righe = System.IO.File.ReadAllLines(filename, tipoEncoding);
//#endif
            System.Data.DataSet ds = new System.Data.DataSet();
            System.Data.DataTable dt = new System.Data.DataTable();

            for (int r = 0; r < righe.Length; r++)
            {
                string riga = righe[r];

                if (riga.Trim() != "")
                {
                    //colonne
                    if (r == 0)
                    {
                        if (primaRigaHeader)
                        {
                            for (int i = 0; i < posizioneCampi.Length; i++)
                                dt.Columns.Add(new System.Data.DataColumn(EstraiCampo(riga, posizioneCampi, i + 1)));
                        }
                        else
                        {
                            for (int i = 0; i < posizioneCampi.Length; i++)
                                dt.Columns.Add(new System.Data.DataColumn("Col" + (i + 1).ToString()));
                        }
                    }

                    //dati
                    if (r > 0 || !primaRigaHeader)
                    {
                        string[] valori = new string[posizioneCampi.Length];
                        for (int i = 0; i < posizioneCampi.Length; i++)
                            valori[i] = EstraiCampo(riga, posizioneCampi, i + 1);
                        dt.Rows.Add(valori);
                    }
                }
            }
            ds.Tables.Add(dt);
            return ds;
        }

        private static string EstraiCampo(string riga, int[] posizioneCampi, int numeroCampo)
        {
            if (numeroCampo == posizioneCampi.Length)
                return riga.Substring(posizioneCampi[numeroCampo-1]);
            else
                return riga.Substring(posizioneCampi[numeroCampo-1], posizioneCampi[numeroCampo] - posizioneCampi[numeroCampo-1]);
        }

    }
}

#endif
// file ...\Data\Util\DBFirebird.cs
#if !MOBILE && !CORE

namespace Zero5.Data.Util
{
#if DB_FIREBIRD
    class DBFirebird
    {
        public static System.Data.DataSet LoadDataSet(string connectionString, string selectQuery)
        {
            try
            {
                System.Data.DataSet ds = new System.Data.DataSet();
                FirebirdSql.Data.FirebirdClient.FbConnection myConnection1 = new FirebirdSql.Data.FirebirdClient.FbConnection(connectionString);
                myConnection1.Open();
                FirebirdSql.Data.FirebirdClient.FbDataAdapter fbAdapter = new FirebirdSql.Data.FirebirdClient.FbDataAdapter(selectQuery, myConnection1);
                fbAdapter.SelectCommand.CommandTimeout = 60;
                fbAdapter.Fill(ds);
                myConnection1.Close();
                return ds;
            }
            catch (Exception ex)
            {
                Zero5.Util.Log.WriteLog(ex.Message);
            }
            return null;
        }

        public static void ExecuteNonQuery(FirebirdSql.Data.FirebirdClient.FbConnection sqlCon, List<FirebirdSql.Data.FirebirdClient.FbCommand> listSQLCommand)
        {
            if (sqlCon.State != System.Data.ConnectionState.Open) sqlCon.Open();
            FirebirdSql.Data.FirebirdClient.FbTransaction sqlTrans = sqlCon.BeginTransaction();
            try
            {
                foreach (FirebirdSql.Data.FirebirdClient.FbCommand cmd in listSQLCommand)
                {
                    cmd.Transaction = sqlTrans;
                    cmd.ExecuteNonQuery();
                }
                sqlTrans.Commit();
            }
            catch (Exception exErr)
            {
                sqlTrans.Rollback();
                throw exErr;
            }
        }
    }
#endif
}
#endif
// file ...\Data\Util\DBGeneric.cs

namespace Zero5.Data.Util
{
    class DBGeneric
    {
        public static void TrimStringsOnDataSet(System.Data.DataSet ds)
        {
            for (int t = 0; t < ds.Tables.Count; t++)
                for (int c = 0; c < ds.Tables[t].Columns.Count; c++)
                    if (ds.Tables[t].Columns[c].DataType == typeof(string))
                        for (int r = 0; r < ds.Tables[t].Rows.Count; r++)
                            if (!(ds.Tables[t].Rows[r][c] is DBNull))
                                ds.Tables[t].Rows[r][c] = ((string)ds.Tables[t].Rows[r][c]).Trim();
        }

        public static void CastDBNullOnDataSet(System.Data.DataSet ds)
        {
            for (int t = 0; t < ds.Tables.Count; t++)
                for (int c = 0; c < ds.Tables[t].Columns.Count; c++)
                {
                    if (ds.Tables[t].Columns[c].DataType == typeof(string))
                        for (int r = 0; r < ds.Tables[t].Rows.Count; r++)
                            if ((ds.Tables[t].Rows[r][c] is DBNull)) ds.Tables[t].Rows[r][c] = "";
                    if (ds.Tables[t].Columns[c].DataType == typeof(int))
                        for (int r = 0; r < ds.Tables[t].Rows.Count; r++)
                            if ((ds.Tables[t].Rows[r][c] is DBNull)) ds.Tables[t].Rows[r][c] = 0;
                    if (ds.Tables[t].Columns[c].DataType == typeof(double))
                        for (int r = 0; r < ds.Tables[t].Rows.Count; r++)
                            if ((ds.Tables[t].Rows[r][c] is DBNull)) ds.Tables[t].Rows[r][c] = 0.0;
                    if (ds.Tables[t].Columns[c].DataType == typeof(DateTime))
                        for (int r = 0; r < ds.Tables[t].Rows.Count; r++)
                            if ((ds.Tables[t].Rows[r][c] is DBNull)) ds.Tables[t].Rows[r][c] = DateTime.MinValue;
                }
        }

        public static string CleanModelUnusedTags(string model)
        {
            if (model.IndexOf("<$") == -1) return model;

            char[] copy = model.ToCharArray();

            int pos = 0;
            bool istag = false;
            int i = 0;
            for (i = 0; i < model.Length - 1; i++)
            {
                if (model[i] == '<') if (model[i + 1] == '$') istag = true;
                if (!istag) copy[pos++] = model[i];
                if (i > 2) if (model[i - 1] == '$') if (model[i] == '>') istag = false;
            }
            if (!istag) copy[pos++] = model[i];
            return new string(copy, 0, pos);
        }

        public static string[] GetColumsInModel(string model, System.Data.DataRow dr, string field_prefix)
        {
            List<string> columnsInTag = new List<string>();

            string[] modeltags = model.Split('<');

            for (int i = 0; i < modeltags.Length; i++)
            {
                if (modeltags[i].Length > 0)
                    if (modeltags[i][0] == '$')
                        modeltags[i] = modeltags[i].Substring(1, modeltags[i].IndexOf("$>") - 1);
            }

            string sPreTag = "<$";
            string sPostTag = "$>";

            if (dr != null)
            {
                for (int i = 0; i < dr.Table.Columns.Count; i++)
                {
                    System.Data.DataColumn c = dr.Table.Columns[i];
                    string sPreTag_ColumnName = sPreTag + field_prefix.ToUpper() + "_" + c.ColumnName.ToUpper();
                    {
                        string tagHeaderToTest = sPreTag_ColumnName.Substring(2); //without <$
                        for (int j = 0; j < modeltags.Length; j++)
                        {
                            if (modeltags[j].StartsWith(tagHeaderToTest))
                            {
                                columnsInTag.Add(c.ColumnName);
                                break;
                            }
                        }
                    }
                }
            }

            return columnsInTag.ToArray();
        }

        public static string ReplaceModel(string model, System.Data.DataRow dr, string field_prefix, bool isEmpty)
        {
            return ReplaceModel(model, dr, new string[0], field_prefix, isEmpty);
        }

        public static string ReplaceModel(string model, System.Data.DataRow dr, string[] datarowColumns, string field_prefix, bool isEmpty)
        {
            try
            {
                string[] modeltags = model.Split('<');

                for (int i = 0; i < modeltags.Length; i++)
                {
                    if (modeltags[i].Length > 0)
                        if (modeltags[i][0] == '$')
                            modeltags[i] = modeltags[i].Substring(1, modeltags[i].IndexOf("$>") - 1);
                }

                string sPreTag = "<$";
                string sPostTag = "$>";

                if (dr != null && !isEmpty)
                {
                    System.Data.DataColumn[] columnsToReplace = new System.Data.DataColumn[0];

                    if (datarowColumns.Length > 0)
                    {
                        List<System.Data.DataColumn> cols = new List<System.Data.DataColumn>();
                        for (int i = 0; i < dr.Table.Columns.Count; i++)
                        {
                            if (datarowColumns.Contains(dr.Table.Columns[i].ColumnName))
                                cols.Add(dr.Table.Columns[i]);
                        }
                        columnsToReplace = cols.ToArray();
                    }

                    if (columnsToReplace.Length == 0)
                    {
                        columnsToReplace = new System.Data.DataColumn[dr.Table.Columns.Count];
                        dr.Table.Columns.CopyTo(columnsToReplace, 0);
                    }

                    for (int i = 0; i < columnsToReplace.Length; i++)
                    {
                        System.Data.DataColumn c = columnsToReplace[i];

                        string sPreTag_ColumnName = sPreTag + field_prefix.ToUpper() + "_" + c.ColumnName.ToUpper();

                        bool existTagForThisCol = false;
                        {
                            string tagHeaderToTest = sPreTag_ColumnName.Substring(2); //without <$
                            for (int j = 0; j < modeltags.Length; j++)
                            {
                                if (modeltags[j].StartsWith(tagHeaderToTest))
                                {
                                    existTagForThisCol = true;
                                    break;
                                }
                            }
                        }

                        if (existTagForThisCol)
                        {
                            object value = dr[c.ColumnName];
                            if (value != null)

                                if (value is System.DateTime)
                                {
                                    if (((DateTime)value) != DateTime.MinValue)
                                    {
                                        model = model.Replace(sPreTag_ColumnName + sPostTag, ((DateTime)value).ToString());
                                        model = model.Replace(sPreTag_ColumnName + "_YEAR" + sPostTag, ((DateTime)value).ToString("yyyy"));
                                        model = model.Replace(sPreTag_ColumnName + "_MONTH" + sPostTag, ((DateTime)value).ToString("MM"));
                                        model = model.Replace(sPreTag_ColumnName + "_DAY" + sPostTag, ((DateTime)value).ToString("dd"));
                                        model = model.Replace(sPreTag_ColumnName + "_SHORTDATE" + sPostTag, ((DateTime)value).ToString("dd/MM/yyyy"));
                                        model = model.Replace(sPreTag_ColumnName + "_SHORTTIME" + sPostTag, ((DateTime)value).ToShortTimeString());

                                        if (model.Contains("HMSFN" + sPostTag) || model.Contains("HMFN" + sPostTag) || model.Contains("MFN" + sPostTag) ||
                                            model.Contains("HMSFNP" + sPostTag) || model.Contains("HMFNP" + sPostTag) ||
                                            model.Contains("HMSTN" + sPostTag) || model.Contains("HMTN" + sPostTag) || model.Contains("MTN" + sPostTag))
                                        {
                                            TimeSpan ts = ((DateTime)value) - DateTime.Now;
                                            string signFN = ts.TotalSeconds < 0 ? "-" : "";
                                            string signTN = ts.TotalSeconds < 0 ? "" : "-";
                                            string valueHMS = Math.Abs(((int)(ts.TotalHours))).ToString() + ":" + Math.Abs(ts.Minutes).ToString("00") + ":" + Math.Abs(ts.Seconds).ToString("00");
                                            string valueHM = Math.Abs(((int)(ts.TotalHours))).ToString() + ":" + Math.Abs(ts.Minutes).ToString("00");
                                            string valueM = Math.Abs((int)ts.TotalMinutes).ToString() + "";

                                            string valueHMSFNP = ts.TotalSeconds < 0 ? "0:00:00" : valueHMS;
                                            string valueHMFNP = ts.TotalSeconds < 0 ? "0:00:00" : valueHM;

                                            model = model.Replace(sPreTag_ColumnName + "_HMSFN" + sPostTag, signFN + valueHMS);
                                            model = model.Replace(sPreTag_ColumnName + "_HMSFNP" + sPostTag, valueHMSFNP);
                                            model = model.Replace(sPreTag_ColumnName + "_HMFN" + sPostTag, signFN + valueHM);
                                            model = model.Replace(sPreTag_ColumnName + "_HMFNP" + sPostTag, valueHMFNP);
                                            model = model.Replace(sPreTag_ColumnName + "_MFN" + sPostTag, signFN + valueM);
                                            model = model.Replace(sPreTag_ColumnName + "_HMSTN" + sPostTag, signTN + valueHMS);
                                            model = model.Replace(sPreTag_ColumnName + "_HMTN" + sPostTag, signTN + valueHM);
                                            model = model.Replace(sPreTag_ColumnName + "_MTN" + sPostTag, signTN + valueM);
                                        }
                                    }
                                    else
                                    {
                                        model = model.Replace(sPreTag_ColumnName + sPostTag, "");
                                        model = model.Replace(sPreTag_ColumnName + "_YEAR" + sPostTag, "");
                                        model = model.Replace(sPreTag_ColumnName + "_MONTH" + sPostTag, "");
                                        model = model.Replace(sPreTag_ColumnName + "_DAY" + sPostTag, "");
                                        model = model.Replace(sPreTag_ColumnName + "_SHORTDATE" + sPostTag, "");
                                        model = model.Replace(sPreTag_ColumnName + "_SHORTTIME" + sPostTag, "");
                                        model = model.Replace(sPreTag_ColumnName + "_HMSFN" + sPostTag, "");
                                        model = model.Replace(sPreTag_ColumnName + "_HMSFNP" + sPostTag, "");
                                        model = model.Replace(sPreTag_ColumnName + "_HMFN" + sPostTag, "");
                                        model = model.Replace(sPreTag_ColumnName + "_HMFNP" + sPostTag, "");
                                        model = model.Replace(sPreTag_ColumnName + "_HMSTN" + sPostTag, "");
                                        model = model.Replace(sPreTag_ColumnName + "_HMTN" + sPostTag, "");
                                        model = model.Replace(sPreTag_ColumnName + "_MTN" + sPostTag, "");
                                        model = model.Replace(sPreTag_ColumnName + "_MFN" + sPostTag, "");
                                    }
                                }

                            if (value is System.Double || value is System.Single)
                            {
                                TimeSpan ts = TimeSpan.FromMinutes((double)value);
                                string valueHMS = (ts.TotalSeconds < 0 ? "-" : "") + Math.Abs(((int)(ts.TotalHours))).ToString() + ":" +
                                                            Math.Abs(ts.Minutes).ToString("00") + ":" +
                                                            Math.Abs(ts.Seconds).ToString("00");
                                string valueHMSF = valueHMS + "." + Math.Abs(ts.Milliseconds).ToString("000");
                                string valueHM = (ts.TotalSeconds < 0 ? "-" : "") + Math.Abs(((int)(ts.TotalHours))).ToString() + ":" +
                                                Math.Abs(ts.Minutes).ToString("00");
                                string valueTotalHours = (ts.TotalSeconds < 0 ? "-" : "") + Math.Abs(((ts.TotalHours))).ToString("0.0000");
                                string countPerHour = "";
                                if ((double)value == 0)
                                    countPerHour = "0";
                                else
                                    countPerHour = (60d / (double)value).ToString("0.00");
                                model = model.Replace(sPreTag_ColumnName + "_HMS" + sPostTag, valueHMS);
                                model = model.Replace(sPreTag_ColumnName + "_HM" + sPostTag, valueHM);
                                model = model.Replace(sPreTag_ColumnName + "_HMSF" + sPostTag, valueHMSF);
                                model = model.Replace(sPreTag_ColumnName + "_INVARIANT" + sPostTag, Math.Round(((double)value), 2).ToString(System.Globalization.CultureInfo.InvariantCulture));
                                model = model.Replace(sPreTag_ColumnName + "_INT" + sPostTag, ((int)(double)value).ToString());
                                model = model.Replace(sPreTag_ColumnName + "_1DIGIT" + sPostTag, Math.Round((double)value, 1).ToString());
                                model = model.Replace(sPreTag_ColumnName + "_2DIGIT" + sPostTag, Math.Round((double)value, 2).ToString());
                                model = model.Replace(sPreTag_ColumnName + "_3DIGIT" + sPostTag, Math.Round((double)value, 3).ToString());
                                model = model.Replace(sPreTag_ColumnName + "_TOTALHOURS" + sPostTag, valueTotalHours);
                                model = model.Replace(sPreTag_ColumnName + "_TOTALSECONDS" + sPostTag, ts.TotalSeconds.ToString());
                                model = model.Replace(sPreTag_ColumnName + "_COUNTPERHOUR" + sPostTag, countPerHour);
                                model = model.Replace(sPreTag_ColumnName + "_SEP" + sPostTag, String.Format("{0:#,##0.##}", ((double)value)));
                                model = model.Replace(sPreTag_ColumnName + "_1DIGIT_SEP" + sPostTag, String.Format("{0:#,##0.##}", Math.Round((double)value, 1)));
                                model = model.Replace(sPreTag_ColumnName + "_2DIGIT_SEP" + sPostTag, String.Format("{0:#,##0.##}", Math.Round((double)value, 2)));
                                model = model.Replace(sPreTag_ColumnName + "_3DIGIT_SEP" + sPostTag, String.Format("{0:#,##0.##}", Math.Round((double)value, 3)));
                                model = model.Replace(sPreTag_ColumnName + sPostTag, ((double)value).ToString());
                            }

                            if (value is System.Int16 || value is System.Int32 || value is System.Int64 || value is string)
                            {
                                string sValue = value.ToString();//OneCodeTODO: separare migliaia con .ToString('#'##0')

                                for (int iCount = 1; iCount < 50; iCount++)
                                {
                                    string sPreTag_ColumnName_Count = sPreTag_ColumnName + "_" + iCount.ToString();

                                    //for (int iCountToStart = 0; iCountToStart < 50; iCountToStart++)
                                    //{//per stringhe senza spazi
                                    //    if (model.Contains(sPreTag_ColumnName_Count + "_DA" + iCountToStart))
                                    //    {
                                    //        model = model.Replace(sPreTag_ColumnName_Count + "_DA" + iCountToStart, sValue.Substring(iCountToStart, iCount));
                                    //    }
                                    //}

                                    if (model.Contains(sPreTag_ColumnName_Count))
                                    {
                                        string tag = "";
                                        string valueTmp = sValue;
                                        if (valueTmp.Length > iCount) valueTmp = valueTmp.Substring(0, iCount);

                                        tag = sPreTag_ColumnName_Count + sPostTag;
                                        if (model.Contains(tag)) model = model.Replace(tag, valueTmp);
                                        tag = sPreTag_ColumnName_Count + "_UC" + sPostTag;
                                        if (model.Contains(tag)) model = model.Replace(tag, valueTmp.ToUpper());

                                        tag = sPreTag_ColumnName_Count + "_R1" + sPostTag;
                                        if (model.Contains(tag))
                                        {
                                            string[] righe = Zero5.Util.StringTools.SplitTextOnCharCount(sValue, iCount).ToString().Split('\n');
                                            if (righe.Length > 0) valueTmp = righe[0]; else valueTmp = "";
                                            model = model.Replace(tag, valueTmp);

                                            tag = sPreTag_ColumnName_Count + "_R2" + sPostTag;
                                            if (righe.Length > 1) valueTmp = righe[1]; else valueTmp = "";
                                            if (model.Contains(tag)) model = model.Replace(tag, valueTmp);

                                            tag = sPreTag_ColumnName_Count + "_R3" + sPostTag;
                                            if (righe.Length > 2) valueTmp = righe[2]; else valueTmp = "";
                                            if (model.Contains(tag)) model = model.Replace(tag, valueTmp);

                                            tag = sPreTag_ColumnName_Count + "_R4" + sPostTag;
                                            if (righe.Length > 3) valueTmp = righe[3]; else valueTmp = "";
                                            if (model.Contains(tag)) model = model.Replace(tag, valueTmp);
                                        }

                                        tag = sPreTag_ColumnName_Count + "_R1_UC" + sPostTag;
                                        if (model.Contains(tag))
                                        {
                                            string[] righe = Zero5.Util.StringTools.SplitTextOnCharCount(sValue.ToUpper(), iCount).ToString().Split('\n');
                                            if (righe.Length > 0) valueTmp = righe[0]; else valueTmp = "";
                                            model = model.Replace(tag, valueTmp);

                                            tag = sPreTag_ColumnName_Count + "_R2_UC" + sPostTag;
                                            if (righe.Length > 1) valueTmp = righe[1]; else valueTmp = "";
                                            if (model.Contains(tag)) model = model.Replace(tag, valueTmp);

                                            tag = sPreTag_ColumnName_Count + "_R3_UC" + sPostTag;
                                            if (righe.Length > 2) valueTmp = righe[2]; else valueTmp = "";
                                            if (model.Contains(tag)) model = model.Replace(tag, valueTmp);

                                            tag = sPreTag_ColumnName_Count + "_R4_UC" + sPostTag;
                                            if (righe.Length > 3) valueTmp = righe[3]; else valueTmp = "";
                                            if (model.Contains(tag)) model = model.Replace(tag, valueTmp);
                                        }


                                    }
                                }

                                bool replaced = false;
                                if (model.Contains(sPreTag_ColumnName + "_"))
                                {
                                    System.Text.RegularExpressions.Regex regex =
                                        new System.Text.RegularExpressions.Regex(sPreTag_ColumnName.Replace("$", "\\$") + "_[0-9]+_[0-9]+" + sPostTag.Replace("$", "\\$"));

                                    for (int j = 0; j < 10; j++)
                                    {
                                        System.Text.RegularExpressions.Match match = regex.Match(model);
                                        if (match.Success)
                                        {
#if !MOBILE
                                            string[] param = (match.Value.Replace(sPreTag_ColumnName, "").Replace(sPostTag, "")).Split(new char[] { '_' }, StringSplitOptions.RemoveEmptyEntries);
#else
                                        string[] param = (match.Value.Replace(sPreTag_ColumnName, "").Replace(sPostTag, "")).Split(new char[] { '_' });
#endif

                                            if (param.Length == 2)
                                            {
                                                int start = 0;
                                                int length = 0;
                                                if (System.intTryParse.TryParse(param[0], out start)
                                                    && System.intTryParse.TryParse(param[1], out length))
                                                {
                                                    if (sValue.Length > start)
                                                    {
                                                        if (length > 0 && sValue.Length >= start + length)
                                                        {
                                                            model = model.Replace(match.Value, sValue.Substring(start, length));
                                                            replaced = true;
                                                        }
                                                        else
                                                        {
                                                            model = model.Replace(match.Value, sValue.Substring(start));
                                                            replaced = true;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if (!replaced)
                                            break;
                                    }
                                }

                                model = model.Replace(sPreTag_ColumnName + sPostTag, sValue);
                                model = model.Replace(sPreTag_ColumnName + "_NL" + sPostTag, sValue + (sValue.Length > 0 ? Environment.NewLine : ""));
                                model = model.Replace(sPreTag_ColumnName + "_UC" + sPostTag, sValue.ToUpper());
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex.Message);
            }
            return model;
        }
    }
}
// file ...\Data\Util\DBMySQL.cs
#if !MOBILE && !CORE

namespace Zero5.Data.Util
{
    #if DB_MYSQL
    class DBMySQL
    {
        public static System.Data.DataSet LoadDataSet(string connectionString, string selectQuery)
        {
            MySql.Data.MySqlClient.MySqlConnection conn = new MySql.Data.MySqlClient.MySqlConnection();

            conn.ConnectionString = connectionString;

            System.Data.DataSet ds = new System.Data.DataSet();

            conn.Open();

            MySql.Data.MySqlClient.MySqlDataAdapter adp = new MySql.Data.MySqlClient.MySqlDataAdapter(selectQuery, conn);

            adp.SelectCommand.CommandTimeout = 60;

            adp.Fill(ds);

            conn.Close();

            return ds;
        }

        public static void ExecuteNonQuery(MySql.Data.MySqlClient.MySqlConnection sqlCon, List<MySql.Data.MySqlClient.MySqlCommand> listSQLCommand)
        {
            if (sqlCon.State != System.Data.ConnectionState.Open) sqlCon.Open();
            MySql.Data.MySqlClient.MySqlTransaction sqlTrans = sqlCon.BeginTransaction();
            try
            {
                foreach (MySql.Data.MySqlClient.MySqlCommand cmd in listSQLCommand)
                {
                    cmd.Transaction = sqlTrans;                    
                    cmd.ExecuteNonQuery();
                }
                sqlTrans.Commit();
            }
            catch (Exception exErr)
            {
                sqlTrans.Rollback();
                throw exErr;
            }
        }
    }
    #endif
}
#endif
// file ...\Data\Util\DBODBC.cs
#if !CORE

namespace Zero5.Data.Util
{
    class DBODBC
    {
#if !MOBILE && !CORE
        public static System.Data.DataSet LoadDataSet(string connectionString, string selectQuery)
        {
            System.Data.Odbc.OdbcConnection conn = new System.Data.Odbc.OdbcConnection();

            conn.ConnectionString = connectionString;

            System.Data.DataSet ds = new System.Data.DataSet();

            conn.Open();

            System.Data.Odbc.OdbcDataAdapter adp = new System.Data.Odbc.OdbcDataAdapter(selectQuery, conn);

            adp.SelectCommand.CommandTimeout = 60;

            adp.Fill(ds);

            conn.Close();

            return ds;
        }


        public static void ExecuteNonQuery(System.Data.Odbc.OdbcConnection sqlCon, List <System.Data.Odbc.OdbcCommand> listSQLCommand)
        {
            if (sqlCon.State != System.Data.ConnectionState.Open) sqlCon.Open();
            System.Data.Odbc.OdbcTransaction sqlTrans = sqlCon.BeginTransaction();
            try
            {
                foreach (System.Data.Odbc.OdbcCommand cmd in listSQLCommand)
                {
                    cmd.Transaction = sqlTrans;                    
                    cmd.ExecuteNonQuery();
                }
                sqlTrans.Commit();
            }
            catch (Exception exErr)
            {
                sqlTrans.Rollback();
                throw exErr;
            }
        }
#endif
    }
}
#endif
// file ...\Data\Util\DBOLEDB.cs
#if !CORE

namespace Zero5.Data.Util
{
    class DBOLEDB
    {
#if !MOBILE && !CORE
        public static System.Data.DataSet LoadDataSet(string connectionString, string selectQuery)
        {
            System.Data.OleDb.OleDbConnection conn = new System.Data.OleDb.OleDbConnection();

            conn.ConnectionString = connectionString;

            System.Data.DataSet ds = new System.Data.DataSet();

            conn.Open();

            System.Data.OleDb.OleDbDataAdapter adp = new System.Data.OleDb.OleDbDataAdapter(selectQuery, conn);

            adp.SelectCommand.CommandTimeout = 60;

            adp.Fill(ds);

            conn.Close();

            return ds;
        }


        public static void ExecuteNonQuery(System.Data.OleDb.OleDbConnection sqlCon, List <System.Data.OleDb.OleDbCommand> listSQLCommand)
        {
            if (sqlCon.State != System.Data.ConnectionState.Open) sqlCon.Open();
            System.Data.OleDb.OleDbTransaction sqlTrans = sqlCon.BeginTransaction();
            try
            {
                foreach (System.Data.OleDb.OleDbCommand cmd in listSQLCommand)
                {
                    cmd.Transaction = sqlTrans;                    
                    cmd.ExecuteNonQuery();
                }
                sqlTrans.Commit();
            }
            catch (Exception exErr)
            {
                sqlTrans.Rollback();
                throw exErr;
            }
        }
#endif
    }
}
#endif
// file ...\Data\Util\DBOracle.cs

namespace Zero5.Data.Util
{
    #if DB_ORACLE
    class DBOracle
    {
        public static System.Data.DataSet LoadDataSet(string datasource, string userID, string password, string selectQuery, bool safeMapping)
        {
            return LoadDataSet("Data Source=" + datasource + ";User Id=" + userID + ";Password=" + password + ";", selectQuery, safeMapping);
        }

        public static System.Data.DataSet LoadDataSet(string connectionString, string selectQuery, bool safeMapping)
        {
            Oracle.DataAccess.Client.OracleConnection conn = new Oracle.DataAccess.Client.OracleConnection();

            conn.ConnectionString = connectionString;

            System.Data.DataSet ds = new System.Data.DataSet();

            conn.Open();

            Oracle.DataAccess.Client.OracleDataAdapter adp = new Oracle.DataAccess.Client.OracleDataAdapter(selectQuery, conn);

            if (safeMapping) adp.SafeMapping.Add("*", typeof(string));
            adp.Fill(ds);

            conn.Close();

            return ds;
        }
    }
    #endif
}
// file ...\Data\Util\DBOracleManaged.cs

namespace Zero5.Data.Util
{
#if DB_ORACLE_MANAGED
    class DBOracleManaged
    {
        public static System.Data.DataSet LoadDataSet(string connectionString, string selectQuery)
        {
            Oracle.ManagedDataAccess.Client.OracleConnection connOracle = new Oracle.ManagedDataAccess.Client.OracleConnection();
            connOracle.ConnectionString = connectionString;
            System.Data.DataSet ds = new System.Data.DataSet();
            Oracle.ManagedDataAccess.Client.OracleCommand cmd = new Oracle.ManagedDataAccess.Client.OracleCommand();
            cmd.Connection = (Oracle.ManagedDataAccess.Client.OracleConnection)connOracle;
            connOracle.Open();
            Oracle.ManagedDataAccess.Client.OracleDataAdapter adpOracle = new Oracle.ManagedDataAccess.Client.OracleDataAdapter(selectQuery, connOracle);
            adpOracle.Fill(ds);
            connOracle.Close();

            return ds;
        }
    }
#endif
}
// file ...\Data\Util\DBSQLServer.cs
#if !CORE
#if !MOBILE && !CORE

namespace Zero5.Data.Util
{
    public class DBSQLServer
    {
        public static System.Data.DataSet LoadDataSet(string connectionString, string selectQuery)
        {
            System.Data.SqlClient.SqlConnection conn = new System.Data.SqlClient.SqlConnection();

            conn.ConnectionString = connectionString;

            System.Data.DataSet ds = new System.Data.DataSet();

            conn.Open();

            System.Data.SqlClient.SqlDataAdapter adp = new System.Data.SqlClient.SqlDataAdapter(selectQuery, conn);

            adp.SelectCommand.CommandTimeout = 60;

            adp.Fill(ds);

            conn.Close();

            return ds;
        }

        public static void ExecuteNonQuery(System.Data.SqlClient.SqlConnection sqlCon, List <System.Data.SqlClient.SqlCommand> listSQLCommand)
        {
            if (sqlCon.State != System.Data.ConnectionState.Open) sqlCon.Open();
            System.Data.SqlClient.SqlTransaction sqlTrans = sqlCon.BeginTransaction("Insert");
            try
            {
                foreach (System.Data.SqlClient.SqlCommand cmd in listSQLCommand)
                {
                    cmd.Transaction = sqlTrans;                    
                    cmd.ExecuteNonQuery();
                }
                sqlTrans.Commit();
            }
            catch (Exception exErr)
            {
                sqlTrans.Rollback();
                throw exErr;
            }
        }
    }
}
#endif
#endif
// file ...\Encryption\Asymmetric.cs
#if !MOBILE && !CORE

namespace Zero5.Encryption
{
    /// <summary>
    ///  Asymmetric encryption uses a pair of keys to encrypt and decrypt.
    ///  There is a "public" key which is used to encrypt. Decrypting, on the other hand, 
    ///  requires both the "public" key and an additional "private" key. The advantage is 
    ///  that people can send you encrypted messages without being able to decrypt them.
    ///  </summary>
    /// <remarks>
    ///  The only provider supported is the <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" />
    /// </remarks>
    public class Asymmetric
    {
        public class PublicKey
        {
            public string Modulus;
            public string Exponent;
            public PublicKey()
            {
            }
            public PublicKey(string KeyXml)
            {
                this.LoadFromXml(KeyXml);
            }
            /// <summary>
            ///  Writes the *.config file representation of this public key to a file
            ///  </summary>
            public void LoadFromXml(string keyXml)
            {
                this.Modulus = Utils.GetXmlElement(keyXml, "Modulus");
                this.Exponent = Utils.GetXmlElement(keyXml, "Exponent");
            }
            /// <summary>
            ///  Converts this public key to an RSAParameters object
            ///  </summary>
            public RSAParameters ToParameters()
            {
                return new RSAParameters
                {
                    Modulus = Convert.FromBase64String(this.Modulus),
                    Exponent = Convert.FromBase64String(this.Exponent)
                };
            }
            public string ToXml()
            {
                StringBuilder sb = new StringBuilder();
                StringBuilder stringBuilder = sb;
                stringBuilder.Append(Utils.WriteXmlNode("RSAKeyValue", false));
                stringBuilder.Append(Utils.WriteXmlElement("Modulus", this.Modulus));
                stringBuilder.Append(Utils.WriteXmlElement("Exponent", this.Exponent));
                stringBuilder.Append(Utils.WriteXmlNode("RSAKeyValue", true));
                return sb.ToString();
            }
            /// <summary>
            ///  Writes the Xml representation of this public key to a file
            ///  </summary>
            public void ExportToXmlFile(string filePath)
            {
                StreamWriter sw = new StreamWriter(filePath, false);
                sw.Write(this.ToXml());
                sw.Close();
            }
        }
        public class PrivateKey
        {
            public string Modulus;
            public string Exponent;
            public string PrimeP;
            public string PrimeQ;
            public string PrimeExponentP;
            public string PrimeExponentQ;
            public string Coefficient;
            public string PrivateExponent;
            public PrivateKey()
            {
            }
            public PrivateKey(string keyXml)
            {
                this.LoadFromXml(keyXml);
            }
            public RSAParameters ToParameters()
            {
                return new RSAParameters
                {
                    Modulus = Convert.FromBase64String(this.Modulus),
                    Exponent = Convert.FromBase64String(this.Exponent),
                    P = Convert.FromBase64String(this.PrimeP),
                    Q = Convert.FromBase64String(this.PrimeQ),
                    DP = Convert.FromBase64String(this.PrimeExponentP),
                    DQ = Convert.FromBase64String(this.PrimeExponentQ),
                    InverseQ = Convert.FromBase64String(this.Coefficient),
                    D = Convert.FromBase64String(this.PrivateExponent)
                };
            }
            /// <summary>
            ///  Loads the private key from its XML string
            ///  </summary>
            public void LoadFromXml(string keyXml)
            {
                this.Modulus = Utils.GetXmlElement(keyXml, "Modulus");
                this.Exponent = Utils.GetXmlElement(keyXml, "Exponent");
                this.PrimeP = Utils.GetXmlElement(keyXml, "P");
                this.PrimeQ = Utils.GetXmlElement(keyXml, "Q");
                this.PrimeExponentP = Utils.GetXmlElement(keyXml, "DP");
                this.PrimeExponentQ = Utils.GetXmlElement(keyXml, "DQ");
                this.Coefficient = Utils.GetXmlElement(keyXml, "InverseQ");
                this.PrivateExponent = Utils.GetXmlElement(keyXml, "D");
            }
            public string ToXml()
            {
                StringBuilder sb = new StringBuilder();
                StringBuilder stringBuilder = sb;
                stringBuilder.Append(Utils.WriteXmlNode("RSAKeyValue", false));
                stringBuilder.Append(Utils.WriteXmlElement("Modulus", this.Modulus));
                stringBuilder.Append(Utils.WriteXmlElement("Exponent", this.Exponent));
                stringBuilder.Append(Utils.WriteXmlElement("P", this.PrimeP));
                stringBuilder.Append(Utils.WriteXmlElement("Q", this.PrimeQ));
                stringBuilder.Append(Utils.WriteXmlElement("DP", this.PrimeExponentP));
                stringBuilder.Append(Utils.WriteXmlElement("DQ", this.PrimeExponentQ));
                stringBuilder.Append(Utils.WriteXmlElement("InverseQ", this.Coefficient));
                stringBuilder.Append(Utils.WriteXmlElement("D", this.PrivateExponent));
                stringBuilder.Append(Utils.WriteXmlNode("RSAKeyValue", true));
                return sb.ToString();
            }
            /// <summary>
            ///  Writes the Xml representation of this private key to a file
            ///  </summary>
            public void ExportToXmlFile(string filePath)
            {
                StreamWriter sw = new StreamWriter(filePath, false);
                sw.Write(this.ToXml());
                sw.Close();
            }
        }
        private RSACryptoServiceProvider _rsa;
        private string _KeyContainerName;
        private bool _UseMachineKeystore;
        private int _KeySize;
        private const string _ElementParent = "RSAKeyValue";
        private const string _ElementModulus = "Modulus";
        private const string _ElementExponent = "Exponent";
        private const string _ElementPrimeP = "P";
        private const string _ElementPrimeQ = "Q";
        private const string _ElementPrimeExponentP = "DP";
        private const string _ElementPrimeExponentQ = "DQ";
        private const string _ElementCoefficient = "InverseQ";
        private const string _ElementPrivateExponent = "D";
        private const string _KeyModulus = "PublicKey.Modulus";
        private const string _KeyExponent = "PublicKey.Exponent";
        private const string _KeyPrimeP = "PrivateKey.P";
        private const string _KeyPrimeQ = "PrivateKey.Q";
        private const string _KeyPrimeExponentP = "PrivateKey.DP";
        private const string _KeyPrimeExponentQ = "PrivateKey.DQ";
        private const string _KeyCoefficient = "PrivateKey.InverseQ";
        private const string _KeyPrivateExponent = "PrivateKey.D";
        /// <summary>
        ///  Sets the name of the key container used to store this key on disk; this is an 
        ///  unavoidable side effect of the underlying Microsoft CryptoAPI. 
        ///  </summary>
        /// <remarks>
        ///  http://support.microsoft.com/default.aspx?scid=http://support.microsoft.com:80/support/kb/articles/q322/3/71.asp&amp;NoWebContent=1
        ///  </remarks>
        public string KeyContainerName
        {
            get
            {
                return this._KeyContainerName;
            }
            set
            {
                this._KeyContainerName = value;
            }
        }
        public int KeySizeBits
        {
            get
            {
                return this._rsa.KeySize;
            }
        }
        /// <summary>
        ///  Returns the maximum supported key size, in bits
        ///  </summary>
        public int KeySizeMaxBits
        {
            get
            {
                return this._rsa.LegalKeySizes[0].MaxSize;
            }
        }
        public int KeySizeMinBits
        {
            get
            {
                return this._rsa.LegalKeySizes[0].MinSize;
            }
        }
        /// <summary>
        ///  Returns valid key step sizes, in bits
        ///  </summary>
        public int KeySizeStepBits
        {
            get
            {
                return this._rsa.LegalKeySizes[0].SkipSize;
            }
        }
        /// <summary>
        ///  Instantiates a new asymmetric encryption session using the default key size; 
        ///  this is usally 1024 bits
        ///  </summary>
        public Asymmetric()
        {
            this._KeyContainerName = "Encryption.AsymmetricEncryption.Zero5";
            this._UseMachineKeystore = true;
            this._KeySize = 1024;
            this._rsa = this.GetRSAProvider();
        }
        public Asymmetric(int keySize)
        {
            this._KeyContainerName = "Encryption.AsymmetricEncryption.Zero5";
            this._UseMachineKeystore = true;
            this._KeySize = 1024;
            this._KeySize = keySize;
            this._rsa = this.GetRSAProvider();
        }
        public void GenerateNewKeyset(ref Asymmetric.PublicKey publicKey, ref Asymmetric.PrivateKey privateKey)
        {
            string PublicKeyXML = null;
            string PrivateKeyXML = null;
            this.GenerateNewKeyset(ref PublicKeyXML, ref PrivateKeyXML);
            publicKey = new Asymmetric.PublicKey(PublicKeyXML);
            privateKey = new Asymmetric.PrivateKey(PrivateKeyXML);
        }
        /// <summary>
        ///  Generates a new public/private key pair as XML strings
        ///  </summary>
        public void GenerateNewKeyset(ref string publicKeyXML, ref string privateKeyXML)
        {
            RSA rsa = RSA.Create();
            publicKeyXML = rsa.ToXmlString(false);
            privateKeyXML = rsa.ToXmlString(true);
        }
        /// <summary>
        ///  Encrypts data using the provided public key
        ///  </summary>
        public Data Encrypt(Data d, Asymmetric.PublicKey publicKey)
        {
            this._rsa.ImportParameters(publicKey.ToParameters());
            return this.EncryptPrivate(d);
        }
        public Data Encrypt(Data d, string publicKeyXML)
        {
            this.LoadKeyXml(publicKeyXML, false);
            return this.EncryptPrivate(d);
        }
        private Data EncryptPrivate(Data d)
        {
            Data EncryptPrivate;
            try
            {
                EncryptPrivate = new Data(this._rsa.Encrypt(d.Bytes, false));
            }
            catch (CryptographicException ex)
            {
                throw new CryptographicException("Your data is too large; RSA encryption is designed to encrypt relatively small amounts of data. The exact byte limit depends on the key size. To encrypt more data, use symmetric encryption and then encrypt that symmetric key with asymmetric RSA encryption.", ex);
            }
            return EncryptPrivate;
        }
        /// <summary>
        ///  Decrypts data using the default private key
        ///  </summary>
        public Data Decrypt(Data encryptedData, Asymmetric.PrivateKey PrivateKey)
        {
            this._rsa.ImportParameters(PrivateKey.ToParameters());
            return this.DecryptPrivate(encryptedData);
        }
        /// <summary>
        ///  Decrypts data using the provided private key as XML
        ///  </summary>
        public Data Decrypt(Data encryptedData, string PrivateKeyXML)
        {
            this.LoadKeyXml(PrivateKeyXML, true);
            return this.DecryptPrivate(encryptedData);
        }
        private void LoadKeyXml(string keyXml, bool isPrivate)
        {
            try
            {
                this._rsa.FromXmlString(keyXml);
            }
            catch (XmlSyntaxException ex)
            {
                string s;
                if (isPrivate)
                {
                    s = "private";
                }
                else
                {
                    s = "public";
                }
                throw new XmlSyntaxException(string.Format("The provided {0} encryption key XML does not appear to be valid.", s), ex);
            }
        }
        private Data DecryptPrivate(Data encryptedData)
        {
            return new Data(this._rsa.Decrypt(encryptedData.Bytes, false));
        }
        private RSACryptoServiceProvider GetRSAProvider()
        {
            RSACryptoServiceProvider rsa = null;
            CspParameters csp = null;
            RSACryptoServiceProvider GetRSAProvider;
            try // with standard container name
            {
                csp = new CspParameters();
                csp.KeyContainerName = this._KeyContainerName;
                rsa = new RSACryptoServiceProvider(this._KeySize, csp);
                rsa.PersistKeyInCsp = false;
                RSACryptoServiceProvider.UseMachineKeyStore = true;
                GetRSAProvider = rsa;
            }
            catch (CryptographicException exStandard)
            {
                try // with random container name
                {
                    csp = new CspParameters();
                    csp.KeyContainerName = Guid.NewGuid().ToString().ToUpperInvariant();
                    rsa = new RSACryptoServiceProvider(this._KeySize, csp);
                    rsa.PersistKeyInCsp = false;
                    RSACryptoServiceProvider.UseMachineKeyStore = true;
                    GetRSAProvider = rsa;
                }
                catch (CryptographicException exRandom)
                {
                    throw new Exception("Unable to obtain Cryptographic Service Provider. Either the permissions are incorrect on the 'C:\\Documents and Settings\\All Users\\Application Data\\Microsoft\\Crypto\\RSA\\MachineKeys' folder, or the current security context '" + WindowsIdentity.GetCurrent().Name + "' does not have access to this folder.", exRandom);
                }
            }
            finally
            {
                bool flag = rsa != null;
                if (flag)
                {
                    rsa = null;
                }
                flag = (csp != null);
                if (flag)
                {
                    csp = null;
                }
            }
            return GetRSAProvider;
        }
    }
}
#endif
// file ...\Encryption\Data.cs

namespace Zero5.Encryption
{
    public class Data
    {
        private byte[] _b;
        private int _MaxBytes;
        private int _MinBytes;
        private int _StepBytes;
        public static Encoding DefaultEncoding = Encoding.GetEncoding("Windows-1252");
        /// <summary>
        ///  Determines the default text encoding for this Data instance
        ///  </summary>
        public Encoding Encoding;
        public bool IsEmpty
        {
            get
            {
                bool flag = this._b == null;
                bool IsEmpty;
                if (flag)
                {
                    IsEmpty = true;
                }
                else
                {
                    flag = (this._b.Length == 0);
                    IsEmpty = flag;
                }
                return IsEmpty;
            }
        }
        /// <summary>
        ///  allowed step interval, in bytes, for this data; if 0, no limit
        ///  </summary>
        public int StepBytes
        {
            get
            {
                return this._StepBytes;
            }
            set
            {
                this._StepBytes = value;
            }
        }
        public int StepBits
        {
            get
            {
                return checked(this._StepBytes * 8);
            }
            set
            {
                this._StepBytes = value / 8;
            }
        }
        /// <summary>
        ///  minimum number of bytes allowed for this data; if 0, no limit
        ///  </summary>
        public int MinBytes
        {
            get
            {
                return this._MinBytes;
            }
            set
            {
                this._MinBytes = value;
            }
        }
        public int MinBits
        {
            get
            {
                return checked(this._MinBytes * 8);
            }
            set
            {
                this._MinBytes = value / 8;
            }
        }
        /// <summary>
        ///  maximum number of bytes allowed for this data; if 0, no limit
        ///  </summary>
        public int MaxBytes
        {
            get
            {
                return this._MaxBytes;
            }
            set
            {
                this._MaxBytes = value;
            }
        }
        public int MaxBits
        {
            get
            {
                return checked(this._MaxBytes * 8);
            }
            set
            {
                this._MaxBytes = value / 8;
            }
        }
        /// <summary>
        ///  Returns the byte representation of the data; 
        ///  This will be padded to MinBytes and trimmed to MaxBytes as necessary!
        ///  </summary>
        public byte[] Bytes
        {
            get
            {
                bool flag = this._MaxBytes > 0;
                checked
                {
                    bool flag2;
                    if (flag)
                    {
                        flag2 = (this._b.Length > this._MaxBytes);
                        if (flag2)
                        {
                            byte[] b = new byte[this._MaxBytes - 1 + 1];
                            Array.Copy(this._b, b, b.Length);
                            this._b = b;
                        }
                    }
                    flag2 = (this._MinBytes > 0);
                    if (flag2)
                    {
                        flag = (this._b.Length < this._MinBytes);
                        if (flag)
                        {
                            byte[] b2 = new byte[this._MinBytes - 1 + 1];
                            Array.Copy(this._b, b2, this._b.Length);
                            this._b = b2;
                        }
                    }
                    return this._b;
                }
            }
            set
            {
                this._b = value;
            }
        }
        public string Text
        {
            get
            {
                bool flag = this._b == null;
                string Text;
                if (flag)
                {
                    Text = "";
                }
                else
                {
                    int i = Array.IndexOf<byte>(this._b, 0);
                    flag = (i >= 0);
                    if (flag)
                    {
                        Text = this.Encoding.GetString(this._b, 0, i);
                    }
                    else
                    {
                        Text = this.Encoding.GetString(this._b, 0, this._b.Length);
                    }
                }
                return Text;
            }
            set
            {
                this._b = this.Encoding.GetBytes(value);
            }
        }
        /// <summary>
        ///  Sets or returns Hex string representation of this data
        ///  </summary>
        public string Hex
        {
            get
            {
                return Utils.ToHex(this._b);
            }
            set
            {
                this._b = Utils.FromHex(value);
            }
        }
        public string Base64
        {
            get
            {
                return Utils.ToBase64(this._b);
            }
            set
            {
                this._b = Utils.FromBase64(value);
            }
        }
        public Data()
        {
            this._MaxBytes = 0;
            this._MinBytes = 0;
            this._StepBytes = 0;
            this.Encoding = Data.DefaultEncoding;
        }
        /// <summary>
        ///  Creates new encryption data with the specified byte array
        ///  </summary>
        public Data(byte[] b)
        {
            this._MaxBytes = 0;
            this._MinBytes = 0;
            this._StepBytes = 0;
            this.Encoding = Data.DefaultEncoding;
            this._b = b;
        }
        public Data(string s)
        {
            this._MaxBytes = 0;
            this._MinBytes = 0;
            this._StepBytes = 0;
            this.Encoding = Data.DefaultEncoding;
            this.Text = s;
        }
        /// <summary>
        ///  Creates new encryption data using the specified string and the 
        ///  specified encoding to convert the string to a byte array.
        ///  </summary>
        public Data(string s, Encoding encoding)
        {
            this._MaxBytes = 0;
            this._MinBytes = 0;
            this._StepBytes = 0;
            this.Encoding = Data.DefaultEncoding;
            this.Encoding = encoding;
            this.Text = s;
        }
        /// <summary>
        ///  Returns text representation of bytes using the default text encoding
        ///  </summary>
        public new string ToString()
        {
            return this.Text;
        }
        public string ToBase64()
        {
            return this.Base64;
        }
        /// <summary>
        ///  returns Hex string representation of this data
        ///  </summary>
        public string ToHex()
        {
            return this.Hex;
        }
    }
}
// file ...\Encryption\Hash.cs

namespace Zero5.Encryption
{
    public class Hash
    {
        /// <summary>
        ///  Type of hash; some are security oriented, others are fast and simple
        ///  </summary>
        public enum Provider
        {
            /// <summary>
            ///  Cyclic Redundancy Check provider, 32-bit
            ///  </summary>
            CRC32,
            SHA1,
            /// <summary>
            ///  Secure Hashing Algorithm provider, SHA-2 variant, 256-bit
            ///  </summary>
            SHA256,
            SHA384,
            /// <summary>
            ///  Secure Hashing Algorithm provider, SHA-2 variant, 512-bit
            ///  </summary>
            SHA512,
            MD5
        }
        private class CRC32 : HashAlgorithm
        {
            private int result;
            private int[] crcLookup;
            public override byte[] Hash
            {
                get
                {
                    byte[] b = BitConverter.GetBytes(~this.result);
                    Array.Reverse(b);
                    return b;
                }
            }
            public CRC32()
            {
                this.result = -1;
                this.crcLookup = new int[]
				{
					0,
					1996959894,
					-301047508,
					-1727442502,
					124634137,
					1886057615,
					-379345611,
					-1637575261,
					249268274,
					2044508324,
					-522852066,
					-1747789432,
					162941995,
					2125561021,
					-407360249,
					-1866523247,
					498536548,
					1789927666,
					-205950648,
					-2067906082,
					450548861,
					1843258603,
					-187386543,
					-2083289657,
					325883990,
					1684777152,
					-43845254,
					-1973040660,
					335633487,
					1661365465,
					-99664541,
					-1928851979,
					997073096,
					1281953886,
					-715111964,
					-1570279054,
					1006888145,
					1258607687,
					-770865667,
					-1526024853,
					901097722,
					1119000684,
					-608450090,
					-1396901568,
					853044451,
					1172266101,
					-589951537,
					-1412350631,
					651767980,
					1373503546,
					-925412992,
					-1076862698,
					565507253,
					1454621731,
					-809855591,
					-1195530993,
					671266974,
					1594198024,
					-972236366,
					-1324619484,
					795835527,
					1483230225,
					-1050600021,
					-1234817731,
					1994146192,
					31158534,
					-1731059524,
					-271249366,
					1907459465,
					112637215,
					-1614814043,
					-390540237,
					2013776290,
					251722036,
					-1777751922,
					-519137256,
					2137656763,
					141376813,
					-1855689577,
					-429695999,
					1802195444,
					476864866,
					-2056965928,
					-228458418,
					1812370925,
					453092731,
					-2113342271,
					-183516073,
					1706088902,
					314042704,
					-1950435094,
					-54949764,
					1658658271,
					366619977,
					-1932296973,
					-69972891,
					1303535960,
					984961486,
					-1547960204,
					-725929758,
					1256170817,
					1037604311,
					-1529756563,
					-740887301,
					1131014506,
					879679996,
					-1385723834,
					-631195440,
					1141124467,
					855842277,
					-1442165665,
					-586318647,
					1342533948,
					654459306,
					-1106571248,
					-921952122,
					1466479909,
					544179635,
					-1184443383,
					-832445281,
					1591671054,
					702138776,
					-1328506846,
					-942167884,
					1504918807,
					783551873,
					-1212326853,
					-1061524307,
					-306674912,
					-1698712650,
					62317068,
					1957810842,
					-355121351,
					-1647151185,
					81470997,
					1943803523,
					-480048366,
					-1805370492,
					225274430,
					2053790376,
					-468791541,
					-1828061283,
					167816743,
					2097651377,
					-267414716,
					-2029476910,
					503444072,
					1762050814,
					-144550051,
					-2140837941,
					426522225,
					1852507879,
					-19653770,
					-1982649376,
					282753626,
					1742555852,
					-105259153,
					-1900089351,
					397917763,
					1622183637,
					-690576408,
					-1580100738,
					953729732,
					1340076626,
					-776247311,
					-1497606297,
					1068828381,
					1219638859,
					-670225446,
					-1358292148,
					906185462,
					1090812512,
					-547295293,
					-1469587627,
					829329135,
					1181335161,
					-882789492,
					-1134132454,
					628085408,
					1382605366,
					-871598187,
					-1156888829,
					570562233,
					1426400815,
					-977650754,
					-1296233688,
					733239954,
					1555261956,
					-1026031705,
					-1244606671,
					752459403,
					1541320221,
					-1687895376,
					-328994266,
					1969922972,
					40735498,
					-1677130071,
					-351390145,
					1913087877,
					83908371,
					-1782625662,
					-491226604,
					2075208622,
					213261112,
					-1831694693,
					-438977011,
					2094854071,
					198958881,
					-2032938284,
					-237706686,
					1759359992,
					534414190,
					-2118248755,
					-155638181,
					1873836001,
					414664567,
					-2012718362,
					-15766928,
					1711684554,
					285281116,
					-1889165569,
					-127750551,
					1634467795,
					376229701,
					-1609899400,
					-686959890,
					1308918612,
					956543938,
					-1486412191,
					-799009033,
					1231636301,
					1047427035,
					-1362007478,
					-640263460,
					1088359270,
					936918000,
					-1447252397,
					-558129467,
					1202900863,
					817233897,
					-1111625188,
					-893730166,
					1404277552,
					615818150,
					-1160759803,
					-841546093,
					1423857449,
					601450431,
					-1285129682,
					-1000256840,
					1567103746,
					711928724,
					-1274298825,
					-1022587231,
					1510334235,
					755167117
				};
            }
            protected override void HashCore(byte[] array, int ibStart, int cbSize)
            {
                checked
                {
                    int num = cbSize - 1;
                    int i = ibStart;
                    while (true)
                    {
                        int arg_56_0 = i;
                        int num2 = num;
                        if (arg_56_0 > num2)
                        {
                            break;
                        }
                        int lookup = (this.result & 255) ^ (int)array[i];
                        this.result = ((this.result & -256) / 256 & 16777215);
                        this.result ^= this.crcLookup[lookup];
                        i++;
                    }
                }
            }
            protected override byte[] HashFinal()
            {
                byte[] b = BitConverter.GetBytes(~this.result);
                Array.Reverse(b);
                return b;
            }
            public override void Initialize()
            {
                this.result = -1;
            }
        }
        private HashAlgorithm _Hash;
        private Data _HashValue;
        /// <summary>
        ///  Returns the previously calculated hash
        ///  </summary>
        public Data Value
        {
            get
            {
                return this._HashValue;
            }
        }
        private Hash()
        {
            this._HashValue = new Data();
        }
        public Hash(Hash.Provider p)
        {
            this._HashValue = new Data();
            switch (p)
            {
                case Hash.Provider.CRC32:
                    this._Hash = new Hash.CRC32();
                    break;
                case Hash.Provider.SHA1:
                    this._Hash = new SHA1Managed();
                    break;
#if !MOBILE && !CORE
                case Hash.Provider.SHA256:
                    this._Hash = new SHA256Managed();
                    break;
                case Hash.Provider.SHA384:
                    this._Hash = new SHA384Managed();
                    break;
                case Hash.Provider.SHA512:
                    this._Hash = new SHA512Managed();
                    break;
#endif
                case Hash.Provider.MD5:
                    this._Hash = new MD5CryptoServiceProvider();
                    break;
            }
        }
        public Data Calculate(ref Stream s)
        {
            this._HashValue.Bytes = this._Hash.ComputeHash(s);
            return this._HashValue;
        }
        /// <summary>
        ///  Calculates hash for fixed length <see cref="T:EncryptionClassLibrary.Encryption.Data" />
        /// </summary>
        public Data Calculate(Data d)
        {
            return this.CalculatePrivate(d.Bytes);
        }
        public Data Calculate(Data d, Data salt)
        {
            byte[] nb = new byte[checked(d.Bytes.Length + salt.Bytes.Length - 1 + 1)];
            salt.Bytes.CopyTo(nb, 0);
            d.Bytes.CopyTo(nb, salt.Bytes.Length);
            return this.CalculatePrivate(nb);
        }
        /// <summary>
        ///  Calculates hash for an array of bytes
        ///  </summary>
        private Data CalculatePrivate(byte[] b)
        {
            this._HashValue.Bytes = this._Hash.ComputeHash(b);
            return this._HashValue;
        }
    }
}
// file ...\Encryption\Simple.cs

namespace Zero5.Encryption
{
    public class Simple
    {
        public static string Encrypt(string input, string key24chars)
        {
            byte[] inputArray = UTF8Encoding.UTF8.GetBytes(input);
            System.Security.Cryptography.TripleDESCryptoServiceProvider tripleDES = new System.Security.Cryptography.TripleDESCryptoServiceProvider();
            tripleDES.Key = UTF8Encoding.UTF8.GetBytes(key24chars);
            tripleDES.Mode = System.Security.Cryptography.CipherMode.ECB;
            tripleDES.Padding = System.Security.Cryptography.PaddingMode.PKCS7;
            System.Security.Cryptography.ICryptoTransform cTransform = tripleDES.CreateEncryptor();
            byte[] resultArray = cTransform.TransformFinalBlock(inputArray, 0, inputArray.Length);
            tripleDES.Clear();
            return Convert.ToBase64String(resultArray, 0, resultArray.Length);
        }

        public static string Decrypt(string input, string key24chars)
        {
            byte[] inputArray = Convert.FromBase64String(input);
            System.Security.Cryptography.TripleDESCryptoServiceProvider tripleDES = new System.Security.Cryptography.TripleDESCryptoServiceProvider();
            tripleDES.Key = UTF8Encoding.UTF8.GetBytes(key24chars);
            tripleDES.Mode = System.Security.Cryptography.CipherMode.ECB;
            tripleDES.Padding = System.Security.Cryptography.PaddingMode.PKCS7;
            System.Security.Cryptography.ICryptoTransform cTransform = tripleDES.CreateDecryptor();
            byte[] resultArray = cTransform.TransformFinalBlock(inputArray, 0, inputArray.Length);
            tripleDES.Clear();
            return UTF8Encoding.UTF8.GetString(resultArray, 0, resultArray.Length);
        }
    }
}
// file ...\Encryption\Symmetric.cs

namespace Zero5.Encryption
{
    public class Symmetric
    {
        public enum Provider
        {
            /// <summary>
            ///  The Data Encryption Standard provider supports a 64 bit key only
            ///  </summary>
            DES,
            RC2,
            /// <summary>
            ///  The Rijndael (also known as AES) provider supports keys of 128, 192, or 256 bits with a default of 256 bits
            ///  </summary>
            Rijndael,
            TripleDES
        }
        private const string _DefaultIntializationVector = "%1Az=-@qT";
        private const int _BufferSize = 2048;
        //private Data _data;
        private Data _key;
        private Data _iv;
        private SymmetricAlgorithm _crypto;
        //private byte[] _EncryptedBytes;
        //private bool _UseDefaultInitializationVector;
        public int KeySizeBytes
        {
            get
            {
                return this._crypto.KeySize / 8;
            }
            set
            {
                this._crypto.KeySize = checked(value * 8);
                this._key.MaxBytes = value;
            }
        }
        /// <summary>
        ///  Key size in bits. We use the default key size for any given provider; if you 
        ///  want to force a specific key size, set this property
        ///  </summary>
        public int KeySizeBits
        {
            get
            {
                return this._crypto.KeySize;
            }
            set
            {
                this._crypto.KeySize = value;
                this._key.MaxBits = value;
            }
        }
        public Data Key
        {
            get
            {
                return this._key;
            }
            set
            {
                this._key = value;
                this._key.MaxBytes = this._crypto.LegalKeySizes[0].MaxSize / 8;
                this._key.MinBytes = this._crypto.LegalKeySizes[0].MinSize / 8;
                this._key.StepBytes = this._crypto.LegalKeySizes[0].SkipSize / 8;
            }
        }
        /// <summary>
        ///  Using the default Cipher Block Chaining (CBC) mode, all data blocks are processed using
        ///  the value derived from the previous block; the first data block has no previous data block
        ///  to use, so it needs an InitializationVector to feed the first block
        ///  </summary>
        public Data IntializationVector
        {
            get
            {
                return this._iv;
            }
            set
            {
                this._iv = value;
                this._iv.MaxBytes = this._crypto.BlockSize / 8;
                this._iv.MinBytes = this._crypto.BlockSize / 8;
            }
        }
        private Symmetric()
        {
        }
        /// <summary>
        ///  Instantiates a new symmetric encryption object using the specified provider.
        ///  </summary>

        public Symmetric(Symmetric.Provider provider)
            :this(provider, true)
        {
        }
        public Symmetric(Symmetric.Provider provider, bool useDefaultInitializationVector)
        {
            switch (provider)
            {
                case Symmetric.Provider.DES:
                    this._crypto = new DESCryptoServiceProvider();
                    break;
                case Symmetric.Provider.RC2:
                    this._crypto = new RC2CryptoServiceProvider();
                    break;
                case Symmetric.Provider.Rijndael:
                    this._crypto = new RijndaelManaged();
                    break;
                case Symmetric.Provider.TripleDES:
                    this._crypto = new TripleDESCryptoServiceProvider();
                    break;
            }
            this.Key = this.RandomKey();
            if (useDefaultInitializationVector)
            {
                this.IntializationVector = new Data("%1Az=-@qT");
            }
            else
            {
                this.IntializationVector = this.RandomInitializationVector();
            }
        }
        public Data RandomInitializationVector()
        {
            this._crypto.GenerateIV();
            return new Data(this._crypto.IV);
        }
        /// <summary>
        ///  generates a random Key, if one was not provided
        ///  </summary>
        public Data RandomKey()
        {
            this._crypto.GenerateKey();
            return new Data(this._crypto.Key);
        }
        private void ValidateKeyAndIv(bool isEncrypting)
        {
            bool isEmpty = this._key.IsEmpty;
            if (isEmpty)
            {
                if (!isEncrypting)
                {
                    throw new CryptographicException("No key was provided for the decryption operation!");
                }
                this._key = this.RandomKey();
            }
            bool isEmpty2 = this._iv.IsEmpty;
            if (isEmpty2)
            {
                if (!isEncrypting)
                {
                    throw new CryptographicException("No initialization vector was provided for the decryption operation!");
                }
                this._iv = this.RandomInitializationVector();
            }
            this._crypto.Key = this._key.Bytes;
            this._crypto.IV = this._iv.Bytes;
        }
        /// <summary>
        ///  Encrypts the specified Data using provided key
        ///  </summary>
        public Data Encrypt(Data d, Data key)
        {
            this.Key = key;
            return this.Encrypt(d);
        }
        public Data Encrypt(Data d)
        {
            MemoryStream ms = new MemoryStream();
            this.ValidateKeyAndIv(true);
            CryptoStream cs = new CryptoStream(ms, this._crypto.CreateEncryptor(), CryptoStreamMode.Write);
            cs.Write(d.Bytes, 0, d.Bytes.Length);
            cs.Close();
            ms.Close();
            return new Data(ms.ToArray());
        }
        /// <summary>
        ///  Encrypts the stream to memory using provided key and provided initialization vector
        ///  </summary>
        public Data Encrypt(Stream s, Data key, Data iv)
        {
            this.IntializationVector = iv;
            this.Key = key;
            return this.Encrypt(s);
        }
        public Data Encrypt(Stream s, Data key)
        {
            this.Key = key;
            return this.Encrypt(s);
        }
        /// <summary>
        ///  Encrypts the specified stream to memory using preset key and preset initialization vector
        ///  </summary>
        public Data Encrypt(Stream s)
        {
            MemoryStream ms = new MemoryStream();
            byte[] b = new byte[2049];
            this.ValidateKeyAndIv(true);
            CryptoStream cs = new CryptoStream(ms, this._crypto.CreateEncryptor(), CryptoStreamMode.Write);
            for (int i = s.Read(b, 0, 2048); i > 0; i = s.Read(b, 0, 2048))
            {
                cs.Write(b, 0, i);
            }
            cs.Close();
            ms.Close();
            return new Data(ms.ToArray());
        }
        public Data Decrypt(Data encryptedData, Data key)
        {
            this.Key = key;
            return this.Decrypt(encryptedData);
        }
        /// <summary>
        ///  Decrypts the specified stream using provided key and preset initialization vector
        ///  </summary>
        public Data Decrypt(Stream encryptedStream, Data key)
        {
            this.Key = key;
            return this.Decrypt(encryptedStream);
        }
        public Data Decrypt(Stream encryptedStream)
        {
            MemoryStream ms = new MemoryStream();
            byte[] b = new byte[2049];
            this.ValidateKeyAndIv(false);
            CryptoStream cs = new CryptoStream(encryptedStream, this._crypto.CreateDecryptor(), CryptoStreamMode.Read);
            for (int i = cs.Read(b, 0, 2048); i > 0; i = cs.Read(b, 0, 2048))
            {
                ms.Write(b, 0, i);
            }
            cs.Close();
            ms.Close();
            return new Data(ms.ToArray());
        }
        /// <summary>
        ///  Decrypts the specified data using preset key and preset initialization vector
        ///  </summary>
        public Data Decrypt(Data encryptedData)
        {
            MemoryStream ms = new MemoryStream(encryptedData.Bytes, 0, encryptedData.Bytes.Length);
            checked
            {
                byte[] b = new byte[encryptedData.Bytes.Length - 1 + 1];
                this.ValidateKeyAndIv(false);
                CryptoStream cs = new CryptoStream(ms, this._crypto.CreateDecryptor(), CryptoStreamMode.Read);
                try
                {
                    cs.Read(b, 0, encryptedData.Bytes.Length - 1);
                }
                catch (CryptographicException ex)
                {
                    throw new CryptographicException("Unable to decrypt data. The provided key may be invalid.", ex);
                }
                finally
                {
                    cs.Close();
                }
                return new Data(b);
            }
        }
    }
}
// file ...\Encryption\Utils.cs

namespace Zero5.Encryption
{
    /// <summary>
    ///  Friend class for shared utility methods used by multiple Encryption classes
    ///  </summary>
    public class Utils
    {
        [DebuggerNonUserCode]
        public Utils()
        {
        }
        /// <summary>
        ///  converts an array of bytes to a string Hex representation
        ///  </summary>
        public static string ToHex(byte[] ba)
        {
            bool flag = ba == null || ba.Length == 0;
            checked
            {
                string ToHex;
                if (flag)
                {
                    ToHex = "";
                }
                else
                {
                    StringBuilder sb = new StringBuilder();
                    for (int i = 0; i < ba.Length; i++)
                    {
                        byte b = ba[i];
                        sb.Append(string.Format("{0:X2}", b));
                    }
                    ToHex = sb.ToString();
                }
                return ToHex;
            }
        }
        public static byte[] FromHex(string hexEncoded)
        {
            bool flag = hexEncoded == null || hexEncoded.Length == 0;
            checked
            {
                byte[] FromHex;
                if (flag)
                {
                    FromHex = null;
                }
                else
                {
                    try
                    {
                        int i = Convert.ToInt32((double)hexEncoded.Length / 2.0);
                        byte[] b = new byte[i - 1 + 1];
                        int arg_48_0 = 0;
                        int num = i - 1;
                        int j = arg_48_0;
                        while (true)
                        {
                            int arg_6B_0 = j;
                            int num2 = num;
                            if (arg_6B_0 > num2)
                            {
                                break;
                            }
                            b[j] = Convert.ToByte(hexEncoded.Substring(j * 2, 2), 16);
                            j++;
                        }
                        FromHex = b;
                    }
                    catch (Exception ex)
                    {
                        throw new FormatException("The provided string does not appear to be Hex encoded:" + Environment.NewLine + hexEncoded + Environment.NewLine, ex);
                    }
                }
                return FromHex;
            }
        }
        public static string ToFatHex(byte[] ba)
        {
            bool flag = ba == null || ba.Length == 0;
            checked
            {
                string ToHex;
                if (flag)
                {
                    ToHex = "";
                }
                else
                {
                    StringBuilder sb = new StringBuilder();
                    for (int i = 0; i < ba.Length; i++)
                    {
                        byte b = ba[i];
                        sb.Append("x");
                        sb.Append(string.Format("{0:X2}", b));
                    }
                    ToHex = sb.ToString();
                }
                return ToHex;
            }
        }
        public static byte[] FromFatHex(string hexEncoded)
        {
            bool flag = hexEncoded == null || hexEncoded.Length == 0;
            checked
            {
                byte[] FromHex;
                if (flag)
                {
                    FromHex = null;
                }
                else
                {
                    try
                    {
                        int i = Convert.ToInt32((double)hexEncoded.Length / 3.0);
                        byte[] b = new byte[i - 1 + 1];
                        int arg_48_0 = 0;
                        int num = i - 1;
                        int j = arg_48_0;
                        while (true)
                        {
                            int arg_6B_0 = j;
                            int num2 = num;
                            if (arg_6B_0 > num2)
                            {
                                break;
                            }
                            b[j] = Convert.ToByte(hexEncoded.Substring(j * 3 + 1, 2), 16);
                            j++;
                        }
                        FromHex = b;
                    }
                    catch (Exception ex)
                    {
                        throw new FormatException("The provided string does not appear to be Hex encoded:" + Environment.NewLine + hexEncoded + Environment.NewLine, ex);
                    }
                }
                return FromHex;
            }
        }
        /// <summary>
        ///  converts from a string Base64 representation to an array of bytes
        ///  </summary>
        public static byte[] FromBase64(string base64Encoded)
        {
            bool flag = base64Encoded == null || base64Encoded.Length == 0;
            byte[] FromBase64;
            if (flag)
            {
                FromBase64 = null;
            }
            else
            {
                try
                {
                    FromBase64 = Convert.FromBase64String(base64Encoded);
                }
                catch (FormatException ex)
                {
                    throw new FormatException("The provided string does not appear to be Base64 encoded:" + Environment.NewLine + base64Encoded + Environment.NewLine, ex);
                }
            }
            return FromBase64;
        }
        public static string ToBase64(byte[] b)
        {
            bool flag = b == null || b.Length == 0;
            string ToBase64;
            if (flag)
            {
                ToBase64 = "";
            }
            else
            {
                ToBase64 = Convert.ToBase64String(b);
            }
            return ToBase64;
        }
        /// <summary>
        ///  retrieve an element from an XML string
        ///  </summary>
        public static string GetXmlElement(string xml, string element)
        {
            Match i = Regex.Match(xml, string.Concat(new string[]
			{
				"<",
				element,
				">(?<Element>[^>]*)</",
				element,
				">"
			}), RegexOptions.IgnoreCase);
            bool flag = i == null;
            if (flag)
            {
                throw new Exception(string.Concat(new string[]
				{
					"Could not find <",
					element,
					"></",
					element,
					"> in provided Public Key XML."
				}));
            }
            return i.Groups["Element"].ToString();
        }
        public static string WriteXmlElement(string element, string value)
        {
            string s = "<{0}>{1}</{0}>" + Environment.NewLine;
            return string.Format(s, element, value);
        }

        public static string WriteXmlNode(string element)
        {
            return WriteXmlNode(element, false);
        }
        public static string WriteXmlNode(string element, bool isClosing)
        {
            string s;
            if (isClosing)
            {
                s = "</{0}>" + Environment.NewLine;
            }
            else
            {
                s = "<{0}>" + Environment.NewLine;
            }
            return string.Format(s, element);
        }
    }
}
// file ...\IO\DataPack.cs

namespace Zero5.IO
{
    public class DataPack
    {
        protected DataSet ds;

        public DataPack(string name)
        {
            ds = new DataSet();
            ds.Tables.Add(name);
        }

        public DataPack(byte[] b)
        {
            ds = Zero5.Util.BinaryConverters.BytesToDataSet(b);
        }

        public string DataPackName
        {
            get { return ds.Tables[0].TableName; }
        }

        //public void SetFieldAsObject(string fieldName, object fieldValue)
        //{
        //    SetField(fieldName, "System.Object", fieldValue);
        //}

        public void SetFieldAsString(string fieldName, string fieldValue)
        {
            SetField(fieldName, "System.String", fieldValue);
        }

        public void SetFieldAsNull(string fieldName)
        {
            SetField(fieldName, "System.String", DBNull.Value);
        }

        public void SetFieldAsInt(string fieldName, int fieldValue)
        {
            SetField(fieldName, "System.Int32", fieldValue);
        }

        public void SetFieldAsBool(string fieldName, bool fieldValue)
        {
            SetField(fieldName, "System.Boolean", fieldValue);
        }

        public void SetFieldAsDouble(string fieldName, double fieldValue)
        {
            SetField(fieldName, "System.Double", fieldValue);
        }

        public void SetFieldAsDateTime(string fieldName, DateTime fieldValue)
        {
            SetField(fieldName, "System.DateTime", fieldValue);
        }

        public void SetFieldAsByteArray(string fieldName, byte[] fieldValue)
        {
            SetField(fieldName, "System.Byte[]", fieldValue);
        }

        public void SetFieldAsIntArray(string fieldName, int[] fieldValue)
        {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < fieldValue.Length; i++)
                sb.Append(fieldValue[i].ToString() + ";");
            SetField(fieldName, "System.String", sb.ToString().TrimEnd(new char[] { ';' }));
        }

        public void SetFieldAsIntArray(string fieldName, int value1)
        {
            SetField(fieldName, "System.String", value1.ToString());
        }

        public void SetFieldAsIntArray(string fieldName, int value1, int value2)
        {
            SetField(fieldName, "System.String", value1.ToString() + ';' + value2.ToString());
        }

        public void SetFieldAsIntArray(string fieldName, int value1, int value2, int value3)
        {
            SetField(fieldName, "System.String", value1.ToString() + ';' + value2.ToString() + ';' + value3.ToString());
        }

        public void SetFieldAsStringArray(string fieldName, string[] fieldValue)
        {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < fieldValue.Length; i++)
                sb.Append(fieldValue[i] + ";");
            SetField(fieldName, "System.String", sb.ToString().TrimEnd(new char[] { ';' }));
        }

        protected void SetField(string fieldName, string fieldSystemTypeName, object fieldValue)
        {
            if (!ds.Tables[0].Columns.Contains(fieldName))
                ds.Tables[0].Columns.Add(fieldName, System.Type.GetType(fieldSystemTypeName));

            if (ds.Tables[0].Rows.Count == 0) ds.Tables[0].Rows.Add(ds.Tables[0].NewRow());

            ds.Tables[0].Rows[0][fieldName] = fieldValue;
        }

        public bool IsFieldNull(string fieldName)
        {
            return ds.Tables[0].Rows[0][fieldName] == DBNull.Value;
        }
        public Object GetFieldAsObject(string fieldName)
        {
            if (IsFieldNull(fieldName)) return null;
            return ds.Tables[0].Rows[0][fieldName];
        }
        public string GetFieldAsString(string fieldName)
        {
            return (string)ds.Tables[0].Rows[0][fieldName];
        }
        public int GetFieldAsInt(string fieldName)
        {
            return (int)ds.Tables[0].Rows[0][fieldName];
        }
        public bool GetFieldAsBool(string fieldName)
        {
            return (bool)ds.Tables[0].Rows[0][fieldName];
        }
        public double GetFieldAsDouble(string fieldName)
        {
            return (double)ds.Tables[0].Rows[0][fieldName];
        }
        public DateTime GetFieldAsDateTime(string fieldName)
        {
            return (DateTime)ds.Tables[0].Rows[0][fieldName];
        }

        public byte[] GetFieldAsByteArray(string fieldName)
        {
            return (byte[])ds.Tables[0].Rows[0][fieldName];
        }

        public int[] GetFieldAsIntArray(string fieldName)
        {
            List<int> lst = new List<int>();
            string[] raw = ((string)ds.Tables[0].Rows[0][fieldName]).Split(new char[] { ';' });
            int t = 0;
            for (int i = 0; i < raw.Length; i++)
                if (raw[i].Trim().Length > 0)
                    if (intTryParse.TryParse(raw[i], out t))
                        lst.Add(t);

            return lst.ToArray();
        }

        public string[] GetFieldAsStringArray(string fieldName)
        {
            List<string> lst = new List<string>();
            string[] raw = ((string)ds.Tables[0].Rows[0][fieldName]).Split(new char[] { ';' });
            for (int i = 0; i < raw.Length; i++)
                if (raw[i].Trim().Length > 0)
                    lst.Add(raw[i].Trim());

            return lst.ToArray();
        }

        public virtual byte[] ToByteArray()
        {
            return Zero5.Util.BinaryConverters.DataSetToBytes(ds, 68); // D as DataPack
        }

        public List<string> FieldNames()
        {
            List<string> l = new List<string>();
            foreach (DataColumn dc in ds.Tables[0].Columns)
                l.Add(dc.ColumnName);
            return l;
        }
    }

    public class DataPackError : DataPack
    {
        public DataPackError(byte[] b)
            :
            base(b)
        { }

        public DataPackError(Exception ex)
            :
            base("ex")
        {
            SetFieldAsString("Message", ex.Message);
#if !MOBILE
            SetFieldAsString("Source", ex.Source);
#else
            SetFieldAsString("Source", "");
#endif
            SetFieldAsString("StackTrace", ex.StackTrace);
        }
        public DataPackError(string message)
            :
            base("ex")
        {
            SetFieldAsString("Message", message);
            SetFieldAsString("Source", "");
            SetFieldAsString("StackTrace", "");
        }

        public override byte[] ToByteArray()
        {
            return Zero5.Util.BinaryConverters.DataSetToBytes(ds, 69); // E as DataPackError
        }

        public string GetMessage()
        {
            return GetFieldAsString("Message");
        }
        public string GetSource()
        {
            return GetFieldAsString("Source");
        }
        public string GetStackTrace()
        {
            return GetFieldAsString("StackTrace");
        }

    }
}
// file ...\IO\FTP.cs
/* Copyright (c) 2006, J.P. Trosclair
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted 
 * provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this list of conditions and 
 *		the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice, this list of conditions 
 *		and the following disclaimer in the documentation and/or other materials provided with the 
 *		distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED 
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * Based on FTPFactory.cs code, pretty much a complete re-write with FTPFactory.cs
 * as a reference.
 * 
 ***********************
 * Authors of this code:
 ***********************
 * J.P. Trosclair    (jptrosclair@judelawfirm.com)
 * Filipe Madureira  (filipe_madureira@hotmail.com) 
 * Carlo M. Andreoli (cmandreoli@numericaprogetti.it)
 * Sloan Holliday    (sloan@ipass.net)
 * 
 *********************** 
 * FTPFactory.cs was written by Jaimon Mathew (jaimonmathew@rediffmail.com)
 * and modified by Dan Rolander (Dan.Rolander@marriott.com).
 *	http://www.csharphelp.com/archives/archive9.html
 ***********************
 * 
 * ** DO NOT ** contact the authors of FTPFactory.cs about problems with this code. It
 * is not their responsibility. Only contact people listed as authors of THIS CODE.
 * 
 *  Any bug fixes or additions to the code will be properly credited to the author.
 * 
 *  BUGS: There probably are plenty. If you fix one, please email me with info
 *   about the bug and the fix, code is welcome.
 * 
 * All calls to the ftplib functions should be:
 * 
 * try 
 * { 
 *		// ftplib function call
 * } 
 * catch(Exception ex) 
 * {
 *		// error handeler
 * }
 * 
 * If you add to the code please make use of OpenDataSocket(), CloseDataSocket(), and
 * ReadResponse() appropriately. See the comments above each for info about using them.
 * 
 * The Fail() function terminates the entire connection. Only call it on critical errors.
 * Non critical errors should NOT close the connection.
 * All errors should throw an exception of type Exception with the response string from
 * the server as the message.
 * 
 * See the simple ftp client for examples on using this class
 */

//#define FTP_DEBUG   


namespace Zero5.IO
{
	public class FTP
	{
		#region Public Variables

		/// <summary>
		/// IP address or hostname to connect to
		/// </summary>
		public string server;
		/// <summary>
		/// Username to login as
		/// </summary>
		public string user;
		/// <summary>
		/// Password for account
		/// </summary>
		public string pass;
		/// <summary>
		/// Port number the FTP server is listening on
		/// </summary>
		public int port;
		/// <summary>
		/// The timeout (miliseconds) for waiting on data to arrive
		/// </summary>
		public int timeout;
		
		#endregion

		#region Private Variables
		
		private string messages; // server messages
		private string responseStr; // server response if the user wants it.
		private bool passive_mode;		// #######################################
		private long bytes_total; // upload/download info if the user wants it.
		private long file_size; // gets set when an upload or download takes place
		private Socket main_sock;
		private IPEndPoint main_ipEndPoint;
		private Socket listening_sock;
		private Socket data_sock;
		private IPEndPoint data_ipEndPoint;
        private FileStream file;
        private MemoryStream mem;
        private int response;
		private string bucket;
		
		#endregion
		
		#region Constructors
		/// <summary>
		/// Constructor
		/// </summary>
		public FTP()
		{
			server = null;
			user = null;
			pass = null;
			port = 21;
			passive_mode = true;		// #######################################
			main_sock = null;
			main_ipEndPoint = null;
			listening_sock = null;
			data_sock = null;
			data_ipEndPoint = null;
			file = null;
			bucket = "";
			bytes_total = 0;
			timeout = 10000;	// 10 seconds
			messages = "";
		}
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="server">Server to connect to</param>
		/// <param name="user">Account to login as</param>
		/// <param name="pass">Account password</param>
		public FTP(string server, string user, string pass)
		{
			this.server = server;
			this.user = user;
			this.pass = pass;
			port = 21;
			passive_mode = true;		// #######################################
			main_sock = null;
			main_ipEndPoint = null;
			listening_sock = null;
			data_sock = null;
			data_ipEndPoint = null;
			file = null;
			bucket = "";
			bytes_total = 0;
			timeout = 10000;	// 10 seconds
			messages = "";
		}
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="server">Server to connect to</param>
		/// <param name="port">Port server is listening on</param>
		/// <param name="user">Account to login as</param>
		/// <param name="pass">Account password</param>
		public FTP(string server, int port, string user, string pass)
		{
			this.server = server;
			this.user = user;
			this.pass = pass;
			this.port = port;
			passive_mode = true;		// #######################################
			main_sock = null;
			main_ipEndPoint = null;
			listening_sock = null;
			data_sock = null;
			data_ipEndPoint = null;
			file = null;
			bucket = "";
			bytes_total = 0;
			timeout = 10000;	// 10 seconds
			messages = "";
		}

		#endregion

		/// <summary>
		/// Connection status to the server
		/// </summary>
		public bool IsConnected
		{
			get
			{
				if (main_sock != null)
					return main_sock.Connected;
				return false;
			}
		}
		/// <summary>
		/// Returns true if the message buffer has data in it
		/// </summary>
		public bool MessagesAvailable
		{
			get
			{
				if(messages.Length > 0)
					return true;
				return false;
			}
		}
		/// <summary>
		/// Server messages if any, buffer is cleared after you access this property
		/// </summary>
		public string Messages
		{
			get
			{
				string tmp = messages;
				messages = "";
				return tmp;
			}
		}
		/// <summary>
		/// The response string from the last issued command
		/// </summary>
		public string ResponseString
		{
			get
			{
				return responseStr;
			}
		}
		/// <summary>
		/// The total number of bytes sent/recieved in a transfer
		/// </summary>
		public long BytesTotal		// #######################################
		{
			get
			{
				return bytes_total;
			}
		}
		/// <summary>
		/// The size of the file being downloaded/uploaded (Can possibly be 0 if no size is available)
		/// </summary>
		public long FileSize		// #######################################
		{
			get
			{
				return file_size;
			}
		}
		/// <summary>
		/// True:  Passive mode [default]
		/// False: Active Mode
		/// </summary>
		public bool PassiveMode		// #######################################
		{
			get
			{
				return passive_mode;
			}
			set
			{
				passive_mode = value;
			}
		}


		private void Fail()
		{
			Disconnect();
			throw new Exception(responseStr);
		}


		private void SetBinaryMode(bool mode)
		{
			if (mode)
				SendCommand("TYPE I");
			else
				SendCommand("TYPE A");

			ReadResponse();
			if (response != 200)
				Fail();
		}


		private void SendCommand(string command)
		{
			Byte[] cmd = Encoding.ASCII.GetBytes((command + "\r\n").ToCharArray());

#if (FTP_DEBUG)
			if (command.Length > 3 && command.Substring(0, 4) == "PASS")
				Console.WriteLine("\rPASS xxx");
			else
				Console.WriteLine("\r" + command);
#endif

			main_sock.Send(cmd, cmd.Length, 0);
		}


		private void FillBucket()
		{
			Byte[] bytes = new Byte[512];
			long bytesgot;
			int msecs_passed = 0;		// #######################################

			while(main_sock.Available < 1)
			{
				System.Threading.Thread.Sleep(50);
				msecs_passed += 50;
				// this code is just a fail safe option 
				// so the code doesn't hang if there is 
				// no data comming.
				if (msecs_passed > timeout)
				{
					Disconnect();
					throw new Exception("Timed out waiting on server to respond.");	
				}
			}

			while(main_sock.Available > 0)
			{
				bytesgot = main_sock.Receive(bytes, 512, 0);
				bucket += Encoding.ASCII.GetString(bytes, 0, (int)bytesgot);
				// this may not be needed, gives any more data that hasn't arrived
				// just yet a small chance to get there.
				System.Threading.Thread.Sleep(50);
			}
		}


		private string GetLineFromBucket()
		{
			int i;
			string buf = "";

			if ((i = bucket.IndexOf('\n')) < 0)
			{
				while(i < 0)
				{
					FillBucket();
					i = bucket.IndexOf('\n');
				}
			}

			buf = bucket.Substring(0, i);
			bucket = bucket.Substring(i + 1);

			return buf;
		}


		// Any time a command is sent, use ReadResponse() to get the response
		// from the server. The variable responseStr holds the entire string and
		// the variable response holds the response number.
		private void ReadResponse()
		{
			string buf;
			messages = "";

			while(true)
			{
				//buf = GetLineFromBucket();
				buf = GetLineFromBucket();

#if (FTP_DEBUG)
				Console.WriteLine(buf);
#endif
				// the server will respond with "000-Foo bar" on multi line responses
				// "000 Foo bar" would be the last line it sent for that response.
				// Better example:
				// "000-This is a multiline response"
				// "000-Foo bar"
				// "000 This is the end of the response"
				if (Regex.Match(buf, "^[0-9]+ ").Success)
				{
					responseStr = buf;
					response = int.Parse(buf.Substring(0, 3));
					break;
				}
				else
					messages += Regex.Replace(buf, "^[0-9]+-", "") + "\n";
			}
		}


		// if you add code that needs a data socket, i.e. a PASV or PORT command required,
		// call this function to do the dirty work. It sends the PASV or PORT command,
		// parses out the port and ip info and opens the appropriate data socket
		// for you. The socket variable is private Socket data_socket. Once you
		// are done with it, be sure to call CloseDataSocket()
		private void OpenDataSocket()
		{
			if (passive_mode)		// #######################################
			{
				string[] pasv;
				string server;
				int port;

				Connect();
				SendCommand("PASV");
				ReadResponse();
				if (response != 227)
					Fail();

				try
				{
					int i1, i2;

					i1 = responseStr.IndexOf('(') + 1;
					i2 = responseStr.IndexOf(')') - i1;
					pasv = responseStr.Substring(i1, i2).Split(',');
				}
				catch(Exception)
				{
					Disconnect();
					throw new Exception("Malformed PASV response: " + responseStr);
				}

				if (pasv.Length < 6)
				{
					Disconnect();
					throw new Exception("Malformed PASV response: " + responseStr);
				}

				server = String.Format("{0}.{1}.{2}.{3}", pasv[0], pasv[1], pasv[2], pasv[3]);
				port = (int.Parse(pasv[4]) << 8) + int.Parse(pasv[5]);

				try
				{
#if (FTP_DEBUG)
					Console.WriteLine("Data socket: {0}:{1}", server, port);
#endif
					CloseDataSocket();
					
#if (FTP_DEBUG)
					Console.WriteLine("Creating socket...");
#endif
					data_sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
					
#if (FTP_DEBUG)
					Console.WriteLine("Resolving host");
#endif

					data_ipEndPoint = new IPEndPoint(Dns.GetHostByName(server).AddressList[0], port);

					
#if (FTP_DEBUG)
					Console.WriteLine("Connecting..");
#endif
					data_sock.Connect(data_ipEndPoint);

#if (FTP_DEBUG)
					Console.WriteLine("Connected.");
#endif
				}
				catch(Exception ex)
				{
					throw new Exception("Failed to connect for data transfer: " + ex.Message);
				}
			}
			else		// #######################################
			{
				Connect();

				try
				{
#if (FTP_DEBUG)
					Console.WriteLine("Data socket (active mode)");
#endif
					CloseDataSocket();
					
#if (FTP_DEBUG)
					Console.WriteLine("Creating listening socket...");
#endif
					listening_sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

#if (FTP_DEBUG)
					Console.WriteLine("Binding it to local address/port");
#endif
					// for the PORT command we need to send our IP address; let's extract it
					// from the LocalEndPoint of the main socket, that's already connected
					string sLocAddr = main_sock.LocalEndPoint.ToString();
					int ix = sLocAddr.IndexOf(':');
					if (ix < 0)
					{
						throw new Exception("Failed to parse the local address: " + sLocAddr);
					}
					string sIPAddr = sLocAddr.Substring(0, ix);
					// let the system automatically assign a port number (setting port = 0)
					System.Net.IPEndPoint localEP = new IPEndPoint(IPAddress.Parse(sIPAddr), 0);

					listening_sock.Bind(localEP);
					sLocAddr = listening_sock.LocalEndPoint.ToString();
					ix = sLocAddr.IndexOf(':');
					if (ix < 0)
					{
						throw new Exception("Failed to parse the local address: " + sLocAddr);
					}
					int nPort = int.Parse(sLocAddr.Substring(ix + 1));
#if (FTP_DEBUG)
					Console.WriteLine("Listening on {0}:{1}", sIPAddr, nPort);
#endif
					// start to listen for a connection request from the host (note that
					// Listen is not blocking) and send the PORT command
					listening_sock.Listen(1);
					string sPortCmd = string.Format("PORT {0},{1},{2}", 
													sIPAddr.Replace('.', ','),
													nPort / 256, nPort % 256);
					SendCommand(sPortCmd);
					ReadResponse();
					if (response != 200)
						Fail();
				}
				catch(Exception ex)
				{
					throw new Exception("Failed to connect for data transfer: " + ex.Message);
				}
			}
		}


		private void ConnectDataSocket()		// #######################################
		{
			if (data_sock != null)		// already connected (always so if passive mode)
				return;

			try
			{
#if (FTP_DEBUG)
				Console.WriteLine("Accepting the data connection.");
#endif
				data_sock = listening_sock.Accept();	// Accept is blocking
				listening_sock.Close();
				listening_sock = null;

				if (data_sock == null)
				{
					throw new Exception("Winsock error: " + 
						Convert.ToString(System.Runtime.InteropServices.Marshal.GetLastWin32Error()) );
				}
#if (FTP_DEBUG)
				Console.WriteLine("Connected.");
#endif
			}
			catch(Exception ex)
			{
				throw new Exception("Failed to connect for data transfer: " + ex.Message);
			}
		}


		private void CloseDataSocket()
		{
#if (FTP_DEBUG)
			Console.WriteLine("Attempting to close data channel socket...");
#endif
			if (data_sock != null)
			{
				if (data_sock.Connected)
				{
#if (FTP_DEBUG)
						Console.WriteLine("Closing data channel socket!");
#endif	
						data_sock.Close();
#if (FTP_DEBUG)
						Console.WriteLine("Data channel socket closed!");
#endif
				}
				data_sock = null;
			}

			data_ipEndPoint = null;
		}
		/// <summary>
		/// Closes all connections to the ftp server
		/// </summary>
		public void Disconnect()
		{
			CloseDataSocket();

			if (main_sock != null)
			{
				if (main_sock.Connected)
				{
					SendCommand("QUIT");
					main_sock.Close();
				}
				main_sock = null;
			}

			if (file != null)
				file.Close();

			main_ipEndPoint = null;
			file = null;
		}
		/// <summary>
		/// Connect to a ftp server
		/// </summary>
		/// <param name="server">IP or hostname of the server to connect to</param>
		/// <param name="port">Port number the server is listening on</param>
		/// <param name="user">Account name to login as</param>
		/// <param name="pass">Password for the account specified</param>
		public void Connect(string server, int port, string user, string pass)
		{
			this.server = server;
			this.user = user;
			this.pass = pass;
			this.port = port;

			Connect();
		}
		/// <summary>
		/// Connect to a ftp server
		/// </summary>
		/// <param name="server">IP or hostname of the server to connect to</param>
		/// <param name="user">Account name to login as</param>
		/// <param name="pass">Password for the account specified</param>
		public void Connect(string server, string user, string pass)
		{
			this.server = server;
			this.user = user;
			this.pass = pass;

			Connect();
		}
		/// <summary>
		/// Connect to an ftp server
		/// </summary>
		public void Connect()
		{
			if (server == null)
				throw new Exception("No server has been set.");
			if (user == null)
				throw new Exception("No username has been set.");

			if (main_sock != null)
				if (main_sock.Connected)
					return;

			main_sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
			main_ipEndPoint = new IPEndPoint(Dns.GetHostByName(server).AddressList[0], port);
			
			try
			{
				main_sock.Connect(main_ipEndPoint);	
			}
			catch(Exception ex)
			{
				throw new Exception(ex.Message);
			}

			ReadResponse();
			if (response != 220)
				Fail();

			SendCommand("USER " + user);
			ReadResponse();

			switch(response)
			{
				case 331:
					if (pass == null)
					{
						Disconnect();
						throw new Exception("No password has been set.");
					}
					SendCommand("PASS " + pass);
					ReadResponse();
					if (response != 230)
						Fail();
					break;
				case 230:
					break;
			}
			
			return;
		}
		/// <summary>
		/// Retrieves a list of files from the ftp server
		/// </summary>
		/// <returns>An ArrayList of files</returns>
		public ArrayList List()
		{
			Byte[] bytes = new Byte[512];
			string file_list = "";
			long bytesgot = 0;
			int msecs_passed = 0;
			ArrayList list = new ArrayList();
		
			Connect();
			OpenDataSocket();
			SendCommand("LIST");
			ReadResponse();

			//FILIPE MADUREIRA.
			//Added response 125
			switch(response)
			{
				case 125:
				case 150:
					break;
				default:
					CloseDataSocket();
					throw new Exception(responseStr);
			}
			ConnectDataSocket();		// #######################################

			while(data_sock.Available < 1)
			{
				System.Threading.Thread.Sleep(50);
				msecs_passed += 50;
				// this code is just a fail safe option 
				// so the code doesn't hang if there is 
				// no data comming.
				if (msecs_passed > (timeout / 10))
				{
					//CloseDataSocket();
					//throw new Exception("Timed out waiting on server to respond.");
					
					//FILIPE MADUREIRA.
					//If there are no files to list it gives timeout.
					//So I wait less time and if no data is received, means that there are no files
					break;//Maybe there are no files
				}
			}

			while(data_sock.Available > 0)
			{
				bytesgot = data_sock.Receive(bytes, bytes.Length, 0);
				file_list += Encoding.ASCII.GetString(bytes, 0, (int)bytesgot);
				System.Threading.Thread.Sleep(50); // *shrug*, sometimes there is data comming but it isn't there yet.
			}
			
			CloseDataSocket();

			ReadResponse();
			if (response != 226)
				throw new Exception(responseStr);

			foreach(string f in file_list.Split('\n'))
			{
				if (f.Length > 0 && !Regex.Match(f, "^total").Success)
					list.Add(f.Substring(0, f.Length - 1));
			}

			return list;
		}
		/// <summary>
		/// Gets a file list only
		/// </summary>
		/// <returns>ArrayList of files only</returns>
		public ArrayList ListFiles()
		{
			ArrayList list = new ArrayList();

			foreach(string f in List())
			{
				//FILIPE MADUREIRA
				//In Windows servers it is identified by <DIR>
				if ((f.Length > 0))
				{
					if ((f[0] != 'd') && (f.ToUpper().IndexOf("<DIR>") < 0))
						list.Add(f);
				}
			}

			return list;
		}
		/// <summary>
		/// Gets a directory list only
		/// </summary>
		/// <returns>ArrayList of directories only</returns>
		public ArrayList ListDirectories()
		{
			ArrayList list = new ArrayList();

			foreach(string f in List())
			{
				//FILIPE MADUREIRA
				//In Windows servers it is identified by <DIR>
				if (f.Length > 0)
				{
					if ((f[0] == 'd') || (f.ToUpper().IndexOf("<DIR>") >= 0))
						list.Add(f);
				}
			}

			return list;
		}
		/// <summary>
		/// Returns the 'Raw' DateInformation in ftp format. (YYYYMMDDhhmmss). Use GetFileDate to return a DateTime object as a better option.
		/// </summary>
		/// <param name="fileName">Remote FileName to Query</param>
		/// <returns>Returns the 'Raw' DateInformation in ftp format</returns>
		public string GetFileDateRaw(string fileName)
		{
			Connect();
			
			SendCommand("MDTM " + fileName);
			ReadResponse();
			if(response != 213)
			{
#if (FTP_DEBUG)
				Console.Write("\r" + responseStr);
#endif
				throw new Exception(responseStr);
			}
			
			return (this.responseStr.Substring(4));
		}
		/// <summary>
		/// GetFileDate will query the ftp server for the date of the remote file.
		/// </summary>
		/// <param name="fileName">Remote FileName to Query</param>
		/// <returns>DateTime of the Input FileName</returns>
		public DateTime GetFileDate(string fileName)
		{
			return ConvertFTPDateToDateTime(GetFileDateRaw(fileName));
		}

		private DateTime ConvertFTPDateToDateTime(string input)
		{
			if(input.Length < 14)
				throw new ArgumentException("Input Value for ConvertFTPDateToDateTime method was too short.");
			
			//YYYYMMDDhhmmss": 
			int year = Convert.ToInt16(input.Substring(0,4));
			int month = Convert.ToInt16(input.Substring(4,2));
			int day = Convert.ToInt16(input.Substring(6,2));
			int hour = Convert.ToInt16(input.Substring(8,2));
			int min = Convert.ToInt16(input.Substring(10,2));
			int sec = Convert.ToInt16(input.Substring(12,2));

			return new DateTime(year, month, day, hour, min, sec);
		}
		/// <summary>
		/// Get the working directory on the ftp server
		/// </summary>
		/// <returns>The working directory</returns>
		public string GetWorkingDirectory()
		{
			//PWD - print working directory
			Connect();
			SendCommand("PWD");
			ReadResponse();

			if(response != 257)
				throw new Exception(responseStr);
			
			string pwd;
			try
			{
				pwd = responseStr.Substring(responseStr.IndexOf("\"", 0) + 1);//5);
				pwd = pwd.Substring(0, pwd.LastIndexOf("\""));
				pwd = pwd.Replace("\"\"", "\""); // directories with quotes in the name come out as "" from the server
			}
			catch(Exception ex)
			{
				throw new Exception("Uhandled PWD response: " + ex.Message);
			}

			return pwd;
		}
		/// <summary>
		/// Change to another directory on the ftp server
		/// </summary>
		/// <param name="path">Directory to change to</param>
		public void ChangeDir(string path)
		{
			Connect();
			SendCommand("CWD " + path);
			ReadResponse();
			if (response != 250)
			{
#if (FTP_DEBUG)
				Console.Write("\r" + responseStr);
#endif
				throw new Exception(responseStr);
			}
		}
		/// <summary>
		/// Create a directory on the ftp server
		/// </summary>
		/// <param name="dir">Directory to create</param>
		public void MakeDir(string dir)
		{
			Connect();
			SendCommand("MKD " + dir);
			ReadResponse();
			
			switch(response)
			{
				case 257:
				case 250:
					break;
				default:
#if (FTP_DEBUG)
                    Console.Write("\r" + responseStr);
#endif
					throw new Exception(responseStr);
			}
		}
		/// <summary>
		/// Remove a directory from the ftp server
		/// </summary>
		/// <param name="dir">Name of directory to remove</param>
		public void RemoveDir(string dir)
		{
			Connect();
			SendCommand("RMD " + dir);
			ReadResponse();
			if (response != 250)
			{
#if (FTP_DEBUG)
				Console.Write("\r" + responseStr);
#endif
				throw new Exception(responseStr);
			}
		}
		/// <summary>
		/// Remove a file from the ftp server
		/// </summary>
		/// <param name="filename">Name of the file to delete</param>
		public void RemoveFile(string filename)
		{
			Connect();
			SendCommand("DELE " + filename);
			ReadResponse();
			if (response != 250)
			{
#if (FTP_DEBUG)
				Console.Write("\r" + responseStr);
#endif
				throw new Exception(responseStr);
			}
		}
		/// <summary>
		/// Rename a file on the ftp server
		/// </summary>
		/// <param name="oldfilename">Old file name</param>
		/// <param name="newfilename">New file name</param>
		public void RenameFile(string oldfilename, string newfilename)		// #######################################
		{
			Connect();
			SendCommand("RNFR " + oldfilename);
			ReadResponse();
			if (response != 350)
			{
#if (FTP_DEBUG)
				Console.Write("\r" + responseStr);
#endif
				throw new Exception(responseStr);
			}
			else
			{
				SendCommand("RNTO " + newfilename);
				ReadResponse();
				if (response != 250)
				{
#if (FTP_DEBUG)
					Console.Write("\r" + responseStr);
#endif
					throw new Exception(responseStr);
				}
			}
		}
		/// <summary>
		/// Get the size of a file (Provided the ftp server supports it)
		/// </summary>
		/// <param name="filename">Name of file</param>
		/// <returns>The size of the file specified by filename</returns>
		public long GetFileSize(string filename)
		{
			Connect();
			SendCommand("SIZE " + filename);
			ReadResponse();
			if (response != 213)
			{
#if (FTP_DEBUG)
				Console.Write("\r" + responseStr);
#endif
				throw new Exception(responseStr);
			}
            
			return Int64.Parse(responseStr.Substring(4));
		}
		/// <summary>
		/// Open an upload with no resume if it already exists
		/// </summary>
		/// <param name="filename">File to upload</param>
		public void OpenUpload(string filename)
		{
			OpenUpload(filename, filename, false);
		}
		/// <summary>
		/// Open an upload with no resume if it already exists
		/// </summary>
		/// <param name="filename">Local file to upload (Can include path to file)</param>
		/// <param name="remotefilename">Filename to store file as on ftp server</param>
		public void OpenUpload(string filename, string remotefilename)
		{
			OpenUpload(filename, remotefilename, false);
		}
		/// <summary>
		/// Open an upload with resume support
		/// </summary>
		/// <param name="filename">Local file to upload (Can include path to file)</param>
		/// <param name="resume">Attempt resume if exists</param>
		public void OpenUpload(string filename, bool resume)
		{
			OpenUpload(filename, filename, resume);
		}
		/// <summary>
		/// Open an upload with resume support
		/// </summary>
		/// <param name="filename">Local file to upload (Can include path to file)</param>
		/// <param name="remote_filename">Filename to store file as on ftp server</param>
		/// <param name="resume">Attempt resume if exists</param>
		public void OpenUpload(string filename, string remote_filename, bool resume)
		{
			Connect();
			SetBinaryMode(true);
			OpenDataSocket();

			bytes_total = 0;

			try
			{
				file = new FileStream(filename, FileMode.Open);
			}
			catch(Exception ex)
			{
				file = null;
				throw new Exception(ex.Message);
			}

			file_size = file.Length;

			if (resume)
			{
				long size = GetFileSize(remote_filename);
				SendCommand("REST " + size);
				ReadResponse();
				if (response == 350)
					file.Seek(size, SeekOrigin.Begin);
			}
			
			SendCommand("STOR " + remote_filename);
			ReadResponse();

			switch(response)
			{
				case 125:
				case 150:
					break;
				default:
					file.Close();
					file = null;
					throw new Exception(responseStr);
			}
			ConnectDataSocket();		// #######################################	

			return;
		}
		/// <summary>
		/// Download a file with no resume
		/// </summary>
		/// <param name="filename">Remote file name</param>
		public void OpenDownload(string filename)
		{
			OpenDownload(filename, filename, false);
		}
		/// <summary>
		/// Download a file with optional resume
		/// </summary>
		/// <param name="filename">Remote file name</param>
		/// <param name="resume">Attempt resume if file exists</param>
		public void OpenDownload(string filename, bool resume)
		{
			OpenDownload(filename, filename, resume);
		}
		/// <summary>
		/// Download a file with no attempt to resume
		/// </summary>
		/// <param name="filename">Remote filename</param>
		/// <param name="localfilename">Local filename (Can include path to file)</param>
		public void OpenDownload(string filename, string localfilename)
		{
			OpenDownload(filename, localfilename, false);
		}
		/// <summary>
		/// Open a file for download
		/// </summary>
		/// <param name="remote_filename">The name of the file on the FTP server</param>
		/// <param name="local_filename">The name of the file to save as (Can include path to file)</param>
		/// <param name="resume">Attempt resume if file exists</param>
		public void OpenDownload(string remote_filename, string local_filename, bool resume)
		{
			Connect();
			SetBinaryMode(true);

			bytes_total = 0;
			
			try
			{
				file_size = GetFileSize(remote_filename);
			}
			catch
			{
				file_size = 0;
			}
			
			if (resume && System.IO.File.Exists(local_filename))
			{
				try
				{
					file = new FileStream(local_filename, FileMode.Open);
				}
				catch(Exception ex)
				{
					file = null;
					throw new Exception(ex.Message);
				}

				SendCommand("REST " + file.Length);
				ReadResponse();
				if (response != 350)
					throw new Exception(responseStr);
				file.Seek(file.Length, SeekOrigin.Begin);
				bytes_total = file.Length;
			}
			else
			{
				try
				{
					file = new FileStream(local_filename, FileMode.Create);
				}
				catch(Exception ex)
				{
					file = null;
					throw new Exception(ex.Message);
				}
			}

			OpenDataSocket();
			SendCommand("RETR " + remote_filename);
			ReadResponse();
			
			switch(response)
			{
				case 125:
				case 150:
					break;
				default:
					file.Close();
					file = null;
					throw new Exception(responseStr);
			}
			ConnectDataSocket();		// #######################################	

			return;
		}

		/// <summary>
		/// Open a file for download in memory
		/// </summary>
		/// <param name="remote_filename">The name of the file on the FTP server</param>
		/// <param name="local_filename">The name of the file to save as (Can include path to file)</param>
		/// <param name="resume">Attempt resume if file exists</param>
		public void OpenDownloadInMemory(string remote_filename, MemoryStream ms)
		{
            mem = ms;
			Connect();
			SetBinaryMode(true);

			bytes_total = 0;
			
			try
			{
				file_size = GetFileSize(remote_filename);
			}
			catch
			{
				file_size = 0;
			}
			
			OpenDataSocket();
			SendCommand("RETR " + remote_filename);
			ReadResponse();
			
			switch(response)
			{
				case 125:
				case 150:
					break;
				default:
					mem = null;
					throw new Exception(responseStr);
			}
			ConnectDataSocket();		// #######################################	

			return;
		}
		/// <summary>
		/// Upload the file, to be used in a loop until file is completely uploaded
		/// </summary>
		/// <returns>Bytes sent</returns>
		public long DoUpload()
		{
			Byte[] bytes = new Byte[512];
			long bytes_got;

			try
			{
				bytes_got = file.Read(bytes, 0, bytes.Length);
				bytes_total += bytes_got;
				data_sock.Send(bytes, (int)bytes_got, 0);

				if(bytes_got <= 0)
				{
					// the upload is complete or an error occured
					file.Close();
					file = null;
				
					CloseDataSocket();
					ReadResponse();
					switch(response)
					{
						case 226:
						case 250:
							break;
						default:
							throw new Exception(responseStr);
					}
				
					SetBinaryMode(false);
				}
			}
			catch(Exception ex)
			{
				file.Close();
				file = null;
				CloseDataSocket();
				ReadResponse();
				SetBinaryMode(false);
				throw ex;
			}

			return bytes_got;
		}
		/// <summary>
		/// Download a file, to be used in a loop until the file is completely downloaded
		/// </summary>
		/// <returns>Number of bytes recieved</returns>
		public long DoDownload()
		{
			Byte[] bytes = new Byte[1024];
			long bytes_got;
			
			try
			{
				bytes_got = data_sock.Receive(bytes, bytes.Length, 0);

				if(bytes_got <= 0)
				{
					// the download is done or an error occured
					CloseDataSocket();
					file.Close();
					file = null;
				
					ReadResponse();
					switch(response)
					{
						case 226:
						case 250:
							break;
						default:
							throw new Exception(responseStr);
					}
				
					SetBinaryMode(false);

					return bytes_got;
				}

				file.Write(bytes, 0, (int)bytes_got);
				bytes_total += bytes_got;
			}
			catch(Exception ex)
			{
				CloseDataSocket();
				file.Close();
				file = null;
				ReadResponse();
				SetBinaryMode(false);
				throw ex;
			}

			return bytes_got;
		}

        /// <summary>
        /// Download a file in memory, to be used in a loop until the file is completely downloaded
        /// </summary>
        /// <returns>Number of bytes recieved</returns>
        public long DoDownloadInMemory()
        {
            Byte[] bytes = new Byte[1024];
            long bytes_got;

            try
            {
                bytes_got = data_sock.Receive(bytes, bytes.Length, 0);

                if (bytes_got <= 0)
                {
                    // the download is done or an error occured
                    CloseDataSocket();
                    mem = null;

                    ReadResponse();
                    switch (response)
                    {
                        case 226:
                        case 250:
                            break;
                        default:
                            throw new Exception(responseStr);
                    }

                    SetBinaryMode(false);

                    return bytes_got;
                }

                mem.Write(bytes, 0, (int)bytes_got);
                bytes_total += bytes_got;
            }
            catch (Exception ex)
            {
                CloseDataSocket();
                mem = null;
                ReadResponse();
                SetBinaryMode(false);
                throw ex;
            }

            return bytes_got;
        }
	}
}
// file ...\IO\PhaseBoard.cs
#if !MOBILE && !CORE


namespace Zero5.IO
{
    class PhaseBoard
    {
        private SSH sshLink;

        public PhaseBoard(string ip, string username, string password)
        {
            sshLink = new SSH(ip, username, password);
        }
        
        public void UpdateFirmwareDontKeepConfiguration(byte[] data)
        {
            UpdateFirmware(data, false);
        }

        public void UpdateFirmwareAndKeepConfiguration(byte[] data)
        {
            UpdateFirmware(data, true);
        }

        private void UpdateFirmware(byte[] data, bool keepConfiguration)
        {
            string locale = System.IO.Path.GetTempFileName();
            System.IO.File.WriteAllBytes(locale, data);
            sshLink.UploadFile(locale, "/tmp/firmware.bin");
            System.IO.File.Delete(locale);

            string command = "";
            if (keepConfiguration)
                command = "sysupgrade -v -c /tmp/firmware.bin";
            else
                command = "sysupgrade -v -n /tmp/firmware.bin";
            
            sshLink.ExecuteCommand(command, 1000 * 60 * 4, "Upgrade completed\nRebooting system...\n");
        }

        public void UpdatePhaseboard(byte[] data)
        {
            string locale = System.IO.Path.GetTempFileName();
            System.IO.File.WriteAllBytes(locale, data);
            sshLink.UploadFile(locale, "/tmp/phaseboard.ipk");
            System.IO.File.Delete(locale);
            sshLink.ExecuteCommand("opkg install /tmp/phaseboard.ipk");
        }

        public void SetDate(DateTime dt)
        {
            //it takes too much time to apply
            //sshLink.ExecuteCommand("date -u " + dt.ToUniversalTime().ToString("yyyyMMddHHmm.ss"));

            DateTime dtStart = DateTime.Now;
            //1-2 seconds to apply
            using (Renci.SshNet.SshClient ssh = new Renci.SshNet.SshClient(sshLink.ServerIP, sshLink.ServerUsername, sshLink.ServerPassword))
            {
                ssh.Connect();

                Renci.SshNet.SshCommand cmd = ssh.CreateCommand("date -u " + dt.AddMilliseconds((DateTime.Now - dtStart).TotalMilliseconds).ToUniversalTime().ToString("yyyyMMddHHmm.ss"));

                IAsyncResult asynch = cmd.BeginExecute(delegate(IAsyncResult ar) { }, null);

                DateTime dtLimitTimeout = DateTime.Now.AddMilliseconds(2000);

                System.IO.StreamReader reader = new System.IO.StreamReader(cmd.OutputStream);

                string exitResultCondition = "";
                string resultComplete = "";
                while (!asynch.IsCompleted)
                {
                    if (DateTime.Now > dtLimitTimeout)
                        throw new TimeoutException();

                    string result = reader.ReadToEnd();
                    resultComplete += result;

                    if (exitResultCondition != "")
                        if (resultComplete.EndsWith(exitResultCondition))
                            break;
                }

                if (exitResultCondition != "" && resultComplete.EndsWith(exitResultCondition)) return;

                if (cmd.Error != "") throw new Exception(cmd.Error);

                return;
            }
        }

        public DateTime GetDate()
        {
            string dt = sshLink.ExecuteCommand("date -u -Iseconds");
            //2016-01-26T14:31:43+0000
            //2016-01-26T14:31:43UTC
            
            return new DateTime(
                int.Parse(dt.Substring(0, 4)),
                int.Parse(dt.Substring(5, 2)),
                int.Parse(dt.Substring(8, 2)),
                int.Parse(dt.Substring(11, 2)),
                int.Parse(dt.Substring(14, 2)),
                int.Parse(dt.Substring(17, 2))).ToLocalTime();
        }

        public string GetLinuxBuild()
        {
            return sshLink.ExecuteCommand("uname -a");
        }

        public string Reboot()
        {
            return sshLink.ExecuteCommand("reboot");
        }

        private void CheckCreateRemoteFolder(string remotePath)
        {
            try
            {
                sshLink.ExecuteCommand("cd " + remotePath);
            }
            catch (Exception)
            {
                sshLink.ExecuteCommand("mkdir " + remotePath);
            }
        }

        public string Get_etc_phaseboard_serverip()
        {
            try
            {
                return sshLink.ReadTextFile("/etc/phaseboard/serverip");
            }
            catch (Exception ex)
            {
                return "";
            }
        }

        public void Set_etc_phaseboard_serverip(string content)
        {
            CheckCreateRemoteFolder("/etc/phaseboard/");
            sshLink.WriteTextFile("/etc/phaseboard/serverip", content);
        }

        public string Get_etc_phaseboard_debounce()
        {
            try
            {
                return sshLink.ReadTextFile("/etc/phaseboard/debounce");
            }
            catch (Exception ex)
            {
                return "";
            }
        }

        public void Set_etc_phaseboard_debounce(string content)
        {
            CheckCreateRemoteFolder("/etc/phaseboard/");
            sshLink.WriteTextFile("/etc/phaseboard/debounce", content);
        }

        public void Set_etc_dnsmasq_conf(string content) { sshLink.WriteTextFile("/etc/dnsmasq.conf", content); }

        public string Get_etc_dnsmasq_conf() { return sshLink.ReadTextFile("/etc/dnsmasq.conf"); }

        public void Set_etc_firewall_user(string content) { sshLink.WriteTextFile("/etc/firewall.user", content); }

        public string Get_etc_firewall_user() { return sshLink.ReadTextFile("/etc/firewall.user"); }

        public void Set_etc_inittab(string content) { sshLink.WriteTextFile("/etc/inittab", content); }

        public string Get_etc_inittab() { return sshLink.ReadTextFile("/etc/inittab"); }

        public void Set_etc_profile(string content) { sshLink.WriteTextFile("/etc/profile", content); }

        public string Get_etc_profile() { return sshLink.ReadTextFile("/etc/profile"); }

        public void Set_etc_protocols(string content) { sshLink.WriteTextFile("/etc/protocols", content); }

        public string Get_etc_protocols() { return sshLink.ReadTextFile("/etc/protocols"); }

        public void Set_etc_rc_local(string content) { sshLink.WriteTextFile("/etc/rc.local", content); }

        public string Get_etc_rc_local() { return sshLink.ReadTextFile("/etc/rc.local"); }

        public void Set_etc_resolv_conf(string content) { sshLink.WriteTextFile("/etc/resolv.conf", content); }

        public string Get_etc_resolv_conf() { return sshLink.ReadTextFile("/etc/resolv.conf"); }

        public void Set_etc_ser_2_net_conf(string content) { sshLink.WriteTextFile("/etc/ser2net.conf", content); }

        public string Get_etc_ser_2_net_conf() { return sshLink.ReadTextFile("/etc/ser2net.conf"); }

        public void Set_etc_services(string content) { sshLink.WriteTextFile("/etc/services", content); }

        public string Get_etc_services() { return sshLink.ReadTextFile("/etc/services"); }

        public void Set_etc_config_dhcp(string content) { sshLink.WriteTextFile("/etc/config/dhcp", content); }

        public string Get_etc_config_dhcp() { return sshLink.ReadTextFile("/etc/config/dhcp"); }

        public void Set_etc_config_firewall(string content) { sshLink.WriteTextFile("/etc/config/firewall", content); }

        public string Get_etc_config_firewall() { return sshLink.ReadTextFile("/etc/config/firewall"); }

        public void Set_etc_config_ntp_client(string content) { sshLink.WriteTextFile("/etc/config/ntpclient", content); }

        public string Get_etc_config_ntp_client() { return sshLink.ReadTextFile("/etc/config/ntpclient"); }

        public void Set_etc_config_network(string content) { sshLink.WriteTextFile("/etc/config/network", content); }

        public string Get_etc_config_network() { return sshLink.ReadTextFile("/etc/config/network"); }

        public void Set_etc_config_p910nd(string content) { sshLink.WriteTextFile("/etc/config/p910nd", content); }

        public string Get_etc_config_p910nd() { return sshLink.ReadTextFile("/etc/config/p910nd"); }

        public void Set_etc_config_wireless(string content) { sshLink.WriteTextFile("/etc/config/wireless", content); }

        public string Get_etc_config_wireless() { return sshLink.ReadTextFile("/etc/config/wireless"); }

    }
}
#endif
// file ...\IO\PhaseDeviceGateway.cs
#if !MOBILE && !CORE


namespace Zero5.IO
{
    class PhaseDeviceGateway
    {
        private SSH sshLink;

        public PhaseDeviceGateway(string ip, string username, string password)
        {
            sshLink = new SSH(ip, username, password);
        }

        public void UpdatePhaseboard(byte[] data)
        {
            string locale = System.IO.Path.GetTempFileName();
            System.IO.File.WriteAllBytes(locale, data);
            sshLink.UploadFile(locale, "/tmp/phaseboard.ipk");
            System.IO.File.Delete(locale);
            sshLink.ExecuteCommand("opkg install /tmp/phaseboard.ipk");
        }

        public void SendCommand(string command)
        {
            using (Renci.SshNet.SshClient ssh = new Renci.SshNet.SshClient(sshLink.ServerIP, sshLink.ServerUsername, sshLink.ServerPassword))
            {
                ssh.Connect();
                sshLink.ExecuteCommand(command);
                ssh.Disconnect();
                return;
            }
        }

        public void SendCommandAsAdmin(string command)
        {
            using (Renci.SshNet.SshClient ssh = new Renci.SshNet.SshClient(sshLink.ServerIP, sshLink.ServerUsername, sshLink.ServerPassword))
            {
                ssh.Connect();

                IDictionary<Renci.SshNet.Common.TerminalModes, uint> modes = new Dictionary<Renci.SshNet.Common.TerminalModes, uint>();
                modes.Add(Renci.SshNet.Common.TerminalModes.ECHO, 53);
                Renci.SshNet.ShellStream shellStream = ssh.CreateShellStream("xterm", 80, 24, 800, 600, 1024, modes);

                var output = shellStream.Expect(new System.Text.RegularExpressions.Regex(@"[$>]"));

                shellStream.WriteLine("sudo " + command);
                output = shellStream.Expect(new System.Text.RegularExpressions.Regex(@"([$#>:])"));
                shellStream.WriteLine(sshLink.ServerPassword);
                ssh.Disconnect();
                return;
            }
        }

        public void SetDate(DateTime dt)
        {
            DateTime dtStart = DateTime.Now;
            using (Renci.SshNet.SshClient ssh = new Renci.SshNet.SshClient(sshLink.ServerIP, sshLink.ServerUsername, sshLink.ServerPassword))
            {
                ssh.Connect();

                IDictionary<Renci.SshNet.Common.TerminalModes, uint> modes = new Dictionary<Renci.SshNet.Common.TerminalModes, uint>();
                modes.Add(Renci.SshNet.Common.TerminalModes.ECHO, 53);
                Renci.SshNet.ShellStream shellStream = ssh.CreateShellStream("xterm", 80, 24, 800, 600, 1024, modes);
                var output = shellStream.Expect(new System.Text.RegularExpressions.Regex(@"[$>]"));

                string command = "sudo date \"" + dt.AddMilliseconds((DateTime.Now - dtStart).TotalMilliseconds).ToString("MMddHHmmyyyy.ss") + "\"";
                shellStream.WriteLine(command);
                shellStream.Flush();
                Zero5.Util.Log.WriteLog("command: " + command);
                output = shellStream.Expect(new System.Text.RegularExpressions.Regex(@"([$#>:])"));
                shellStream.Flush();
                Zero5.Util.Log.WriteLog("output: " + output);
                shellStream.WriteLine(sshLink.ServerPassword);
                shellStream.Flush();
                string result = shellStream.ReadLine();
                Zero5.Util.Log.WriteLog("result: " + result);
                ssh.Disconnect();

                return;
            }
        }

        public DateTime GetDate()
        {
            string dt = sshLink.ExecuteCommand("date -u -Iseconds");
            //2016-01-26T14:31:43+0000
            //2016-01-26T14:31:43UTC

            return new DateTime(
                int.Parse(dt.Substring(0, 4)),
                int.Parse(dt.Substring(5, 2)),
                int.Parse(dt.Substring(8, 2)),
                int.Parse(dt.Substring(11, 2)),
                int.Parse(dt.Substring(14, 2)),
                int.Parse(dt.Substring(17, 2))).ToLocalTime();
        }

        public string GetLinuxBuild()
        {
            return sshLink.ExecuteCommand("uname -a");
        }

        public string Reboot()
        {
            return sshLink.ExecuteCommand("reboot");
        }

        private void CheckCreateRemoteFolder(string remotePath)
        {
            try
            {
                sshLink.ExecuteCommand("cd " + remotePath);
            }
            catch (Exception)
            {
                sshLink.ExecuteCommand("mkdir " + remotePath);
            }
        }

        public string Get_etc_phase_serverip()
        {
            try
            {
                return sshLink.ReadTextFile("/etc/phase/serverip");
            }
            catch (Exception ex)
            {
                return "";
            }
        }

        public string Get_etc_phase_serial()
        {
            try
            {
                return sshLink.ReadTextFile("/etc/phase/serial");
            }
            catch (Exception ex)
            {
                return "";
            }
        }

        public void Set_etc_phase_serverip(string content)
        {
            CheckCreateRemoteFolder("/etc/phase/");
            sshLink.WriteTextFile("/etc/phase/serverip", content);
        }

        public void UploadDataCollector(string localPath)
        {
            UploadFileToMainFolder(localPath);
        }

        public void UploadFileToMainFolder(string localPath)
        {
            CheckCreateRemoteFolder("/etc/phase/");
            sshLink.UploadFile(localPath, "/etc/phase/" + System.IO.Path.GetFileName(localPath));
        }

        public void UploadFileToMainFolder(string[] localPath)
        {
            CheckCreateRemoteFolder("/etc/phase/");
            foreach (string file in localPath)
                sshLink.UploadFile(file, "/etc/phase/" + System.IO.Path.GetFileName(file));
        }

        //public void Set_etc_dnsmasq_conf(string content) { sshLink.WriteTextFile("/etc/dnsmasq.conf", content); }

        //public string Get_etc_dnsmasq_conf() { return sshLink.ReadTextFile("/etc/dnsmasq.conf"); }

        //public void Set_etc_firewall_user(string content) { sshLink.WriteTextFile("/etc/firewall.user", content); }

        //public string Get_etc_firewall_user() { return sshLink.ReadTextFile("/etc/firewall.user"); }

        //public void Set_etc_inittab(string content) { sshLink.WriteTextFile("/etc/inittab", content); }

        //public string Get_etc_inittab() { return sshLink.ReadTextFile("/etc/inittab"); }

        //public void Set_etc_profile(string content) { sshLink.WriteTextFile("/etc/profile", content); }

        //public string Get_etc_profile() { return sshLink.ReadTextFile("/etc/profile"); }

        //public void Set_etc_protocols(string content) { sshLink.WriteTextFile("/etc/protocols", content); }

        //public string Get_etc_protocols() { return sshLink.ReadTextFile("/etc/protocols"); }

        //public void Set_etc_rc_local(string content) { sshLink.WriteTextFile("/etc/rc.local", content); }

        //public string Get_etc_rc_local() { return sshLink.ReadTextFile("/etc/rc.local"); }

        //public void Set_etc_resolv_conf(string content) { sshLink.WriteTextFile("/etc/resolv.conf", content); }

        //public string Get_etc_resolv_conf() { return sshLink.ReadTextFile("/etc/resolv.conf"); }

        //public void Set_etc_ser_2_net_conf(string content) { sshLink.WriteTextFile("/etc/ser2net.conf", content); }

        //public string Get_etc_ser_2_net_conf() { return sshLink.ReadTextFile("/etc/ser2net.conf"); }

        //public void Set_etc_services(string content) { sshLink.WriteTextFile("/etc/services", content); }

        //public string Get_etc_services() { return sshLink.ReadTextFile("/etc/services"); }

        //public void Set_etc_config_dhcp(string content) { sshLink.WriteTextFile("/etc/config/dhcp", content); }

        //public string Get_etc_config_dhcp() { return sshLink.ReadTextFile("/etc/config/dhcp"); }

        //public void Set_etc_config_firewall(string content) { sshLink.WriteTextFile("/etc/config/firewall", content); }

        //public string Get_etc_config_firewall() { return sshLink.ReadTextFile("/etc/config/firewall"); }

        //public void Set_etc_config_ntp_client(string content) { sshLink.WriteTextFile("/etc/config/ntpclient", content); }

        //public string Get_etc_config_ntp_client() { return sshLink.ReadTextFile("/etc/config/ntpclient"); }

        //public void Set_etc_config_network(string content) { sshLink.WriteTextFile("/etc/config/network", content); }

        //public string Get_etc_config_network() { return sshLink.ReadTextFile("/etc/config/network"); }

        //public void Set_etc_config_p910nd(string content) { sshLink.WriteTextFile("/etc/config/p910nd", content); }

        //public string Get_etc_config_p910nd() { return sshLink.ReadTextFile("/etc/config/p910nd"); }

        //public void Set_etc_config_wireless(string content) { sshLink.WriteTextFile("/etc/config/wireless", content); }

        //public string Get_etc_config_wireless() { return sshLink.ReadTextFile("/etc/config/wireless"); }

    }
}
#endif
// file ...\IO\Ping.cs
#if !MOBILE

namespace Zero5.IO
{
    public class Ping
    {
        public enum PingResult
        {
            Success = 1,
            Timeout = 2,
            Fail = 3
        }

        public static PingResult Test(string ip)
        {
            long timeout = 1000;
            return Test(ip, ref timeout);
        }

        public static PingResult Test(string ip, ref long timeout)
        {
            if (ip == "") return PingResult.Fail;
            System.Net.NetworkInformation.PingOptions options = new System.Net.NetworkInformation.PingOptions();
            options.DontFragment = true;
            options.Ttl = 128;
            
            byte[] bytes = new byte[] { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
                                        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
                                        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
                                        0x30, 0x31 };

            System.Net.NetworkInformation.Ping ping = new System.Net.NetworkInformation.Ping();
            System.Net.NetworkInformation.PingReply pingReply = ping.Send(ip, (int)timeout, bytes, options);
            timeout = pingReply.RoundtripTime;
            if (pingReply.Status == System.Net.NetworkInformation.IPStatus.Success)
                return PingResult.Success;
            else if (pingReply.Status == System.Net.NetworkInformation.IPStatus.TimedOut)
                return PingResult.Timeout;
            else
                return PingResult.Fail;
        }
    }
}
#endif
// file ...\IO\SSH.cs
#if !MOBILE && !CORE


namespace Zero5.IO
{
    class SSH
    {
        public string ServerIP;
        public string ServerUsername;
        public string ServerPassword;
        
        public SSH(string ip, string username, string password)
        {
            ServerIP = ip;
            ServerUsername = username;
            ServerPassword = password;
        }

        public void UploadFile(string locale, string remoto)
        {
            using (Renci.SshNet.ScpClient scp = new Renci.SshNet.ScpClient(ServerIP, ServerUsername, ServerPassword))
            {
                scp.Connect();
                scp.Upload(new System.IO.FileInfo(locale), remoto);
            }
        }

        public void DownloadFile(string remoto, string locale)
        {
            using (Renci.SshNet.ScpClient scp = new Renci.SshNet.ScpClient(ServerIP, ServerUsername, ServerPassword))
            {
                scp.Connect();
                scp.Download(remoto, new System.IO.FileInfo(locale));
            }            
        }

        public string ReadTextFile(string remoto)
        {
            string locale = System.IO.Path.GetTempFileName();
            DownloadFile(remoto, locale);
            string content = System.IO.File.ReadAllText(locale);
            System.IO.File.Delete(locale);
            return content.Replace("\n", "\r\n").Replace("\r\r\n", "\r\n");
        }

        public void WriteTextFile(string remoto, string content)
        {
            string locale = System.IO.Path.GetTempFileName();
            System.IO.File.WriteAllText(locale, content.Replace("\r\n", "\n"));
            this.UploadFile(locale, remoto);
            System.IO.File.Delete(locale);            
        }

        public string ExecuteCommand(string comando)
        {
            return ExecuteCommand(comando, 2000, "");
        }

        public string ExecuteCommand(string comando, int milliTimeout, string exitResultCondition)
        {
            using (Renci.SshNet.SshClient ssh = new Renci.SshNet.SshClient(ServerIP, ServerUsername, ServerPassword))
            {
                ssh.Connect();

                Renci.SshNet.SshCommand cmd = ssh.CreateCommand(comando);

                IAsyncResult asynch = cmd.BeginExecute(delegate(IAsyncResult ar) { }, null);

                DateTime dtLimitTimeout = DateTime.Now.AddMilliseconds(milliTimeout);

                System.IO.StreamReader reader = new System.IO.StreamReader(cmd.OutputStream);

                string resultComplete = "";
                while (!asynch.IsCompleted)
                {
                    if (DateTime.Now > dtLimitTimeout)
                        throw new TimeoutException();

                    string result = reader.ReadToEnd();
                    resultComplete += result;

                    if (exitResultCondition != "")
                        if (resultComplete.EndsWith(exitResultCondition))
                            break;
                }

                if (exitResultCondition != "" && resultComplete.EndsWith(exitResultCondition)) return resultComplete;
                
                if (cmd.Error != "") throw new Exception(cmd.Error);
                
                return resultComplete;
            }
        }

    }
}

#endif
// file ...\IO\Util.cs

namespace Zero5.IO
{
    public class Util
    {
        public static string LocalPath()
        {
#if !MOBILE && !CORE
            return System.Windows.Forms.Application.StartupPath;
#else
            return System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().GetModules()[0].FullyQualifiedName);
#endif
        }

        public static string LocalPathFile(string filename)
        {
            return LocalPathFile("", filename);
        }

        public static string LocalPathFile(string folder, string filename)
        {
            string path = LocalPath();

            if (folder != "") path += System.IO.Path.DirectorySeparatorChar + folder;

            return path + System.IO.Path.DirectorySeparatorChar + filename;
        }

#if !MOBILE && !CORE

        public static string LocalUserPath()
        {
            string path = System.Windows.Forms.Application.UserAppDataPath;
            path = path.Substring(0, path.LastIndexOf("\\"));
            path = path.Replace("Roaming", "Local");
            if (!System.IO.Directory.Exists(path)) System.IO.Directory.CreateDirectory(path);
            return path;
        }

        public static string LocalUserPathFile(string filename)
        {
            return LocalUserPathFile("", filename);
        }

        public static string LocalUserPathFile(string folder, string filename)
        {
            string path = LocalUserPath();

            if (folder != "") path += System.IO.Path.DirectorySeparatorChar + folder;

            return path + System.IO.Path.DirectorySeparatorChar + filename;
        }

        public static Version GetFileVersionByName(string filename)
        {
            System.Text.RegularExpressions.Match match = System.Text.RegularExpressions.Regex.Match(filename, "([0-9])+([\".\"]([0-9])+)*");
            string[] splitted = match.ToString().Split('.');
            int[] numbers = new int[4] { 0, 0, 0, 0 };
            if (splitted.Length > 0 && splitted[0] != "")
            {
                for (int i = 0; (i < splitted.Length && i < 4); i++)
                {
                    numbers[i] = int.Parse(splitted[i]);
                }
            }
            return new Version(numbers[0], numbers[1], numbers[2], numbers[3]);
        }

        public static byte[] GetFileMD5(string path)
        {
            using (var md5 = System.Security.Cryptography.MD5.Create())
            {
                using (var stream = System.IO.File.OpenRead(path))
                {
                    return md5.ComputeHash(stream);
                }
            }
        }

        public static String GetMD5(string content)
        {
            using (var md5 = System.Security.Cryptography.MD5.Create())
            {
                byte[] toByte = System.Text.Encoding.ASCII.GetBytes(content);
                byte[] hash = md5.ComputeHash(toByte);
                return System.Text.Encoding.ASCII.GetString(hash);
            }
        }

        public static string CleanPathAsShare(string path)
        {
            return System.IO.Path.DirectorySeparatorChar.ToString() + System.IO.Path.DirectorySeparatorChar.ToString() +
                    path.Split(System.IO.Path.DirectorySeparatorChar)[2] +
                    System.IO.Path.DirectorySeparatorChar.ToString() +
                    path.Split(System.IO.Path.DirectorySeparatorChar)[3];
        }

        public static string GetServerTempFileName()
        {
            string pathTemp = Zero5.IO.Util.LocalPath() + System.IO.Path.DirectorySeparatorChar + "Temp";
            if (!System.IO.Directory.Exists(pathTemp)) System.IO.Directory.CreateDirectory(pathTemp);
            return pathTemp + System.IO.Path.DirectorySeparatorChar + "TMP" + DateTime.Now.Ticks.ToString() + "_" + System.Threading.Thread.CurrentThread.ManagedThreadId.ToString() + ".tmp";
        }
#endif
    }
}

// file ...\IO\File\NetMapper.cs

namespace Zero5.IO.File
{
    public class NetMapper :
        IDisposable
    {
        private string _path = "";

        public NetMapper(
            string path,
            string userName,
            string domainName,
            string password)
        {
            _path = PinvokeWindowsNetworking.clearPathToMap(path);

            //checks
            if (!_path.StartsWith("\\\\")) _path = "";
            if (userName == "") _path = "";
            if (domainName != "") userName = domainName + "\\" + userName;

            if (_path == "") return;

            string resultResetMapping = PinvokeWindowsNetworking.disconnectRemote(_path, true);
            string resultMapping = PinvokeWindowsNetworking.connectToRemote(_path, userName, password, true);
            if (resultMapping != null)
            {
                if (resultResetMapping == null)
                    throw new Exception("Mapper error: " + resultMapping);
                else
                {
                    //if (resultResetMapping == "Error: Not Connected" && resultMapping.EndsWith("1219"))
                    //{
                    //    System.Diagnostics.Process ps = new System.Diagnostics.Process();
                    //    ps.StartInfo.FileName = "cmd.exe";
                    //    ps.StartInfo.Arguments = "/C net use " + _path + " /DELETE";
                    //    ps.Start();
                    //}
                    throw new Exception("Mapper error: " + resultMapping + "\r\n" +
                                        "Mapper reset error: " + resultResetMapping);
                }
            }
        }


        public void Dispose()
        {
            if (_path != "") PinvokeWindowsNetworking.disconnectRemote(_path);

        }

    }
}
// file ...\IO\File\PinvokeWindowsNetworking.cs

namespace Zero5.IO.File
{
	public class PinvokeWindowsNetworking
	{
		#region Consts
		const int RESOURCE_CONNECTED = 0x00000001;
		const int RESOURCE_GLOBALNET = 0x00000002;
		const int RESOURCE_REMEMBERED = 0x00000003;

		const int RESOURCETYPE_ANY = 0x00000000;
		const int RESOURCETYPE_DISK = 0x00000001;
		const int RESOURCETYPE_PRINT = 0x00000002;

		const int RESOURCEDISPLAYTYPE_GENERIC = 0x00000000;
		const int RESOURCEDISPLAYTYPE_DOMAIN = 0x00000001;
		const int RESOURCEDISPLAYTYPE_SERVER = 0x00000002;
		const int RESOURCEDISPLAYTYPE_SHARE = 0x00000003;
		const int RESOURCEDISPLAYTYPE_FILE = 0x00000004;
		const int RESOURCEDISPLAYTYPE_GROUP = 0x00000005;

		const int RESOURCEUSAGE_CONNECTABLE = 0x00000001;
		const int RESOURCEUSAGE_CONTAINER = 0x00000002;


		const int CONNECT_INTERACTIVE = 0x00000008;
		const int CONNECT_PROMPT = 0x00000010;
		const int CONNECT_REDIRECT = 0x00000080;
		const int CONNECT_UPDATE_PROFILE = 0x00000001;
		const int CONNECT_COMMANDLINE = 0x00000800;
		const int CONNECT_CMD_SAVECRED = 0x00001000;

		const int CONNECT_LOCALDRIVE = 0x00000100;
		#endregion

		#region Errors
		const int NO_ERROR = 0;

		const int ERROR_ACCESS_DENIED = 5;
		const int ERROR_ALREADY_ASSIGNED = 85;
		const int ERROR_BAD_DEVICE = 1200;
		const int ERROR_BAD_NET_NAME = 67;
		const int ERROR_BAD_PROVIDER = 1204;
		const int ERROR_CANCELLED = 1223;
		const int ERROR_EXTENDED_ERROR = 1208;
		const int ERROR_INVALID_ADDRESS = 487;
		const int ERROR_INVALID_PARAMETER = 87;
		const int ERROR_INVALID_PASSWORD = 1216;
		const int ERROR_MORE_DATA = 234;
		const int ERROR_NO_MORE_ITEMS = 259;
		const int ERROR_NO_NET_OR_BAD_PATH = 1203;
		const int ERROR_NO_NETWORK = 1222;

		const int ERROR_BAD_PROFILE = 1206;
		const int ERROR_CANNOT_OPEN_PROFILE = 1205;
		const int ERROR_DEVICE_IN_USE = 2404;
		const int ERROR_NOT_CONNECTED = 2250;
		const int ERROR_OPEN_FILES  = 2401;

		private struct ErrorClass 
		{
			public int num;
			public string message;
			public ErrorClass(int num, string message) 
			{
				this.num = num;
				this.message = message;
			}
		}


		// Created with excel formula:
		// ="new ErrorClass("&A1&", """&PROPER(SUBSTITUTE(MID(A1,7,LEN(A1)-6), "_", " "))&"""), "
		private static ErrorClass[] ERROR_LIST = new ErrorClass[] {
			new ErrorClass(ERROR_ACCESS_DENIED, "Error: Access Denied"), 
			new ErrorClass(ERROR_ALREADY_ASSIGNED, "Error: Already Assigned"), 
			new ErrorClass(ERROR_BAD_DEVICE, "Error: Bad Device"), 
			new ErrorClass(ERROR_BAD_NET_NAME, "Error: Bad Net Name"), 
			new ErrorClass(ERROR_BAD_PROVIDER, "Error: Bad Provider"), 
			new ErrorClass(ERROR_CANCELLED, "Error: Cancelled"), 
			new ErrorClass(ERROR_EXTENDED_ERROR, "Error: Extended Error"), 
			new ErrorClass(ERROR_INVALID_ADDRESS, "Error: Invalid Address"), 
			new ErrorClass(ERROR_INVALID_PARAMETER, "Error: Invalid Parameter"), 
			new ErrorClass(ERROR_INVALID_PASSWORD, "Error: Invalid Password"), 
			new ErrorClass(ERROR_MORE_DATA, "Error: More Data"), 
			new ErrorClass(ERROR_NO_MORE_ITEMS, "Error: No More Items"), 
			new ErrorClass(ERROR_NO_NET_OR_BAD_PATH, "Error: No Net Or Bad Path"), 
			new ErrorClass(ERROR_NO_NETWORK, "Error: No Network"), 
			new ErrorClass(ERROR_BAD_PROFILE, "Error: Bad Profile"), 
			new ErrorClass(ERROR_CANNOT_OPEN_PROFILE, "Error: Cannot Open Profile"), 
			new ErrorClass(ERROR_DEVICE_IN_USE, "Error: Device In Use"), 
			new ErrorClass(ERROR_EXTENDED_ERROR, "Error: Extended Error"), 
			new ErrorClass(ERROR_NOT_CONNECTED, "Error: Not Connected"), 
			new ErrorClass(ERROR_OPEN_FILES, "Error: Open Files"), 
		};

		private static string getErrorForNumber(int errNum) 
		{
			foreach (ErrorClass er in ERROR_LIST) 
			{
				if (er.num == errNum) return er.message;
			}
			return "Error: Unknown, " + errNum;
		}
		#endregion

		[DllImport("Mpr.dll")] private static extern int WNetUseConnection(
			IntPtr hwndOwner,
			NETRESOURCE lpNetResource,
			string lpPassword,
			string lpUserID,
			int dwFlags,
			string lpAccessName,
			string lpBufferSize,
			string lpResult
		);

		[DllImport("Mpr.dll")] private static extern int WNetCancelConnection2(
			string lpName,
			int dwFlags,
			bool fForce
		);

		[StructLayout(LayoutKind.Sequential)] private class NETRESOURCE
		{ 
			public int dwScope = 0;
			public int dwType = 0;
			public int dwDisplayType = 0;
			public int dwUsage = 0;
			public string lpLocalName = "";
			public string lpRemoteName = "";
			public string lpComment = "";
			public string lpProvider = "";
		}

        public static string connectToRemote(string remoteUNC, string username, string password) 
		{
			return connectToRemote(remoteUNC, username, password, false, false);
		}

        public static string connectToRemote(string remoteUNC, string username, string password, bool ignoreAlreadyMapped)
        {
            return connectToRemote(remoteUNC, username, password, ignoreAlreadyMapped, false);
        }

        public static string connectToRemote(string remoteUNC, string username, string password, bool ignoreAlreadyMapped, bool promptUser) 
		{
			NETRESOURCE nr = new NETRESOURCE();
			nr.dwType = RESOURCETYPE_DISK;
			nr.lpRemoteName = remoteUNC;
			//			nr.lpLocalName = "F:";

            if (password == "") password = null; //fix empty password

			int ret;
			if (promptUser) 
				ret = WNetUseConnection(IntPtr.Zero, nr, "", "", CONNECT_INTERACTIVE | CONNECT_PROMPT, null, null, null);
			else 
				ret = WNetUseConnection(IntPtr.Zero, nr, password, username, 0, null, null, null);

			if (ret == NO_ERROR) return null;
            if (ret == 1219 && ignoreAlreadyMapped) return null;

			return getErrorForNumber(ret);
		}

		public static string disconnectRemote(string remoteUNC) 
		{
            return disconnectRemote(remoteUNC, false);
		}

        public static string disconnectRemote(string remoteUNC, bool force)
        {
            int ret = WNetCancelConnection2(remoteUNC, CONNECT_UPDATE_PROFILE, force);
            if (ret == NO_ERROR) return null;
            return getErrorForNumber(ret);
        }

        public static string clearPathToMap(string path)
        {
            string path_to_map = "";

            int slashcount = 0;

            for (int i = 0; i < path.Length; i++)
            {
                if (path[i] == '\\') slashcount++;
                if (slashcount > 3) break;
                path_to_map += path[i].ToString();
            }

            return path_to_map;
        }
	}
}
// file ...\IO\File\Csv\CachedCsvReader.cs
//	Zero5.IO.File.CSV.CachedCsvReader
//	Copyright (c) 2005 S�bastien Lorion
//
//	MIT license (http://en.wikipedia.org/wiki/MIT_License)
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights 
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//	of the Software, and to permit persons to whom the Software is furnished to do so, 
//	subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all 
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
//	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//	PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
//	FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#if !MOBILE


namespace Zero5.IO.File.Csv
{
	/// <summary>
	/// Represents a reader that provides fast, cached, dynamic access to CSV data.
	/// </summary>
	/// <remarks>The number of records is limited to <see cref="System.Int32.MaxValue"/> - 1.</remarks>
	public partial class CachedCsvReader
		: CsvReader, IListSource
	{
		#region Fields

		/// <summary>
		/// Contains the cached records.
		/// </summary>
		private List<string[]> _records;

		/// <summary>
		/// Contains the current record index (inside the cached records array).
		/// </summary>
		private long _currentRecordIndex;

		/// <summary>
		/// Indicates if a new record is being read from the CSV stream.
		/// </summary>
		private bool _readingStream;

		/// <summary>
		/// Contains the binding list linked to this reader.
		/// </summary>
		private CsvBindingList _bindingList;

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the CsvReader class.
		/// </summary>
		/// <param name="reader">A <see cref="T:TextReader"/> pointing to the CSV file.</param>
		/// <param name="hasHeaders"><see langword="true"/> if field names are located on the first non commented line, otherwise, <see langword="false"/>.</param>
		/// <exception cref="T:ArgumentNullException">
		///		<paramref name="reader"/> is a <see langword="null"/>.
		/// </exception>
		/// <exception cref="T:ArgumentException">
		///		Cannot read from <paramref name="reader"/>.
		/// </exception>
		public CachedCsvReader(TextReader reader, bool hasHeaders)
			: this(reader, hasHeaders, DefaultBufferSize)
		{
		}

		/// <summary>
		/// Initializes a new instance of the CsvReader class.
		/// </summary>
		/// <param name="reader">A <see cref="T:TextReader"/> pointing to the CSV file.</param>
		/// <param name="hasHeaders"><see langword="true"/> if field names are located on the first non commented line, otherwise, <see langword="false"/>.</param>
		/// <param name="bufferSize">The buffer size in bytes.</param>
		/// <exception cref="T:ArgumentNullException">
		///		<paramref name="reader"/> is a <see langword="null"/>.
		/// </exception>
		/// <exception cref="T:ArgumentException">
		///		Cannot read from <paramref name="reader"/>.
		/// </exception>
		public CachedCsvReader(TextReader reader, bool hasHeaders, int bufferSize)
			: this(reader, hasHeaders, DefaultDelimiter, DefaultQuote, DefaultEscape, DefaultComment, ValueTrimmingOptions.UnquotedOnly, bufferSize)
		{
		}

		/// <summary>
		/// Initializes a new instance of the CsvReader class.
		/// </summary>
		/// <param name="reader">A <see cref="T:TextReader"/> pointing to the CSV file.</param>
		/// <param name="hasHeaders"><see langword="true"/> if field names are located on the first non commented line, otherwise, <see langword="false"/>.</param>
		/// <param name="delimiter">The delimiter character separating each field (default is ',').</param>
		/// <exception cref="T:ArgumentNullException">
		///		<paramref name="reader"/> is a <see langword="null"/>.
		/// </exception>
		/// <exception cref="T:ArgumentException">
		///		Cannot read from <paramref name="reader"/>.
		/// </exception>
		public CachedCsvReader(TextReader reader, bool hasHeaders, char delimiter)
			: this(reader, hasHeaders, delimiter, DefaultQuote, DefaultEscape, DefaultComment, ValueTrimmingOptions.UnquotedOnly, DefaultBufferSize)
		{
		}

		/// <summary>
		/// Initializes a new instance of the CsvReader class.
		/// </summary>
		/// <param name="reader">A <see cref="T:TextReader"/> pointing to the CSV file.</param>
		/// <param name="hasHeaders"><see langword="true"/> if field names are located on the first non commented line, otherwise, <see langword="false"/>.</param>
		/// <param name="delimiter">The delimiter character separating each field (default is ',').</param>
		/// <param name="bufferSize">The buffer size in bytes.</param>
		/// <exception cref="T:ArgumentNullException">
		///		<paramref name="reader"/> is a <see langword="null"/>.
		/// </exception>
		/// <exception cref="T:ArgumentException">
		///		Cannot read from <paramref name="reader"/>.
		/// </exception>
		public CachedCsvReader(TextReader reader, bool hasHeaders, char delimiter, int bufferSize)
			: this(reader, hasHeaders, delimiter, DefaultQuote, DefaultEscape, DefaultComment, ValueTrimmingOptions.UnquotedOnly, bufferSize)
		{
		}

		/// <summary>
		/// Initializes a new instance of the CsvReader class.
		/// </summary>
		/// <param name="reader">A <see cref="T:TextReader"/> pointing to the CSV file.</param>
		/// <param name="hasHeaders"><see langword="true"/> if field names are located on the first non commented line, otherwise, <see langword="false"/>.</param>
		/// <param name="delimiter">The delimiter character separating each field (default is ',').</param>
		/// <param name="quote">The quotation character wrapping every field (default is ''').</param>
		/// <param name="escape">
		/// The escape character letting insert quotation characters inside a quoted field (default is '\').
		/// If no escape character, set to '\0' to gain some performance.
		/// </param>
		/// <param name="comment">The comment character indicating that a line is commented out (default is '#').</param>
		/// <param name="trimmingOptions">Determines how values should be trimmed.</param>
		/// <exception cref="T:ArgumentNullException">
		///		<paramref name="reader"/> is a <see langword="null"/>.
		/// </exception>
		/// <exception cref="T:ArgumentException">
		///		Cannot read from <paramref name="reader"/>.
		/// </exception>
		public CachedCsvReader(TextReader reader, bool hasHeaders, char delimiter, char quote, char escape, char comment, ValueTrimmingOptions trimmingOptions)
			: this(reader, hasHeaders, delimiter, quote, escape, comment, trimmingOptions, DefaultBufferSize)
		{
		}

		/// <summary>
		/// Initializes a new instance of the CsvReader class.
		/// </summary>
		/// <param name="reader">A <see cref="T:TextReader"/> pointing to the CSV file.</param>
		/// <param name="hasHeaders"><see langword="true"/> if field names are located on the first non commented line, otherwise, <see langword="false"/>.</param>
		/// <param name="delimiter">The delimiter character separating each field (default is ',').</param>
		/// <param name="quote">The quotation character wrapping every field (default is ''').</param>
		/// <param name="escape">
		/// The escape character letting insert quotation characters inside a quoted field (default is '\').
		/// If no escape character, set to '\0' to gain some performance.
		/// </param>
		/// <param name="comment">The comment character indicating that a line is commented out (default is '#').</param>
		/// <param name="trimSpaces"><see langword="true"/> if spaces at the start and end of a field are trimmed, otherwise, <see langword="false"/>. Default is <see langword="true"/>.</param>
		/// <param name="bufferSize">The buffer size in bytes.</param>
		/// <exception cref="T:ArgumentNullException">
		///		<paramref name="reader"/> is a <see langword="null"/>.
		/// </exception>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<paramref name="bufferSize"/> must be 1 or more.
		/// </exception>
		public CachedCsvReader(TextReader reader, bool hasHeaders, char delimiter, char quote, char escape, char comment, ValueTrimmingOptions trimmingOptions, int bufferSize)
			: base(reader, hasHeaders, delimiter, quote, escape, comment, trimmingOptions, bufferSize)
		{
			_records = new List<string[]>();
			_currentRecordIndex = -1;
		}

		#endregion

		#region Properties

		#region State

		/// <summary>
		/// Gets the current record index in the CSV file.
		/// </summary>
		/// <value>The current record index in the CSV file.</value>
		public override long CurrentRecordIndex
		{
			get
			{
				return _currentRecordIndex;
			}
		}

		/// <summary>
		/// Gets a value that indicates whether the current stream position is at the end of the stream.
		/// </summary>
		/// <value><see langword="true"/> if the current stream position is at the end of the stream; otherwise <see langword="false"/>.</value>
		public override bool EndOfStream
		{
			get
			{
				if (_currentRecordIndex < base.CurrentRecordIndex)
					return false;
				else
					return base.EndOfStream;
			}
		}

		#endregion

		#endregion

		#region Indexers

		/// <summary>
		/// Gets the field at the specified index.
		/// </summary>
		/// <value>The field at the specified index.</value>
		/// <exception cref="T:ArgumentOutOfRangeException">
		///		<paramref name="field"/> must be included in [0, <see cref="M:FieldCount"/>[.
		/// </exception>
		/// <exception cref="T:InvalidOperationException">
		///		No record read yet. Call ReadLine() first.
		/// </exception>
		/// <exception cref="MissingFieldCsvException">
		///		The CSV data appears to be missing a field.
		/// </exception>
		/// <exception cref="T:MalformedCsvException">
		///		The CSV appears to be corrupt at the current position.
		/// </exception>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///		The instance has been disposed of.
		/// </exception>
		public override String this[int field]
		{
			get
			{
				if (_readingStream)
					return base[field];
				else if (_currentRecordIndex > -1)
				{
					if (field > -1 && field < this.FieldCount)
						return _records[(int) _currentRecordIndex][field];
					else
						throw new ArgumentOutOfRangeException("field", field, string.Format(CultureInfo.InvariantCulture, ExceptionMessage.FieldIndexOutOfRange, field));
				}
				else
					throw new InvalidOperationException(ExceptionMessage.NoCurrentRecord);
			}
		}

		#endregion

		#region Methods

		#region Read

		/// <summary>
		/// Reads the CSV stream from the current position to the end of the stream.
		/// </summary>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		public virtual void ReadToEnd()
		{
			_currentRecordIndex = base.CurrentRecordIndex;

			while (ReadNextRecord()) ;
		}

		/// <summary>
		/// Reads the next record.
		/// </summary>
		/// <param name="onlyReadHeaders">
		/// Indicates if the reader will proceed to the next record after having read headers.
		/// <see langword="true"/> if it stops after having read headers; otherwise, <see langword="false"/>.
		/// </param>
		/// <param name="skipToNextLine">
		/// Indicates if the reader will skip directly to the next line without parsing the current one. 
		/// To be used when an error occurs.
		/// </param>
		/// <returns><see langword="true"/> if a record has been successfully reads; otherwise, <see langword="false"/>.</returns>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		protected override bool ReadNextRecord(bool onlyReadHeaders, bool skipToNextLine)
		{
			if (_currentRecordIndex < base.CurrentRecordIndex)
			{
				_currentRecordIndex++;
				return true;
			}
			else
			{
				_readingStream = true;

				try
				{
					bool canRead = base.ReadNextRecord(onlyReadHeaders, skipToNextLine);

					if (canRead)
					{
						string[] record = new string[this.FieldCount];

						if (base.CurrentRecordIndex > -1)
						{
							CopyCurrentRecordTo(record);
							_records.Add(record);
						}
						else
						{
							if (MoveTo(0))
								CopyCurrentRecordTo(record);

							MoveTo(-1);
						}

						if (!onlyReadHeaders)
							_currentRecordIndex++;
					}
					else
					{
						// No more records to read, so set array size to only what is needed
						_records.Capacity = _records.Count;
					}

					return canRead;
				}
				finally
				{
					_readingStream = false;
				}
			}
		}

		#endregion

		#region Move

		/// <summary>
		/// Moves before the first record.
		/// </summary>
		public void MoveToStart()
		{
			_currentRecordIndex = -1;
		}

		/// <summary>
		/// Moves to the last record read so far.
		/// </summary>
		public void MoveToLastCachedRecord()
		{
			_currentRecordIndex = base.CurrentRecordIndex;
		}

		/// <summary>
		/// Moves to the specified record index.
		/// </summary>
		/// <param name="record">The record index.</param>
		/// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///		The instance has been disposed of.
		/// </exception>
		public override bool MoveTo(long record)
		{
			if (record < -1)
				record = -1;

			if (record <= base.CurrentRecordIndex)
			{
				_currentRecordIndex = record;
				return true;
			}
			else
			{
				_currentRecordIndex = base.CurrentRecordIndex;
				return base.MoveTo(record);
			}
		}

		#endregion

		#endregion

		#region IListSource Members

		bool IListSource.ContainsListCollection
		{
			get { return false; }
		}

		System.Collections.IList IListSource.GetList()
		{
			if (_bindingList == null)
				_bindingList = new CsvBindingList(this);

			return _bindingList;
		}

		#endregion
	}
}

#endif
// file ...\IO\File\Csv\CachedCsvReader.CsvBindingList.cs
//	Zero5.IO.File.CSV.CachedCsvReader.CsvBindingList
//	Copyright (c) 2006 S�bastien Lorion
//
//	MIT license (http://en.wikipedia.org/wiki/MIT_License)
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights 
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//	of the Software, and to permit persons to whom the Software is furnished to do so, 
//	subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all 
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
//	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//	PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
//	FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#if !MOBILE

namespace Zero5.IO.File.Csv
{
	public partial class CachedCsvReader
		: CsvReader
	{
		/// <summary>
		/// Represents a binding list wrapper for a CSV reader.
		/// </summary>
		private class CsvBindingList
			: IBindingList, ITypedList, IList<string[]>, IList
		{
			#region Fields

			/// <summary>
			/// Contains the linked CSV reader.
			/// </summary>
			private CachedCsvReader _csv;

			/// <summary>
			/// Contains the cached record count.
			/// </summary>
			private int _count;

			/// <summary>
			/// Contains the cached property descriptors.
			/// </summary>
			private PropertyDescriptorCollection _properties;

			/// <summary>
			/// Contains the current sort property.
			/// </summary>
			private CsvPropertyDescriptor _sort;

			/// <summary>
			/// Contains the current sort direction.
			/// </summary>
			private ListSortDirection _direction;

			#endregion

			#region Constructors

			/// <summary>
			/// Initializes a new instance of the CsvBindingList class.
			/// </summary>
			/// <param name="csv"></param>
			public CsvBindingList(CachedCsvReader csv)
			{
				_csv = csv;
				_count = -1;
				_direction = ListSortDirection.Ascending;
			}

			#endregion

			#region IBindingList members

			public void AddIndex(PropertyDescriptor property)
			{
			}

			public bool AllowNew
			{
				get
				{
					return false;
				}
			}

			public void ApplySort(PropertyDescriptor property, System.ComponentModel.ListSortDirection direction)
			{
				_sort = (CsvPropertyDescriptor) property;
				_direction = direction;

				_csv.ReadToEnd();

				_csv._records.Sort(new CsvRecordComparer(_sort.Index, _direction));
			}

			public PropertyDescriptor SortProperty
			{
				get
				{
					return _sort;
				}
			}

			public int Find(PropertyDescriptor property, object key)
			{
				int fieldIndex = ((CsvPropertyDescriptor) property).Index;
				string value = (string) key;

				int recordIndex = 0;
				int count = this.Count;

				while (recordIndex < count && _csv[recordIndex, fieldIndex] != value)
					recordIndex++;

				if (recordIndex == count)
					return -1;
				else
					return recordIndex;
			}

			public bool SupportsSorting
			{
				get
				{
					return true;
				}
			}

			public bool IsSorted
			{
				get
				{
					return _sort != null;
				}
			}

			public bool AllowRemove
			{
				get
				{
					return false;
				}
			}

			public bool SupportsSearching
			{
				get
				{
					return true;
				}
			}

			public System.ComponentModel.ListSortDirection SortDirection
			{
				get
				{
					return _direction;
				}
			}

			public event System.ComponentModel.ListChangedEventHandler ListChanged
			{
				add { }
				remove { }
			}

			public bool SupportsChangeNotification
			{
				get
				{
					return false;
				}
			}

			public void RemoveSort()
			{
				_sort = null;
				_direction = ListSortDirection.Ascending;
			}

			public object AddNew()
			{
				throw new NotSupportedException();
			}

			public bool AllowEdit
			{
				get
				{
					return false;
				}
			}

			public void RemoveIndex(PropertyDescriptor property)
			{
			}

			#endregion

			#region ITypedList Members

			public PropertyDescriptorCollection GetItemProperties(PropertyDescriptor[] listAccessors)
			{
				if (_properties == null)
				{
					PropertyDescriptor[] properties = new PropertyDescriptor[_csv.FieldCount];

					for (int i = 0; i < properties.Length; i++)
						properties[i] = new CsvPropertyDescriptor(((System.Data.IDataReader) _csv).GetName(i), i);

					_properties = new PropertyDescriptorCollection(properties);
				}

				return _properties;
			}

			public string GetListName(PropertyDescriptor[] listAccessors)
			{
				return string.Empty;
			}

			#endregion

			#region IList<string[]> Members

			public int IndexOf(string[] item)
			{
				throw new NotSupportedException();
			}

			public void Insert(int index, string[] item)
			{
				throw new NotSupportedException();
			}

			public void RemoveAt(int index)
			{
				throw new NotSupportedException();
			}

			public string[] this[int index]
			{
				get
				{
					_csv.MoveTo(index);
					return _csv._records[index];
				}
				set
				{
					throw new NotSupportedException();
				}
			}

			#endregion

			#region ICollection<string[]> Members

			public void Add(string[] item)
			{
				throw new NotSupportedException();
			}

			public void Clear()
			{
				throw new NotSupportedException();
			}

			public bool Contains(string[] item)
			{
				throw new NotSupportedException();
			}

			public void CopyTo(string[][] array, int arrayIndex)
			{
				_csv.MoveToStart();

				while (_csv.ReadNextRecord())
					_csv.CopyCurrentRecordTo(array[arrayIndex++]);
			}

			public int Count
			{
				get
				{
					if (_count < 0)
					{
						_csv.ReadToEnd();
						_count = (int) _csv.CurrentRecordIndex + 1;
					}

					return _count;
				}
			}

			public bool IsReadOnly
			{
				get { return true; }
			}

			public bool Remove(string[] item)
			{
				throw new NotSupportedException();
			}

			#endregion

			#region IEnumerable<string[]> Members

			public IEnumerator<string[]> GetEnumerator()
			{
				return _csv.GetEnumerator();
			}

			#endregion

			#region IList Members

			public int Add(object value)
			{
				throw new NotSupportedException();
			}

			public bool Contains(object value)
			{
				throw new NotSupportedException();
			}

			public int IndexOf(object value)
			{
				throw new NotSupportedException();
			}

			public void Insert(int index, object value)
			{
				throw new NotSupportedException();
			}

			public bool IsFixedSize
			{
				get { return true; }
			}

			public void Remove(object value)
			{
				throw new NotSupportedException();
			}

			object IList.this[int index]
			{
				get
				{
					return this[index];
				}
				set
				{
					throw new NotSupportedException();
				}
			}

			#endregion

			#region ICollection Members

			public void CopyTo(Array array, int index)
			{
				_csv.MoveToStart();

				while (_csv.ReadNextRecord())
					_csv.CopyCurrentRecordTo((string[]) array.GetValue(index++));
			}

			public bool IsSynchronized
			{
				get { return false; }
			}

			public object SyncRoot
			{
				get { return null; }
			}

			#endregion

			#region IEnumerable Members

			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return this.GetEnumerator();
			}

			#endregion
		}
	}
}
#endif
// file ...\IO\File\Csv\CachedCsvReader.CsvPropertyDescriptor.cs
//	Zero5.IO.File.CSV.CachedCsvReader.CsvPropertyDescriptor
//	Copyright (c) 2006 S�bastien Lorion
//
//	MIT license (http://en.wikipedia.org/wiki/MIT_License)
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights 
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//	of the Software, and to permit persons to whom the Software is furnished to do so, 
//	subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all 
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
//	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//	PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
//	FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#if !MOBILE

namespace Zero5.IO.File.Csv
{
	public partial class CachedCsvReader
		: CsvReader
	{
		/// <summary>
		/// Represents a CSV field property descriptor.
		/// </summary>
		private class CsvPropertyDescriptor
			: PropertyDescriptor
		{
			#region Fields

			/// <summary>
			/// Contains the field index.
			/// </summary>
			private int _index;

			#endregion

			#region Constructors

			/// <summary>
			/// Initializes a new instance of the CsvPropertyDescriptor class.
			/// </summary>
			/// <param name="fieldName">The field name.</param>
			/// <param name="index">The field index.</param>
			public CsvPropertyDescriptor(string fieldName, int index)
				: base(fieldName, null)
			{
				_index = index;
			}

			#endregion

			#region Properties

			/// <summary>
			/// Gets the field index.
			/// </summary>
			/// <value>The field index.</value>
			public int Index
			{
				get { return _index; }
			}

			#endregion

			#region Overrides

			public override bool CanResetValue(object component)
			{
				return false;
			}

			public override object GetValue(object component)
			{
				return ((string[]) component)[_index];
			}

			public override void ResetValue(object component)
			{
			}

			public override void SetValue(object component, object value)
			{
			}

			public override bool ShouldSerializeValue(object component)
			{
				return false;
			}

			public override Type ComponentType
			{
				get
				{
					return typeof(CachedCsvReader);
				}
			}

			public override bool IsReadOnly
			{
				get
				{
					return true;
				}
			}

			public override Type PropertyType
			{
				get
				{
					return typeof(string);
				}
			}

			#endregion
		}
	}
}

#endif
// file ...\IO\File\Csv\CachedCsvReader.CsvRecordComparer.cs
//	Zero5.IO.File.CSV.CachedCsvReader.CsvRecordComparer
//	Copyright (c) 2006 S�bastien Lorion
//
//	MIT license (http://en.wikipedia.org/wiki/MIT_License)
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights 
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//	of the Software, and to permit persons to whom the Software is furnished to do so, 
//	subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all 
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
//	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//	PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
//	FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#if !MOBILE

namespace Zero5.IO.File.Csv
{
	public partial class CachedCsvReader
		: CsvReader
	{
		/// <summary>
		/// Represents a CSV record comparer.
		/// </summary>
		private class CsvRecordComparer
			: IComparer<string[]>
		{
			#region Fields

			/// <summary>
			/// Contains the field index of the values to compare.
			/// </summary>
			private int _field;

			/// <summary>
			/// Contains the sort direction.
			/// </summary>
			private ListSortDirection _direction;

			#endregion

			#region Constructors

			/// <summary>
			/// Initializes a new instance of the CsvRecordComparer class.
			/// </summary>
			/// <param name="field">The field index of the values to compare.</param>
			/// <param name="direction">The sort direction.</param>
			public CsvRecordComparer(int field, ListSortDirection direction)
			{
				if (field < 0)
					throw new ArgumentOutOfRangeException("field", field, string.Format(CultureInfo.InvariantCulture, Resources.ExceptionMessage.FieldIndexOutOfRange, field));

				_field = field;
				_direction = direction;
			}

			#endregion

			#region IComparer<string[]> Members

			public int Compare(string[] x, string[] y)
			{
				Debug.Assert(x != null && y != null && x.Length == y.Length && _field < x.Length);

				int result = String.Compare(x[_field], y[_field], StringComparison.CurrentCulture);

				return (_direction == ListSortDirection.Ascending ? result : -result);
			}

			#endregion
		}
	}
}
#endif
// file ...\IO\File\Csv\CsvReader.cs
//	Zero5.IO.File.CSV.CsvReader
//	Copyright (c) 2005 S�bastien Lorion
//
//	MIT license (http://en.wikipedia.org/wiki/MIT_License)
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights 
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//	of the Software, and to permit persons to whom the Software is furnished to do so, 
//	subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all 
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
//	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//	PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
//	FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#if !MOBILE


namespace Zero5.IO.File.Csv
{
	/// <summary>
	/// Represents a reader that provides fast, non-cached, forward-only access to CSV data.  
	/// </summary>
	public partial class CsvReader
		: IDataReader, IEnumerable<string[]>, IDisposable
	{
		#region Constants

		/// <summary>
		/// Defines the default buffer size.
		/// </summary>
		public const int DefaultBufferSize = 0x1000;

		/// <summary>
		/// Defines the default delimiter character separating each field.
		/// </summary>
		public const char DefaultDelimiter = ',';

		/// <summary>
		/// Defines the default quote character wrapping every field.
		/// </summary>
		public const char DefaultQuote = '"';

		/// <summary>
		/// Defines the default escape character letting insert quotation characters inside a quoted field.
		/// </summary>
		public const char DefaultEscape = '"';

		/// <summary>
		/// Defines the default comment character indicating that a line is commented out.
		/// </summary>
		public const char DefaultComment = '#';

		#endregion

		#region Fields

		/// <summary>
		/// Contains the field header comparer.
		/// </summary>
		private static readonly StringComparer _fieldHeaderComparer = StringComparer.CurrentCultureIgnoreCase;

		#region Settings

		/// <summary>
		/// Contains the <see cref="T:TextReader"/> pointing to the CSV file.
		/// </summary>
		private TextReader _reader;

		/// <summary>
		/// Contains the buffer size.
		/// </summary>
		private int _bufferSize;

		/// <summary>
		/// Contains the comment character indicating that a line is commented out.
		/// </summary>
		private char _comment;

		/// <summary>
		/// Contains the escape character letting insert quotation characters inside a quoted field.
		/// </summary>
		private char _escape;

		/// <summary>
		/// Contains the delimiter character separating each field.
		/// </summary>
		private char _delimiter;

		/// <summary>
		/// Contains the quotation character wrapping every field.
		/// </summary>
		private char _quote;

		/// <summary>
		/// Determines which values should be trimmed.
		/// </summary>
		private ValueTrimmingOptions _trimmingOptions;

		/// <summary>
		/// Indicates if field names are located on the first non commented line.
		/// </summary>
		private bool _hasHeaders;

		/// <summary>
		/// Contains the default action to take when a parsing error has occured.
		/// </summary>
		private ParseErrorAction _defaultParseErrorAction;

		/// <summary>
		/// Contains the action to take when a field is missing.
		/// </summary>
		private MissingFieldAction _missingFieldAction;

		/// <summary>
		/// Indicates if the reader supports multiline.
		/// </summary>
		private bool _supportsMultiline;

		/// <summary>
		/// Indicates if the reader will skip empty lines.
		/// </summary>
		private bool _skipEmptyLines;

		#endregion

		#region State

		/// <summary>
		/// Indicates if the class is initialized.
		/// </summary>
		private bool _initialized;

		/// <summary>
		/// Contains the field headers.
		/// </summary>
		private string[] _fieldHeaders;

		/// <summary>
		/// Contains the dictionary of field indexes by header. The key is the field name and the value is its index.
		/// </summary>
		private Dictionary<string, int> _fieldHeaderIndexes;

		/// <summary>
		/// Contains the current record index in the CSV file.
		/// A value of <see cref="M:Int32.MinValue"/> means that the reader has not been initialized yet.
		/// Otherwise, a negative value means that no record has been read yet.
		/// </summary>
		private long _currentRecordIndex;

		/// <summary>
		/// Contains the starting position of the next unread field.
		/// </summary>
		private int _nextFieldStart;

		/// <summary>
		/// Contains the index of the next unread field.
		/// </summary>
		private int _nextFieldIndex;

		/// <summary>
		/// Contains the array of the field values for the current record.
		/// A null value indicates that the field have not been parsed.
		/// </summary>
		private string[] _fields;

		/// <summary>
		/// Contains the maximum number of fields to retrieve for each record.
		/// </summary>
		private int _fieldCount;

		/// <summary>
		/// Contains the read buffer.
		/// </summary>
		private char[] _buffer;

		/// <summary>
		/// Contains the current read buffer length.
		/// </summary>
		private int _bufferLength;

		/// <summary>
		/// Indicates if the end of the reader has been reached.
		/// </summary>
		private bool _eof;

		/// <summary>
		/// Indicates if the last read operation reached an EOL character.
		/// </summary>
		private bool _eol;

		/// <summary>
		/// Indicates if the first record is in cache.
		/// This can happen when initializing a reader with no headers
		/// because one record must be read to get the field count automatically
		/// </summary>
		private bool _firstRecordInCache;

		/// <summary>
		/// Indicates if one or more field are missing for the current record.
		/// Resets after each successful record read.
		/// </summary>
		private bool _missingFieldFlag;

		/// <summary>
		/// Indicates if a parse error occured for the current record.
		/// Resets after each successful record read.
		/// </summary>
		private bool _parseErrorFlag;

		#endregion

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the CsvReader class.
		/// </summary>
		/// <param name="reader">A <see cref="T:TextReader"/> pointing to the CSV file.</param>
		/// <param name="hasHeaders"><see langword="true"/> if field names are located on the first non commented line, otherwise, <see langword="false"/>.</param>
		/// <exception cref="T:ArgumentNullException">
		///		<paramref name="reader"/> is a <see langword="null"/>.
		/// </exception>
		/// <exception cref="T:ArgumentException">
		///		Cannot read from <paramref name="reader"/>.
		/// </exception>
		public CsvReader(TextReader reader, bool hasHeaders)
			: this(reader, hasHeaders, DefaultDelimiter, DefaultQuote, DefaultEscape, DefaultComment, ValueTrimmingOptions.UnquotedOnly, DefaultBufferSize)
		{
		}

		/// <summary>
		/// Initializes a new instance of the CsvReader class.
		/// </summary>
		/// <param name="reader">A <see cref="T:TextReader"/> pointing to the CSV file.</param>
		/// <param name="hasHeaders"><see langword="true"/> if field names are located on the first non commented line, otherwise, <see langword="false"/>.</param>
		/// <param name="bufferSize">The buffer size in bytes.</param>
		/// <exception cref="T:ArgumentNullException">
		///		<paramref name="reader"/> is a <see langword="null"/>.
		/// </exception>
		/// <exception cref="T:ArgumentException">
		///		Cannot read from <paramref name="reader"/>.
		/// </exception>
		public CsvReader(TextReader reader, bool hasHeaders, int bufferSize)
			: this(reader, hasHeaders, DefaultDelimiter, DefaultQuote, DefaultEscape, DefaultComment, ValueTrimmingOptions.UnquotedOnly, bufferSize)
		{
		}

		/// <summary>
		/// Initializes a new instance of the CsvReader class.
		/// </summary>
		/// <param name="reader">A <see cref="T:TextReader"/> pointing to the CSV file.</param>
		/// <param name="hasHeaders"><see langword="true"/> if field names are located on the first non commented line, otherwise, <see langword="false"/>.</param>
		/// <param name="delimiter">The delimiter character separating each field (default is ',').</param>
		/// <exception cref="T:ArgumentNullException">
		///		<paramref name="reader"/> is a <see langword="null"/>.
		/// </exception>
		/// <exception cref="T:ArgumentException">
		///		Cannot read from <paramref name="reader"/>.
		/// </exception>
		public CsvReader(TextReader reader, bool hasHeaders, char delimiter)
			: this(reader, hasHeaders, delimiter, DefaultQuote, DefaultEscape, DefaultComment, ValueTrimmingOptions.UnquotedOnly, DefaultBufferSize)
		{
		}

		/// <summary>
		/// Initializes a new instance of the CsvReader class.
		/// </summary>
		/// <param name="reader">A <see cref="T:TextReader"/> pointing to the CSV file.</param>
		/// <param name="hasHeaders"><see langword="true"/> if field names are located on the first non commented line, otherwise, <see langword="false"/>.</param>
		/// <param name="delimiter">The delimiter character separating each field (default is ',').</param>
		/// <param name="bufferSize">The buffer size in bytes.</param>
		/// <exception cref="T:ArgumentNullException">
		///		<paramref name="reader"/> is a <see langword="null"/>.
		/// </exception>
		/// <exception cref="T:ArgumentException">
		///		Cannot read from <paramref name="reader"/>.
		/// </exception>
		public CsvReader(TextReader reader, bool hasHeaders, char delimiter, int bufferSize)
			: this(reader, hasHeaders, delimiter, DefaultQuote, DefaultEscape, DefaultComment, ValueTrimmingOptions.UnquotedOnly, bufferSize)
		{
		}

		/// <summary>
		/// Initializes a new instance of the CsvReader class.
		/// </summary>
		/// <param name="reader">A <see cref="T:TextReader"/> pointing to the CSV file.</param>
		/// <param name="hasHeaders"><see langword="true"/> if field names are located on the first non commented line, otherwise, <see langword="false"/>.</param>
		/// <param name="delimiter">The delimiter character separating each field (default is ',').</param>
		/// <param name="quote">The quotation character wrapping every field (default is ''').</param>
		/// <param name="escape">
		/// The escape character letting insert quotation characters inside a quoted field (default is '\').
		/// If no escape character, set to '\0' to gain some performance.
		/// </param>
		/// <param name="comment">The comment character indicating that a line is commented out (default is '#').</param>
		/// <param name="trimmingOptions">Determines which values should be trimmed.</param>
		/// <exception cref="T:ArgumentNullException">
		///		<paramref name="reader"/> is a <see langword="null"/>.
		/// </exception>
		/// <exception cref="T:ArgumentException">
		///		Cannot read from <paramref name="reader"/>.
		/// </exception>
		public CsvReader(TextReader reader, bool hasHeaders, char delimiter, char quote, char escape, char comment, ValueTrimmingOptions trimmingOptions)
			: this(reader, hasHeaders, delimiter, quote, escape, comment, trimmingOptions, DefaultBufferSize)
		{
		}

		/// <summary>
		/// Initializes a new instance of the CsvReader class.
		/// </summary>
		/// <param name="reader">A <see cref="T:TextReader"/> pointing to the CSV file.</param>
		/// <param name="hasHeaders"><see langword="true"/> if field names are located on the first non commented line, otherwise, <see langword="false"/>.</param>
		/// <param name="delimiter">The delimiter character separating each field (default is ',').</param>
		/// <param name="quote">The quotation character wrapping every field (default is ''').</param>
		/// <param name="escape">
		/// The escape character letting insert quotation characters inside a quoted field (default is '\').
		/// If no escape character, set to '\0' to gain some performance.
		/// </param>
		/// <param name="comment">The comment character indicating that a line is commented out (default is '#').</param>
		/// <param name="trimmingOptions">Determines which values should be trimmed.</param>
		/// <param name="bufferSize">The buffer size in bytes.</param>
		/// <exception cref="T:ArgumentNullException">
		///		<paramref name="reader"/> is a <see langword="null"/>.
		/// </exception>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<paramref name="bufferSize"/> must be 1 or more.
		/// </exception>
		public CsvReader(TextReader reader, bool hasHeaders, char delimiter, char quote, char escape, char comment, ValueTrimmingOptions trimmingOptions, int bufferSize)
		{
			if (reader == null)
				throw new ArgumentNullException("reader");

			if (bufferSize <= 0)
				throw new ArgumentOutOfRangeException("bufferSize", bufferSize, ExceptionMessage.BufferSizeTooSmall);

            _bufferSize = bufferSize;

			if (reader is StreamReader)
			{
				Stream stream = ((StreamReader) reader).BaseStream;

				if (stream.CanSeek)
				{
					// Handle bad implementations returning 0 or less
					if (stream.Length > 0)
						_bufferSize = (int) Math.Min(bufferSize, stream.Length);
				}
			}

			_reader = reader;
			_delimiter = delimiter;
			_quote = quote;
			_escape = escape;
			_comment = comment;

			_hasHeaders = hasHeaders;
			_trimmingOptions = trimmingOptions;
			_supportsMultiline = true;
			_skipEmptyLines = true;
			this.DefaultHeaderName = "Column";

			_currentRecordIndex = -1;
			_defaultParseErrorAction = ParseErrorAction.RaiseEvent;
		}

		#endregion

		#region Events

		/// <summary>
		/// Occurs when there is an error while parsing the CSV stream.
		/// </summary>
		public event EventHandler<ParseErrorEventArgs> ParseError;

		/// <summary>
		/// Raises the <see cref="M:ParseError"/> event.
		/// </summary>
		/// <param name="e">The <see cref="ParseErrorEventArgs"/> that contains the event data.</param>
		protected virtual void OnParseError(ParseErrorEventArgs e)
		{
			EventHandler<ParseErrorEventArgs> handler = ParseError;

			if (handler != null)
				handler(this, e);
		}

		#endregion

		#region Properties

		#region Settings

		/// <summary>
		/// Gets the comment character indicating that a line is commented out.
		/// </summary>
		/// <value>The comment character indicating that a line is commented out.</value>
		public char Comment
		{
			get
			{
				return _comment;
			}
		}

		/// <summary>
		/// Gets the escape character letting insert quotation characters inside a quoted field.
		/// </summary>
		/// <value>The escape character letting insert quotation characters inside a quoted field.</value>
		public char Escape
		{
			get
			{
				return _escape;
			}
		}

		/// <summary>
		/// Gets the delimiter character separating each field.
		/// </summary>
		/// <value>The delimiter character separating each field.</value>
		public char Delimiter
		{
			get
			{
				return _delimiter;
			}
		}

		/// <summary>
		/// Gets the quotation character wrapping every field.
		/// </summary>
		/// <value>The quotation character wrapping every field.</value>
		public char Quote
		{
			get
			{
				return _quote;
			}
		}

		/// <summary>
		/// Indicates if field names are located on the first non commented line.
		/// </summary>
		/// <value><see langword="true"/> if field names are located on the first non commented line, otherwise, <see langword="false"/>.</value>
		public bool HasHeaders
		{
			get
			{
				return _hasHeaders;
			}
		}

		/// <summary>
		/// Indicates if spaces at the start and end of a field are trimmed.
		/// </summary>
		/// <value><see langword="true"/> if spaces at the start and end of a field are trimmed, otherwise, <see langword="false"/>.</value>
		public ValueTrimmingOptions TrimmingOption
		{
			get
			{
				return _trimmingOptions;
			}
		}

		/// <summary>
		/// Gets the buffer size.
		/// </summary>
		public int BufferSize
		{
			get
			{
				return _bufferSize;
			}
		}

		/// <summary>
		/// Gets or sets the default action to take when a parsing error has occured.
		/// </summary>
		/// <value>The default action to take when a parsing error has occured.</value>
		public ParseErrorAction DefaultParseErrorAction
		{
			get
			{
				return _defaultParseErrorAction;
			}
			set
			{
				_defaultParseErrorAction = value;
			}
		}

		/// <summary>
		/// Gets or sets the action to take when a field is missing.
		/// </summary>
		/// <value>The action to take when a field is missing.</value>
		public MissingFieldAction MissingFieldAction
		{
			get
			{
				return _missingFieldAction;
			}
			set
			{
				_missingFieldAction = value;
			}
		}

		/// <summary>
		/// Gets or sets a value indicating if the reader supports multiline fields.
		/// </summary>
		/// <value>A value indicating if the reader supports multiline field.</value>
		public bool SupportsMultiline
		{
			get
			{
				return _supportsMultiline;
			}
			set
			{
				_supportsMultiline = value;
			}
		}

		/// <summary>
		/// Gets or sets a value indicating if the reader will skip empty lines.
		/// </summary>
		/// <value>A value indicating if the reader will skip empty lines.</value>
		public bool SkipEmptyLines
		{
			get
			{
				return _skipEmptyLines;
			}
			set
			{
				_skipEmptyLines = value;
			}
		}

		/// <summary>
		/// Gets or sets the default header name when it is an empty string or only whitespaces.
		/// The header index will be appended to the specified name.
		/// </summary>
		/// <value>The default header name when it is an empty string or only whitespaces.</value>
		public string DefaultHeaderName { get; set; }

		#endregion

		#region State

		/// <summary>
		/// Gets the maximum number of fields to retrieve for each record.
		/// </summary>
		/// <value>The maximum number of fields to retrieve for each record.</value>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		public int FieldCount
		{
			get
			{
				EnsureInitialize();
				return _fieldCount;
			}
		}

		/// <summary>
		/// Gets a value that indicates whether the current stream position is at the end of the stream.
		/// </summary>
		/// <value><see langword="true"/> if the current stream position is at the end of the stream; otherwise <see langword="false"/>.</value>
		public virtual bool EndOfStream
		{
			get
			{
				return _eof;
			}
		}

		/// <summary>
		/// Gets the field headers.
		/// </summary>
		/// <returns>The field headers or an empty array if headers are not supported.</returns>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		public string[] GetFieldHeaders()
		{
			EnsureInitialize();
			Debug.Assert(_fieldHeaders != null, "Field headers must be non null.");

			string[] fieldHeaders = new string[_fieldHeaders.Length];

			for (int i = 0; i < fieldHeaders.Length; i++)
				fieldHeaders[i] = _fieldHeaders[i];

			return fieldHeaders;
		}

		/// <summary>
		/// Gets the current record index in the CSV file.
		/// </summary>
		/// <value>The current record index in the CSV file.</value>
		public virtual long CurrentRecordIndex
		{
			get
			{
				return _currentRecordIndex;
			}
		}

		/// <summary>
		/// Indicates if one or more field are missing for the current record.
		/// Resets after each successful record read.
		/// </summary>
		public bool MissingFieldFlag
		{
			get { return _missingFieldFlag; }
		}

		/// <summary>
		/// Indicates if a parse error occured for the current record.
		/// Resets after each successful record read.
		/// </summary>
		public bool ParseErrorFlag
		{
			get { return _parseErrorFlag; }
		}

		#endregion

		#endregion

		#region Indexers

		/// <summary>
		/// Gets the field with the specified name and record position. <see cref="M:hasHeaders"/> must be <see langword="true"/>.
		/// </summary>
		/// <value>
		/// The field with the specified name and record position.
		/// </value>
		/// <exception cref="T:ArgumentNullException">
		///		<paramref name="field"/> is <see langword="null"/> or an empty string.
		/// </exception>
		/// <exception cref="T:InvalidOperationException">
		///	The CSV does not have headers (<see cref="M:HasHeaders"/> property is <see langword="false"/>).
		/// </exception>
		/// <exception cref="T:ArgumentException">
		///		<paramref name="field"/> not found.
		/// </exception>
		/// <exception cref="T:ArgumentOutOfRangeException">
		///		Record index must be > 0.
		/// </exception>
		/// <exception cref="T:InvalidOperationException">
		///		Cannot move to a previous record in forward-only mode.
		/// </exception>
		/// <exception cref="T:EndOfStreamException">
		///		Cannot read record at <paramref name="record"/>.
		///	</exception>
		///	<exception cref="T:MalformedCsvException">
		///		The CSV appears to be corrupt at the current position.
		/// </exception>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		public string this[int record, string field]
		{
			get
			{
				if (!MoveTo(record))
					throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, ExceptionMessage.CannotReadRecordAtIndex, record));

				return this[field];
			}
		}

		/// <summary>
		/// Gets the field at the specified index and record position.
		/// </summary>
		/// <value>
		/// The field at the specified index and record position.
		/// A <see langword="null"/> is returned if the field cannot be found for the record.
		/// </value>
		/// <exception cref="T:ArgumentOutOfRangeException">
		///		<paramref name="field"/> must be included in [0, <see cref="M:FieldCount"/>[.
		/// </exception>
		/// <exception cref="T:ArgumentOutOfRangeException">
		///		Record index must be > 0.
		/// </exception>
		/// <exception cref="T:InvalidOperationException">
		///		Cannot move to a previous record in forward-only mode.
		/// </exception>
		/// <exception cref="T:EndOfStreamException">
		///		Cannot read record at <paramref name="record"/>.
		/// </exception>
		/// <exception cref="T:MalformedCsvException">
		///		The CSV appears to be corrupt at the current position.
		/// </exception>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		public string this[int record, int field]
		{
			get
			{
				if (!MoveTo(record))
					throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, ExceptionMessage.CannotReadRecordAtIndex, record));

				return this[field];
			}
		}

		/// <summary>
		/// Gets the field with the specified name. <see cref="M:hasHeaders"/> must be <see langword="true"/>.
		/// </summary>
		/// <value>
		/// The field with the specified name.
		/// </value>
		/// <exception cref="T:ArgumentNullException">
		///		<paramref name="field"/> is <see langword="null"/> or an empty string.
		/// </exception>
		/// <exception cref="T:InvalidOperationException">
		///	The CSV does not have headers (<see cref="M:HasHeaders"/> property is <see langword="false"/>).
		/// </exception>
		/// <exception cref="T:ArgumentException">
		///		<paramref name="field"/> not found.
		/// </exception>
		/// <exception cref="T:MalformedCsvException">
		///		The CSV appears to be corrupt at the current position.
		/// </exception>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		public string this[string field]
		{
			get
			{
				if (string.IsNullOrEmpty(field))
					throw new ArgumentNullException("field");

				if (!_hasHeaders)
					throw new InvalidOperationException(ExceptionMessage.NoHeaders);

				int index = GetFieldIndex(field);

				if (index < 0)
					throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, ExceptionMessage.FieldHeaderNotFound, field), "field");

				return this[index];
			}
		}

		/// <summary>
		/// Gets the field at the specified index.
		/// </summary>
		/// <value>The field at the specified index.</value>
		/// <exception cref="T:ArgumentOutOfRangeException">
		///		<paramref name="field"/> must be included in [0, <see cref="M:FieldCount"/>[.
		/// </exception>
		/// <exception cref="T:InvalidOperationException">
		///		No record read yet. Call ReadLine() first.
		/// </exception>
		/// <exception cref="T:MalformedCsvException">
		///		The CSV appears to be corrupt at the current position.
		/// </exception>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		public virtual string this[int field]
		{
			get
			{
				return ReadField(field, false, false);
			}
		}

		#endregion

		#region Methods

		#region EnsureInitialize

		/// <summary>
		/// Ensures that the reader is initialized.
		/// </summary>
		private void EnsureInitialize()
		{
			if (!_initialized)
				this.ReadNextRecord(true, false);

			Debug.Assert(_fieldHeaders != null);
			Debug.Assert(_fieldHeaders.Length > 0 || (_fieldHeaders.Length == 0 && _fieldHeaderIndexes == null));
		}

		#endregion

		#region GetFieldIndex

		/// <summary>
		/// Gets the field index for the provided header.
		/// </summary>
		/// <param name="header">The header to look for.</param>
		/// <returns>The field index for the provided header. -1 if not found.</returns>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		public int GetFieldIndex(string header)
		{
			EnsureInitialize();

			int index;

			if (_fieldHeaderIndexes != null && _fieldHeaderIndexes.TryGetValue(header, out index))
				return index;
			else
				return -1;
		}

		#endregion

		#region CopyCurrentRecordTo

		/// <summary>
		/// Copies the field array of the current record to a one-dimensional array, starting at the beginning of the target array.
		/// </summary>
		/// <param name="array"> The one-dimensional <see cref="T:Array"/> that is the destination of the fields of the current record.</param>
		/// <exception cref="T:ArgumentNullException">
		///		<paramref name="array"/> is <see langword="null"/>.
		/// </exception>
		/// <exception cref="ArgumentException">
		///		The number of fields in the record is greater than the available space from <paramref name="index"/> to the end of <paramref name="array"/>.
		/// </exception>
		public void CopyCurrentRecordTo(string[] array)
		{
			CopyCurrentRecordTo(array, 0);
		}

		/// <summary>
		/// Copies the field array of the current record to a one-dimensional array, starting at the beginning of the target array.
		/// </summary>
		/// <param name="array"> The one-dimensional <see cref="T:Array"/> that is the destination of the fields of the current record.</param>
		/// <param name="index">The zero-based index in <paramref name="array"/> at which copying begins.</param>
		/// <exception cref="T:ArgumentNullException">
		///		<paramref name="array"/> is <see langword="null"/>.
		/// </exception>
		/// <exception cref="T:ArgumentOutOfRangeException">
		///		<paramref name="index"/> is les than zero or is equal to or greater than the length <paramref name="array"/>. 
		/// </exception>
		/// <exception cref="InvalidOperationException">
		///	No current record.
		/// </exception>
		/// <exception cref="ArgumentException">
		///		The number of fields in the record is greater than the available space from <paramref name="index"/> to the end of <paramref name="array"/>.
		/// </exception>
		public void CopyCurrentRecordTo(string[] array, int index)
		{
			if (array == null)
				throw new ArgumentNullException("array");

			if (index < 0 || index >= array.Length)
                throw new ArgumentOutOfRangeException("index", index, string.Empty);

            if (_currentRecordIndex < 0 || !_initialized)
				throw new InvalidOperationException(ExceptionMessage.NoCurrentRecord);

			if (array.Length - index < _fieldCount)
				throw new ArgumentException(ExceptionMessage.NotEnoughSpaceInArray, "array");

			for (int i = 0; i < _fieldCount; i++)
			{
				if (_parseErrorFlag)
					array[index + i] = null;
				else
					array[index + i] = this[i];
			}
		}

		#endregion

		#region GetCurrentRawData

		/// <summary>
		/// Gets the current raw CSV data.
		/// </summary>
		/// <remarks>Used for exception handling purpose.</remarks>
		/// <returns>The current raw CSV data.</returns>
		public string GetCurrentRawData()
		{
			if (_buffer != null && _bufferLength > 0)
				return new string(_buffer, 0, _bufferLength);
			else
				return string.Empty;
		}

		#endregion

		#region IsWhiteSpace

		/// <summary>
		/// Indicates whether the specified Unicode character is categorized as white space.
		/// </summary>
		/// <param name="c">A Unicode character.</param>
		/// <returns><see langword="true"/> if <paramref name="c"/> is white space; otherwise, <see langword="false"/>.</returns>
		private bool IsWhiteSpace(char c)
		{
			// Handle cases where the delimiter is a whitespace (e.g. tab)
			if (c == _delimiter)
				return false;
			else
			{
				// See char.IsLatin1(char c) in Reflector
				if (c <= '\x00ff')
					return (c == ' ' || c == '\t');
				else
					return (System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c) == System.Globalization.UnicodeCategory.SpaceSeparator);
			}
		}

		#endregion

		#region MoveTo

		/// <summary>
		/// Moves to the specified record index.
		/// </summary>
		/// <param name="record">The record index.</param>
		/// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		public virtual bool MoveTo(long record)
		{
			if (record < _currentRecordIndex)
				return false;

			// Get number of record to read
			long offset = record - _currentRecordIndex;

			while (offset > 0)
			{
				if (!ReadNextRecord())
					return false;

				offset--;
			}

			return true;
		}

		#endregion

		#region ParseNewLine

		/// <summary>
		/// Parses a new line delimiter.
		/// </summary>
		/// <param name="pos">The starting position of the parsing. Will contain the resulting end position.</param>
		/// <returns><see langword="true"/> if a new line delimiter was found; otherwise, <see langword="false"/>.</returns>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		private bool ParseNewLine(ref int pos)
		{
			Debug.Assert(pos <= _bufferLength);

			// Check if already at the end of the buffer
			if (pos == _bufferLength)
			{
				pos = 0;

				if (!ReadBuffer())
					return false;
			}

			char c = _buffer[pos];

			// Treat \r as new line only if it's not the delimiter

			if (c == '\r' && _delimiter != '\r')
			{
				pos++;

				// Skip following \n (if there is one)

				if (pos < _bufferLength)
				{
					if (_buffer[pos] == '\n')
						pos++;
				}
				else
				{
					if (ReadBuffer())
					{
						if (_buffer[0] == '\n')
							pos = 1;
						else
							pos = 0;
					}
				}

				if (pos >= _bufferLength)
				{
					ReadBuffer();
					pos = 0;
				}

				return true;
			}
			else if (c == '\n')
			{
				pos++;

				if (pos >= _bufferLength)
				{
					ReadBuffer();
					pos = 0;
				}

				return true;
			}

			return false;
		}

		/// <summary>
		/// Determines whether the character at the specified position is a new line delimiter.
		/// </summary>
		/// <param name="pos">The position of the character to verify.</param>
		/// <returns>
		/// 	<see langword="true"/> if the character at the specified position is a new line delimiter; otherwise, <see langword="false"/>.
		/// </returns>
		private bool IsNewLine(int pos)
		{
			Debug.Assert(pos < _bufferLength);

			char c = _buffer[pos];

			if (c == '\n')
				return true;
			else if (c == '\r' && _delimiter != '\r')
				return true;
			else
				return false;
		}

		#endregion

		#region ReadBuffer

		/// <summary>
		/// Fills the buffer with data from the reader.
		/// </summary>
		/// <returns><see langword="true"/> if data was successfully read; otherwise, <see langword="false"/>.</returns>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		private bool ReadBuffer()
		{
			if (_eof)
				return false;

			CheckDisposed();

			_bufferLength = _reader.Read(_buffer, 0, _bufferSize);

			if (_bufferLength > 0)
				return true;
			else
			{
				_eof = true;
				_buffer = null;

				return false;
			}
		}

		#endregion

		#region ReadField

		/// <summary>
		/// Reads the field at the specified index.
		/// Any unread fields with an inferior index will also be read as part of the required parsing.
		/// </summary>
		/// <param name="field">The field index.</param>
		/// <param name="initializing">Indicates if the reader is currently initializing.</param>
		/// <param name="discardValue">Indicates if the value(s) are discarded.</param>
		/// <returns>
		/// The field at the specified index. 
		/// A <see langword="null"/> indicates that an error occured or that the last field has been reached during initialization.
		/// </returns>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<paramref name="field"/> is out of range.
		/// </exception>
		/// <exception cref="InvalidOperationException">
		///		There is no current record.
		/// </exception>
		/// <exception cref="MissingFieldCsvException">
		///		The CSV data appears to be missing a field.
		/// </exception>
		/// <exception cref="MalformedCsvException">
		///		The CSV data appears to be malformed.
		/// </exception>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		private string ReadField(int field, bool initializing, bool discardValue)
		{
			if (!initializing)
			{
				if (field < 0 || field >= _fieldCount)
                    throw new ArgumentOutOfRangeException("field", field, string.Format(CultureInfo.InvariantCulture, ExceptionMessage.FieldIndexOutOfRange, field));

                if (_currentRecordIndex < 0)
					throw new InvalidOperationException(ExceptionMessage.NoCurrentRecord);

				// Directly return field if cached
				if (_fields[field] != null)
					return _fields[field];
				else if (_missingFieldFlag)
					return HandleMissingField(null, field, ref _nextFieldStart);
			}

			CheckDisposed();

			int index = _nextFieldIndex;

			while (index < field + 1)
			{
				// Handle case where stated start of field is past buffer
				// This can occur because _nextFieldStart is simply 1 + last char position of previous field
				if (_nextFieldStart == _bufferLength)
				{
					_nextFieldStart = 0;

					// Possible EOF will be handled later (see Handle_EOF1)
					ReadBuffer();
				}

				string value = null;

				if (_missingFieldFlag)
				{
					value = HandleMissingField(value, index, ref _nextFieldStart);
				}
				else if (_nextFieldStart == _bufferLength)
				{
					// Handle_EOF1: Handle EOF here

					// If current field is the requested field, then the value of the field is "" as in "f1,f2,f3,(\s*)"
					// otherwise, the CSV is malformed

					if (index == field)
					{
						if (!discardValue)
						{
							value = string.Empty;
							_fields[index] = value;
						}

						_missingFieldFlag = true;
					}
					else
					{
						value = HandleMissingField(value, index, ref _nextFieldStart);
					}
				}
				else
				{
					// Trim spaces at start
					if ((_trimmingOptions & ValueTrimmingOptions.UnquotedOnly) != 0)
						SkipWhiteSpaces(ref _nextFieldStart);

					if (_eof)
					{
						value = string.Empty;
						_fields[field] = value;

						if (field < _fieldCount)
							_missingFieldFlag = true;
					}
					else if (_buffer[_nextFieldStart] != _quote)
					{
						// Non-quoted field

						int start = _nextFieldStart;
						int pos = _nextFieldStart;

						for (; ; )
						{
							while (pos < _bufferLength)
							{
								char c = _buffer[pos];

								if (c == _delimiter)
								{
									_nextFieldStart = pos + 1;

									break;
								}
								else if (c == '\r' || c == '\n')
								{
									_nextFieldStart = pos;
									_eol = true;

									break;
								}
								else
									pos++;
							}

							if (pos < _bufferLength)
								break;
							else
							{
								if (!discardValue)
									value += new string(_buffer, start, pos - start);

								start = 0;
								pos = 0;
								_nextFieldStart = 0;

								if (!ReadBuffer())
									break;
							}
						}

						if (!discardValue)
						{
							if ((_trimmingOptions & ValueTrimmingOptions.UnquotedOnly) == 0)
							{
								if (!_eof && pos > start)
									value += new string(_buffer, start, pos - start);
							}
							else
							{
								if (!_eof && pos > start)
								{
									// Do the trimming
									pos--;
									while (pos > -1 && IsWhiteSpace(_buffer[pos]))
										pos--;
									pos++;

									if (pos > 0)
										value += new string(_buffer, start, pos - start);
								}
								else
									pos = -1;

								// If pos <= 0, that means the trimming went past buffer start,
								// and the concatenated value needs to be trimmed too.
								if (pos <= 0)
								{
									pos = (value == null ? -1 : value.Length - 1);

									// Do the trimming
									while (pos > -1 && IsWhiteSpace(value[pos]))
										pos--;

									pos++;

									if (pos > 0 && pos != value.Length)
										value = value.Substring(0, pos);
								}
							}

							if (value == null)
								value = string.Empty;
						}

						if (_eol || _eof)
						{
							_eol = ParseNewLine(ref _nextFieldStart);

							// Reaching a new line is ok as long as the parser is initializing or it is the last field
							if (!initializing && index != _fieldCount - 1)
							{
								if (value != null && value.Length == 0)
									value = null;

								value = HandleMissingField(value, index, ref _nextFieldStart);
							}
						}

						if (!discardValue)
							_fields[index] = value;
					}
					else
					{
						// Quoted field

						// Skip quote
						int start = _nextFieldStart + 1;
						int pos = start;

						bool quoted = true;
						bool escaped = false;

						if ((_trimmingOptions & ValueTrimmingOptions.QuotedOnly) != 0)
						{
							SkipWhiteSpaces(ref start);
							pos = start;
						}

						for (; ; )
						{
							while (pos < _bufferLength)
							{
								char c = _buffer[pos];

								if (escaped)
								{
									escaped = false;
									start = pos;
								}
								// IF current char is escape AND (escape and quote are different OR next char is a quote)
								else if (c == _escape && (_escape != _quote || (pos + 1 < _bufferLength && _buffer[pos + 1] == _quote) || (pos + 1 == _bufferLength && _reader.Peek() == _quote)))
								{
									if (!discardValue)
										value += new string(_buffer, start, pos - start);

									escaped = true;
								}
								else if (c == _quote)
								{
									quoted = false;
									break;
								}

								pos++;
							}

							if (!quoted)
								break;
							else
							{
								if (!discardValue && !escaped)
									value += new string(_buffer, start, pos - start);

								start = 0;
								pos = 0;
								_nextFieldStart = 0;

								if (!ReadBuffer())
								{
									HandleParseError(new MalformedCsvException(GetCurrentRawData(), _nextFieldStart, Math.Max(0, _currentRecordIndex), index), ref _nextFieldStart);
									return null;
								}
							}
						}

						if (!_eof)
						{
							// Append remaining parsed buffer content
							if (!discardValue && pos > start)
								value += new string(_buffer, start, pos - start);

							if (!discardValue && value != null && (_trimmingOptions & ValueTrimmingOptions.QuotedOnly) != 0)
							{
								int newLength = value.Length;
								while (newLength > 0 && IsWhiteSpace(value[newLength - 1]))
									newLength--;

								if (newLength < value.Length)
									value = value.Substring(0, newLength);
							}

							// Skip quote
							_nextFieldStart = pos + 1;

							// Skip whitespaces between the quote and the delimiter/eol
							SkipWhiteSpaces(ref _nextFieldStart);

							// Skip delimiter
							bool delimiterSkipped;
							if (_nextFieldStart < _bufferLength && _buffer[_nextFieldStart] == _delimiter)
							{
								_nextFieldStart++;
								delimiterSkipped = true;
							}
							else
							{
								delimiterSkipped = false;
							}

							// Skip new line delimiter if initializing or last field
							// (if the next field is missing, it will be caught when parsed)
							if (!_eof && !delimiterSkipped && (initializing || index == _fieldCount - 1))
								_eol = ParseNewLine(ref _nextFieldStart);

							// If no delimiter is present after the quoted field and it is not the last field, then it is a parsing error
							if (!delimiterSkipped && !_eof && !(_eol || IsNewLine(_nextFieldStart)))
								HandleParseError(new MalformedCsvException(GetCurrentRawData(), _nextFieldStart, Math.Max(0, _currentRecordIndex), index), ref _nextFieldStart);
						}

						if (!discardValue)
						{
							if (value == null)
								value = string.Empty;

							_fields[index] = value;
						}
					}
				}

				_nextFieldIndex = Math.Max(index + 1, _nextFieldIndex);

				if (index == field)
				{
					// If initializing, return null to signify the last field has been reached

					if (initializing)
					{
						if (_eol || _eof)
							return null;
						else
							return string.IsNullOrEmpty(value) ? string.Empty : value;
					}
					else
						return value;
				}

				index++;
			}

			// Getting here is bad ...
			HandleParseError(new MalformedCsvException(GetCurrentRawData(), _nextFieldStart, Math.Max(0, _currentRecordIndex), index), ref _nextFieldStart);
			return null;
		}

		#endregion

		#region ReadNextRecord

		/// <summary>
		/// Reads the next record.
		/// </summary>
		/// <returns><see langword="true"/> if a record has been successfully reads; otherwise, <see langword="false"/>.</returns>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		public bool ReadNextRecord()
		{
			return ReadNextRecord(false, false);
		}

		/// <summary>
		/// Reads the next record.
		/// </summary>
		/// <param name="onlyReadHeaders">
		/// Indicates if the reader will proceed to the next record after having read headers.
		/// <see langword="true"/> if it stops after having read headers; otherwise, <see langword="false"/>.
		/// </param>
		/// <param name="skipToNextLine">
		/// Indicates if the reader will skip directly to the next line without parsing the current one. 
		/// To be used when an error occurs.
		/// </param>
		/// <returns><see langword="true"/> if a record has been successfully reads; otherwise, <see langword="false"/>.</returns>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		protected virtual bool ReadNextRecord(bool onlyReadHeaders, bool skipToNextLine)
		{
			if (_eof)
			{
				if (_firstRecordInCache)
				{
					_firstRecordInCache = false;
					_currentRecordIndex++;

					return true;
				}
				else
					return false;
			}

			CheckDisposed();

			if (!_initialized)
			{
				_buffer = new char[_bufferSize];

				// will be replaced if and when headers are read
				_fieldHeaders = new string[0];

				if (!ReadBuffer())
					return false;

				if (!SkipEmptyAndCommentedLines(ref _nextFieldStart))
					return false;

				// Keep growing _fields array until the last field has been found
				// and then resize it to its final correct size

				_fieldCount = 0;
				_fields = new string[16];

				while (ReadField(_fieldCount, true, false) != null)
				{
					if (_parseErrorFlag)
					{
						_fieldCount = 0;
						Array.Clear(_fields, 0, _fields.Length);
						_parseErrorFlag = false;
						_nextFieldIndex = 0;
					}
					else
					{
						_fieldCount++;

						if (_fieldCount == _fields.Length)
							Array.Resize<string>(ref _fields, (_fieldCount + 1) * 2);
					}
				}

				// _fieldCount contains the last field index, but it must contains the field count,
				// so increment by 1
				_fieldCount++;

				if (_fields.Length != _fieldCount)
					Array.Resize<string>(ref _fields, _fieldCount);

				_initialized = true;

				// If headers are present, call ReadNextRecord again
				if (_hasHeaders)
				{
					// Don't count first record as it was the headers
					_currentRecordIndex = -1;

					_firstRecordInCache = false;

					_fieldHeaders = new string[_fieldCount];
					_fieldHeaderIndexes = new Dictionary<string, int>(_fieldCount, _fieldHeaderComparer);

					for (int i = 0; i < _fields.Length; i++)
					{
						string headerName = _fields[i];
						if (string.IsNullOrEmpty(headerName) || headerName.Trim().Length == 0)
							headerName = this.DefaultHeaderName + i.ToString();

						_fieldHeaders[i] = headerName;
						_fieldHeaderIndexes.Add(headerName, i);
					}

					// Proceed to first record
					if (!onlyReadHeaders)
					{
						// Calling again ReadNextRecord() seems to be simpler, 
						// but in fact would probably cause many subtle bugs because a derived class does not expect a recursive behavior
						// so simply do what is needed here and no more.

						if (!SkipEmptyAndCommentedLines(ref _nextFieldStart))
							return false;

						Array.Clear(_fields, 0, _fields.Length);
						_nextFieldIndex = 0;
						_eol = false;

						_currentRecordIndex++;
						return true;
					}
				}
				else
				{
					if (onlyReadHeaders)
					{
						_firstRecordInCache = true;
						_currentRecordIndex = -1;
					}
					else
					{
						_firstRecordInCache = false;
						_currentRecordIndex = 0;
					}
				}
			}
			else
			{
				if (skipToNextLine)
					SkipToNextLine(ref _nextFieldStart);
				else if (_currentRecordIndex > -1 && !_missingFieldFlag)
				{
					// If not already at end of record, move there
					if (!_eol && !_eof)
					{
						if (!_supportsMultiline)
							SkipToNextLine(ref _nextFieldStart);
						else
						{
							// a dirty trick to handle the case where extra fields are present
							while (ReadField(_nextFieldIndex, true, true) != null)
							{
							}
						}
					}
				}

				if (!_firstRecordInCache && !SkipEmptyAndCommentedLines(ref _nextFieldStart))
					return false;

				if (_hasHeaders || !_firstRecordInCache)
					_eol = false;

				// Check to see if the first record is in cache.
				// This can happen when initializing a reader with no headers
				// because one record must be read to get the field count automatically
				if (_firstRecordInCache)
					_firstRecordInCache = false;
				else
				{
					Array.Clear(_fields, 0, _fields.Length);
					_nextFieldIndex = 0;
				}

				_missingFieldFlag = false;
				_parseErrorFlag = false;
				_currentRecordIndex++;
			}

			return true;
		}

		#endregion

		#region SkipEmptyAndCommentedLines

		/// <summary>
		/// Skips empty and commented lines.
		/// If the end of the buffer is reached, its content be discarded and filled again from the reader.
		/// </summary>
		/// <param name="pos">
		/// The position in the buffer where to start parsing. 
		/// Will contains the resulting position after the operation.
		/// </param>
		/// <returns><see langword="true"/> if the end of the reader has not been reached; otherwise, <see langword="false"/>.</returns>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		private bool SkipEmptyAndCommentedLines(ref int pos)
		{
			if (pos < _bufferLength)
				DoSkipEmptyAndCommentedLines(ref pos);

			while (pos >= _bufferLength && !_eof)
			{
				if (ReadBuffer())
				{
					pos = 0;
					DoSkipEmptyAndCommentedLines(ref pos);
				}
				else
					return false;
			}

			return !_eof;
		}

		/// <summary>
		/// <para>Worker method.</para>
		/// <para>Skips empty and commented lines.</para>
		/// </summary>
		/// <param name="pos">
		/// The position in the buffer where to start parsing. 
		/// Will contains the resulting position after the operation.
		/// </param>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		private void DoSkipEmptyAndCommentedLines(ref int pos)
		{
			while (pos < _bufferLength)
			{
				if (_buffer[pos] == _comment)
				{
					pos++;
					SkipToNextLine(ref pos);
				}
				else if (_skipEmptyLines && ParseNewLine(ref pos))
					continue;
				else
					break;
			}
		}

		#endregion

		#region SkipWhiteSpaces

		/// <summary>
		/// Skips whitespace characters.
		/// </summary>
		/// <param name="pos">The starting position of the parsing. Will contain the resulting end position.</param>
		/// <returns><see langword="true"/> if the end of the reader has not been reached; otherwise, <see langword="false"/>.</returns>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		private bool SkipWhiteSpaces(ref int pos)
		{
			for (; ; )
			{
				while (pos < _bufferLength && IsWhiteSpace(_buffer[pos]))
					pos++;

				if (pos < _bufferLength)
					break;
				else
				{
					pos = 0;

					if (!ReadBuffer())
						return false;
				}
			}

			return true;
		}

		#endregion

		#region SkipToNextLine

		/// <summary>
		/// Skips ahead to the next NewLine character.
		/// If the end of the buffer is reached, its content be discarded and filled again from the reader.
		/// </summary>
		/// <param name="pos">
		/// The position in the buffer where to start parsing. 
		/// Will contains the resulting position after the operation.
		/// </param>
		/// <returns><see langword="true"/> if the end of the reader has not been reached; otherwise, <see langword="false"/>.</returns>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		private bool SkipToNextLine(ref int pos)
		{
			// ((pos = 0) == 0) is a little trick to reset position inline
			while ((pos < _bufferLength || (ReadBuffer() && ((pos = 0) == 0))) && !ParseNewLine(ref pos))
				pos++;

			return !_eof;
		}

		#endregion

		#region HandleParseError

		/// <summary>
		/// Handles a parsing error.
		/// </summary>
		/// <param name="error">The parsing error that occured.</param>
		/// <param name="pos">The current position in the buffer.</param>
		/// <exception cref="ArgumentNullException">
		///	<paramref name="error"/> is <see langword="null"/>.
		/// </exception>
		private void HandleParseError(MalformedCsvException error, ref int pos)
		{
			if (error == null)
				throw new ArgumentNullException("error");

			_parseErrorFlag = true;

			switch (_defaultParseErrorAction)
			{
				case ParseErrorAction.ThrowException:
					throw error;

				case ParseErrorAction.RaiseEvent:
					ParseErrorEventArgs e = new ParseErrorEventArgs(error, ParseErrorAction.ThrowException);
					OnParseError(e);

					switch (e.Action)
					{
						case ParseErrorAction.ThrowException:
							throw e.Error;

						case ParseErrorAction.RaiseEvent:
							throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, ExceptionMessage.ParseErrorActionInvalidInsideParseErrorEvent, e.Action), e.Error);

						case ParseErrorAction.AdvanceToNextLine:
							// already at EOL when fields are missing, so don't skip to next line in that case
							if (!_missingFieldFlag && pos >= 0)
								SkipToNextLine(ref pos);
							break;

						default:
							throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture, ExceptionMessage.ParseErrorActionNotSupported, e.Action), e.Error);
					}
					break;

				case ParseErrorAction.AdvanceToNextLine:
					// already at EOL when fields are missing, so don't skip to next line in that case
					if (!_missingFieldFlag && pos >= 0)
						SkipToNextLine(ref pos);
					break;

				default:
					throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture, ExceptionMessage.ParseErrorActionNotSupported, _defaultParseErrorAction), error);
			}
		}

		#endregion

		#region HandleMissingField

		/// <summary>
		/// Handles a missing field error.
		/// </summary>
		/// <param name="value">The partially parsed value, if available.</param>
		/// <param name="fieldIndex">The missing field index.</param>
		/// <param name="currentPosition">The current position in the raw data.</param>
		/// <returns>
		/// The resulting value according to <see cref="M:MissingFieldAction"/>.
		/// If the action is set to <see cref="T:MissingFieldAction.TreatAsParseError"/>,
		/// then the parse error will be handled according to <see cref="DefaultParseErrorAction"/>.
		/// </returns>
		private string HandleMissingField(string value, int fieldIndex, ref int currentPosition)
		{
			if (fieldIndex < 0 || fieldIndex >= _fieldCount)
                throw new ArgumentOutOfRangeException("fieldIndex", fieldIndex, string.Format(CultureInfo.InvariantCulture, ExceptionMessage.FieldIndexOutOfRange, fieldIndex));

            _missingFieldFlag = true;

			for (int i = fieldIndex + 1; i < _fieldCount; i++)
				_fields[i] = null;

			if (value != null)
				return value;
			else
			{
				switch (_missingFieldAction)
				{
					case MissingFieldAction.ParseError:
						HandleParseError(new MissingFieldCsvException(GetCurrentRawData(), currentPosition, Math.Max(0, _currentRecordIndex), fieldIndex), ref currentPosition);
						return value;

					case MissingFieldAction.ReplaceByEmpty:
						return string.Empty;

					case MissingFieldAction.ReplaceByNull:
						return null;

					default:
						throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture, ExceptionMessage.MissingFieldActionNotSupported, _missingFieldAction));
				}
			}
		}

		#endregion

		#endregion

		#region IDataReader support methods

		/// <summary>
		/// Validates the state of the data reader.
		/// </summary>
		/// <param name="validations">The validations to accomplish.</param>
		/// <exception cref="InvalidOperationException">
		///	No current record.
		/// </exception>
		/// <exception cref="InvalidOperationException">
		///	This operation is invalid when the reader is closed.
		/// </exception>
		private void ValidateDataReader(DataReaderValidations validations)
		{
			if ((validations & DataReaderValidations.IsInitialized) != 0 && !_initialized)
				throw new InvalidOperationException(ExceptionMessage.NoCurrentRecord);

			if ((validations & DataReaderValidations.IsNotClosed) != 0 && _isDisposed)
				throw new InvalidOperationException(ExceptionMessage.ReaderClosed);
		}

		/// <summary>
		/// Copy the value of the specified field to an array.
		/// </summary>
		/// <param name="field">The index of the field.</param>
		/// <param name="fieldOffset">The offset in the field value.</param>
		/// <param name="destinationArray">The destination array where the field value will be copied.</param>
		/// <param name="destinationOffset">The destination array offset.</param>
		/// <param name="length">The number of characters to copy from the field value.</param>
		/// <returns></returns>
		private long CopyFieldToArray(int field, long fieldOffset, Array destinationArray, int destinationOffset, int length)
		{
			EnsureInitialize();

			if (field < 0 || field >= _fieldCount)
                throw new ArgumentOutOfRangeException("field", field, string.Format(CultureInfo.InvariantCulture, ExceptionMessage.FieldIndexOutOfRange, field));

			if (fieldOffset < 0 || fieldOffset >= int.MaxValue)
                throw new ArgumentOutOfRangeException("fieldOffset");

            // Array.Copy(...) will do the remaining argument checks

			if (length == 0)
				return 0;

			string value = this[field];

			if (value == null)
				value = string.Empty;

			Debug.Assert(fieldOffset < int.MaxValue);

			Debug.Assert(destinationArray.GetType() == typeof(char[]) || destinationArray.GetType() == typeof(byte[]));

			if (destinationArray.GetType() == typeof(char[]))
				Array.Copy(value.ToCharArray((int) fieldOffset, length), 0, destinationArray, destinationOffset, length);
			else
			{
				char[] chars = value.ToCharArray((int) fieldOffset, length);
				byte[] source = new byte[chars.Length];
				;

				for (int i = 0; i < chars.Length; i++)
					source[i] = Convert.ToByte(chars[i]);

				Array.Copy(source, 0, destinationArray, destinationOffset, length);
			}

			return length;
		}

		#endregion

		#region IDataReader Members

		int IDataReader.RecordsAffected
		{
			get
			{
				// For SELECT statements, -1 must be returned.
				return -1;
			}
		}

		bool IDataReader.IsClosed
		{
			get
			{
				return _eof;
			}
		}

		bool IDataReader.NextResult()
		{
			ValidateDataReader(DataReaderValidations.IsNotClosed);

			return false;
		}

		void IDataReader.Close()
		{
			Dispose();
		}

		bool IDataReader.Read()
		{
			ValidateDataReader(DataReaderValidations.IsNotClosed);

			return ReadNextRecord();
		}

		int IDataReader.Depth
		{
			get
			{
				ValidateDataReader(DataReaderValidations.IsNotClosed);

				return 0;
			}
		}

		DataTable IDataReader.GetSchemaTable()
		{
			EnsureInitialize();
			ValidateDataReader(DataReaderValidations.IsNotClosed);

			DataTable schema = new DataTable("SchemaTable");
			schema.Locale = CultureInfo.InvariantCulture;
			schema.MinimumCapacity = _fieldCount;

			schema.Columns.Add(SchemaTableColumn.AllowDBNull, typeof(bool)).ReadOnly = true;
			schema.Columns.Add(SchemaTableColumn.BaseColumnName, typeof(string)).ReadOnly = true;
			schema.Columns.Add(SchemaTableColumn.BaseSchemaName, typeof(string)).ReadOnly = true;
			schema.Columns.Add(SchemaTableColumn.BaseTableName, typeof(string)).ReadOnly = true;
			schema.Columns.Add(SchemaTableColumn.ColumnName, typeof(string)).ReadOnly = true;
			schema.Columns.Add(SchemaTableColumn.ColumnOrdinal, typeof(int)).ReadOnly = true;
			schema.Columns.Add(SchemaTableColumn.ColumnSize, typeof(int)).ReadOnly = true;
			schema.Columns.Add(SchemaTableColumn.DataType, typeof(object)).ReadOnly = true;
			schema.Columns.Add(SchemaTableColumn.IsAliased, typeof(bool)).ReadOnly = true;
			schema.Columns.Add(SchemaTableColumn.IsExpression, typeof(bool)).ReadOnly = true;
			schema.Columns.Add(SchemaTableColumn.IsKey, typeof(bool)).ReadOnly = true;
			schema.Columns.Add(SchemaTableColumn.IsLong, typeof(bool)).ReadOnly = true;
			schema.Columns.Add(SchemaTableColumn.IsUnique, typeof(bool)).ReadOnly = true;
			schema.Columns.Add(SchemaTableColumn.NumericPrecision, typeof(short)).ReadOnly = true;
			schema.Columns.Add(SchemaTableColumn.NumericScale, typeof(short)).ReadOnly = true;
			schema.Columns.Add(SchemaTableColumn.ProviderType, typeof(int)).ReadOnly = true;

			schema.Columns.Add(SchemaTableOptionalColumn.BaseCatalogName, typeof(string)).ReadOnly = true;
			schema.Columns.Add(SchemaTableOptionalColumn.BaseServerName, typeof(string)).ReadOnly = true;
			schema.Columns.Add(SchemaTableOptionalColumn.IsAutoIncrement, typeof(bool)).ReadOnly = true;
			schema.Columns.Add(SchemaTableOptionalColumn.IsHidden, typeof(bool)).ReadOnly = true;
			schema.Columns.Add(SchemaTableOptionalColumn.IsReadOnly, typeof(bool)).ReadOnly = true;
			schema.Columns.Add(SchemaTableOptionalColumn.IsRowVersion, typeof(bool)).ReadOnly = true;

			string[] columnNames;

			if (_hasHeaders)
				columnNames = _fieldHeaders;
			else
			{
				columnNames = new string[_fieldCount];

				for (int i = 0; i < _fieldCount; i++)
					columnNames[i] = "Column" + i.ToString(CultureInfo.InvariantCulture);
			}

			// null marks columns that will change for each row
			object[] schemaRow = new object[] { 
					true,					// 00- AllowDBNull
					null,					// 01- BaseColumnName
					string.Empty,			// 02- BaseSchemaName
					string.Empty,			// 03- BaseTableName
					null,					// 04- ColumnName
					null,					// 05- ColumnOrdinal
					int.MaxValue,			// 06- ColumnSize
					typeof(string),			// 07- DataType
					false,					// 08- IsAliased
					false,					// 09- IsExpression
					false,					// 10- IsKey
					false,					// 11- IsLong
					false,					// 12- IsUnique
					DBNull.Value,			// 13- NumericPrecision
					DBNull.Value,			// 14- NumericScale
					(int) DbType.String,	// 15- ProviderType

					string.Empty,			// 16- BaseCatalogName
					string.Empty,			// 17- BaseServerName
					false,					// 18- IsAutoIncrement
					false,					// 19- IsHidden
					true,					// 20- IsReadOnly
					false					// 21- IsRowVersion
			  };

			for (int i = 0; i < columnNames.Length; i++)
			{
				schemaRow[1] = columnNames[i]; // Base column name
				schemaRow[4] = columnNames[i]; // Column name
				schemaRow[5] = i; // Column ordinal

				schema.Rows.Add(schemaRow);
			}

			return schema;
		}

		#endregion

		#region IDataRecord Members

		int IDataRecord.GetInt32(int i)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);

			string value = this[i];

			return Int32.Parse(value == null ? string.Empty : value, CultureInfo.CurrentCulture);
		}

		object IDataRecord.this[string name]
		{
			get
			{
				ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);
				return this[name];
			}
		}

		object IDataRecord.this[int i]
		{
			get
			{
				ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);
				return this[i];
			}
		}

		object IDataRecord.GetValue(int i)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);

			if (((IDataRecord) this).IsDBNull(i))
				return DBNull.Value;
			else
				return this[i];
		}

		bool IDataRecord.IsDBNull(int i)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);
			return (string.IsNullOrEmpty(this[i]));
		}

		long IDataRecord.GetBytes(int i, long fieldOffset, byte[] buffer, int bufferoffset, int length)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);

			return CopyFieldToArray(i, fieldOffset, buffer, bufferoffset, length);
		}

		byte IDataRecord.GetByte(int i)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);
			return Byte.Parse(this[i], CultureInfo.CurrentCulture);
		}

		Type IDataRecord.GetFieldType(int i)
		{
			EnsureInitialize();
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);

			if (i < 0 || i >= _fieldCount)
				throw new ArgumentOutOfRangeException("i", i, string.Format(CultureInfo.InvariantCulture, ExceptionMessage.FieldIndexOutOfRange, i));

			return typeof(string);
		}

		decimal IDataRecord.GetDecimal(int i)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);
			return Decimal.Parse(this[i], CultureInfo.CurrentCulture);
		}

		int IDataRecord.GetValues(object[] values)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);

			IDataRecord record = (IDataRecord) this;

			for (int i = 0; i < _fieldCount; i++)
				values[i] = record.GetValue(i);

			return _fieldCount;
		}

		string IDataRecord.GetName(int i)
		{
			EnsureInitialize();
			ValidateDataReader(DataReaderValidations.IsNotClosed);

			if (i < 0 || i >= _fieldCount)
				throw new ArgumentOutOfRangeException("i", i, string.Format(CultureInfo.InvariantCulture, ExceptionMessage.FieldIndexOutOfRange, i));

			if (_hasHeaders)
				return _fieldHeaders[i];
			else
				return "Column" + i.ToString(CultureInfo.InvariantCulture);
		}

		long IDataRecord.GetInt64(int i)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);
			return Int64.Parse(this[i], CultureInfo.CurrentCulture);
		}

		double IDataRecord.GetDouble(int i)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);
			return Double.Parse(this[i], CultureInfo.CurrentCulture);
		}

		bool IDataRecord.GetBoolean(int i)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);

			string value = this[i];

			int result;

			if (Int32.TryParse(value, out result))
				return (result != 0);
			else
				return Boolean.Parse(value);
		}

		Guid IDataRecord.GetGuid(int i)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);
			return new Guid(this[i]);
		}

		DateTime IDataRecord.GetDateTime(int i)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);
			return DateTime.Parse(this[i], CultureInfo.CurrentCulture);
		}

		int IDataRecord.GetOrdinal(string name)
		{
			EnsureInitialize();
			ValidateDataReader(DataReaderValidations.IsNotClosed);

			int index;

			if (!_fieldHeaderIndexes.TryGetValue(name, out index))
				throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, ExceptionMessage.FieldHeaderNotFound, name), "name");

			return index;
		}

		string IDataRecord.GetDataTypeName(int i)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);
			return typeof(string).FullName;
		}

		float IDataRecord.GetFloat(int i)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);
			return Single.Parse(this[i], CultureInfo.CurrentCulture);
		}

		IDataReader IDataRecord.GetData(int i)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);

			if (i == 0)
				return this;
			else
				return null;
		}

		long IDataRecord.GetChars(int i, long fieldoffset, char[] buffer, int bufferoffset, int length)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);

			return CopyFieldToArray(i, fieldoffset, buffer, bufferoffset, length);
		}

		string IDataRecord.GetString(int i)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);
			return this[i];
		}

		char IDataRecord.GetChar(int i)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);
			return Char.Parse(this[i]);
		}

		short IDataRecord.GetInt16(int i)
		{
			ValidateDataReader(DataReaderValidations.IsInitialized | DataReaderValidations.IsNotClosed);
			return Int16.Parse(this[i], CultureInfo.CurrentCulture);
		}

		#endregion

		#region IEnumerable<string[]> Members

		/// <summary>
		/// Returns an <see cref="T:RecordEnumerator"/>  that can iterate through CSV records.
		/// </summary>
		/// <returns>An <see cref="T:RecordEnumerator"/>  that can iterate through CSV records.</returns>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		public CsvReader.RecordEnumerator GetEnumerator()
		{
			return new CsvReader.RecordEnumerator(this);
		}

		/// <summary>
		/// Returns an <see cref="T:System.Collections.Generics.IEnumerator"/>  that can iterate through CSV records.
		/// </summary>
		/// <returns>An <see cref="T:System.Collections.Generics.IEnumerator"/>  that can iterate through CSV records.</returns>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		IEnumerator<string[]> IEnumerable<string[]>.GetEnumerator()
		{
			return this.GetEnumerator();
		}

		#endregion

		#region IEnumerable Members

		/// <summary>
		/// Returns an <see cref="T:System.Collections.IEnumerator"/>  that can iterate through CSV records.
		/// </summary>
		/// <returns>An <see cref="T:System.Collections.IEnumerator"/>  that can iterate through CSV records.</returns>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		///	The instance has been disposed of.
		/// </exception>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		#endregion

		#region IDisposable members

		/// <summary>
		/// Contains the disposed status flag.
		/// </summary>
		private bool _isDisposed = false;

		/// <summary>
		/// Contains the locking object for multi-threading purpose.
		/// </summary>
		private readonly object _lock = new object();

		/// <summary>
		/// Occurs when the instance is disposed of.
		/// </summary>
		public event EventHandler Disposed;

		/// <summary>
		/// Gets a value indicating whether the instance has been disposed of.
		/// </summary>
		/// <value>
		/// 	<see langword="true"/> if the instance has been disposed of; otherwise, <see langword="false"/>.
		/// </value>
		[System.ComponentModel.Browsable(false)]
		public bool IsDisposed
		{
			get { return _isDisposed; }
		}

		/// <summary>
		/// Raises the <see cref="M:Disposed"/> event.
		/// </summary>
		/// <param name="e">A <see cref="T:System.EventArgs"/> that contains the event data.</param>
		protected virtual void OnDisposed(EventArgs e)
		{
			EventHandler handler = Disposed;

			if (handler != null)
				handler(this, e);
		}

		/// <summary>
		/// Checks if the instance has been disposed of, and if it has, throws an <see cref="T:System.ComponentModel.ObjectDisposedException"/>; otherwise, does nothing.
		/// </summary>
		/// <exception cref="T:System.ComponentModel.ObjectDisposedException">
		/// 	The instance has been disposed of.
		/// </exception>
		/// <remarks>
		/// 	Derived classes should call this method at the start of all methods and properties that should not be accessed after a call to <see cref="M:Dispose()"/>.
		/// </remarks>
		protected void CheckDisposed()
		{
			if (_isDisposed)
				throw new ObjectDisposedException(this.GetType().FullName);
		}

		/// <summary>
		/// Releases all resources used by the instance.
		/// </summary>
		/// <remarks>
		/// 	Calls <see cref="M:Dispose(Boolean)"/> with the disposing parameter set to <see langword="true"/> to free unmanaged and managed resources.
		/// </remarks>
		public void Dispose()
		{
			if (!_isDisposed)
			{
				Dispose(true);
				GC.SuppressFinalize(this);
			}
		}

		/// <summary>
		/// Releases the unmanaged resources used by this instance and optionally releases the managed resources.
		/// </summary>
		/// <param name="disposing">
		/// 	<see langword="true"/> to release both managed and unmanaged resources; <see langword="false"/> to release only unmanaged resources.
		/// </param>
		protected virtual void Dispose(bool disposing)
		{
			// Refer to http://www.bluebytesoftware.com/blog/PermaLink,guid,88e62cdf-5919-4ac7-bc33-20c06ae539ae.aspx
			// Refer to http://www.gotdotnet.com/team/libraries/whitepapers/resourcemanagement/resourcemanagement.aspx

			// No exception should ever be thrown except in critical scenarios.
			// Unhandled exceptions during finalization will tear down the process.
			if (!_isDisposed)
			{
				try
				{
					// Dispose-time code should call Dispose() on all owned objects that implement the IDisposable interface. 
					// "owned" means objects whose lifetime is solely controlled by the container. 
					// In cases where ownership is not as straightforward, techniques such as HandleCollector can be used.  
					// Large managed object fields should be nulled out.

					// Dispose-time code should also set references of all owned objects to null, after disposing them. This will allow the referenced objects to be garbage collected even if not all references to the "parent" are released. It may be a significant memory consumption win if the referenced objects are large, such as big arrays, collections, etc. 
					if (disposing)
					{
						// Acquire a lock on the object while disposing.

						if (_reader != null)
						{
							lock (_lock)
							{
								if (_reader != null)
								{
									_reader.Dispose();

									_reader = null;
									_buffer = null;
									_eof = true;
								}
							}
						}
					}
				}
				finally
				{
					// Ensure that the flag is set
					_isDisposed = true;

					// Catch any issues about firing an event on an already disposed object.
					try
					{
						OnDisposed(EventArgs.Empty);
					}
					catch { }
				}
			}
		}

		/// <summary>
		/// Releases unmanaged resources and performs other cleanup operations before the instance is reclaimed by garbage collection.
		/// </summary>
		~CsvReader()
		{
			Dispose(false);
		}

		#endregion
	}
}
#endif
// file ...\IO\File\Csv\CsvReader.DataReaderValidations.cs
//	Zero5.IO.File.CSV.CsvReader.DataReaderValidations
//	Copyright (c) 2005 S�bastien Lorion
//
//	MIT license (http://en.wikipedia.org/wiki/MIT_License)
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights 
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//	of the Software, and to permit persons to whom the Software is furnished to do so, 
//	subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all 
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
//	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//	PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
//	FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#if !MOBILE


namespace Zero5.IO.File.Csv
{
	public partial class CsvReader
	{
		/// <summary>
		/// Defines the data reader validations.
		/// </summary>
		[Flags]
		private enum DataReaderValidations
		{
			/// <summary>
			/// No validation.
			/// </summary>
			None = 0,

			/// <summary>
			/// Validate that the data reader is initialized.
			/// </summary>
			IsInitialized = 1,

			/// <summary>
			/// Validate that the data reader is not closed.
			/// </summary>
			IsNotClosed = 2
		}
	}
}
#endif
// file ...\IO\File\Csv\CsvReader.RecordEnumerator.cs
//	Zero5.IO.File.CSV.CsvReader.RecordEnumerator
//	Copyright (c) 2005 S�bastien Lorion
//
//	MIT license (http://en.wikipedia.org/wiki/MIT_License)
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights 
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//	of the Software, and to permit persons to whom the Software is furnished to do so, 
//	subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all 
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
//	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//	PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
//	FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#if !MOBILE


namespace Zero5.IO.File.Csv
{
	public partial class CsvReader
	{
		/// <summary>
		/// Supports a simple iteration over the records of a <see cref="T:CsvReader"/>.
		/// </summary>
		public struct RecordEnumerator
			: IEnumerator<string[]>, IEnumerator
		{
			#region Fields

			/// <summary>
			/// Contains the enumerated <see cref="T:CsvReader"/>.
			/// </summary>
			private CsvReader _reader;

			/// <summary>
			/// Contains the current record.
			/// </summary>
			private string[] _current;

			/// <summary>
			/// Contains the current record index.
			/// </summary>
			private long _currentRecordIndex;

			#endregion

			#region Constructors

			/// <summary>
			/// Initializes a new instance of the <see cref="T:RecordEnumerator"/> class.
			/// </summary>
			/// <param name="reader">The <see cref="T:CsvReader"/> to iterate over.</param>
			/// <exception cref="T:ArgumentNullException">
			///		<paramref name="reader"/> is a <see langword="null"/>.
			/// </exception>
			public RecordEnumerator(CsvReader reader)
			{
				if (reader == null)
					throw new ArgumentNullException("reader");

				_reader = reader;
				_current = null;

				_currentRecordIndex = reader._currentRecordIndex;
			}

			#endregion

			#region IEnumerator<string[]> Members

			/// <summary>
			/// Gets the current record.
			/// </summary>
			public string[] Current
			{
				get { return _current; }
			}

			/// <summary>
			/// Advances the enumerator to the next record of the CSV.
			/// </summary>
			/// <returns><see langword="true"/> if the enumerator was successfully advanced to the next record, <see langword="false"/> if the enumerator has passed the end of the CSV.</returns>
			public bool MoveNext()
			{
				if (_reader._currentRecordIndex != _currentRecordIndex)
					throw new InvalidOperationException(ExceptionMessage.EnumerationVersionCheckFailed);

				if (_reader.ReadNextRecord())
				{
					_current = new string[_reader._fieldCount];

					_reader.CopyCurrentRecordTo(_current);
					_currentRecordIndex = _reader._currentRecordIndex;

					return true;
				}
				else
				{
					_current = null;
					_currentRecordIndex = _reader._currentRecordIndex;

					return false;
				}
			}

			#endregion

			#region IEnumerator Members

			/// <summary>
			/// Sets the enumerator to its initial position, which is before the first record in the CSV.
			/// </summary>
			public void Reset()
			{
				if (_reader._currentRecordIndex != _currentRecordIndex)
					throw new InvalidOperationException(ExceptionMessage.EnumerationVersionCheckFailed);

				_reader.MoveTo(-1);

				_current = null;
				_currentRecordIndex = _reader._currentRecordIndex;
			}

			/// <summary>
			/// Gets the current record.
			/// </summary>
			object IEnumerator.Current
			{
				get
				{
					if (_reader._currentRecordIndex != _currentRecordIndex)
						throw new InvalidOperationException(ExceptionMessage.EnumerationVersionCheckFailed);

					return this.Current;
				}
			}

			#endregion

			#region IDisposable Members

			/// <summary>
			/// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
			/// </summary>
			public void Dispose()
			{
				_reader = null;
				_current = null;
			}

			#endregion
		}
	}
}
#endif
// file ...\IO\File\Csv\MissingFieldAction.cs
//	Zero5.IO.File.CSV.MissingFieldAction
//	Copyright (c) 2006 S�bastien Lorion
//
//	MIT license (http://en.wikipedia.org/wiki/MIT_License)
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights 
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//	of the Software, and to permit persons to whom the Software is furnished to do so, 
//	subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all 
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
//	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//	PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
//	FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#if !MOBILE

namespace Zero5.IO.File.Csv
{
	/// <summary>
	/// Specifies the action to take when a field is missing.
	/// </summary>
	public enum MissingFieldAction
	{
		/// <summary>
		/// Treat as a parsing error.
		/// </summary>
		ParseError = 0,

		/// <summary>
		/// Replaces by an empty value.
		/// </summary>
		ReplaceByEmpty = 1,

		/// <summary>
		/// Replaces by a null value (<see langword="null"/>).
		/// </summary>
		ReplaceByNull = 2,
	}
}
#endif
// file ...\IO\File\Csv\ParseErrorAction.cs
//	Zero5.IO.File.CSV.ParseErrorAction
//	Copyright (c) 2006 S�bastien Lorion
//
//	MIT license (http://en.wikipedia.org/wiki/MIT_License)
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights 
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//	of the Software, and to permit persons to whom the Software is furnished to do so, 
//	subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all 
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
//	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//	PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
//	FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#if !MOBILE

namespace Zero5.IO.File.Csv
{
	/// <summary>
	/// Specifies the action to take when a parsing error has occured.
	/// </summary>
	public enum ParseErrorAction
	{
		/// <summary>
		/// Raises the <see cref="M:CsvReader.ParseError"/> event.
		/// </summary>
		RaiseEvent = 0,

		/// <summary>
		/// Tries to advance to next line.
		/// </summary>
		AdvanceToNextLine = 1,

		/// <summary>
		/// Throws an exception.
		/// </summary>
		ThrowException = 2,
	}
}

#endif
// file ...\IO\File\Csv\ValueTrimmingOptions.cs
#if !MOBILE

namespace Zero5.IO.File.Csv
{
	[Flags]
	public enum ValueTrimmingOptions
	{
		None = 0,
		UnquotedOnly = 1,
		QuotedOnly = 2,
		All = UnquotedOnly | QuotedOnly
	}
}
#endif
// file ...\IO\File\Csv\Events\ParseErrorEventArgs.cs
//	Zero5.IO.File.CSV.ParseErrorEventArgs
//	Copyright (c) 2006 S�bastien Lorion
//
//	MIT license (http://en.wikipedia.org/wiki/MIT_License)
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights 
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//	of the Software, and to permit persons to whom the Software is furnished to do so, 
//	subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all 
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
//	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//	PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
//	FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#if !MOBILE

namespace Zero5.IO.File.Csv
{
	/// <summary>
	/// Provides data for the <see cref="M:CsvReader.ParseError"/> event.
	/// </summary>
	public class ParseErrorEventArgs
		: EventArgs
	{
		#region Fields

		/// <summary>
		/// Contains the error that occured.
		/// </summary>
		private MalformedCsvException _error;

		/// <summary>
		/// Contains the action to take.
		/// </summary>
		private ParseErrorAction _action;

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the ParseErrorEventArgs class.
		/// </summary>
		/// <param name="error">The error that occured.</param>
		/// <param name="defaultAction">The default action to take.</param>
		public ParseErrorEventArgs(MalformedCsvException error, ParseErrorAction defaultAction)
			: base()
		{
			_error = error;
			_action = defaultAction;
		}

		#endregion

		#region Properties

		/// <summary>
		/// Gets the error that occured.
		/// </summary>
		/// <value>The error that occured.</value>
		public MalformedCsvException Error
		{
			get { return _error; }
		}

		/// <summary>
		/// Gets or sets the action to take.
		/// </summary>
		/// <value>The action to take.</value>
		public ParseErrorAction Action
		{
			get { return _action; }
			set { _action = value; }
		}

		#endregion
	}
}
#endif
// file ...\IO\File\Csv\Exceptions\MalformedCsvException.cs
//	Zero5.IO.File.Csv.MalformedCsvException
//	Copyright (c) 2005 S�bastien Lorion
//
//	MIT license (http://en.wikipedia.org/wiki/MIT_License)
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights 
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//	of the Software, and to permit persons to whom the Software is furnished to do so, 
//	subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all 
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
//	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//	PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
//	FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#if !MOBILE


namespace Zero5.IO.File.Csv
{
	/// <summary>
	/// Represents the exception that is thrown when a CSV file is malformed.
	/// </summary>
	public class MalformedCsvException 
		: Exception
	{
		#region Fields

		/// <summary>
		/// Contains the message that describes the error.
		/// </summary>
		private string _message;

		/// <summary>
		/// Contains the raw data when the error occured.
		/// </summary>
		private string _rawData;

		/// <summary>
		/// Contains the current field index.
		/// </summary>
		private int _currentFieldIndex;

		/// <summary>
		/// Contains the current record index.
		/// </summary>
		private long _currentRecordIndex;

		/// <summary>
		/// Contains the current position in the raw data.
		/// </summary>
		private int _currentPosition;

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the MalformedCsvException class.
		/// </summary>
		public MalformedCsvException()
			: this(null, null)
		{
		}

		/// <summary>
		/// Initializes a new instance of the MalformedCsvException class.
		/// </summary>
		/// <param name="message">The message that describes the error.</param>
		public MalformedCsvException(string message)
			: this(message, null)
		{
		}

		/// <summary>
		/// Initializes a new instance of the MalformedCsvException class.
		/// </summary>
		/// <param name="message">The message that describes the error.</param>
		/// <param name="innerException">The exception that is the cause of the current exception.</param>
		public MalformedCsvException(string message, Exception innerException)
			: base(String.Empty, innerException)
		{
			_message = (message == null ? string.Empty : message);

			_rawData = string.Empty;
			_currentPosition = -1;
			_currentRecordIndex = -1;
			_currentFieldIndex = -1;
		}

		/// <summary>
		/// Initializes a new instance of the MalformedCsvException class.
		/// </summary>
		/// <param name="rawData">The raw data when the error occured.</param>
		/// <param name="currentPosition">The current position in the raw data.</param>
		/// <param name="currentRecordIndex">The current record index.</param>
		/// <param name="currentFieldIndex">The current field index.</param>
		public MalformedCsvException(string rawData, int currentPosition, long currentRecordIndex, int currentFieldIndex)
			: this(rawData, currentPosition, currentRecordIndex, currentFieldIndex, null)
		{
		}

		/// <summary>
		/// Initializes a new instance of the MalformedCsvException class.
		/// </summary>
		/// <param name="rawData">The raw data when the error occured.</param>
		/// <param name="currentPosition">The current position in the raw data.</param>
		/// <param name="currentRecordIndex">The current record index.</param>
		/// <param name="currentFieldIndex">The current field index.</param>
		/// <param name="innerException">The exception that is the cause of the current exception.</param>
		public MalformedCsvException(string rawData, int currentPosition, long currentRecordIndex, int currentFieldIndex, Exception innerException)
			: base(String.Empty, innerException)
		{
			_rawData = (rawData == null ? string.Empty : rawData);
			_currentPosition = currentPosition;
			_currentRecordIndex = currentRecordIndex;
			_currentFieldIndex = currentFieldIndex;

			_message = String.Format(CultureInfo.InvariantCulture, ExceptionMessage.MalformedCsvException, _currentRecordIndex, _currentFieldIndex, _currentPosition, _rawData);
		}

		#endregion

		#region Properties

		/// <summary>
		/// Gets the raw data when the error occured.
		/// </summary>
		/// <value>The raw data when the error occured.</value>
		public string RawData
		{
			get { return _rawData; }
		}

		/// <summary>
		/// Gets the current position in the raw data.
		/// </summary>
		/// <value>The current position in the raw data.</value>
		public int CurrentPosition
		{
			get { return _currentPosition; }
		}

		/// <summary>
		/// Gets the current record index.
		/// </summary>
		/// <value>The current record index.</value>
		public long CurrentRecordIndex
		{
			get { return _currentRecordIndex; }
		}

		/// <summary>
		/// Gets the current field index.
		/// </summary>
		/// <value>The current record index.</value>
		public int CurrentFieldIndex
		{
			get { return _currentFieldIndex; }
		}

		#endregion

		#region Overrides

		/// <summary>
		/// Gets a message that describes the current exception.
		/// </summary>
		/// <value>A message that describes the current exception.</value>
		public override string Message
		{
			get { return _message; }
		}

		/// <summary>
		/// When overridden in a derived class, sets the <see cref="T:SerializationInfo"/> with information about the exception.
		/// </summary>
		/// <param name="info">The <see cref="T:SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
		/// <param name="context">The <see cref="T:StreamingContext"/> that contains contextual information about the source or destination.</param>
		public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
		{
			base.GetObjectData(info, context);

			info.AddValue("MyMessage", _message);

			info.AddValue("RawData", _rawData);
			info.AddValue("CurrentPosition", _currentPosition);
			info.AddValue("CurrentRecordIndex", _currentRecordIndex);
			info.AddValue("CurrentFieldIndex", _currentFieldIndex);
		}

		#endregion
	}
}

#endif
// file ...\IO\File\Csv\Exceptions\MissingFieldCsvException.cs
//	Zero5.IO.File.Csv.MissingFieldCsvException
//	Copyright (c) 2005 S�bastien Lorion
//
//	MIT license (http://en.wikipedia.org/wiki/MIT_License)
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights 
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//	of the Software, and to permit persons to whom the Software is furnished to do so, 
//	subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all 
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
//	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
//	PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
//	FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#if !MOBILE


namespace Zero5.IO.File.Csv
{
	/// <summary>
	/// Represents the exception that is thrown when a there is a missing field in a record of the CSV file.
	/// </summary>
	/// <remarks>
	/// MissingFieldException would have been a better name, but there is already a <see cref="T:System.MissingFieldException"/>.
	/// </remarks>
	public class MissingFieldCsvException
		: MalformedCsvException
	{
		#region Constructors

		/// <summary>
		/// Initializes a new instance of the MissingFieldCsvException class.
		/// </summary>
		public MissingFieldCsvException()
			: base()
		{
		}

		/// <summary>
		/// Initializes a new instance of the MissingFieldCsvException class.
		/// </summary>
		/// <param name="message">The message that describes the error.</param>
		public MissingFieldCsvException(string message)
			: base(message)
		{
		}

		/// <summary>
		/// Initializes a new instance of the MissingFieldCsvException class.
		/// </summary>
		/// <param name="message">The message that describes the error.</param>
		/// <param name="innerException">The exception that is the cause of the current exception.</param>
		public MissingFieldCsvException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		/// <summary>
		/// Initializes a new instance of the MissingFieldCsvException class.
		/// </summary>
		/// <param name="rawData">The raw data when the error occured.</param>
		/// <param name="currentPosition">The current position in the raw data.</param>
		/// <param name="currentRecordIndex">The current record index.</param>
		/// <param name="currentFieldIndex">The current field index.</param>
		public MissingFieldCsvException(string rawData, int currentPosition, long currentRecordIndex, int currentFieldIndex)
			: base(rawData, currentPosition, currentRecordIndex, currentFieldIndex)
		{
		}

		/// <summary>
		/// Initializes a new instance of the MissingFieldCsvException class.
		/// </summary>
		/// <param name="rawData">The raw data when the error occured.</param>
		/// <param name="currentPosition">The current position in the raw data.</param>
		/// <param name="currentRecordIndex">The current record index.</param>
		/// <param name="currentFieldIndex">The current field index.</param>
		/// <param name="innerException">The exception that is the cause of the current exception.</param>
		public MissingFieldCsvException(string rawData, int currentPosition, long currentRecordIndex, int currentFieldIndex, Exception innerException)
			: base(rawData, currentPosition, currentRecordIndex, currentFieldIndex, innerException)
		{
		}

		#endregion
	}
}
#endif
// file ...\IO\File\Csv\Resources\ExceptionMessage.Designer.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Zero5.IO.File.Csv.Resources {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class ExceptionMessage {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal ExceptionMessage() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Zero5.IO.File.Csv.Resources.ExceptionMessage", typeof(ExceptionMessage).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Buffer size must be 1 or more..
        /// </summary>
        internal static string BufferSizeTooSmall {
            get {
                return ResourceManager.GetString("BufferSizeTooSmall", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cannot move to a previous record in forward-only mode..
        /// </summary>
        internal static string CannotMovePreviousRecordInForwardOnly {
            get {
                return ResourceManager.GetString("CannotMovePreviousRecordInForwardOnly", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cannot read record at index &apos;{0}&apos;..
        /// </summary>
        internal static string CannotReadRecordAtIndex {
            get {
                return ResourceManager.GetString("CannotReadRecordAtIndex", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enumeration has either not started or has already finished..
        /// </summary>
        internal static string EnumerationFinishedOrNotStarted {
            get {
                return ResourceManager.GetString("EnumerationFinishedOrNotStarted", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Collection was modified; enumeration operation may not execute..
        /// </summary>
        internal static string EnumerationVersionCheckFailed {
            get {
                return ResourceManager.GetString("EnumerationVersionCheckFailed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; field header not found..
        /// </summary>
        internal static string FieldHeaderNotFound {
            get {
                return ResourceManager.GetString("FieldHeaderNotFound", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Field index must be included in [0, FieldCount[. Specified field index was : &apos;{0}&apos;..
        /// </summary>
        internal static string FieldIndexOutOfRange {
            get {
                return ResourceManager.GetString("FieldIndexOutOfRange", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The CSV appears to be corrupt near record &apos;{0}&apos; field &apos;{1} at position &apos;{2}&apos;. Current raw data : &apos;{3}&apos;..
        /// </summary>
        internal static string MalformedCsvException {
            get {
                return ResourceManager.GetString("MalformedCsvException", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is not a supported missing field action..
        /// </summary>
        internal static string MissingFieldActionNotSupported {
            get {
                return ResourceManager.GetString("MissingFieldActionNotSupported", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No current record..
        /// </summary>
        internal static string NoCurrentRecord {
            get {
                return ResourceManager.GetString("NoCurrentRecord", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The CSV does not have headers (CsvReader.HasHeaders property is false)..
        /// </summary>
        internal static string NoHeaders {
            get {
                return ResourceManager.GetString("NoHeaders", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The number of fields in the record is greater than the available space from index to the end of the destination array..
        /// </summary>
        internal static string NotEnoughSpaceInArray {
            get {
                return ResourceManager.GetString("NotEnoughSpaceInArray", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is not a valid ParseErrorAction while inside a ParseError event..
        /// </summary>
        internal static string ParseErrorActionInvalidInsideParseErrorEvent {
            get {
                return ResourceManager.GetString("ParseErrorActionInvalidInsideParseErrorEvent", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is not a supported ParseErrorAction..
        /// </summary>
        internal static string ParseErrorActionNotSupported {
            get {
                return ResourceManager.GetString("ParseErrorActionNotSupported", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This operation is invalid when the reader is closed..
        /// </summary>
        internal static string ReaderClosed {
            get {
                return ResourceManager.GetString("ReaderClosed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Record index must be 0 or more..
        /// </summary>
        internal static string RecordIndexLessThanZero {
            get {
                return ResourceManager.GetString("RecordIndexLessThanZero", resourceCulture);
            }
        }
    }
}
// file ...\IO\File\Csv\Resources\ExceptionMessage1.Designer.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Resources {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class ExceptionMessage {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal ExceptionMessage() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Zero5.IO.File.Csv.Resources.ExceptionMessage", typeof(ExceptionMessage).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Buffer size must be 1 or more..
        /// </summary>
        internal static string BufferSizeTooSmall {
            get {
                return ResourceManager.GetString("BufferSizeTooSmall", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cannot move to a previous record in forward-only mode..
        /// </summary>
        internal static string CannotMovePreviousRecordInForwardOnly {
            get {
                return ResourceManager.GetString("CannotMovePreviousRecordInForwardOnly", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cannot read record at index &apos;{0}&apos;..
        /// </summary>
        internal static string CannotReadRecordAtIndex {
            get {
                return ResourceManager.GetString("CannotReadRecordAtIndex", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enumeration has either not started or has already finished..
        /// </summary>
        internal static string EnumerationFinishedOrNotStarted {
            get {
                return ResourceManager.GetString("EnumerationFinishedOrNotStarted", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Collection was modified; enumeration operation may not execute..
        /// </summary>
        internal static string EnumerationVersionCheckFailed {
            get {
                return ResourceManager.GetString("EnumerationVersionCheckFailed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; field header not found..
        /// </summary>
        internal static string FieldHeaderNotFound {
            get {
                return ResourceManager.GetString("FieldHeaderNotFound", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Field index must be included in [0, FieldCount[. Specified field index was : &apos;{0}&apos;..
        /// </summary>
        internal static string FieldIndexOutOfRange {
            get {
                return ResourceManager.GetString("FieldIndexOutOfRange", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The CSV appears to be corrupt near record &apos;{0}&apos; field &apos;{1} at position &apos;{2}&apos;. Current raw data : &apos;{3}&apos;..
        /// </summary>
        internal static string MalformedCsvException {
            get {
                return ResourceManager.GetString("MalformedCsvException", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is not a supported missing field action..
        /// </summary>
        internal static string MissingFieldActionNotSupported {
            get {
                return ResourceManager.GetString("MissingFieldActionNotSupported", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No current record..
        /// </summary>
        internal static string NoCurrentRecord {
            get {
                return ResourceManager.GetString("NoCurrentRecord", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The CSV does not have headers (CsvReader.HasHeaders property is false)..
        /// </summary>
        internal static string NoHeaders {
            get {
                return ResourceManager.GetString("NoHeaders", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The number of fields in the record is greater than the available space from index to the end of the destination array..
        /// </summary>
        internal static string NotEnoughSpaceInArray {
            get {
                return ResourceManager.GetString("NotEnoughSpaceInArray", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is not a valid ParseErrorAction while inside a ParseError event..
        /// </summary>
        internal static string ParseErrorActionInvalidInsideParseErrorEvent {
            get {
                return ResourceManager.GetString("ParseErrorActionInvalidInsideParseErrorEvent", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is not a supported ParseErrorAction..
        /// </summary>
        internal static string ParseErrorActionNotSupported {
            get {
                return ResourceManager.GetString("ParseErrorActionNotSupported", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This operation is invalid when the reader is closed..
        /// </summary>
        internal static string ReaderClosed {
            get {
                return ResourceManager.GetString("ReaderClosed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Record index must be 0 or more..
        /// </summary>
        internal static string RecordIndexLessThanZero {
            get {
                return ResourceManager.GetString("RecordIndexLessThanZero", resourceCulture);
            }
        }
    }
}
// file ...\IO\Host\HostPinger.cs
#if !MOBILE

/*
 * 
 * Copyright (c) 2006-2010 Mladen Jankovic. All rights reserved.
 * 
 * contact: kataklinger@gmail[dot]com
 * 
 *	- Redistributions of source code must retain the above copyright notice,
 *	  this list of conditions and the following disclaimer. 
 * 
 *	- Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 * 
 *  - The names of contributors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */


namespace Zero5.IO.Host
{

	#region HostPinger Events' Delegates

	public delegate void OnPingDelegate(HostPinger host);

	public delegate void OnHostStatusChangeDelegate(HostPinger host,
		HostStatus oldStatus, HostStatus newStatus);

	public delegate void OnHostPingerCommandDelegate(HostPinger host);

	public delegate void OnHostNameChangedDelegate(HostPinger host);

	#endregion

	#region HostPinger

	/// <summary>
	/// Stores information about host and ping options, performs pinging, statistical calculations and stors statistics.
	/// </summary>
	public class HostPinger
	{

		#region Public Constants

		/// <summary>
		/// Number of defined host statuses.
		/// </summary>
		public const int NUMBER_OF_STATUSES = 4;

		#endregion

		#region ID

		/// <summary>
		/// ID of the host that is automatically assigned.
		/// </summary>
		private int _id;

		/// <summary>
		/// ID of the host that is automatically assigned.
		/// </summary>
		public int ID
		{
			get { return _id; }
            set { _id = value; }
		}

		/// <summary>
		/// Protects ID assigning process from concurent access.
		/// </summary>
		private static object _idLock = new object();

		/// <summary>
		/// ID that will be assigned to new host.
		/// </summary>
		private static int _nextID;

		/// <summary>
		/// Updates ID tracker with ID of loaded host.
		/// </summary>
		/// <param name="id">ID of loaded host.</param>
		private static void UpdateIDTrack(int id)
		{
			lock (_idLock)
			{
				if (_nextID <= id)
					_nextID = id + 1;
			}
		}

		#endregion

		#region Host Infromation

		#region IPAddres

		/// <summary>
		/// Host's IP address.
		/// </summary>
		private IPAddress _hostIP;

		/// <summary>
		/// Host's IP address.
		/// </summary>
		public IPAddress HostIP
		{
			get
			{
				lock (_syncObject)
					return _hostIP != null ? _hostIP : new IPAddress(0);
			}
			set
			{
				lock (_syncObject)
				{
					_hostIP = value;

					// successfully obtained IP address from previously unavailable DNS
					if (_status == HostStatus.DnsError)
						Status = HostStatus.Unknown;
				}
			}
		}

		#endregion

		#region HostName

		/// <summary>
		/// Name of the host.
		/// </summary>
		private string _hostName = string.Empty;

		/// <summary>
		/// Name of the host.
		/// </summary>
		public string HostName
		{
			get
			{
				lock (_syncObject)
					return _hostName;
			}
			set
			{
				lock (_syncObject)
					_hostName = value;
			}
		}

		#endregion

		#region HostDescription

		/// <summary>
		/// Description of the host.
		/// </summary>
		private string _hostDescription = string.Empty;

		/// <summary>
		/// Description of the host.
		/// </summary>
		public string HostDescription
		{
			get
			{
				lock (_syncObject)
					return _hostDescription;
			}
			set
			{
				lock (_syncObject)
					_hostDescription = value;
			}
		}

		#endregion

		#endregion

		#region Status

		/// <summary>
		/// Current status of the host.
		/// </summary>
		private HostStatus _status = HostStatus.Unknown;

		/// <summary>
		/// Current status of the host.
		/// </summary>
		public HostStatus Status
		{
			get
			{
				lock (_syncObject)
					return _isRunning ? _status : HostStatus.Unknown;
			}

			private set
			{
				// no change to the status?
				if (_status == value && _status != HostStatus.Unknown)
					// no need to perform calculation about status durations
					return;

				DateTime now = DateTime.Now;

				// duration of the old status
				TimeSpan duration = now - _statusReachedAt;

				// duration of the old status is valid only if the pinging was active during that time
				if (_isRunning)
					_statusDurations[(int)_status] += duration;

				// save time when the new status is reached
				_statusReachedAt = now;

				HostStatus old = _status;
				_status = value;

				// notify listeners that status of the host is changed
				ThreadPool.QueueUserWorkItem(new WaitCallback(RaiseOnStatusChange),
					new OnHostStatusChangeParams(old, _status));
			}
		}

		/// <summary>
		/// Name of current state of the host;
		/// </summary>
		public string StatusName
		{
			get
			{
				HostStatus status = Status;
				switch (status)
				{
					case HostStatus.Dead:
						return "Dead";
					case HostStatus.Alive:
						return "Alive";
					case HostStatus.DnsError:
						return "Dns Error";
				}

				return "Unknown";
			}
		}

		#endregion

		#region Statistics

		#region Counting Statistics

		private int _continousPacketLost = 0;

		#region SentPakets

		private int _sentPackets;

		public int SentPackets
		{
			get
			{
				lock (_syncObject)
					return _sentPackets;
			}
		}

		#endregion

		#region ReceivedPackets

		private int _receivedPackets;

		public int ReceivedPackets
		{
			get
			{
				lock (_syncObject)
					return _receivedPackets;
			}
		}

		#endregion

		#region ReceivedPacketsPercent

		public float ReceivedPacketsPercent
		{
			get
			{
				lock (_syncObject)
					return (float)_receivedPackets / _sentPackets * 100;
			}
		}

		#endregion

		#region LostPackets

		private int _lostPackets;

		public int LostPackets
		{
			get
			{
				lock (_syncObject)
					return _lostPackets;
			}
		}

		#endregion

		#region LostPacketsPercent

		public float LostPacketsPercent
		{
			get
			{
				lock (_syncObject)
					return (float)_lostPackets / _sentPackets * 100;
			}
		}

		#endregion

		#region LastPacketLost

		private bool _lastPacketLost = false;

		public bool LastPacketLost
		{
			get
			{
				lock (_syncObject)
					return _lastPacketLost;
			}
		}

		#endregion

		#region ConsecutivePacketsLost

		private int _consecutivePacketsLost;

		public int ConsecutivePacketsLost
		{
			get
			{
				lock (_syncObject)
					return _consecutivePacketsLost;
			}
		}

		#endregion

		#region MaxConsecutivePacketsLost

		private int _maxConsecutivePacketsLost = 0;

		public int MaxConsecutivePacketsLost
		{
			get
			{
				lock (_syncObject)
					return _maxConsecutivePacketsLost;
			}
		}

		#endregion

		#region Recent History

		#region RecentlyReceivedPackets

		public int RecentlyReceivedPackets
		{
			get
			{
				lock (_syncObject)
					return _recentHistory.ReceivedCount;
			}
		}

		#endregion

		#region RecentlyReceivedPacketsPercent

		public float RecentlyReceivedPacketsPercent
		{
			get
			{
				lock (_syncObject)
					return _recentHistory.ReceivedCountPercent;
			}
		}

		#endregion

		#region RecentlyLostPackets

		public int RecentlyLostPackets
		{
			get
			{
				lock (_syncObject)
					return _recentHistory.LostCount;
			}
		}

		#endregion

		#region RecentlyLostPacketsPercent

		public float RecentlyLostPacketsPercent
		{
			get
			{
				lock (_syncObject)
					return _recentHistory.LostCountPercent;
			}
		}

		#endregion

		#endregion

		#endregion

		#region Time Statistics

		#region CurrentResponseTime

		/// <summary>
		/// Response time of the last successfull ping.
		/// </summary>
		private long _currentResponseTime;

		/// <summary>
		/// Response time of the last successfull ping.
		/// </summary>
		public long CurrentResponseTime
		{
			get
			{
				lock (_syncObject)
					return _currentResponseTime;
			}
		}

		#endregion

		#region AverageResponseTime

		/// <summary>
		/// Sum of response times of all successfull pings.
		/// </summary>
		private long _totalResponseTime = 0;

		/// <summary>
		/// Calculates and returns average response time of the host.
		/// </summary>
		public float AverageResponseTime
		{
			get
			{
				lock (_syncObject)
					return _receivedPackets != 0 ? (float)_totalResponseTime / _receivedPackets : 0;
			}
		}

		#endregion

		#region MinResponseTime

		private long _minResponseTime = long.MaxValue;

		public long MinResponseTime
		{
			get
			{
				lock (_syncObject)
					return _minResponseTime;
			}
		}

		#endregion

		#region MaxResponseTime

		private long _maxResponseTime = 0;

		public long MaxResponseTime
		{
			get
			{
				lock (_syncObject)
					return _maxResponseTime;
			}
		}

		#endregion

		#region CurrentStatusDuration

		/// <summary>
		/// Time when the current status is reached.
		/// </summary>
		private DateTime _statusReachedAt = DateTime.Now;

		/// <summary>
		/// Duration of the current status. 
		/// </summary>
		public TimeSpan CurrentStatusDuration
		{
			get
			{
				lock (_syncObject)
					return DateTime.Now.Subtract(_statusReachedAt);
			}
		}

		#endregion

		#region StatusDurations

		/// <summary>
		/// Array of the durations of each status.
		/// </summary>
		private TimeSpan[] _statusDurations = new TimeSpan[NUMBER_OF_STATUSES];

		/// <summary>
		/// Method returns duration of specific status.
		/// </summary>
		/// <param name="status">status whose duration is queried.</param>
		/// <returns>Returns duration of specific status.</returns>
		public TimeSpan GetStatusDuration(HostStatus status)
		{
			lock (_syncObject)
			{
				TimeSpan duration = _statusDurations[(int)status];
				if (_status == status && _isRunning)
					duration += DateTime.Now - _statusReachedAt;

				return duration;
			}
		}

		#endregion

		#region HostAvailability

		/// <summary>
		/// Calculates and returns availability of the host in percents.
		/// </summary>
		public float HostAvailability
		{
			get
			{
				lock (_syncObject)
				{
					// total test time
					long total = _totalTestDuration.Ticks;

					// total available time
					long available = _statusDurations[(int)HostStatus.Alive].Ticks;

					// include current status duration
					if (_isRunning)
					{
						DateTime now = DateTime.Now;

						// current status duration
						total += now.Subtract(_startTime).Ticks;

						// include to total available time if the current state is alive
						if (_status == HostStatus.Alive)
							available += (now - _statusReachedAt).Ticks;
					}

					// calculate and returns availability in parecents
					return (float)((double)available / total * 100);
				}
			}
		}

		#endregion

		#region Test Durations

		/// <summary>
		/// Time when the pinging was started.
		/// </summary>
        private DateTime _startTime = DateTime.Now;

        public DateTime StartTime
        {
            get { return _startTime; }
        }

		#region CurrentTestDuration

		/// <summary>
		/// Time that has passed since the current pinging is started.
		/// </summary>
		public TimeSpan CurrentTestDuration
		{
			get
			{
				lock (_syncObject)
				{
					return _isRunning ? DateTime.Now.Subtract(_startTime) : new TimeSpan(0);
				}
			}
		}

		#endregion

		#region TotalTestDuration

		/// <summary>
		/// Total duration of the pingign since the program was started.
		/// </summary>
		private TimeSpan _totalTestDuration;

		/// <summary>
		/// Total duration of the pingign since the program was started.
		/// </summary>
		public TimeSpan TotalTestDuration
		{
			get
			{
				lock (_syncObject)
				{
					return _isRunning
						? _totalTestDuration + DateTime.Now.Subtract(_startTime)
						: _totalTestDuration;
				}
			}
		}

		#endregion

		#endregion

		#endregion

		#region Counting

		/// <summary>
		/// Increments number of lost packets and change status of the host if enough successive packets are lost.
		/// </summary>
		private void IncLost()
		{
			_sentPackets++;
			_lostPackets++;
			_consecutivePacketsLost++;
			_lastPacketLost = true;

			if (_consecutivePacketsLost > _maxConsecutivePacketsLost)
				_maxConsecutivePacketsLost = _consecutivePacketsLost;

			_recentHistory.AddPingResult(false);

			// enough packets has been lost so we can assume that the host is dead 
			if (++_continousPacketLost > _pingsBeforeDead && _status != HostStatus.Dead)
				Status = HostStatus.Dead;
		}

		/// <summary>
		/// Increments number of responded pings and sets status of the host to <see cref="Alive"/>.
		/// </summary>
		/// <param name="time">response time.</param>
		private void IncReceived(long time)
		{
			_sentPackets++;
			_receivedPackets++;
			_consecutivePacketsLost = 0;
			_lastPacketLost = false;

			_recentHistory.AddPingResult(true);

			_totalResponseTime += time;
			_currentResponseTime = time;

			if (time > _maxResponseTime)
				_maxResponseTime = time;

			if (time < _minResponseTime)
				_minResponseTime = time;

			// restarts counter
			_continousPacketLost = 0;

			if (_status != HostStatus.Alive)
				Status = HostStatus.Alive;
		}

		#endregion

		#region ClearStatistics

		/// <summary>
		/// Clears statistics.
		/// </summary>
		/// <param name="clearTimes">if this parameter is set to <c>true</c> this method also clears time statistics
		/// such as durations of specific statuses and test durations.</param>
		public void ClearStatistics(bool clearTimes)
		{
			lock (_syncObject)
			{
				_sentPackets = 0;
				_receivedPackets = 0;
				_lostPackets = 0;
				_currentResponseTime = 0;
				_totalResponseTime = 0;
				_minResponseTime = long.MaxValue;
				_maxResponseTime = 0;
				_continousPacketLost = 0;
				_consecutivePacketsLost = 0;
				_maxConsecutivePacketsLost = 0;
				_lastPacketLost = false;

				_recentHistory.Clear();

				if (clearTimes)
				{
					_statusReachedAt = DateTime.Now;
					_startTime = DateTime.Now;

					for (int i = _statusDurations.Length - 1; i >= 0; i--)
						_statusDurations[i] = new TimeSpan(0);
				}
			}
		}

		#endregion

		#endregion

		#region Options

		#region TTL

		/// <summary>
		/// Default Time-To-Live.
		/// </summary>
		public static readonly int DEFAULT_TTL = 32;

		/// <summary>
		/// Time-to-live for echo message.
		/// </summary>
		private int _ttl = DEFAULT_TTL;

		/// <summary>
		/// Time-to-live for echo message.
		/// </summary>
		public int TTL
		{
			get
			{
				lock (_syncObject)
					return _ttl;
			}
			set
			{
				lock (_syncObject)
				{
					if (value > 0 && value != _ttl)
					{
						_ttl = value;
						_pingerOptions.Ttl = value;
					}
				}
			}
		}

		#endregion

		#region DontFragment

		/// <summary>
		/// Default state of 'do not fragment' flag.
		/// </summary>
		public static readonly bool DEFALUT_FRAGMENT = false;

		/// <summary>
		/// Stat of 'do not fragment' flag of IP header.
		/// </summary>
		private bool _dontFragment;

		/// <summary>
		/// Stat of 'do not fragment' flag of IP header.
		/// </summary>
		public bool DontFragment
		{
			get
			{
				lock (_syncObject)
					return _dontFragment;
			}
			set
			{
				lock (_syncObject)
				{
					if (value != _dontFragment)
					{
						_dontFragment = value;
						_pingerOptions.DontFragment = value;
					}
				}
			}
		}

		#endregion

		#region BufferSize

		/// <summary>
		/// Default size of data sent in a single echo message (in bytes).
		/// </summary>
		public static readonly int DEFAULT_BUFFER_SIZE = 32;

		/// <summary>
		/// Size of data sent in a single echo message (in bytes).
		/// </summary>
		private int _bufferSize = DEFAULT_BUFFER_SIZE;

		/// <summary>
		/// Size of data sent in a single echo message (in bytes).
		/// </summary>
		public int BufferSize
		{
			get
			{
				lock (_syncObject)
					return _bufferSize;
			}
			set
			{
				lock (_syncObject)
				{
					if (value > 0)
					{
						_bufferSize = value;
						_buffer = new byte[value];
					}
				}
			}
		}

		#endregion

		#region Timeout

		/// <summary>
		/// Default timeout period for the echo message.
		/// </summary>
		public static readonly int DEFAULT_TIMEOUT = 2000;

		/// <summary>
		/// Timeout period for the message.
		/// </summary>
		private int _timeout = DEFAULT_TIMEOUT;

		/// <summary>
		/// Timeout period for the message.
		/// </summary>
		public int Timeout
		{
			get
			{
				lock (_syncObject)
					return _timeout;
			}
			set
			{
				lock (_syncObject)
					_timeout = value;
			}
		}


		#endregion

		#region PingInterval

		/// <summary>
		/// Default duration interval between end of processing of the previous message
		/// and sending of new echo message (in milliseconds).
		/// </summary>
		public static readonly int DEFAULT_PING_INTERVAL = 1000;

		/// <summary>
		/// Duration interval between end of processing of the previous message and sending of new echo message (in milliseconds).
		/// </summary>
		private int _pingInterval = DEFAULT_PING_INTERVAL;

		/// <summary>
		/// Duration interval between end of processing of the previous message and sending of new echo message (in milliseconds).
		/// </summary>
		public int PingInterval
		{
			get
			{
				lock (_syncObject)
					return _pingInterval;
			}
			set
			{
				lock (_syncObject)
					_pingInterval = value;
			}
		}

		#endregion

		#region DnsQueryInterval

		/// <summary>
		/// Default duration interval between DNS quiries 
		/// while pinger tries to obtain IP address (in milliseconds).
		/// </summary>
		public static readonly int DEFAULT_DNS_QUERY_INTERVAL = 60000;

		/// <summary>
		/// Interval duration between DNS quiries while pinger tries to obtain IP address (in milliseconds).
		/// </summary>
		private int _dnsQueryInterval = DEFAULT_DNS_QUERY_INTERVAL;

		/// <summary>
		/// Interval duration between DNS quiries while pinger tries to obtain IP address (in milliseconds).
		/// </summary>
		public int DnsQueryInterval
		{
			get
			{
				lock (_syncObject)
					return _dnsQueryInterval;
			}

			set
			{
				lock (_syncObject)
					_dnsQueryInterval = value;
			}
		}

		#endregion

		#region PingsBeforeDead

		/// <summary>
		/// Default number of packets that should be lost successivly to declare host as dead.
		/// </summary>
		public static readonly int DEFALUT_PINGS_BEFORE_DEAD = 10;

		/// <summary>
		/// Number of packets that should be lost successivly to declare host as dead.
		/// </summary>
		private int _pingsBeforeDead = DEFALUT_PINGS_BEFORE_DEAD;

		/// <summary>
		/// Number of packets that should be lost successivly to declare host as dead.
		/// </summary>
		public int PingsBeforeDead
		{
			get
			{
				lock (_syncObject)
					return _pingsBeforeDead;
			}
			set
			{
				lock (_syncObject)
					_pingsBeforeDead = value;
			}
		}

		#endregion

		#region RecentHisoryDepth

		/// <summary>
		/// Depth of recent history (number of results of previous pings that are stored in history buffer).
		/// </summary>
		public int RecentHisoryDepth
		{
			get
			{
				lock (_syncObject)
					return _recentHistory.BufferSize;
			}

			set
			{
				lock (_syncObject)
					_recentHistory.BufferSize = value;
			}
		}

		#endregion

		#endregion

		#region Private Attributes

		/// <summary>
		/// Buffer that is sent as echo message.
		/// </summary>
		byte[] _buffer = new byte[DEFAULT_BUFFER_SIZE];

		/// <summary>
		/// Timer used to initiate ping.
		/// </summary>
		System.Timers.Timer _timer = new System.Timers.Timer();

		/// <summary>
		/// Ping object used for pinging the host.
		/// </summary>
        System.Net.NetworkInformation.Ping _pinger = new System.Net.NetworkInformation.Ping();

		/// <summary>
		/// Stores options of ping object (options of the echo message).
		/// </summary>
        System.Net.NetworkInformation.PingOptions _pingerOptions = new System.Net.NetworkInformation.PingOptions(DEFAULT_TTL, DEFALUT_FRAGMENT);

		/// <summary>
		/// Object that stores only the recent history of pinging.
		/// </summary>
		private PingResultsBuffer _recentHistory = new PingResultsBuffer();

		#region Synchronization Object

		object _syncObject = new object();

		#endregion

		#endregion

		#region Logger

		/// <summary>
		/// Logger used to log host changes and commands issued to this host pinger.
		/// </summary>
		private IPingLogger _logger = null;

		/// <summary>
		/// Logger used to log host changes and commands issued to this host pinger.
		/// </summary>
		public IPingLogger Logger
		{
			get
			{
				lock (_syncObject)
					return _logger;
			}
			set
			{
				lock (_syncObject)
					_logger = value;
			}
		}

		#endregion

		#region Events

		#region OnPing

		/// <summary>
		/// This event is raised when the single ping is completed.
		/// </summary>
		public event OnPingDelegate OnPing;

		/// <summary>
		/// Raise <see cref="OnPing"/> event if there is subscribed listeners.
		/// </summary>
		private void RaiseOnPing()
		{
			if (OnPing != null)
				OnPing(this);
		}

		#endregion

		#region OnStatusChange

		#region OnHostStatusChangeParams

		/// <summary>
		/// This class stores data that are passed to listeners of <see cref="OnStatusChange"/> event.
		/// </summary>
		private class OnHostStatusChangeParams
		{
			/// <summary>
			/// Previous status of the host.
			/// </summary>
			public HostStatus _oldState;

			/// <summary>
			/// New status of the host.
			/// </summary>
			public HostStatus _newState;

			/// <summary>
			/// Initialize parameters.
			/// </summary>
			/// <param name="oldStatus">previous status of the host.</param>
			/// <param name="newStatus">new status of the host.</param>
			public OnHostStatusChangeParams(HostStatus oldStatus, HostStatus newStatus)
			{
				_oldState = oldStatus;
				_newState = newStatus;
			}
		}

		#endregion

		/// <summary>
		/// This event is raised when the status of the host is changed.
		/// </summary>
		public event OnHostStatusChangeDelegate OnStatusChange;

		/// <summary>
		/// Raise <see cref="OnStatusChange"/> event if there is subscribed listeners.
		/// </summary>
		/// <param name="param">data that are passed to listeners of <see cref="OnStatusChange"/>event (old and new statuses).</param>
		private void RaiseOnStatusChange(object param)
		{
			OnHostStatusChangeParams p = (OnHostStatusChangeParams)param;

			// log status change
			if (_logger != null)
				_logger.LogStatusChange(this, p._oldState, p._newState);

			if (OnStatusChange != null)
				OnStatusChange(this, p._oldState, p._newState);
		}

		#endregion

		#region OnStartPinging

		/// <summary>
		/// This event is raised when user starts pinging.
		/// </summary>
		public event OnHostPingerCommandDelegate OnStartPinging;

		/// <summary>
		/// Raise <see cref="OnStartPinging"/> event if there is subscribed listeners.
		/// </summary>
		private void RaiseOnStartPinging()
		{
			// log start command
			if (_logger != null)
				_logger.LogStart(this);

			if (OnStartPinging != null)
				OnStartPinging(this);
		}

		#endregion

		#region OnStopPinging

		/// <summary>
		/// This event is raised when user stops pinging.
		/// </summary>
		public event OnHostPingerCommandDelegate OnStopPinging;

		/// <summary>
		/// Raise <see cref="OnStopPinging"/> event if there is subscribed listeners.
		/// </summary>
		private void RaiseOnStopPinging()
		{
			// log stop command
			if (_logger != null)
				_logger.LogStop(this);

			if (OnStopPinging != null)
				OnStopPinging(this);
		}

		#endregion

		#region OnHostNameChanged

		/// <summary>
		/// This event is raised when user changes host's name.
		/// </summary>
		public event OnHostNameChangedDelegate OnHostNameChanged;

		/// <summary>
		/// Raise <see cref="OnHostNameChanged"/> event if there is subscribed listeners.
		/// </summary>
		private void RaiseOnHostNameChanged()
		{
			if (OnHostNameChanged != null)
				OnHostNameChanged(this);
		}

		#endregion

		#endregion

		#region Constructors

		/// <summary>
		/// Initialize host pinger with host name. This constructor sends DNS query to obtain IP address.
		/// </summary>
		/// <param name="hostName">name of the host.</param>
		public HostPinger(string hostName)
		{
			_hostName = hostName;

			try
			{
				_hostIP = GetHostIpByName(_hostName);
			}
			catch
			{
				Status = HostStatus.DnsError;
			}

			InitTimer();
		}

		/// <summary>
		/// Initializes host pinger with IP address of the host.
		/// </summary>
		/// <param name="address">IP address of the host.</param>
		public HostPinger(IPAddress address)
		{
			_hostName = "No Name";
			_hostIP = address;

			InitTimer();
		}

		/// <summary>
		/// Initializes host pinger with host name and IP address. Host name is only used for displaying.
		/// </summary>
		/// <param name="hostName">display name of the host.</param>
		/// <param name="address">IP address of the host.</param>
		public HostPinger(string hostName, IPAddress address)
		{
			_hostName = hostName;
			_hostIP = address;

			InitTimer();
		}

		/// <summary>
		/// This method sends DNS query to obtain IP address of the host with specified name.
		/// </summary>
		/// <param name="name">host name.</param>
		/// <returns>Method returns IP address of the host.</returns>
		private IPAddress GetHostIpByName(string name)
		{
			IPHostEntry dnse;
			try
			{
				dnse = Dns.GetHostEntry(_hostName);
			}
			catch (Exception ex)
			{
				throw new Exception("Error connecting DNS for " + _hostName + " host", ex);
			}

			if (dnse != null)
				return dnse.AddressList[0];
			else
				throw new Exception("Cannot resolve host \"" + _hostName + "\" IP by its name.");
		}

		#endregion
        
		#region Timer

		/// <summary>
		/// Initializes timer.
		/// </summary>
		void InitTimer()
		{
			_timer.AutoReset = false;
			_timer.Elapsed += new System.Timers.ElapsedEventHandler(_timer_Elapsed);
		}

		/// <summary>
		/// Handle even raised by the timer when the time elapses
		/// </summary>
		/// <param name="sender">ignored.</param>
		/// <param name="e">ignored.</param>
		void _timer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
		{
			Pinger();
		}

		#endregion

		#region Control

		#region IsRunning

		/// <summary>
		/// Inidicate whether the pinging is active.
		/// </summary>
		private bool _isRunning;

		/// <summary>
		/// Inidicate whether the pinging is active.
		/// </summary>
		public bool IsRunning
		{
			get
			{
				lock (_syncObject)
					return _isRunning;
			}

			set
			{
				if (value)
					Start();
				else
					Stop();
			}
		}

		#endregion

		/// <summary>
		/// Starts pinging the host. If the pinging is already active this method performs no actions.
		/// </summary>
		public void Start()
		{
			bool started = false;
			Monitor.Enter(_syncObject);
			if (!_isRunning)
			{
				// save the time when the pinging is started
				_startTime = DateTime.Now;

				if (_status != HostStatus.DnsError)
					Status = HostStatus.Unknown;

				started = _isRunning = true;

				// schedule ping if it is not already
				if (!_pingScheduled)
				{
					_pingScheduled = true;
					_timer.Interval = _pingInterval;
					_timer.Start();
				}
			}
			Monitor.Exit(_syncObject);

			if (started)
				RaiseOnStartPinging();
		}

		/// <summary>
		/// Stops pinging the host. If the pinging is not active this method performs no actions.
		/// </summary>
		public void Stop()
		{
			bool stopped = false;

			lock (_syncObject)
			{
				if (_isRunning)
				{
					_continousPacketLost = 0;

					if (_status != HostStatus.DnsError)
						Status = HostStatus.Unknown;

					_totalTestDuration += DateTime.Now - _startTime;

					_isRunning = false;
					stopped = true;
				}
			}

			if (stopped)
				RaiseOnStopPinging();
		}

		#endregion

		#region Pinging

		/// <summary>
		/// Indicates that next ping is scheduled.
		/// </summary>
		private bool _pingScheduled = false;

		/// <summary>
		/// Send ping echo message, waits for the response, performs statistical calculations based on the response and schedule next ping.
		/// </summary>
		private void Pinger()
		{
			bool ping;

			lock (_syncObject)
				// did pinger obtain IP address
				ping = _status != HostStatus.DnsError;

			// pinger has not yet obtained IP address
			if (!ping)
			{
				try
				{
					// send DNS query
					IPAddress addr = GetHostIpByName(HostName);

					lock (_syncObject)
					{
						// IP address obrained sucessfully change host status
						if (_status == HostStatus.DnsError && _isRunning)
						{
							_hostIP = addr;
							Status = HostStatus.Unknown;
						}
					}
				}
				catch
				{
					// DNS query failed and IP address was not obtained
					lock (_syncObject)
					{
						if (_isRunning)
						{
							// schedule next DNS query
							_pingScheduled = true;
							_timer.Interval = _dnsQueryInterval;
							_timer.Start();
						}
						else
							_pingScheduled = false;
					}

					RaiseOnPing();
					return;
				}
			}

			PingReply reply = null;

			IPAddress ip;
			int timeout;
			byte[] buffer;
			PingOptions options;

			lock (_syncObject)
			{
				// copy ping options
				ip = _hostIP;
				timeout = _timeout;
				buffer = _buffer;
				options = _pingerOptions;
			}

			// send ping message
            try
            {
                reply = _pinger.Send(ip, timeout, buffer, options);
            }
            catch
            {
            }

			lock (_syncObject)
			{
				ping = false;

				if (_isRunning)
				{
					if (ip == _hostIP)
					{
                        if (reply == null)
                        {
                            IncLost();
                        }
                        else
                        {
                            switch (reply.Status)
                            {
                                #region Checking Reply Status

                                case IPStatus.BadDestination:
                                case IPStatus.BadHeader:
                                case IPStatus.BadOption:
                                case IPStatus.BadRoute:
                                case IPStatus.UnrecognizedNextHeader:
                                case IPStatus.PacketTooBig:
                                case IPStatus.ParameterProblem:
                                    // wrong message format
                                    IncLost();
                                    break;

                                case IPStatus.DestinationScopeMismatch:
                                case IPStatus.Unknown:
                                case IPStatus.HardwareError:
                                case IPStatus.IcmpError:
                                case IPStatus.NoResources:
                                case IPStatus.SourceQuench:
                                    // error
                                    IncLost();
                                    break;

                                case IPStatus.DestinationHostUnreachable:
                                case IPStatus.DestinationNetworkUnreachable:
                                case IPStatus.DestinationPortUnreachable:
                                case IPStatus.DestinationProhibited:
                                case IPStatus.DestinationUnreachable:
                                    // unreachability of the remote host
                                    IncLost();
                                    break;

                                case IPStatus.TimeExceeded:
                                case IPStatus.TimedOut:
                                case IPStatus.TtlExpired:
                                case IPStatus.TtlReassemblyTimeExceeded:
                                    // time outs
                                    IncLost();
                                    break;

                                case IPStatus.Success:
                                    // success
                                    IncReceived(reply.RoundtripTime);
                                    break;

                                default:
                                    // something went wrong
                                    IncLost();
                                    break;

                                #endregion
                            }
                        }
                        ping = true;
						
					}

					// schedule next ping
					_pingScheduled = true;
					_timer.Interval = _pingInterval;
					_timer.Start();
				}
				else
					_pingScheduled = false;
			}

			if (ping)
				RaiseOnPing();
		}

		#endregion

	}

	#endregion

}
#endif
// file ...\IO\Host\HostStatus.cs

/*
 * 
 * Copyright (c) 2006-2010 Mladen Jankovic. All rights reserved.
 * 
 * contact: kataklinger@gmail[dot]com
 * 
 *	- Redistributions of source code must retain the above copyright notice,
 *	  this list of conditions and the following disclaimer. 
 * 
 *	- Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 * 
 *  - The names of contributors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */


namespace Zero5.IO.Host
{

	#region HostStatus

	/// <summary>
	/// Defines host status.
	/// </summary>
	public enum HostStatus
	{
		/// <summary>
		/// Host is dead (it is not responsing to pings).
		/// </summary>
		Dead,
		/// <summary>
		/// Host is alive (it is responsing to pings).
		/// </summary>
		Alive,
		/// <summary>
		/// IP address cannot be obtained using DNS server.
		/// </summary>
		DnsError,
		/// <summary>
		/// Host did not respond to any ping since pinging is started
		/// but number of unresponded pings are not enough to declare host as dead.
		/// </summary>
		Unknown
	};

	#endregion

}
// file ...\IO\Host\IPingLogger.cs
#if !MOBILE

/*
 * 
 * Copyright (c) 2006-2010 Mladen Jankovic. All rights reserved.
 * 
 * contact: kataklinger@gmail[dot]com
 * 
 *	- Redistributions of source code must retain the above copyright notice,
 *	  this list of conditions and the following disclaimer. 
 * 
 *	- Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 * 
 *  - The names of contributors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */


namespace Zero5.IO.Host
{
	#region IPingLogger

	/// <summary>
	/// Logs commands issued to host pinger and status changes.
	/// </summary>
	public interface IPingLogger
	{
		/// <summary>
		/// Logs command that starts pinging.
		/// </summary>
		/// <param name="host">host pinger that was started.</param>
		void LogStart(HostPinger host);

		/// <summary>
		/// Logs command that stops pinging.
		/// </summary>
		/// <param name="host">host pinger that was stopped.</param>
		void LogStop(HostPinger host);

		/// <summary>
		/// Logs status change of the host.
		/// </summary>
		/// <param name="host">host whose status has been changed.</param>
		/// <param name="oldStatus">old status of the host.</param>
		/// <param name="newStatus">new status of the host.</param>
		void LogStatusChange(HostPinger host, HostStatus oldStatus, HostStatus newStatus);
	}

	#endregion
}
#endif
// file ...\IO\Host\PingResultsBuffer.cs
#if !MOBILE

/*
 * 
 * Copyright (c) 2006-2010 Mladen Jankovic. All rights reserved.
 * 
 * contact: kataklinger@gmail[dot]com
 * 
 *	- Redistributions of source code must retain the above copyright notice,
 *	  this list of conditions and the following disclaimer. 
 * 
 *	- Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 * 
 *  - The names of contributors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */


namespace Zero5.IO.Host
{
	#region PingResultsBuffer

	/// <summary>
	/// Keeps recent history (results of most recent pings).
	/// </summary>
	public class PingResultsBuffer
	{

		#region Entry Class

		/// <summary>
		/// Object of this class represent several combined results that has same values in the recent history buffer.
		/// </summary>
		private class Entry
		{
			/// <summary>
			/// Initializes entry of the recent history buffer.
			/// </summary>
			/// <param name="received">indicates whether the combined results was successfull pings or unresponded pings.</param>
			/// <param name="count">number of combined results.</param>
			public Entry(bool received, int count)
			{
				_received = received;
				_count = count;
			}

			/// <summary>
			/// Indicates whether the combined results was successfull pings or unresponded pings.
			/// </summary>
			public bool _received;

			/// <summary>
			/// Number of combined results.
			/// </summary>
			public int _count;
		}

		#endregion

		#region Private Attributes

		/// <summary>
		/// Entries of recent history buffer
		/// </summary>
		private List<Entry> _buffer = new List<Entry>();

		private object _syncObject = new object();

		#endregion

		#region BufferSize

		/// <summary>
		/// Default number of results stored in the buffer.
		/// </summary>
		public static readonly int DEFAULT_BUFFER_SIZE = 100;

		/// <summary>
		/// Number of results stored in the buffer.
		/// </summary>
		private int _bufferSize = DEFAULT_BUFFER_SIZE;

		/// <summary>
		/// Number of results stored in the buffer. When the new buffer size is smaller then previous 
		/// results that cannot fit the new size are removed from the buffer.
		/// </summary>
		public int BufferSize
		{
			get
			{
				lock (_syncObject)
					return _bufferSize;
			}
			set
			{
				lock (_syncObject)
				{
					if (value < 0)
						value = 0;

					if (value > _bufferSize)
						_bufferSize = value;
					else
					{
						// new buffer size is smaller

						// remove those results that cannot fit new size
						for (int diff = _currentSize - value; diff > 0; )
						{
							Entry e = _buffer[0];

							if (e._count <= diff)
							{
								// entire combined entry cannot fit	new size

								// remove the entry complitely
								_buffer.RemoveAt(0);
								DecCount(e._received, e._count);

								diff -= e._count;
							}
							else
							{
								// only part of the combined entry cannot fit new size

								// remove only some	results from the entry
								e._count -= diff;
								DecCount(e._received, diff);

								diff = 0;
							}
						}

						if (_currentSize > value)
							_currentSize = value;

						_bufferSize = value;
					}
				}
			}
		}

		#endregion

		#region CurrentSize

		/// <summary>
		/// Number of results currently stored in the buffer.
		/// </summary>
		private int _currentSize = 0;

		/// <summary>
		/// Number of results currently stored in the buffer.
		/// </summary>
		public int CurrentSize
		{
			get
			{
				lock (_syncObject)
					return _currentSize;
			}
		}

		#endregion

		#region Statistics

		#region LostCount

		/// <summary>
		/// Number of unresponded pings.
		/// </summary>
		private int _lostCount;

		/// <summary>
		/// Number of unresponded pings.
		/// </summary>
		public int LostCount
		{
			get
			{
				lock (_syncObject)
					return _lostCount;
			}
		}

		#endregion

		#region LostCountPercent

		/// <summary>
		/// Percent of unresponded pings.
		/// </summary>
		public float LostCountPercent
		{
			get
			{
				lock (_syncObject)
					return (float)_lostCount / _currentSize * 100;
			}
		}

		#endregion

		#region ReceivedCount

		/// <summary>
		/// Number of successful pings.
		/// </summary>
		private int _receivedCount;

		/// <summary>
		/// Number of successful pings.
		/// </summary>
		public int ReceivedCount
		{
			get
			{
				lock (_syncObject)
					return _receivedCount;
			}
		}

		#endregion

		#region ReceivedCountPercent

		/// <summary>
		/// Percent of successful pings.
		/// </summary>
		public float ReceivedCountPercent
		{
			get
			{
				lock (_syncObject)
					return (float)_receivedCount / _currentSize * 100;
			}
		}

		#endregion

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes recent history buffer with specified size.
		/// </summary>
		/// <param name="size">Number of results of most recent pings that are stored in the buffer.</param>
		public PingResultsBuffer(int size)
		{
			_bufferSize = size;
		}

		public PingResultsBuffer() { }

		#endregion

		#region Counting

		/// <summary>
		/// Increments number of results od specific type.
		/// </summary>
		/// <param name="received">whether to increment number of successful or unsuccessful ping results.</param>
		private void IncCount(bool received)
		{
			if (received)
				_receivedCount++;
			else
				_lostCount++;
		}

		/// <summary>
		/// Decrements number of results od specific type.
		/// </summary>
		/// <param name="received">whether to increment number of successful or unsuccessful ping results.</param>
		/// <param name="count">number by which the number of results are decremented.</param>
		private void DecCount(bool received, int count)
		{
			if (received)
				_receivedCount -= count;
			else
				_lostCount -= count;
		}

		#endregion

		#region AddPingResult

		/// <summary>
		/// Inserts ping results into recent history buffer.
		/// </summary>
		/// <param name="received">whether the ping was successful or not.</param>
		public void AddPingResult(bool received)
		{
			if (_bufferSize < 1)
				return;

			lock (_syncObject)
			{
				// buffer is not full yet?
				if (_currentSize < _bufferSize)
				{
					if (_currentSize == 0)
					{
						// empty buffer create first entry

						_buffer.Add(new Entry(received, 1));
						IncCount(received);
						_currentSize++;
						return;
					}

					_currentSize++;
				}
				else
				{
					// buffer is full

					// remove the oldes result
					Entry first = _buffer[0];
					first._count--;
					DecCount(first._received, 1);

					// if the last result was occpied entire combined entry
					/// remove that entry
					if (first._count == 0)
						_buffer.RemoveAt(0);
				}

				// insert new result
				Entry last = _buffer[_buffer.Count - 1];
				if (last._received == received)
					// the newest result can be combined with newest combined entry
					last._count++;
				else
					// the newest result cannot be combined with newest combined entry 
					// create new entry and add it tho the buffer
					_buffer.Add(new Entry(received, 1));

				// increment number of results os specific type
				IncCount(received);
			}
		}

		#endregion

		#region Clear

		/// <summary>
		/// Clears results of most recent pings.
		/// </summary>
		public void Clear()
		{
			lock (_syncObject)
			{
				_currentSize = 0;
				_lostCount = 0;
				_receivedCount = 0;
				_buffer.Clear();
			}
		}

		#endregion

	}

	#endregion
}

#endif
// file ...\IO\RawSerializer\RawDeserializer.cs
/*
Copyright (c) 2005, Marc Clifton
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list
  of conditions and the following disclaimer. 

* Redistributions in binary form must reproduce the above copyright notice, this 
  list of conditions and the following disclaimer in the documentation and/or other
  materials provided with the distribution. 
 
* Neither the name of Marc Clifton nor the names of its contributors may be
  used to endorse or promote products derived from this software without specific
  prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/


namespace Zero5.IO.RawSerializer
{
    public class RawDeserializer
    {
        protected BinaryReader br;

        /// <summary>
        /// Helper instance for reading value types.
        /// </summary>
        protected TypeIO tr;

        public RawDeserializer(Stream input)
        {
            br = new BinaryReader(input);
            tr = new TypeIO();
        }

        public long Lenght()
        {
            return br.BaseStream.Length;
        }

        public bool DeserializeBool()
        {
            return br.ReadBoolean();
        }

        public byte DeserializeByte()
        {
            return br.ReadByte();
        }

        public byte[] DeserializeBytes()
        {
            int count = br.ReadInt32();
            return br.ReadBytes(count);
        }

        public char DeserializeChar()
        {
            return br.ReadChar();
        }

        public char[] DeserializeChars()
        {
            int count = br.ReadInt32();
            return br.ReadChars(count);
        }

        public decimal DeserializeDecimal()
        {
#if MOBILE
            return 0;
#else
            return br.ReadDecimal();
#endif
        }

        public double DeserializeDouble()
        {
            return br.ReadDouble();
        }

        public short DeserializeShort()
        {
            return br.ReadInt16();
        }

        public int DeserializeInt()
        {
            return br.ReadInt32();
        }

        public long DeserializeLong()
        {
            return br.ReadInt64();
        }

        public sbyte DeserializeSByte()
        {
            return br.ReadSByte();
        }

        public float DeserializeFloat()
        {
            return br.ReadSingle();
        }

        public string DeserializeString()
        {
            return br.ReadString();
        }

        public ushort DeserializeUShort()
        {
            return br.ReadUInt16();
        }

        public uint DeserializeUInt()
        {
            return br.ReadUInt32();
        }

        public ulong DeserializeULong()
        {
            return br.ReadUInt64();
        }

        public Guid DeserializeGuid()
        {
            return (Guid)Deserialize(typeof(Guid));
        }

        public DateTime DeserializeDateTime()
        {
            return (DateTime)Deserialize(typeof(DateTime));
        }

        #region NullableTypes

        // Nullable value type support.

        public bool? DeserializeNBool()
        {
            bool? ret = null;

            if (br.ReadByte() == 2)
            {
                ret = br.ReadBoolean();
            }

            return ret;
        }

        public byte? DeserializeNByte()
        {
            byte? ret = null;

            if (br.ReadByte() == 2)
            {
                ret = br.ReadByte();
            }

            return ret;
        }

        public char? DeserializeNChar()
        {
            char? ret = null;

            if (br.ReadByte() == 2)
            {
                ret = br.ReadChar();
            }

            return ret;
        }

        public decimal? DeserializeNDecimal()
        {
#if MOBILE
            return 0;
#else
            decimal? ret = null;

            if (br.ReadByte() == 2)
            {
                ret = br.ReadDecimal();
            }

            return ret;
#endif
        }

        public double? DeserializeNDouble()
        {
            double? ret = null;

            if (br.ReadByte() == 2)
            {
                ret = br.ReadDouble();
            }

            return ret;
        }

        public short? DeserializeNShort()
        {
            short? ret = null;

            if (br.ReadByte() == 2)
            {
                ret = br.ReadInt16();
            }

            return ret;
        }

        public int? DeserializeNInt()
        {
            int? ret = null;

            if (br.ReadByte() == 2)
            {
                ret = br.ReadInt32();
            }

            return ret;
        }

        public long? DeserializeNLong()
        {
            long? ret = null;

            if (br.ReadByte() == 2)
            {
                ret = br.ReadInt64();
            }

            return ret;
        }

        public sbyte? DeserializeNSByte()
        {
            sbyte? ret = null;

            if (br.ReadByte() == 2)
            {
                ret = br.ReadSByte();
            }

            return ret;
        }

        public float? DeserializeNFloat()
        {
            float? ret = null;

            if (br.ReadByte() == 2)
            {
                ret = br.ReadSingle();
            }

            return ret;
        }

        public ushort? DeserializeNUShort()
        {
            ushort? ret = null;

            if (br.ReadByte() == 2)
            {
                ret = br.ReadUInt16();
            }

            return ret;
        }

        public uint? DeserializeNUInt()
        {
            uint? ret = null;

            if (br.ReadByte() == 2)
            {
                ret = br.ReadUInt32();
            }

            return ret;
        }

        public ulong? DeserializeNULong()
        {
            ulong? ret = null;

            if (br.ReadByte() == 2)
            {
                ret = br.ReadUInt64();
            }

            return ret;
        }

        public DateTime? DeserializeNDateTime()
        {
            DateTime? ret = null;

            if (br.ReadByte() == 2)
            {
                ret = (DateTime?)Deserialize(typeof(DateTime));
            }

            return ret;
        }

        public Guid? DeserializeNGuid()
        {
            Guid? ret = null;

            if (br.ReadByte() == 2)
            {
                ret = (Guid?)Deserialize(typeof(Guid));
            }

            return ret;
        }

        #endregion NullableTypes

        public object Deserialize(Type type)
        {
            bool success;
            object ret = tr.Read(br, type, out success);

            if (!success)
            {
                if (type.IsValueType)
                {
                    int count = br.ReadInt32();
                    byte[] data = br.ReadBytes(count);
                    ret = Deserialize(data, type);
                }
                else
                {
                    throw new RawSerializerException("Cannot deserialize " + type.AssemblyQualifiedName);
                }
            }

            return ret;
        }

        public object DeserializeNullable(Type type)
        {
            object ret = null;

            byte code = br.ReadByte();

            if (code == 0)
            {
                ret = System.DBNull.Value;
            }
            else if (code == 1)
            {
                ret = null;
            }
            else if (code == 2)
            {
                ret = Deserialize(type);
            }
            else
            {
                throw new RawSerializerException("Expected a code byte during deserialization of " + type.Name);
            }

            return ret;
        }

        protected virtual object Deserialize(byte[] bytes, Type type)
        {
            object structure = null;

            try
            {
                GCHandle h = GCHandle.Alloc(bytes, GCHandleType.Pinned);
#if MOBILE
                structure = Marshal.PtrToStructure((IntPtr)((int)h.AddrOfPinnedObject() + 0 + 4), type);
#else
                structure = Marshal.PtrToStructure(Marshal.UnsafeAddrOfPinnedArrayElement(bytes, 0), type);
#endif
                h.Free();
            }
            catch (Exception e)
            {
                throw new RawSerializerException(e.Message);
            }

            return structure;
        }
    }
}
// file ...\IO\RawSerializer\RawSerializer.cs
/*
Copyright (c) 2005, Marc Clifton
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list
  of conditions and the following disclaimer. 

* Redistributions in binary form must reproduce the above copyright notice, this 
  list of conditions and the following disclaimer in the documentation and/or other
  materials provided with the distribution. 
 
* Neither the name of Marc Clifton nor the names of its contributors may be
  used to endorse or promote products derived from this software without specific
  prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/


namespace Zero5.IO.RawSerializer
{
    public class RawSerializerException : ApplicationException
    {
        public RawSerializerException(string msg)
            : base(msg)
        {
        }
    }

    /// <summary>
    /// Helper class encapsulating both the object and the nullable state flag.
    /// </summary>
    public class ObjectInfo
    {
        protected object obj;
        protected bool nullable;

        /// <summary>
        /// Get/set the object.
        /// </summary>
        public object Object
        {
            get { return obj; }
            set { obj = value; }
        }

        /// <summary>
        /// Get/set the nullable state.
        /// </summary>
        public bool Nullable
        {
            get { return nullable; }
            set { nullable = value; }
        }

        /// <summary>
        /// Constructor, defaulting nullable to false.
        /// </summary>
        /// <param name="obj">The object to serialize.</param>
        public ObjectInfo(object obj)
        {
            this.obj = obj;
            nullable = false;
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="obj">The object to serialize.</param>
        /// <param name="nullable">The nullable state.</param>
        public ObjectInfo(object obj, bool nullable)
        {
            this.obj = obj;
            this.nullable = nullable;
        }

    }

    /// <summary>
    /// Raw serializer class.  Serializes value types and structs whose length can be determined by the marshaller.
    /// </summary>
    public class RawSerializer
    {
        /// <summary>
        /// The binary writer instance to which value types are written.
        /// </summary>
        protected BinaryWriter bw;

        /// <summary>
        /// Helper instance for writing value types.
        /// </summary>
        protected TypeIO tw;

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="output">The output stream.</param>
        public RawSerializer(Stream output)
        {
            bw = new BinaryWriter(output);
            tw = new TypeIO();
        }

        public void Serialize(bool val)
        {
            bw.Write(val);
        }

        public void Serialize(byte val)
        {
            bw.Write(val);
        }

        public void Serialize(byte[] val)
        {
            bw.Write(val.Length);
            bw.Write(val);
        }

        public void Serialize(char val)
        {
            bw.Write(val);
        }

        public void Serialize(char[] val)
        {
            bw.Write(val.Length);
            bw.Write(val);
        }

        public void Serialize(decimal val)
        {
#if MOBILE
#else
            bw.Write(val);
#endif
        }

        public void Serialize(double val)
        {
            bw.Write(val);
        }

        public void Serialize(short val)
        {
            bw.Write(val);
        }

        public void Serialize(int val)
        {
            bw.Write(val);
        }

        public void Serialize(long val)
        {
            bw.Write(val);
        }

        public void Serialize(sbyte val)
        {
            bw.Write(val);
        }

        public void Serialize(float val)
        {
            bw.Write(val);
        }

        public void Serialize(string val)
        {
            if (val == null)
            {
                throw new RawSerializerException("Serialize(string val) cannot be used to serialize a null string.  Use SerializeNullable instead.");
            }

            bw.Write(val);
        }

        public void Serialize(ushort val)
        {
            bw.Write(val);
        }

        public void Serialize(uint val)
        {
            bw.Write(val);
        }

        public void Serialize(ulong val)
        {
            bw.Write(val);
        }

        public void Serialize(DateTime val)
        {
            tw.Write(bw, val);
        }

        public void Serialize(Guid val)
        {
            Serialize((object)val);
        }

        // Nullable value type support.
        // Note that byte?[] and char?[] types are not supported, as an array of sometimes null values is a bit obscure.
        // String is also not here, because string is a reference type.

        public void Serialize(bool? val)
        {
            WriteSimpleNullFlag(val);

            if (val.HasValue)
            {
                bw.Write((bool)val);
            }
        }

        public void Serialize(byte? val)
        {
            WriteSimpleNullFlag(val);

            if (val.HasValue)
            {
                bw.Write((byte)val);
            }
        }

        public void Serialize(char? val)
        {
            WriteSimpleNullFlag(val);

            if (val.HasValue)
            {
                bw.Write((char)val);
            }
        }

        public void Serialize(decimal? val)
        {
#if MOBILE
#else
            WriteSimpleNullFlag(val);

            if (val.HasValue)
            {
                bw.Write((decimal)val);
            }
#endif
        }

        public void Serialize(double? val)
        {
            WriteSimpleNullFlag(val);

            if (val.HasValue)
            {
                bw.Write((double)val);
            }
        }

        public void Serialize(short? val)
        {
            WriteSimpleNullFlag(val);

            if (val.HasValue)
            {
                bw.Write((short)val);
            }
        }

        public void Serialize(int? val)
        {
            WriteSimpleNullFlag(val);

            if (val.HasValue)
            {
                bw.Write((int)val);
            }
        }

        public void Serialize(long? val)
        {
            WriteSimpleNullFlag(val);

            if (val.HasValue)
            {
                bw.Write((long)val);
            }
        }

        public void Serialize(sbyte? val)
        {
            WriteSimpleNullFlag(val);

            if (val.HasValue)
            {
                bw.Write((sbyte)val);
            }
        }

        public void Serialize(float? val)
        {
            WriteSimpleNullFlag(val);

            if (val.HasValue)
            {
                bw.Write((float)val);
            }
        }

        public void Serialize(ushort? val)
        {
            WriteSimpleNullFlag(val);

            if (val.HasValue)
            {
                bw.Write((ushort)val);
            }
        }

        public void Serialize(uint? val)
        {
            WriteSimpleNullFlag(val);

            if (val.HasValue)
            {
                bw.Write((uint)val);
            }
        }

        public void Serialize(ulong? val)
        {
            WriteSimpleNullFlag(val);

            if (val.HasValue)
            {
                bw.Write((ulong)val);
            }
        }

        public void Serialize(DateTime? val)
        {
            WriteSimpleNullFlag(val);

            if (val.HasValue)
            {
                tw.Write(bw, val);
            }
        }

        public void Serialize(Guid? val)
        {
            SerializeNullable(val);
        }

        /// <summary>
        /// Serialize a boxed value assuming nullable is false.
        /// </summary>
        /// <param name="val">The value.</param>
        public void Serialize(object val)
        {
            if ((val == null) || (val == DBNull.Value))
            {
                throw new RawSerializerException("Serialize(object val) cannot be used to serialize a null value.  Use SerializeNullable instead.");
            }

            InternalSerialize(val);
        }

        protected virtual void InternalSerialize(object val)
        {
            bool success = tw.Write(bw, val);

            // If the TypeWriter helper failed, attempt to write out the struct.
            if (!success)
            {
                // Is it a struct?
                if (val.GetType().IsValueType)
                {
                    SerializeStruct(val);
                }
                else
                {
                    throw new RawSerializerException("Cannot serialize " + val.GetType().AssemblyQualifiedName);
                }
            }
        }

        /// <summary>
        /// Serialize a boxed value specifying the nullable state.
        /// </summary>
        /// <param name="val">The value.</param>
        /// <param name="nullable">The nullable state.</param>
        public virtual void SerializeNullable(object val)
        {
            bool isNull = WriteNullFlag(val);

            if (!isNull)
            {
                InternalSerialize(val);
            }
        }

        public virtual bool WriteNullFlag(object val)
        {
            bool isNull = false;

            // If nullable, write out the flag indicating the value state:
            // 0 - DBNull.Value
            // 1 - null
            // 2 - not null
            if (val == DBNull.Value)
            {
                tw.Write(bw, (byte)0);
                isNull = true;
            }
            else if (val == null)
            {
                tw.Write(bw, (byte)1);
                isNull = true;
            }
            else
            {
                tw.Write(bw, (byte)2);
            }

            return isNull;
        }

        public virtual bool WriteSimpleNullFlag(object val)
        {
            bool isNull = false;

            // If nullable, write out the flag indicating the value state:
            // 1 - null
            // 2 - not null
            if (val == null)
            {
                tw.Write(bw, (byte)1);
                isNull = true;
            }
            else
            {
                tw.Write(bw, (byte)2);
            }

            return isNull;
        }

        /// <summary>
        /// Serialize an array of objects.
        /// </summary>
        /// <param name="objs">The array of objects.</param>
        public virtual void Serialize(object[] objs)
        {
            foreach (object obj in objs)
            {
                Serialize(obj);
            }
        }

        public virtual void SerializeNullable(object[] objs)
        {
            foreach (object obj in objs)
            {
                SerializeNullable(obj);
            }
        }

        /// <summary>
        /// Serialize an array of objects that specify the nullable state flag.
        /// </summary>
        /// <param name="objs">An array of ObjectInfo instance.</param>
        public virtual void Serialize(ObjectInfo[] objs)
        {
            foreach (ObjectInfo obj in objs)
            {
                if (obj.Nullable)
                {
                    SerializeNullable(obj.Object);
                }
                else
                {
                    Serialize(obj.Object);
                }
            }
        }

        /// <summary>
        /// Flush the stream.
        /// </summary>
        public void Flush()
        {
            bw.Flush();
        }

        /// <summary>
        /// Close the stream.
        /// </summary>
        public void Close()
        {
            bw.Flush();
            bw.Close();
        }

        /// <summary>
        /// Virtual method to manage serializing structures, using the Marshaller.
        /// Override this method to handle structs that the marshaller doesn't.
        /// </summary>
        /// <param name="val">The struct to serialize.</param>
        protected virtual void SerializeStruct(object val)
        {
            try
            {
                // Get the size of the structure.
                byte[] bytes = new byte[Marshal.SizeOf(val.GetType())];

                // Pin the bytes so the GC doesn't move them.
                GCHandle h = GCHandle.Alloc(bytes, GCHandleType.Pinned);

                // Copy the structure into the byte array.
#if MOBILE
                Marshal.StructureToPtr(val, (IntPtr)((int)h.AddrOfPinnedObject() + 0 + 4), false);
#else
                Marshal.StructureToPtr(val, Marshal.UnsafeAddrOfPinnedArrayElement(bytes, 0), false);
#endif
                // Unpin the memory.
                h.Free();

                // Write the byte array length and the bytes.
                bw.Write(bytes.Length);
                bw.Write(bytes);
            }
            catch (Exception e)
            {
                throw new RawSerializerException(e.Message);
            }
        }
    }
}
// file ...\IO\RawSerializer\TypeIO.cs
/*
Copyright (c) 2005, Marc Clifton
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list
  of conditions and the following disclaimer. 

* Redistributions in binary form must reproduce the above copyright notice, this 
  list of conditions and the following disclaimer in the documentation and/or other
  materials provided with the distribution. 
 
* Neither the name of Marc Clifton nor the names of its contributors may be
  used to endorse or promote products derived from this software without specific
  prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/


namespace Zero5.IO.RawSerializer
{
    public class TypeIO
    {
        private delegate void WriterDlgt(BinaryWriter bw, object val);
        private delegate object ReaderDlgt(BinaryReader br);

        private class IODelegate
        {
            protected WriterDlgt writer;
            protected ReaderDlgt reader;

            public WriterDlgt Writer
            {
                get { return writer; }
            }

            public ReaderDlgt Reader
            {
                get { return reader; }
            }

            public IODelegate(WriterDlgt writer, ReaderDlgt reader)
            {
                this.writer = writer;
                this.reader = reader;
            }
        }

        private Dictionary<Type, IODelegate> typeToDelegateMap;

        public TypeIO()
        {
            typeToDelegateMap = new Dictionary<Type, IODelegate>();
            typeToDelegateMap[typeof(bool)] = new IODelegate(new WriterDlgt(BoolWriter), new ReaderDlgt(BoolReader));
            typeToDelegateMap[typeof(byte)] = new IODelegate(new WriterDlgt(ByteWriter), new ReaderDlgt(ByteReader));
            typeToDelegateMap[typeof(byte[])] = new IODelegate(new WriterDlgt(ByteArrayWriter), new ReaderDlgt(ByteArrayReader));
            typeToDelegateMap[typeof(char)] = new IODelegate(new WriterDlgt(CharWriter), new ReaderDlgt(CharReader));
            typeToDelegateMap[typeof(char[])] = new IODelegate(new WriterDlgt(CharArrayWriter), new ReaderDlgt(CharArrayReader));
            typeToDelegateMap[typeof(decimal)] = new IODelegate(new WriterDlgt(DecimalWriter), new ReaderDlgt(DecimalReader));
            typeToDelegateMap[typeof(double)] = new IODelegate(new WriterDlgt(DoubleWriter), new ReaderDlgt(DoubleReader));
            typeToDelegateMap[typeof(short)] = new IODelegate(new WriterDlgt(ShortWriter), new ReaderDlgt(ShortReader));
            typeToDelegateMap[typeof(int)] = new IODelegate(new WriterDlgt(IntWriter), new ReaderDlgt(IntReader));
            typeToDelegateMap[typeof(long)] = new IODelegate(new WriterDlgt(LongWriter), new ReaderDlgt(LongReader));
            typeToDelegateMap[typeof(sbyte)] = new IODelegate(new WriterDlgt(SByteWriter), new ReaderDlgt(SByteReader));
            typeToDelegateMap[typeof(float)] = new IODelegate(new WriterDlgt(FloatWriter), new ReaderDlgt(FloatReader));
            typeToDelegateMap[typeof(string)] = new IODelegate(new WriterDlgt(StringWriter), new ReaderDlgt(StringReader));
            typeToDelegateMap[typeof(ushort)] = new IODelegate(new WriterDlgt(UShortWriter), new ReaderDlgt(UShortReader));
            typeToDelegateMap[typeof(uint)] = new IODelegate(new WriterDlgt(UIntWriter), new ReaderDlgt(UIntReader));
            typeToDelegateMap[typeof(ulong)] = new IODelegate(new WriterDlgt(ULongWriter), new ReaderDlgt(ULongReader));
            typeToDelegateMap[typeof(DateTime)] = new IODelegate(new WriterDlgt(DateTimeWriter), new ReaderDlgt(DateTimeReader));
        }

        public bool Write(BinaryWriter bw, object val)
        {
            bool success = false;
            Type t = val.GetType();

            if (typeToDelegateMap.ContainsKey(t))
            {
                typeToDelegateMap[t].Writer(bw, val);
                success = true;
            }

            return success;
        }

        public object Read(BinaryReader br, Type t, out bool success)
        {
            object ret = null;
            success = false;

            if (typeToDelegateMap.ContainsKey(t))
            {
                ret = typeToDelegateMap[t].Reader(br);
                success = true;
            }

            return ret;
        }

        protected void BoolWriter(BinaryWriter bw, object val)
        {
            bw.Write((bool)val);
        }

        protected object BoolReader(BinaryReader br)
        {
            return br.ReadBoolean();
        }

        protected void ByteWriter(BinaryWriter bw, object val)
        {
            bw.Write((byte)val);
        }

        protected object ByteReader(BinaryReader br)
        {
            return br.ReadByte();
        }

        protected void ByteArrayWriter(BinaryWriter bw, object val)
        {
            bw.Write(((byte[])val).Length);
            bw.Write((byte[])val);
        }

        protected object ByteArrayReader(BinaryReader br)
        {
            int count = br.ReadInt32();
            return br.ReadBytes(count);
        }

        protected void CharWriter(BinaryWriter bw, object val)
        {
            bw.Write((char)val);
        }

        protected object CharReader(BinaryReader br)
        {
            return br.ReadChar();
        }

        protected void CharArrayWriter(BinaryWriter bw, object val)
        {
            bw.Write(((char[])val).Length);
            bw.Write((char[])val);
        }

        protected object CharArrayReader(BinaryReader br)
        {
            int count = br.ReadInt32();
            return br.ReadChars(count);
        }

        protected void DecimalWriter(BinaryWriter bw, object val)
        {
#if MOBILE
            long v1 = (long)((decimal)val) / long.MaxValue;
            long v2 = (long)((decimal)val) % long.MaxValue;
            bw.Write((long)v1);
            bw.Write((long)v2);
#else
            bw.Write((decimal)val);
#endif
        }

        protected object DecimalReader(BinaryReader br)
        {
#if MOBILE
            return (decimal)br.ReadInt64() * (decimal)long.MaxValue + (decimal)br.ReadInt64();
#else
            return br.ReadDecimal();
#endif
        }

        protected void DoubleWriter(BinaryWriter bw, object val)
        {
            bw.Write((double)val);
        }

        protected object DoubleReader(BinaryReader br)
        {
            return br.ReadDouble();
        }

        protected void ShortWriter(BinaryWriter bw, object val)
        {
            bw.Write((short)val);
        }

        protected object ShortReader(BinaryReader br)
        {
            return br.ReadInt16();
        }

        protected void IntWriter(BinaryWriter bw, object val)
        {
            bw.Write((int)val);
        }

        protected object IntReader(BinaryReader br)
        {
            return br.ReadInt32();
        }

        protected void LongWriter(BinaryWriter bw, object val)
        {
            bw.Write((long)val);
        }

        protected object LongReader(BinaryReader br)
        {
            return br.ReadInt64();
        }

        protected void SByteWriter(BinaryWriter bw, object val)
        {
            bw.Write((sbyte)val);
        }

        protected object SByteReader(BinaryReader br)
        {
            return br.ReadSByte();
        }

        protected void FloatWriter(BinaryWriter bw, object val)
        {
            bw.Write((float)val);
        }

        protected object FloatReader(BinaryReader br)
        {
            return br.ReadSingle();
        }

        protected void StringWriter(BinaryWriter bw, object val)
        {
            bw.Write((string)val);
        }

        protected object StringReader(BinaryReader br)
        {
            return br.ReadString();
        }

        protected void UShortWriter(BinaryWriter bw, object val)
        {
            bw.Write((ushort)val);
        }

        protected object UShortReader(BinaryReader br)
        {
            return br.ReadUInt16();
        }

        protected void UIntWriter(BinaryWriter bw, object val)
        {
            bw.Write((uint)val);
        }

        protected object UIntReader(BinaryReader br)
        {
            return br.ReadUInt32();
        }

        protected void ULongWriter(BinaryWriter bw, object val)
        {
            bw.Write((ulong)val);
        }

        protected object ULongReader(BinaryReader br)
        {
            return br.ReadUInt64();
        }

        protected void DateTimeWriter(BinaryWriter bw, object val)
        {
            bw.Write(((DateTime)val).Ticks);
        }

        protected object DateTimeReader(BinaryReader br)
        {
            long ticks = br.ReadInt64();
            return new DateTime(ticks);
        }
    }
}
// file ...\IO\Scs\Client\ClientReConnecter.cs
#if !MOBILE

namespace Zero5.IO.Scs.Client
{
    /// <summary>
    /// This class is used to automatically re-connect to server if disconnected.
    /// It attempts to reconnect to server periodically until connection established.
    /// </summary>
    public class ClientReConnecter : IDisposable
    {
        /// <summary>
        /// Reconnect check period.
        /// Default: 20 seconds.
        /// </summary>
        public int ReConnectCheckPeriod
        {
            get { return _reconnectTimer.Period; }
            set { _reconnectTimer.Period = value; }
        }

        /// <summary>
        /// Reference to client object.
        /// </summary>
        private readonly IConnectableClient _client;

        /// <summary>
        /// Timer to  attempt ro reconnect periodically.
        /// </summary>
        private readonly TimerElapsed _reconnectTimer;

        /// <summary>
        /// Indicates the dispose state of this object.
        /// </summary>
        private volatile bool _disposed;

        /// <summary>
        /// Creates a new ClientReConnecter object.
        /// It is not needed to start ClientReConnecter since it automatically
        /// starts when the client disconnected.
        /// </summary>
        /// <param name="client">Reference to client object</param>
        /// <exception cref="ArgumentNullException">Throws ArgumentNullException if client is null.</exception>
        public ClientReConnecter(IConnectableClient client)
        {
            if (client == null)
            {
                throw new ArgumentNullException("client");
            }

            _client = client;
            _client.Disconnected += Client_Disconnected;
            _reconnectTimer = new TimerElapsed(20000);
            _reconnectTimer.Elapsed += ReconnectTimer_Elapsed;
            _reconnectTimer.Start();
        }

        /// <summary>
        /// Disposes this object.
        /// Does nothing if already disposed.
        /// </summary>
        public void Dispose()
        {
            if (_disposed)
            {
                return;
            }

            _disposed = true;
            _client.Disconnected -= Client_Disconnected;
            _reconnectTimer.Stop();
        }

        /// <summary>
        /// Handles Disconnected event of _client object.
        /// </summary>
        /// <param name="sender">Source of the event</param>
        /// <param name="e">Event arguments</param>
        private void Client_Disconnected(object sender, EventArgs e)
        {
            _reconnectTimer.Start();
        }

        /// <summary>
        /// Hadles Elapsed event of _reconnectTimer.
        /// </summary>
        /// <param name="sender">Source of the event</param>
        /// <param name="e">Event arguments</param>
        private void ReconnectTimer_Elapsed(object sender, EventArgs e)
        {
            if (_disposed || _client.CommunicationState == CommunicationStates.Connected)
            {
                _reconnectTimer.Stop();
                return;
            }

            try
            {
                _client.Connect();
                _reconnectTimer.Stop();
            }
            catch
            {
                //No need to catch since it will try to re-connect again
            }
        }
    }
}
#endif
// file ...\IO\Scs\Client\IConnectableClient.cs
#if !MOBILE

namespace Zero5.IO.Scs.Client
{
    /// <summary>
    /// Represents a client for SCS servers.
    /// </summary>
    public interface IConnectableClient : IDisposable
    {
        /// <summary>
        /// This event is raised when client connected to server.
        /// </summary>
        event EventHandler Connected;

        /// <summary>
        /// This event is raised when client disconnected from server.
        /// </summary>
        event EventHandler Disconnected;

        /// <summary>
        /// Timeout for connecting to a server (as milliseconds).
        /// Default value: 15 seconds (15000 ms).
        /// </summary>
        int ConnectTimeout { get; set; }

        /// <summary>
        /// Gets the current communication state.
        /// </summary>
        CommunicationStates CommunicationState { get; }

        /// <summary>
        /// Connects to server.
        /// </summary>
        void Connect();

        /// <summary>
        /// Disconnects from server.
        /// Does nothing if already disconnected.
        /// </summary>
        void Disconnect();
    }
}
#endif
// file ...\IO\Scs\Client\IScsClient.cs
#if !MOBILE

namespace Zero5.IO.Scs.Client
{
    /// <summary>
    /// Represents a client to connect to server.
    /// </summary>
    public interface IScsClient : IMessenger, IConnectableClient
    {
        //Does not define any additional member
    }
}
#endif
// file ...\IO\Scs\Client\ScsClientBase.cs
#if !MOBILE

namespace Zero5.IO.Scs.Client
{
    /// <summary>
    /// This class provides base functionality for client classes.
    /// </summary>
    public abstract class ScsClientBase : IScsClient
    {
        #region Public events

        /// <summary>
        /// This event is raised when a new message is received.
        /// </summary>
        public event EventHandler<MessageEventArgs> MessageReceived;

        /// <summary>
        /// This event is raised when a new message is sent without any error.
        /// It does not guaranties that message is properly handled and processed by remote application.
        /// </summary>
        public event EventHandler<MessageEventArgs> MessageSent;

        /// <summary>
        /// This event is raised when communication channel closed.
        /// </summary>
        public event EventHandler Connected;

        /// <summary>
        /// This event is raised when client disconnected from server.
        /// </summary>
        public event EventHandler Disconnected;

        #endregion

        #region Public properties

        /// <summary>
        /// Timeout for connecting to a server (as milliseconds).
        /// Default value: 15 seconds (15000 ms).
        /// </summary>
        public int ConnectTimeout { get; set; }

        /// <summary>
        /// Gets/sets wire protocol that is used while reading and writing messages.
        /// </summary>
        public IScsWireProtocol WireProtocol
        {
            get { return _wireProtocol; }
            set
            {
                if (CommunicationState == CommunicationStates.Connected)
                {
                    throw new ApplicationException("Wire protocol can not be changed while connected to server.");
                }

                _wireProtocol = value;
            }
        }
        private IScsWireProtocol _wireProtocol;

        /// <summary>
        /// Gets the communication state of the Client.
        /// </summary>
        public CommunicationStates CommunicationState
        {
            get
            {
                return _communicationChannel != null
                           ? _communicationChannel.CommunicationState
                           : CommunicationStates.Disconnected;
            }
        }

        /// <summary>
        /// Gets the time of the last succesfully received message.
        /// </summary>
        public DateTime LastReceivedMessageTime
        {
            get
            {
                return _communicationChannel != null
                           ? _communicationChannel.LastReceivedMessageTime
                           : DateTime.MinValue;
            }
        }

        /// <summary>
        /// Gets the time of the last succesfully received message.
        /// </summary>
        public DateTime LastSentMessageTime
        {
            get
            {
                return _communicationChannel != null
                           ? _communicationChannel.LastSentMessageTime
                           : DateTime.MinValue;
            }
        }

        #endregion

        #region Private fields

        /// <summary>
        /// Default timeout value for connecting a server.
        /// </summary>
        private const int DefaultConnectionAttemptTimeout = 15000; //15 seconds.

        /// <summary>
        /// The communication channel that is used by client to send and receive messages.
        /// </summary>
        private ICommunicationChannel _communicationChannel;

        /// <summary>
        /// This timer is used to send PingMessage messages to server periodically.
        /// </summary>
        private readonly TimerElapsed _pingTimer;

        #endregion
        
        #region Constructor

        /// <summary>
        /// Constructor.
        /// </summary>
        protected ScsClientBase()
        {
            _pingTimer = new TimerElapsed(30000);
            _pingTimer.Elapsed += PingTimer_Elapsed;
            ConnectTimeout = DefaultConnectionAttemptTimeout;
            WireProtocol = WireProtocolManager.GetDefaultWireProtocol();
        }

        #endregion

        #region Public methods

        /// <summary>
        /// Connects to server.
        /// </summary>
        public void Connect()
        {
            WireProtocol.Reset();
            _communicationChannel = CreateCommunicationChannel();
            _communicationChannel.WireProtocol = WireProtocol;
            _communicationChannel.Disconnected += CommunicationChannel_Disconnected;
            _communicationChannel.MessageReceived += CommunicationChannel_MessageReceived;
            _communicationChannel.MessageSent += CommunicationChannel_MessageSent;
            _communicationChannel.Start();
            _pingTimer.Start();
            OnConnected();
        }

        /// <summary>
        /// Disconnects from server.
        /// Does nothing if already disconnected.
        /// </summary>
        public void Disconnect()
        {
            if (CommunicationState != CommunicationStates.Connected)
            {
                return;
            }

            _communicationChannel.Disconnect();
        }

        /// <summary>
        /// Disposes this object and closes underlying connection.
        /// </summary>
        public void Dispose()
        {
            Disconnect();
        }

        /// <summary>
        /// Sends a message to the server.
        /// </summary>
        /// <param name="message">Message to be sent</param>
        /// <exception cref="CommunicationStateException">Throws a CommunicationStateException if client is not connected to the server.</exception>
        public void SendMessage(IScsMessage message)
        {
            if (CommunicationState != CommunicationStates.Connected)
            {
                this.Connect();
                System.Threading.Thread.Sleep(500);
                if (CommunicationState != CommunicationStates.Connected)
                {
                    this.Connect();
                    throw new CommunicationStateException("Client is not connected to the server.");
                }
            }
            _communicationChannel.SendMessage(message);
        }

        #endregion

        #region Abstract methods

        /// <summary>
        /// This method is implemented by derived classes to create appropriate communication channel.
        /// </summary>
        /// <returns>Ready communication channel to communicate</returns>
        protected abstract ICommunicationChannel CreateCommunicationChannel();

        #endregion

        #region Private methods

        /// <summary>
        /// Handles MessageReceived event of _communicationChannel object.
        /// </summary>
        /// <param name="sender">Source of event</param>
        /// <param name="e">Event arguments</param>
        private void CommunicationChannel_MessageReceived(object sender, MessageEventArgs e)
        {
            if (e.Message is ScsPingMessage)
            {
                return;
            }

            OnMessageReceived(e.Message);
        }

        /// <summary>
        /// Handles MessageSent event of _communicationChannel object.
        /// </summary>
        /// <param name="sender">Source of event</param>
        /// <param name="e">Event arguments</param>
        private void CommunicationChannel_MessageSent(object sender, MessageEventArgs e)
        {
            OnMessageSent(e.Message);
        }

        /// <summary>
        /// Handles Disconnected event of _communicationChannel object.
        /// </summary>
        /// <param name="sender">Source of event</param>
        /// <param name="e">Event arguments</param>
        private void CommunicationChannel_Disconnected(object sender, EventArgs e)
        {
            _pingTimer.Stop();
            OnDisconnected();
        }

        /// <summary>
        /// Handles Elapsed event of _pingTimer to send PingMessage messages to server.
        /// </summary>
        /// <param name="sender">Source of event</param>
        /// <param name="e">Event arguments</param>
        private void PingTimer_Elapsed(object sender, EventArgs e)
        {
            if (CommunicationState != CommunicationStates.Connected)
            {
                return;
            }

            try
            {
                var lastMinute = DateTime.Now.AddMinutes(-1);
                if (_communicationChannel.LastReceivedMessageTime > lastMinute || _communicationChannel.LastSentMessageTime > lastMinute)
                {
                    return;
                }

                _communicationChannel.SendMessage(new ScsPingMessage());
            }
            catch
            {

            }
        }

        #endregion

        #region Event raising methods

        /// <summary>
        /// Raises Connected event.
        /// </summary>
        protected virtual void OnConnected()
        {
            var handler = Connected;
            if (handler != null)
            {
                handler(this, EventArgs.Empty);
            }
        }

        /// <summary>
        /// Raises Disconnected event.
        /// </summary>
        protected virtual void OnDisconnected()
        {
            var handler = Disconnected;
            if (handler != null)
            {
                handler(this, EventArgs.Empty);
            }
        }

        /// <summary>
        /// Raises MessageReceived event.
        /// </summary>
        /// <param name="message">Received message</param>
        protected virtual void OnMessageReceived(IScsMessage message)
        {
            var handler = MessageReceived;
            if (handler != null)
            {
                handler(this, new MessageEventArgs(message));
            }
        }

        /// <summary>
        /// Raises MessageSent event.
        /// </summary>
        /// <param name="message">Received message</param>
        protected virtual void OnMessageSent(IScsMessage message)
        {
            var handler = MessageSent;
            if (handler != null)
            {
                handler(this, new MessageEventArgs(message));
            }
        }

        #endregion
    }
}
#endif
// file ...\IO\Scs\Client\ScsClientFactory.cs
#if !MOBILE

namespace Zero5.IO.Scs.Client
{
    /// <summary>
    /// This class is used to create SCS Clients to connect to a SCS server.
    /// </summary>
    public static class ScsClientFactory
    {
        /// <summary>
        /// Creates a new client to connect to a server using an end point.
        /// </summary>
        /// <param name="endpoint">End point of the server to connect it</param>
        /// <returns>Created TCP client</returns>
        public static IScsClient CreateClient(ScsEndPoint endpoint)
        {
            return endpoint.CreateClient();
        }

        /// <summary>
        /// Creates a new client to connect to a server using an end point.
        /// </summary>
        /// <param name="endpointAddress">End point address of the server to connect it</param>
        /// <returns>Created TCP client</returns>
        public static IScsClient CreateClient(string endpointAddress)
        {
            return CreateClient(ScsEndPoint.CreateEndPoint(endpointAddress));
        }
    }
}
#endif
// file ...\IO\Scs\Client\Tcp\ScsTcpClient.cs
#if !MOBILE

namespace Zero5.IO.Scs.Client.Tcp
{
    /// <summary>
    /// This class is used to communicate with server over TCP/IP protocol.
    /// </summary>
    public class ScsTcpClient : ScsClientBase
    {
        /// <summary>
        /// The endpoint address of the server.
        /// </summary>
        private readonly ScsTcpEndPoint _serverEndPoint;

        /// <summary>
        /// Creates a new ScsTcpClient object.
        /// </summary>
        /// <param name="serverEndPoint">The endpoint address to connect to the server</param>
        public ScsTcpClient(ScsTcpEndPoint serverEndPoint)
        {
            _serverEndPoint = serverEndPoint;
        }

        /// <summary>
        /// Creates a communication channel using ServerIpAddress and ServerPort.
        /// </summary>
        /// <returns>Ready communication channel to communicate</returns>
        protected override ICommunicationChannel CreateCommunicationChannel()
        {
            return new TcpCommunicationChannel(
                TcpHelper.ConnectToServer(
                    new IPEndPoint(IPAddress.Parse(_serverEndPoint.IpAddress), _serverEndPoint.TcpPort),
                    ConnectTimeout
                    ));
        }
    }
}
#endif
// file ...\IO\Scs\Client\Tcp\TcpHelper.cs

namespace Zero5.IO.Scs.Client.Tcp
{
    /// <summary>
    /// This class is used to simplify TCP socket operations.
    /// </summary>
    public static class TcpHelper
    {
        /// <summary>
        /// This code is used to connect to a TCP socket with timeout option.
        /// </summary>
        /// <param name="endPoint">IP endpoint of remote server</param>
        /// <param name="timeoutMs">Timeout to wait until connect</param>
        /// <returns>Socket object connected to server</returns>
        /// <exception cref="SocketException">Throws SocketException if can not connect.</exception>
        /// <exception cref="TimeoutException">Throws TimeoutException if can not connect within specified timeoutMs</exception>
        public static Socket ConnectToServer(EndPoint endPoint, int timeoutMs)
        {
#if !MOBILE
            var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            try
            {
#if CORE
                socket.Blocking = true;
#else
                socket.Blocking = false;
#endif
                socket.Connect(endPoint);
                socket.Blocking = true;
                return socket;
            }
            catch (SocketException socketException)
            {
                if (socketException.ErrorCode != 10035)
                {
                    socket.Close();
                    throw;
                }

                if (!socket.Poll(timeoutMs * 1000, SelectMode.SelectWrite))
                {
                    socket.Close();
                    throw new System.TimeoutException("The host failed to connect. Timeout occurred.");
                }

                socket.Blocking = true;
                return socket;
            }
#else
            SocketMobile socket = new SocketMobile();
            return socket.Connect(endPoint, timeoutMs);
#endif
            }

#if MOBILE
        public class SocketMobile
        {
            public Socket client;
            
            private AsyncCallback connectCallback;
            private bool waitCallBack;
            private int connectTimeout = 10000; //milliseconds

            public SocketMobile()
            {
                connectCallback = new AsyncCallback(ConnectCallback);
            }

            public Socket Connect(EndPoint endPoint, int timeoutMS)
            {
                connectTimeout = timeoutMS;

                waitCallBack = false;

                client = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                
                client.BeginConnect(endPoint, connectCallback, null);

                long tickLimit = DateTime.Now.AddMilliseconds((double)connectTimeout).Ticks;
                for (; ; )
                {
                    if (waitCallBack)
                    {
                        if (this.Connected)
                        {
                            return client;
                        }
                        else
                        {
                            throw new Exception("Connection Failed");
                        }
                    }
                    System.Threading.Thread.Sleep(10);

                    if (tickLimit < DateTime.Now.Ticks) break;
                }
                throw new Exception("Connection Timeout");
            }

            private void ConnectCallback(IAsyncResult ar)
            {
                try
                {
                    // pass connection status with event
                    client.EndConnect(ar);
                    waitCallBack = true;
                }
                catch //(Exception ex)
                {
                    //RaiseNotifyEvent(NotifyCommand.Error, ex.Message);
                }
            }
            
            public bool Connected
            {
                get
                {
                    if (client == null) return false;
                    if (!client.Connected) return false;
                    
                    try
                    {
                    
                        try
                        {
                            client.Send(new byte[0]);                    
                        }
                        catch
                        {
                            return false;
                        }

                    }
                    catch
                    {
                        return false;
                    }
                    return true;
                }
            }
        }
#endif

    }
}
// file ...\IO\Scs\Communication\CommunicationException.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication
{
    /// <summary>
    /// This application is thrown in a communication error.
    /// </summary>
    public class CommunicationException : Exception
    {
        /// <summary>
        /// Contstructor.
        /// </summary>
        public CommunicationException()
        {

        }

        /// <summary>
        /// Contstructor for serializing.
        /// </summary>
        public CommunicationException(SerializationInfo serializationInfo, StreamingContext context)
            : base(serializationInfo, context)
        {
            
        }

        /// <summary>
        /// Contstructor.
        /// </summary>
        /// <param name="message">Exception message</param>
        public CommunicationException(string message)
            : base(message)
        {

        }

        /// <summary>
        /// Contstructor.
        /// </summary>
        /// <param name="message">Exception message</param>
        /// <param name="innerException">Inner exception</param>
        public CommunicationException(string message, Exception innerException)
            : base(message, innerException)
        {

        }
    }
}
#endif
// file ...\IO\Scs\Communication\CommunicationStateException.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication
{
    /// <summary>
    /// This application is thrown if communication is not expected state.
    /// </summary>
    public class CommunicationStateException : CommunicationException
    {
        /// <summary>
        /// Contstructor.
        /// </summary>
        public CommunicationStateException()
        {

        }

        /// <summary>
        /// Contstructor for serializing.
        /// </summary>
        public CommunicationStateException(SerializationInfo serializationInfo, StreamingContext context)
            : base(serializationInfo, context)
        {
            
        }

        /// <summary>
        /// Contstructor.
        /// </summary>
        /// <param name="message">Exception message</param>
        public CommunicationStateException(string message)
            : base(message)
        {

        }

        /// <summary>
        /// Contstructor.
        /// </summary>
        /// <param name="message">Exception message</param>
        /// <param name="innerException">Inner exception</param>
        public CommunicationStateException(string message, Exception innerException)
            : base(message, innerException)
        {

        }
    }
}
#endif
// file ...\IO\Scs\Communication\CommunicationStates.cs
#if !MOBILE
namespace Zero5.IO.Scs.Communication
{
    /// <summary>
    /// Communication states.
    /// </summary>
    public enum CommunicationStates
    {
        /// <summary>
        /// Connected.
        /// </summary>
        Connected,

        /// <summary>
        /// Disconnected.
        /// </summary>
        Disconnected
    }
}
#endif
// file ...\IO\Scs\Communication\Channels\CommunicationChannelBase.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Channels
{
    /// <summary>
    /// This class provides base functionality for all communication channel classes.
    /// </summary>
    public abstract class CommunicationChannelBase : ICommunicationChannel
    {
        #region Public events

        /// <summary>
        /// This event is raised when a new message is received.
        /// </summary>
        public event EventHandler<MessageEventArgs> MessageReceived;

        /// <summary>
        /// This event is raised when a new message is sent without any error.
        /// It does not guaranties that message is properly handled and processed by remote application.
        /// </summary>
        public event EventHandler<MessageEventArgs> MessageSent;

        /// <summary>
        /// This event is raised when communication channel closed.
        /// </summary>
        public event EventHandler Disconnected;

        #endregion

        #region Public abstract properties

        ///<summary>
        /// Gets endpoint of remote application.
        ///</summary>
        public abstract ScsEndPoint RemoteEndPoint { get; }

        #endregion

        #region Public properties

        /// <summary>
        /// Gets the current communication state.
        /// </summary>
        public CommunicationStates CommunicationState { get; protected set; }

        /// <summary>
        /// Gets the time of the last succesfully received message.
        /// </summary>
        public DateTime LastReceivedMessageTime { get; protected set; }

        /// <summary>
        /// Gets the time of the last succesfully sent message.
        /// </summary>
        public DateTime LastSentMessageTime { get; protected set; }

        /// <summary>
        /// Gets/sets wire protocol that the channel uses.
        /// This property must set before first communication.
        /// </summary>
        public IScsWireProtocol WireProtocol { get; set; }

        #endregion

        #region Constructor

        /// <summary>
        /// Constructor.
        /// </summary>
        protected CommunicationChannelBase()
        {
            CommunicationState = CommunicationStates.Disconnected;
            LastReceivedMessageTime = DateTime.MinValue;
            LastSentMessageTime = DateTime.MinValue;
        }

        #endregion

        #region Public abstract methods

        /// <summary>
        /// Disconnects from remote application and closes this channel.
        /// </summary>
        public abstract void Disconnect();

        #endregion

        #region Public methods

        /// <summary>
        /// Starts the communication with remote application.
        /// </summary>
        public void Start()
        {
            StartInternal();
            CommunicationState = CommunicationStates.Connected;
        }

        /// <summary>
        /// Sends a message to the remote application.
        /// </summary>
        /// <param name="message">Message to be sent</param>
        /// <exception cref="ArgumentNullException">Throws ArgumentNullException if message is null</exception>
        public void SendMessage(IScsMessage message)
        {
            if (message == null)
            {
                throw new ArgumentNullException("message");
            }

            SendMessageInternal(message);
        }

        #endregion

        #region Protected abstract methods

        /// <summary>
        /// Starts the communication with remote application really.
        /// </summary>
        protected abstract void StartInternal();

        /// <summary>
        /// Sends a message to the remote application.
        /// This method is overrided by derived classes to really send to message.
        /// </summary>
        /// <param name="message">Message to be sent</param>
        protected abstract void SendMessageInternal(IScsMessage message);

        #endregion

        #region Event raising methods

        /// <summary>
        /// Raises Disconnected event.
        /// </summary>
        protected virtual void OnDisconnected()
        {
            var handler = Disconnected;
            if (handler != null)
            {
                handler(this, EventArgs.Empty);
            }
        }

        /// <summary>
        /// Raises MessageReceived event.
        /// </summary>
        /// <param name="message">Received message</param>
        protected virtual void OnMessageReceived(IScsMessage message)
        {
            var handler = MessageReceived;
            if (handler != null)
            {
                handler(this, new MessageEventArgs(message));
            }
        }

        /// <summary>
        /// Raises MessageSent event.
        /// </summary>
        /// <param name="message">Received message</param>
        protected virtual void OnMessageSent(IScsMessage message)
        {
            var handler = MessageSent;
            if (handler != null)
            {
                handler(this, new MessageEventArgs(message));
            }
        }

        #endregion
    }
}
#endif
// file ...\IO\Scs\Communication\Channels\CommunicationChannelEventArgs.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Channels
{
    /// <summary>
    /// Stores communication channel information to be used by an event.
    /// </summary>
    public class CommunicationChannelEventArgs : EventArgs
    {
        /// <summary>
        /// Communication channel that is associated with this event.
        /// </summary>
        public ICommunicationChannel Channel { get; private set; }

        /// <summary>
        /// Creates a new CommunicationChannelEventArgs object.
        /// </summary>
        /// <param name="channel">Communication channel that is associated with this event</param>
        public CommunicationChannelEventArgs(ICommunicationChannel channel)
        {
            Channel = channel;
        }
    }
}
#endif
// file ...\IO\Scs\Communication\Channels\ConnectionListenerBase.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Channels
{
    /// <summary>
    /// This class provides base functionality for communication listener classes.
    /// </summary>
    public abstract class ConnectionListenerBase : IConnectionListener
    {
        /// <summary>
        /// This event is raised when a new communication channel is connected.
        /// </summary>
        public event EventHandler<CommunicationChannelEventArgs> CommunicationChannelConnected;

        /// <summary>
        /// Starts listening incoming connections.
        /// </summary>
        public abstract void Start();
        
        /// <summary>
        /// Stops listening incoming connections.
        /// </summary>
        public abstract void Stop();

        /// <summary>
        /// Raises CommunicationChannelConnected event.
        /// </summary>
        /// <param name="client"></param>
        protected virtual void OnCommunicationChannelConnected(ICommunicationChannel client)
        {
            var handler = CommunicationChannelConnected;
            if (handler != null)
            {
                handler(this, new CommunicationChannelEventArgs(client));
            }
        }
    }
}
#endif
// file ...\IO\Scs\Communication\Channels\ICommunicationChannel.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Channels
{
    /// <summary>
    /// Represents a communication channel.
    /// A communication channel is used to communicate (send/receive messages) with a remote application.
    /// </summary>
    public interface ICommunicationChannel : IMessenger
    {
        /// <summary>
        /// This event is raised when client disconnected from server.
        /// </summary>
        event EventHandler Disconnected;

        ///<summary>
        /// Gets endpoint of remote application.
        ///</summary>
        ScsEndPoint RemoteEndPoint { get; }

        /// <summary>
        /// Gets the current communication state.
        /// </summary>
        CommunicationStates CommunicationState { get; }

        /// <summary>
        /// Starts the communication with remote application.
        /// </summary>
        void Start();

        /// <summary>
        /// Closes messenger.
        /// </summary>
        void Disconnect();
    }
}
#endif
// file ...\IO\Scs\Communication\Channels\IConnectionListener.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Channels
{
    /// <summary>
    /// Represents a communication listener.
    /// A connection listener is used to accept incoming client connection requests.
    /// </summary>
    public interface IConnectionListener
    {
        /// <summary>
        /// This event is raised when a new communication channel connected.
        /// </summary>
        event EventHandler<CommunicationChannelEventArgs> CommunicationChannelConnected;

        /// <summary>
        /// Starts listening incoming connections.
        /// </summary>
        void Start();

        /// <summary>
        /// Stops listening incoming connections.
        /// </summary>
        void Stop();
    }
}
#endif
// file ...\IO\Scs\Communication\Channels\Tcp\TcpCommunicationChannel.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Channels.Tcp
{
    /// <summary>
    /// This class is used to communicate with a remote application over TCP/IP protocol.
    /// </summary>
    public class TcpCommunicationChannel : CommunicationChannelBase
    {
        #region Public properties

        ///<summary>
        /// Gets the endpoint of remote application.
        ///</summary>
        public override ScsEndPoint RemoteEndPoint
        {
            get
            {
                return _remoteEndPoint;
            }
        }
        private readonly ScsTcpEndPoint _remoteEndPoint;

        #endregion

        #region Private fields

        /// <summary>
        /// Size of the buffer that is used to receive bytes from TCP socket.
        /// </summary>
        private const int ReceiveBufferSize = 4 * 1024; //4KB

        /// <summary>
        /// This buffer is used to receive bytes 
        /// </summary>
        private readonly byte[] _buffer;

        /// <summary>
        /// Socket object to send/reveice messages.
        /// </summary>
        private readonly Socket _clientSocket;

        /// <summary>
        /// A flag to control thread's running
        /// </summary>
        private volatile bool _running;

        /// <summary>
        /// This object is just used for thread synchronizing (locking).
        /// </summary>
        private readonly object _syncLock;

        #endregion

        #region Constructor

        /// <summary>
        /// Creates a new TcpCommunicationChannel object.
        /// </summary>
        /// <param name="clientSocket">A connected Socket object that is
        /// used to communicate over network</param>
        public TcpCommunicationChannel(Socket clientSocket)
        {
            _clientSocket = clientSocket;
            _clientSocket.NoDelay = true;

            var ipEndPoint = (IPEndPoint)_clientSocket.RemoteEndPoint;
            _remoteEndPoint = new ScsTcpEndPoint(ipEndPoint.Address.ToString(), ipEndPoint.Port);

            _buffer = new byte[ReceiveBufferSize];
            _syncLock = new object();
        }

        #endregion

        #region Public methods

        /// <summary>
        /// Disconnects from remote application and closes channel.
        /// </summary>
        public override void Disconnect()
        {
            if (CommunicationState != CommunicationStates.Connected)
            {
                return;
            }

            _running = false;
            try
            {
                if (_clientSocket.Connected)
                {
                    _clientSocket.Close();
                }

                _clientSocket.Dispose();
            }
            catch
            {

            }

            CommunicationState = CommunicationStates.Disconnected;
            OnDisconnected();
        }

        #endregion

        #region Protected methods

        /// <summary>
        /// Starts the thread to receive messages from socket.
        /// </summary>
        protected override void StartInternal()
        {
            _running = true;
            _clientSocket.BeginReceive(_buffer, 0, _buffer.Length, 0, new AsyncCallback(ReceiveCallback), null);
        }

        /// <summary>
        /// Sends a message to the remote application.
        /// </summary>
        /// <param name="message">Message to be sent</param>
        protected override void SendMessageInternal(IScsMessage message)
        {
            //Send message
            var totalSent = 0;
            lock (_syncLock)
            {
                //Create a byte array from message according to current protocol
                var messageBytes = WireProtocol.GetBytes(message);
                //Send all bytes to the remote application
                while (totalSent < messageBytes.Length)
                {
                    var sent = _clientSocket.Send(messageBytes, totalSent, messageBytes.Length - totalSent, SocketFlags.None);
                    if (sent <= 0)
                    {
                        throw new CommunicationException("Message could not be sent via TCP socket. Only " + totalSent + " bytes of " + messageBytes.Length + " bytes are sent.");
                    }

                    totalSent += sent;
                }

                LastSentMessageTime = DateTime.Now;
                OnMessageSent(message);
            }
        }

        #endregion

        #region Private methods

        /// <summary>
        /// This method is used as callback method in _clientSocket's BeginReceive method.
        /// It reveives bytes from socker.
        /// </summary>
        /// <param name="ar">Asyncronous call result</param>
        private void ReceiveCallback(IAsyncResult ar)
        {
            if(!_running)
            {
                return;
            }

            try
            {
                //Get received bytes count
                var bytesRead = _clientSocket.EndReceive(ar);
                if (bytesRead > 0)
                {
                    LastReceivedMessageTime = DateTime.Now;

                    //Copy received bytes to a new byte array
                    var receivedBytes = new byte[bytesRead];
                    Array.Copy(_buffer, 0, receivedBytes, 0, bytesRead);

                    //Read messages according to current wire protocol
                    var messages = WireProtocol.CreateMessages(receivedBytes);
                    
                    //Raise MessageReceived event for all received messages
                    foreach (var message in messages)
                    {
                        OnMessageReceived(message);
                    }
                }
                else
                {
                    throw new CommunicationException("Tcp socket is closed");
                }

                //Read more bytes if still running
                if (_running)
                {
                    _clientSocket.BeginReceive(_buffer, 0, _buffer.Length, 0, new AsyncCallback(ReceiveCallback), null);
                }
            }
            catch
            {
                Disconnect();
            }
        }
        
        #endregion
    }
}
#endif
// file ...\IO\Scs\Communication\Channels\Tcp\TcpConnectionListener.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Channels.Tcp
{
    /// <summary>
    /// This class is used to listen and accept incoming TCP
    /// connection requests on a TCP port.
    /// </summary>
    public class TcpConnectionListener : ConnectionListenerBase
    {
        /// <summary>
        /// The endpoint address of the server to listen incoming connections.
        /// </summary>
        private readonly ScsTcpEndPoint _endPoint;

        /// <summary>
        /// Server socket to listen incoming connection requests.
        /// </summary>
        private TcpListener _listenerSocket;

        /// <summary>
        /// The thread to listen socket
        /// </summary>
        private Thread _thread;

        /// <summary>
        /// A flag to control thread's running
        /// </summary>
        private volatile bool _running;

        /// <summary>
        /// Creates a new TcpConnectionListener for given endpoint.
        /// </summary>
        /// <param name="endPoint">The endpoint address of the server to listen incoming connections</param>
        public TcpConnectionListener(ScsTcpEndPoint endPoint)
        {
            _endPoint = endPoint;
        }

        /// <summary>
        /// Starts listening incoming connections.
        /// </summary>
        public override void Start()
        {
            StartSocket();
            _running = true;
            _thread = new Thread(DoListenAsThread);
            _thread.Name = "TCPListener";
            _thread.Start();
        }

        /// <summary>
        /// Stops listening incoming connections.
        /// </summary>
        public override void Stop()
        {
            _running = false;
            StopSocket();
        }

        /// <summary>
        /// Starts listening socket.
        /// </summary>
        private void StartSocket()
        {
            _listenerSocket = new TcpListener(System.Net.IPAddress.Any, _endPoint.TcpPort);
            _listenerSocket.Start();
        }

        /// <summary>
        /// Stops listening socket.
        /// </summary>
        private void StopSocket()
        {
            try
            {
                _listenerSocket.Stop();
            }
            catch
            {

            }
        }

        /// <summary>
        /// Entrance point of the thread.
        /// This method is used by the thread to listen incoming requests.
        /// </summary>
        private void DoListenAsThread()
        {
            while (_running)
            {
                try
                {
                    var clientSocket = _listenerSocket.AcceptSocket();
                    if (clientSocket.Connected)
                    {
                        OnCommunicationChannelConnected(new TcpCommunicationChannel(clientSocket));
                    }
                }
                catch
                {
                    //Disconnect, wait for a while and connect again.
                    StopSocket();
                    Thread.Sleep(1000);
                    if (!_running)
                    {
                        return;
                    }

                    try
                    {
                        StartSocket();
                    }
                    catch
                    {

                    }
                }
            }
        }
    }
}
#endif
// file ...\IO\Scs\Communication\EndPoints\ScsEndPoint.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.EndPoints
{
    ///<summary>
    /// Represents a server side end point in SCS.
    ///</summary>
    public abstract class ScsEndPoint
    {
        /// <summary>
        /// Create a Scs End Point from a string.
        /// Address must be formatted as: protocol://address
        /// For example: tcp://89.43.104.179:10048 for a TCP endpoint with
        /// IP 89.43.104.179 and port 10048.
        /// </summary>
        /// <param name="endPointAddress">Address to create endpoint</param>
        /// <returns>Created end point</returns>
        public static ScsEndPoint CreateEndPoint(string endPointAddress)
        {
            //Check if end point address is null
            if (string.IsNullOrEmpty(endPointAddress))
            {
                throw new ArgumentNullException("endPointAddress");
            }

            //If not protocol specified, assume TCP.
            var endPointAddr = endPointAddress;
            if (!endPointAddr.Contains("://"))
            {
                endPointAddr = "tcp://" + endPointAddr;
            }

            //Split protocol and address parts
            var splittedEndPoint = endPointAddr.Split(new[] { "://" }, StringSplitOptions.RemoveEmptyEntries);
            if (splittedEndPoint.Length != 2)
            {
                throw new ApplicationException(endPointAddress + " is not a valid endpoint address.");
            }

            //Split end point, find protocol and address
            var protocol = splittedEndPoint[0].Trim().ToLower();
            var address = splittedEndPoint[1].Trim();
            switch (protocol)
            {
                case "tcp":
                    return new ScsTcpEndPoint(address);
                default:
                    throw new ApplicationException("Unsupported protocol " + protocol + " in end point " + endPointAddress);
            }
        }

        /// <summary>
        /// Creates a Scs Server that uses this end point to listen incoming connections.
        /// </summary>
        /// <returns>Scs Server</returns>
        internal abstract IScsServer CreateServer();

        /// <summary>
        /// Creates a Scs Server that uses this end point to connect to server.
        /// </summary>
        /// <returns>Scs Client</returns>
        internal abstract IScsClient CreateClient();

    }
}
#endif
// file ...\IO\Scs\Communication\EndPoints\Tcp\ScsTcpEndPoint.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.EndPoints.Tcp
{
    /// <summary>
    /// Represens a TCP end point in SCS.
    /// </summary>
    public sealed class ScsTcpEndPoint : ScsEndPoint
    {
        ///<summary>
        /// IP address of the server.
        ///</summary>
        public string IpAddress { get; set; }

        ///<summary>
        /// Listening TCP Port for incoming connection requests on server.
        ///</summary>
        public int TcpPort { get; private set; }

        /// <summary>
        /// Creates a new ScsTcpEndPoint object with specified port number.
        /// </summary>
        /// <param name="tcpPort">Listening TCP Port for incoming connection requests on server</param>
        public ScsTcpEndPoint(int tcpPort)
        {
            TcpPort = tcpPort;
        }

        /// <summary>
        /// Creates a new ScsTcpEndPoint object with specified IP address and port number.
        /// </summary>
        /// <param name="ipAddress">IP address of the server</param>
        /// <param name="port">Listening TCP Port for incoming connection requests on server</param>
        public ScsTcpEndPoint(string ipAddress, int port)
        {
            IpAddress = ipAddress;
            TcpPort = port;
        }
        
        /// <summary>
        /// Creates a new ScsTcpEndPoint from a string address.
        /// Address format must be like IPAddress:Port (For example: 127.0.0.1:10085).
        /// </summary>
        /// <param name="address">TCP end point Address</param>
        /// <returns>Created ScsTcpEndpoint object</returns>
        public ScsTcpEndPoint(string address)
        {
            var splittedAddress = address.Trim().Split(':');
            IpAddress = splittedAddress[0].Trim();
            TcpPort = Convert.ToInt32(splittedAddress[1].Trim());
        }

        /// <summary>
        /// Creates a Scs Server that uses this end point to listen incoming connections.
        /// </summary>
        /// <returns>Scs Server</returns>
        internal override IScsServer CreateServer()
        {
            return new ScsTcpServer(this);
        }

        /// <summary>
        /// Creates a Scs Client that uses this end point to connect to server.
        /// </summary>
        /// <returns>Scs Client</returns>
        internal override IScsClient CreateClient()
        {
            return new ScsTcpClient(this);
        }

        /// <summary>
        /// Generates a string representation of this end point object.
        /// </summary>
        /// <returns>String representation of this end point object</returns>
        public override string ToString()
        {
            return string.IsNullOrEmpty(IpAddress) ? ("tcp://" + TcpPort) : ("tcp://" + IpAddress + ":" + TcpPort);
        }

    }
}
#endif
// file ...\IO\Scs\Communication\Messages\IScsMessage.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Messages
{
    /// <summary>
    /// Represents a message that is sent and received by server and client.
    /// </summary>
    public interface IScsMessage
    {
        /// <summary>
        /// Unique identified for this message. 
        /// </summary>
        string MessageId { get; }

        /// <summary>
        /// Unique identified for this message. 
        /// </summary>
        string RepliedMessageId { get; set; }

        /// <summary>
        /// Type for this message. 
        /// </summary>
        int MessageType { get; set; }

        void SerializeOn(Zero5.IO.RawSerializer.RawSerializer rawSer);

        void DeserializeFrom(Zero5.IO.RawSerializer.RawDeserializer rawDes);
    }
}
#endif
// file ...\IO\Scs\Communication\Messages\MessageEventArgs.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Messages
{
    /// <summary>
    /// Stores message to be used by an event.
    /// </summary>
    public class MessageEventArgs : EventArgs
    {
        /// <summary>
        /// Message object that is associated with this event.
        /// </summary>
        public IScsMessage Message { get; private set; }

        /// <summary>
        /// Creates a new MessageEventArgs object.
        /// </summary>
        /// <param name="message">Message object that is associated with this event</param>
        public MessageEventArgs(IScsMessage message)
        {
            Message = message;
        }
    }
}
#endif
// file ...\IO\Scs\Communication\Messages\PingMessage.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Messages
{
    /// <summary>
    /// This message is used to send/receive ping messages.
    /// Ping messages is used to keep connection alive between server and client.
    /// </summary>
    public class ScsPingMessage : ScsMessage
    {
        ///<summary>
        /// Creates a new PingMessage object.
        ///</summary>
        public ScsPingMessage()
        {
            MessageType = 1;          
        }

        /// <summary>
        /// Creates a new reply PingMessage object.
        /// </summary>
        /// <param name="repliedMessageId">
        /// Replied message id if this is a reply for
        /// a message.
        /// </param>
        public ScsPingMessage(string repliedMessageId)
            : this()
        {
            RepliedMessageId = repliedMessageId;
        }


        /// <summary>
        /// Creates a string to represents this object.
        /// </summary>
        /// <returns>A string to represents this object</returns>
        public override string ToString()
        {
            return string.IsNullOrEmpty(RepliedMessageId)
                       ? string.Format("ScsPingMessage [{0}]", MessageId)
                       : string.Format("ScsPingMessage [{0}] Replied To [{1}]", MessageId, RepliedMessageId);
        }
         

    }
}
#endif
// file ...\IO\Scs\Communication\Messages\ScsMessage.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Messages
{
    /// <summary>
    /// Represents a message that is sent and received by server and client.
    /// This is the base class for all messages.
    /// </summary>
    public class ScsMessage : IScsMessage
    {
        /// <summary>
        /// Unique identified for this message.
        /// Default value: New GUID.
        /// Do not change if you do not want to do low level changes
        /// such as custom wire protocols.
        /// </summary>
        public string MessageId { get; set; }

        /// <summary>
        /// This property is used to indicate that this is
        /// a Reply message to a message.
        /// It may be null if this is not a reply message.
        /// </summary>
        public string RepliedMessageId { get; set; }

        /// <summary>
        /// Type for this message.
        /// </summary>
        public int MessageType { get; set; }

        /// <summary>
        /// Creates a new ScsMessage.
        /// </summary>
        public ScsMessage()
        {
            MessageType = 0;
            MessageId = Guid.NewGuid().ToString(); 
        }

        /// <summary>
        /// Creates a new reply ScsMessage.
        /// </summary>
        /// <param name="repliedMessageId">
        /// Replied message id if this is a reply for
        /// a message.
        /// </param>
        public ScsMessage(string repliedMessageId)
            : this()
        {
            RepliedMessageId = repliedMessageId;
        }

        /// <summary>
        /// Creates a string to represents this object.
        /// </summary>
        /// <returns>A string to represents this object</returns>
        public override string ToString()
        {
            return string.IsNullOrEmpty(RepliedMessageId)
                       ? string.Format("ScsMessage [{0}]", MessageId)
                       : string.Format("ScsMessage [{0}] Replied To [{1}]", MessageId, RepliedMessageId);
        }

        public virtual void SerializeOn(Zero5.IO.RawSerializer.RawSerializer rawSer)
        {
            if (this.MessageId == null) this.MessageId = "";
            if (this.RepliedMessageId == null) this.RepliedMessageId = "";
            rawSer.Serialize(this.MessageId);
            rawSer.Serialize(this.RepliedMessageId); 
        }

        public virtual void DeserializeFrom(Zero5.IO.RawSerializer.RawDeserializer rawDes)
        {
            this.MessageId = rawDes.DeserializeString();
            this.RepliedMessageId = rawDes.DeserializeString(); 
        }

    }
}
#endif
// file ...\IO\Scs\Communication\Messages\ScsRawDataMessage.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Messages
{
    /// <summary>
    /// This message is used to send/receive a raw byte array as message data.
    /// </summary>
    public class ScsRawDataMessage : ScsMessage
    {      
        /// <summary>
        /// Message data that is being transmitted.
        /// </summary>
        public byte[] MessageData { get; set; }

        /// <summary>
        /// Default empty constructor.
        /// </summary>
        public ScsRawDataMessage()
        {
            MessageType = 3;            
        }

        /// <summary>
        /// Creates a new ScsRawDataMessage object with MessageData property.
        /// </summary>
        /// <param name="messageData">Message data that is being transmitted</param>
        public ScsRawDataMessage(byte[] messageData)
            : this()
        {
            MessageData = messageData;
        }

                /// <summary>
        /// Creates a new reply ScsRawDataMessage object with MessageData property.
        /// </summary>
        /// <param name="messageData">Message data that is being transmitted</param>
        /// <param name="repliedMessageId">
        /// Replied message id if this is a reply for
        /// a message.
        /// </param>
        public ScsRawDataMessage(byte[] messageData, string repliedMessageId)
            : this(messageData)
        {
            RepliedMessageId = repliedMessageId;
        }

        /// <summary>
        /// Creates a string to represents this object.
        /// </summary>
        /// <returns>A string to represents this object</returns>
        public override string ToString()
        {
            var messageLength = MessageData == null ? 0 : MessageData.Length;
            return string.IsNullOrEmpty(RepliedMessageId)
                       ? string.Format("ScsRawDataMessage [{0}]: {1} bytes", MessageId, messageLength)
                       : string.Format("ScsRawDataMessage [{0}] Replied To [{1}]: {2} bytes", MessageId, RepliedMessageId, messageLength);
        }

        public override void SerializeOn(Zero5.IO.RawSerializer.RawSerializer rawSer)
        {
            if (this.MessageId == null) this.MessageId = "";
            if (this.RepliedMessageId == null) this.RepliedMessageId = "";
            if (this.MessageData == null) this.MessageData = new byte[0];
            rawSer.Serialize(this.MessageId);
            rawSer.Serialize(this.RepliedMessageId);
            rawSer.Serialize(this.MessageData);
        }

        public override void DeserializeFrom(Zero5.IO.RawSerializer.RawDeserializer rawDes)
        {
            this.MessageId = rawDes.DeserializeString();
            this.RepliedMessageId = rawDes.DeserializeString();
            this.MessageData = rawDes.DeserializeBytes();
        }
    }
}
#endif
// file ...\IO\Scs\Communication\Messages\ScsTextMessage.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Messages
{
    /// <summary>
    /// This message is used to send/receive a text as message data.
    /// </summary>
    public class ScsTextMessage : ScsMessage
    {
        /// <summary>
        /// Message text that is being transmitted.
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// Creates a new ScsTextMessage object.
        /// </summary>
        public ScsTextMessage()
        {
            MessageType = 2; 
        }

        /// <summary>
        /// Creates a new ScsTextMessage object with Text property.
        /// </summary>
        /// <param name="text">Message text that is being transmitted</param>
        public ScsTextMessage(string text)
            : this()
        {
            Text = text;
        }

        /// <summary>
        /// Creates a new reply ScsTextMessage object with Text property.
        /// </summary>
        /// <param name="text">Message text that is being transmitted</param>
        /// <param name="repliedMessageId">
        /// Replied message id if this is a reply for
        /// a message.
        /// </param>
        public ScsTextMessage(string text, string repliedMessageId)
            : this(text)
        {
            RepliedMessageId = repliedMessageId;
        }
        
        /// <summary>
        /// Creates a string to represents this object.
        /// </summary>
        /// <returns>A string to represents this object</returns>
        public override string ToString()
        {
            return string.IsNullOrEmpty(RepliedMessageId)
                       ? string.Format("ScsTextMessage [{0}]: {1}", MessageId, Text)
                       : string.Format("ScsTextMessage [{0}] Replied To [{1}]: {2}", MessageId, RepliedMessageId, Text);
        }

        public override void SerializeOn(Zero5.IO.RawSerializer.RawSerializer rawSer)
        {
            if (this.MessageId == null) this.MessageId = "";
            if (this.RepliedMessageId == null) this.RepliedMessageId = "";
            if (this.Text == null) this.Text = "";
            rawSer.Serialize(this.MessageId);
            rawSer.Serialize(this.RepliedMessageId);
            rawSer.Serialize(this.Text);
        }

        public override void DeserializeFrom(Zero5.IO.RawSerializer.RawDeserializer rawDes)
        {
            this.MessageId = rawDes.DeserializeString();
            this.RepliedMessageId = rawDes.DeserializeString();
            this.Text = rawDes.DeserializeString();
        }
    }
}
#endif
// file ...\IO\Scs\Communication\Messengers\IMessenger.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Messengers
{
    /// <summary>
    /// Represents an object that can send and receive messages.
    /// </summary>
    public interface IMessenger
    {
        /// <summary>
        /// This event is raised when a new message is received.
        /// </summary>
        event EventHandler<MessageEventArgs> MessageReceived;

        /// <summary>
        /// This event is raised when a new message is sent without any error.
        /// It does not guaranties that message is properly handled and processed by remote application.
        /// </summary>
        event EventHandler<MessageEventArgs> MessageSent;

        /// <summary>
        /// Gets/sets wire protocol that is used while reading and writing messages.
        /// </summary>
        IScsWireProtocol WireProtocol { get; set; }

        /// <summary>
        /// Gets the time of the last succesfully received message.
        /// </summary>
        DateTime LastReceivedMessageTime { get; }

        /// <summary>
        /// Gets the time of the last succesfully sent message.
        /// </summary>
        DateTime LastSentMessageTime { get; }

        /// <summary>
        /// Sends a message to the remote application.
        /// </summary>
        /// <param name="message">Message to be sent</param>
        void SendMessage(IScsMessage message);
    }
}
#endif
// file ...\IO\Scs\Communication\Messengers\RequestReplyMessenger.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Messengers
{
    /// <summary>
    /// This class adds SendMessageAndWaitForResponse(...) and SendAndReceiveMessage methods
    /// to a IMessenger for synchronous request/response style messaging.
    /// It also adds queued processing of incoming messages.
    /// </summary>
    /// <typeparam name="T">Type of IMessenger object to use as underlying communication</typeparam>
    public class RequestReplyMessenger<T> : IMessenger, IDisposable where T : IMessenger
    {
        #region Public events

        /// <summary>
        /// This event is raised when a new message is received from underlying messenger.
        /// </summary>
        public event EventHandler<MessageEventArgs> MessageReceived;

        /// <summary>
        /// This event is raised when a new message is sent without any error.
        /// It does not guaranties that message is properly handled and processed by remote application.
        /// </summary>
        public event EventHandler<MessageEventArgs> MessageSent;

        #endregion

        #region Public properties

        /// <summary>
        /// Gets/sets wire protocol that is used while reading and writing messages.
        /// </summary>
        public IScsWireProtocol WireProtocol
        {
            get { return Messenger.WireProtocol; }
            set { Messenger.WireProtocol = value; }
        }

        /// <summary>
        /// Gets the time of the last succesfully received message.
        /// </summary>
        public DateTime LastReceivedMessageTime
        {
            get
            {
                return Messenger.LastReceivedMessageTime;
            }
        }

        /// <summary>
        /// Gets the time of the last succesfully received message.
        /// </summary>
        public DateTime LastSentMessageTime
        {
            get
            {
                return Messenger.LastSentMessageTime;
            }
        }

        /// <summary>
        /// Gets the underlying IMessenger object.
        /// </summary>
        public T Messenger { get; private set; }

        /// <summary>
        /// Timeout value as milliseconds to wait for a receiving message on 
        /// SendMessageAndWaitForResponse and SendAndReceiveMessage methods.
        /// Default value: 60000 (1 minute).
        /// </summary>
        public int Timeout { get; set; }

        #endregion

        #region Private fields

        /// <summary>
        /// Default Timeout value.
        /// </summary>
        private const int DefaultTimeout = 60000;

        /// <summary>
        /// This messages are waiting for a response those are used when 
        /// SendMessageAndWaitForResponse is called.
        /// Key: MessageID of waiting request message.
        /// Value: A WaitingMessage instance.
        /// </summary>
        private readonly SortedList<string, WaitingMessage> _waitingMessages;

        /// <summary>
        /// This object is used to process incoming messages sequentially.
        /// </summary>
        private readonly SequentialItemProcessor<IScsMessage> _incomingMessageProcessor;

        /// <summary>
        /// This object is used for thread synchronization.
        /// </summary>
        private readonly object _syncObj = new object();

        #endregion

        #region Constructor

        /// <summary>
        /// Creates a new RequestReplyMessenger.
        /// </summary>
        /// <param name="messenger">IMessenger object to use as underlying communication</param>
        public RequestReplyMessenger(T messenger)
        {
            Messenger = messenger;
            messenger.MessageReceived += Messenger_MessageReceived;
            messenger.MessageSent += Messenger_MessageSent;
            _incomingMessageProcessor = new SequentialItemProcessor<IScsMessage>(OnMessageReceived);
            _waitingMessages = new SortedList<string, WaitingMessage>();
            Timeout = DefaultTimeout;
        }

        #endregion

        #region Public methods

        /// <summary>
        /// Starts the messenger.
        /// </summary>
        public virtual void Start()
        {
            _incomingMessageProcessor.Start();
        }

        /// <summary>
        /// Stops the messenger.
        /// Cancels all waiting threads in SendMessageAndWaitForResponse method and stops message queue.
        /// SendMessageAndWaitForResponse method throws exception if there is a thread that is waiting for response message.
        /// Also stops incoming message processing and deletes all messages in incoming message queue.
        /// </summary>
        public virtual void Stop()
        {
            _incomingMessageProcessor.Stop();

            //Pulse waiting threads for incoming messages, since underlying messenger is disconnected
            //and can not receive messages anymore.
            lock (_syncObj)
            {
                foreach (var waitingMessage in _waitingMessages.Values)
                {
                    waitingMessage.State = WaitingMessageStates.Cancelled;
                    waitingMessage.WaitEvent.Set();
                }

                _waitingMessages.Clear();
            }
        }

        /// <summary>
        /// Calls Stop method of this object.
        /// </summary>
        public void Dispose()
        {
            Stop();
        }

        /// <summary>
        /// Sends a message.
        /// </summary>
        /// <param name="message">Message to be sent</param>
        public void SendMessage(IScsMessage message)
        {
            Messenger.SendMessage(message);
        }

        /// <summary>
        /// Sends a message and waits a response for that message.
        /// </summary>
        /// <remarks>
        /// Response message is matched with RepliedMessageId property, so if
        /// any other message (that is not reply for sent message) is received
        /// from remote application, it is not considered as a reply and is not
        /// returned as return value of this method.
        /// 
        /// MessageReceived event is not raised for response messages.
        /// </remarks>
        /// <param name="message">message to send</param>
        /// <returns>Response message</returns>
        public IScsMessage SendMessageAndWaitForResponse(IScsMessage message)
        {
            return SendMessageAndWaitForResponse(message, Timeout);
        }

        /// <summary>
        /// Sends a message and waits a response for that message.
        /// </summary>
        /// <remarks>
        /// Response message is matched with RepliedMessageId property, so if
        /// any other message (that is not reply for sent message) is received
        /// from remote application, it is not considered as a reply and is not
        /// returned as return value of this method.
        /// 
        /// MessageReceived event is not raised for response messages.
        /// </remarks>
        /// <param name="message">message to send</param>
        /// <param name="timeoutMilliseconds">Timeout duration as milliseconds.</param>
        /// <returns>Response message</returns>
        /// <exception cref="TimeoutException">Throws TimeoutException if can not receive reply message in timeout value</exception>
        /// <exception cref="CommunicationException">Throws CommunicationException if communication fails before reply message.</exception>
        public IScsMessage SendMessageAndWaitForResponse(IScsMessage message, int timeoutMilliseconds)
        {
            //Create a waiting message record and add to list
            var waitingMessage = new WaitingMessage();
            lock (_syncObj)
            {
                _waitingMessages[message.MessageId] = waitingMessage;
            }

            try
            {
                //Send message
                Messenger.SendMessage(message);

                //Wait for response
                waitingMessage.WaitEvent.Wait(timeoutMilliseconds);

                //Check for exceptions
                switch (waitingMessage.State)
                {
                    case WaitingMessageStates.WaitingForResponse:
                        throw new System.TimeoutException("Timeout occurred. Can not received response.");
                    case WaitingMessageStates.Cancelled:
                        throw new CommunicationException("Disconnected before response received.");
                }

                //return response message
                return waitingMessage.ResponseMessage;
            }
            finally
            {
                //Remove message from waiting messages
                lock (_syncObj)
                {
                    if (_waitingMessages.ContainsKey(message.MessageId))
                    {
                        _waitingMessages.Remove(message.MessageId);
                    }
                }
            }
        }

        #endregion

        #region Private methods

        /// <summary>
        /// Handles MessageReceived event of Messenger object.
        /// </summary>
        /// <param name="sender">Source of event</param>
        /// <param name="e">Event arguments</param>
        private void Messenger_MessageReceived(object sender, MessageEventArgs e)
        {
            //Check if there is a waiting thread for this message in SendMessageAndWaitForResponse method
            if (!string.IsNullOrEmpty(e.Message.RepliedMessageId))
            {
                WaitingMessage waitingMessage = null;
                lock (_syncObj)
                {
                    if (_waitingMessages.ContainsKey(e.Message.RepliedMessageId))
                    {
                        waitingMessage = _waitingMessages[e.Message.RepliedMessageId];
                    }
                }

                //If there is a thread waiting for this response message, pulse it
                if (waitingMessage != null)
                {
                    waitingMessage.ResponseMessage = e.Message;
                    waitingMessage.State = WaitingMessageStates.ResponseReceived;
                    waitingMessage.WaitEvent.Set();
                    return;
                }
            }

            _incomingMessageProcessor.EnqueueMessage(e.Message);
        }

        /// <summary>
        /// Handles MessageSent event of Messenger object.
        /// </summary>
        /// <param name="sender">Source of event</param>
        /// <param name="e">Event arguments</param>
        private void Messenger_MessageSent(object sender, MessageEventArgs e)
        {
            OnMessageSent(e.Message);
        }

        #endregion

        #region Event raising methods

        /// <summary>
        /// Raises MessageReceived event.
        /// </summary>
        /// <param name="message">Received message</param>
        protected virtual void OnMessageReceived(IScsMessage message)
        {
            var handler = MessageReceived;
            if (handler != null)
            {
                handler(this, new MessageEventArgs(message));
            }
        }

        /// <summary>
        /// Raises MessageSent event.
        /// </summary>
        /// <param name="message">Received message</param>
        protected virtual void OnMessageSent(IScsMessage message)
        {
            var handler = MessageSent;
            if (handler != null)
            {
                handler(this, new MessageEventArgs(message));
            }
        }

        #endregion

        #region WaitingMessage class

        /// <summary>
        /// This class is used to store messaging context for a request message
        /// until response is received.
        /// </summary>
        private sealed class WaitingMessage
        {
            /// <summary>
            /// Response message for request message 
            /// (null if response is not received yet).
            /// </summary>
            public IScsMessage ResponseMessage { get; set; }

            /// <summary>
            /// ManualResetEvent to block thread until response is received.
            /// </summary>
            public ManualResetEventSlim WaitEvent { get; private set; }

            /// <summary>
            /// State of the request message.
            /// </summary>
            public WaitingMessageStates State { get; set; }

            /// <summary>
            /// Creates a new WaitingMessage object.
            /// </summary>
            public WaitingMessage()
            {
                WaitEvent = new ManualResetEventSlim(false);
                State = WaitingMessageStates.WaitingForResponse;
            }
        }

        /// <summary>
        /// This enum is used to store the state of a waiting message.
        /// </summary>
        private enum WaitingMessageStates
        {
            /// <summary>
            /// Still waiting for response.
            /// </summary>
            WaitingForResponse,

            /// <summary>
            /// Message sending is cancelled.
            /// </summary>
            Cancelled,

            /// <summary>
            /// Response is properly received.
            /// </summary>
            ResponseReceived
        }

        #endregion
    }
}
#endif
// file ...\IO\Scs\Communication\Messengers\SynchronizedMessenger.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Messengers
{
    /// <summary>
    /// This class is a wrapper for IMessenger and is used
    /// to synchronize message receiving operation.
    /// It extends RequestReplyMessenger.
    /// It is suitable to use in applications those want to receive
    /// messages by synchronized method calls instead of asynchronous 
    /// MessageReceived event.
    /// </summary>
    public class SynchronizedMessenger<T> : RequestReplyMessenger<T> where T : IMessenger
    {
        #region Public properties

        ///<summary>
        /// Gets/sets capacity of the incoming message queue.
        /// No message is received from remote application if
        /// number of messages in internal queue exceeds this value.
        /// Default value: int.MaxValue (2147483647).
        ///</summary>
        public int IncomingMessageQueueCapacity { get; set; }

        #endregion

        #region Private fields

        /// <summary>
        /// A queue that is used to store receiving messages until Receive(...)
        /// method is called to get them.
        /// </summary>
        private readonly Queue<IScsMessage> _receivingMessageQueue;

        /// <summary>
        /// This object is used to synchronize/wait threads.
        /// </summary>
        private readonly ManualResetEventSlim _receiveWaiter;

        /// <summary>
        /// This boolean value indicates the running state of this class.
        /// </summary>
        private volatile bool _running;

        #endregion

        #region Constructors

        ///<summary>
        /// Creates a new SynchronizedMessenger object.
        ///</summary>
        ///<param name="messenger">A IMessenger object to be used to send/receive messages</param>
        public SynchronizedMessenger(T messenger)
            : this(messenger, int.MaxValue)
        {

        }

        ///<summary>
        /// Creates a new SynchronizedMessenger object.
        ///</summary>
        ///<param name="messenger">A IMessenger object to be used to send/receive messages</param>
        ///<param name="incomingMessageQueueCapacity">capacity of the incoming message queue</param>
        public SynchronizedMessenger(T messenger, int incomingMessageQueueCapacity)
            : base(messenger)
        {
            _receiveWaiter = new ManualResetEventSlim();
            _receivingMessageQueue = new Queue<IScsMessage>();
            IncomingMessageQueueCapacity = incomingMessageQueueCapacity;
        }

        #endregion

        #region Public methods

        /// <summary>
        /// Starts the messenger.
        /// </summary>
        public override void Start()
        {
            lock (_receivingMessageQueue)
            {
                _running = true;
            }

            base.Start();
        }

        /// <summary>
        /// Stops the messenger.
        /// </summary>
        public override void Stop()
        {
            base.Stop();

            lock (_receivingMessageQueue)
            {
                _running = false;
                _receiveWaiter.Set();
            }
        }

        /// <summary>
        /// This method is used to receive a message from remote application.
        /// It waits until a message is received.
        /// </summary>
        /// <returns>Received message</returns>
        public IScsMessage ReceiveMessage()
        {
            return ReceiveMessage(System.Threading.Timeout.Infinite);
        }

        /// <summary>
        /// This method is used to receive a message from remote application.
        /// It waits until a message is received or timeout occurs.
        /// </summary>
        /// <param name="timeout">
        /// Timeout value to wait if no message is received.
        /// Use -1 to wait indefinitely.
        /// </param>
        /// <returns>Received message</returns>
        /// <exception cref="TimeoutException">Throws TimeoutException if timeout occurs</exception>
        /// <exception cref="Exception">Throws Exception if SynchronizedMessenger stops before a message is received</exception>
        public IScsMessage ReceiveMessage(int timeout)
        {
            while (_running)
            {
                lock (_receivingMessageQueue)
                {
                    //Check if SynchronizedMessenger is running
                    if (!_running)
                    {
                        throw new Exception("SynchronizedMessenger is stopped. Can not receive message.");
                    }

                    //Get a message immediately if any message does exists
                    if (_receivingMessageQueue.Count > 0)
                    {
                        return _receivingMessageQueue.Dequeue();
                    }

                    _receiveWaiter.Reset();
                }

                //Wait for a message
                var signalled = _receiveWaiter.Wait(timeout);

                //If not signalled, throw exception
                if (!signalled)
                {
                    throw new System.TimeoutException("Timeout occurred. Can not received any message");
                }
            }

            throw new Exception("SynchronizedMessenger is stopped. Can not receive message.");
        }

        /// <summary>
        /// This method is used to receive a specific type of message from remote application.
        /// It waits until a message is received.
        /// </summary>
        /// <returns>Received message</returns>
        public TMessage ReceiveMessage<TMessage>() where TMessage : IScsMessage
        {
            return ReceiveMessage<TMessage>(System.Threading.Timeout.Infinite);
        }

        /// <summary>
        /// This method is used to receive a specific type of message from remote application.
        /// It waits until a message is received or timeout occurs.
        /// </summary>
        /// <param name="timeout">
        /// Timeout value to wait if no message is received.
        /// Use -1 to wait indefinitely.
        /// </param>
        /// <returns>Received message</returns>
        public TMessage ReceiveMessage<TMessage>(int timeout) where TMessage : IScsMessage
        {
            var receivedMessage = ReceiveMessage(timeout);
            if (!(receivedMessage is TMessage))
            {
                throw new Exception("Unexpected message received." +
                                    " Expected type: " + typeof(TMessage).Name +
                                    ". Received message type: " + receivedMessage.GetType().Name);
            }

            return (TMessage)receivedMessage;
        }

        #endregion

        #region Protected methods

        /// <summary>
        /// Overrides
        /// </summary>
        /// <param name="message"></param>
        protected override void OnMessageReceived(IScsMessage message)
        {
            lock (_receivingMessageQueue)
            {
                if (_receivingMessageQueue.Count < IncomingMessageQueueCapacity)
                {
                    _receivingMessageQueue.Enqueue(message);
                }

                _receiveWaiter.Set();
            }
        }

        #endregion
    }
}
#endif
// file ...\IO\Scs\Communication\Protocols\IScsWireProtocol.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Protocols
{
    /// <summary>
    /// Represents a byte-level communication protocol between applications.
    /// </summary>
    public interface IScsWireProtocol
    {
        /// <summary>
        /// Serializes a message to a byte array to send to remote application.
        /// This method is synchronized. So, only one thread can call it concurrently.
        /// </summary>
        /// <param name="message">Message to be serialized</param>
        byte[] GetBytes(IScsMessage message);

        /// <summary>
        /// Builds messages from a byte array that is received from remote application.
        /// The Byte array may contain just a part of a message, the protocol must
        /// cumulate bytes to build messages.
        /// This method is synchronized. So, only one thread can call it concurrently.
        /// </summary>
        /// <param name="receivedBytes">Received bytes from remote application</param>
        /// <returns>
        /// List of messages.
        /// Protocol can generate more than one message from a byte array.
        /// Also, if received bytes are not sufficient to build a message, the protocol
        /// may return an empty list (and save bytes to combine with next method call).
        /// </returns>
        IEnumerable<IScsMessage> CreateMessages(byte[] receivedBytes);

        /// <summary>
        /// This method is called when connection with remote application is reset (connection is renewing or first connecting).
        /// So, wire protocol must reset itself.
        /// </summary>
        void Reset();
    }
}
#endif
// file ...\IO\Scs\Communication\Protocols\IScsWireProtocolFactory.cs
#if !MOBILE
namespace Zero5.IO.Scs.Communication.Protocols
{
    ///<summary>
    /// Defines a Wire Protocol Factory class that is used to create Wire Protocol objects.
    ///</summary>
    public interface IScsWireProtocolFactory
    {
        /// <summary>
        /// Creates a new Wire Protocol object.
        /// </summary>
        /// <returns>Newly created wire protocol object</returns>
        IScsWireProtocol CreateWireProtocol();
    }
}
#endif
// file ...\IO\Scs\Communication\Protocols\WireProtocolManager.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Protocols
{
    /// <summary>
    /// This class is used to get default protocols.
    /// </summary>
    public static class WireProtocolManager
    {
        /// <summary>
        /// Creates a default wire protocol factory object to be used on communicating of applications.
        /// </summary>
        /// <returns>A new instance of default wire protocol</returns>
        public static IScsWireProtocolFactory GetDefaultWireProtocolFactory()
        {
            return new BinarySerializationProtocolFactory();
        }

        /// <summary>
        /// Creates a default wire protocol object to be used on communicating of applications.
        /// </summary>
        /// <returns>A new instance of default wire protocol</returns>
        public static IScsWireProtocol GetDefaultWireProtocol()
        {
            return new BinarySerializationProtocol();
        }
    }
}
#endif
// file ...\IO\Scs\Communication\Protocols\BinarySerialization\BinarySerializationProtocol.cs
#if !MOBILE

namespace Zero5.IO.Scs.Communication.Protocols.BinarySerialization
{
    /// <summary>
    /// Default communication protocol between server and clients to send and receive a message.
    /// It uses .NET binary serialization to write and read messages.
    /// 
    /// A Message format:
    /// [Message Length (4 bytes)][Serialized Message Content]
    /// 
    /// If a message is serialized to byte array as N bytes, this protocol
    /// adds 4 bytes size information to head of the message bytes, so total length is (4 + N) bytes.
    /// 
    /// This class can be derived to change serializer (default: BinaryFormatter). To do this,
    /// SerializeMessage and DeserializeMessage methods must be overrided.
    /// </summary>
    public class BinarySerializationProtocol : IScsWireProtocol
    {
        #region Private fields

        /// <summary>
        /// Maximum length of a message.
        /// </summary>
        private const int MaxMessageLength = 128 * 1024 * 1024; //128 Megabytes.

        /// <summary>
        /// This MemoryStream object is used to collect receiving bytes to build messages.
        /// </summary>
        private MemoryStream _receiveMemoryStream;

        #endregion

        #region Constructor

        /// <summary>
        /// Creates a new instance of BinarySerializationProtocol.
        /// </summary>
        public BinarySerializationProtocol()
        {
            _receiveMemoryStream = new MemoryStream();
        }

        #endregion

        #region IScsWireProtocol implementation

        /// <summary>
        /// Serializes a message to a byte array to send to remote application.
        /// This method is synchronized. So, only one thread can call it concurrently.
        /// </summary>
        /// <param name="message">Message to be serialized</param>
        /// <exception cref="CommunicationException">Throws CommunicationException if message is bigger than maximum allowed message length.</exception>
        public byte[] GetBytes(IScsMessage message)
        {
            //Serialize the message to a byte array
            var serializedMessage = SerializeMessage(message); 
           
            //Check for message length
            var messageLength = serializedMessage.Length;
            if (messageLength > MaxMessageLength)
            {
                throw new CommunicationException("Message is too big (" + messageLength + " bytes). Max allowed length is " + MaxMessageLength + " bytes.");
            }

            //Create a byte array including the length of the message (4 bytes) and serialized message content
            var bytes = new byte[messageLength + 4];
            WriteInt32(bytes, 0, messageLength);
            Array.Copy(serializedMessage, 0, bytes, 4, messageLength);

            //Return serialized message by this protocol
            return bytes;
        }

        /// <summary>
        /// Builds messages from a byte array that is received from remote application.
        /// The Byte array may contain just a part of a message, the protocol must
        /// cumulate bytes to build messages.
        /// This method is synchronized. So, only one thread can call it concurrently.
        /// </summary>
        /// <param name="receivedBytes">Received bytes from remote application</param>
        /// <returns>
        /// List of messages.
        /// Protocol can generate more than one message from a byte array.
        /// Also, if received bytes are not sufficient to build a message, the protocol
        /// may return an empty list (and save bytes to combine with next method call).
        /// </returns>
        public IEnumerable<IScsMessage> CreateMessages(byte[] receivedBytes)
        {
            //Write all received bytes to the _receiveMemoryStream
            _receiveMemoryStream.Write(receivedBytes, 0, receivedBytes.Length);
            //Create a list to collect messages
            var messages = new List<IScsMessage>();
            //Read all available messages and add to messages collection
            while (ReadSingleMessage(messages)) { }
            //Return message list
            return messages;
        }

        /// <summary>
        /// This method is called when connection with remote application is reset (connection is renewing or first connecting).
        /// So, wire protocol must reset itself.
        /// </summary>
        public void Reset()
        {
            if (_receiveMemoryStream.Length > 0)
            {
                _receiveMemoryStream = new MemoryStream();
            }
        }

        #endregion

        #region Proptected virtual methods

        /// <summary>
        /// This method is used to serialize a IScsMessage to a byte array.
        /// This method can be overrided by derived classes to change serialization strategy.
        /// It is a couple with DeserializeMessage method and must be overrided together.
        /// </summary>
        /// <param name="message">Message to be serialized</param>
        /// <returns>
        /// Serialized message bytes.
        /// Does not include length of the message.
        /// </returns>
        protected virtual byte[] SerializeMessage(IScsMessage message)
        {
            using (var memoryStream = new MemoryStream())
            {
                Zero5.IO.RawSerializer.RawSerializer rawSerializer = new RawSerializer.RawSerializer(memoryStream);
                rawSerializer.Serialize(message.MessageType);
                message.SerializeOn(rawSerializer);
                return memoryStream.ToArray();
            }
        }

        /// <summary>
        /// This method is used to deserialize a IScsMessage from it's bytes.
        /// This method can be overrided by derived classes to change deserialization strategy.
        /// It is a couple with SerializeMessage method and must be overrided together.
        /// </summary>
        /// <param name="bytes">
        /// Bytes of message to be deserialized (does not include message length. It consist
        /// of a single whole message)
        /// </param>
        /// <returns>Deserialized message</returns>
        protected virtual IScsMessage DeserializeMessage(byte[] bytes)
        {
            //Create a MemoryStream to convert bytes to a stream
            using (var deserializeMemoryStream = new MemoryStream(bytes))
            {
                //Go to head of the stream
                deserializeMemoryStream.Position = 0;

                IScsMessage message;

                Zero5.IO.RawSerializer.RawDeserializer rawDeserializer = new RawSerializer.RawDeserializer(deserializeMemoryStream);
                int messageType = rawDeserializer.DeserializeInt();
                if (messageType == 0) message = new ScsMessage();
                else 
                    if (messageType == 1) message = new ScsPingMessage();
                    else
                        if (messageType == 2) message = new ScsTextMessage();
                        else
                            if (messageType == 3) message = new ScsRawDataMessage();
                            else
                                message = new ScsMessage(); //fallback

                message.DeserializeFrom(rawDeserializer);

                return message;


                ////Deserialize the message
                //var binaryFormatter = new BinaryFormatter
                //{
                //    AssemblyFormat = System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple,
                //    Binder = new DeserializationAppDomainBinder()
                //};
                
                ////Return the deserialized message
                //return (IScsMessage) binaryFormatter.Deserialize(deserializeMemoryStream);
            }
        }

        #endregion

        #region Private methods

        /// <summary>
        /// This method tries to read a single message and add to the messages collection. 
        /// </summary>
        /// <param name="messages">Messages collection to collect messages</param>
        /// <returns>
        /// Returns a boolean value indicates that if there is a need to re-call this method.
        /// </returns>
        /// <exception cref="CommunicationException">Throws CommunicationException if message is bigger than maximum allowed message length.</exception>
        private bool ReadSingleMessage(ICollection<IScsMessage> messages)
        {
            //Go to the begining of the stream
            _receiveMemoryStream.Position = 0;

            //If stream has less than 4 bytes, that means we can not even read length of the message
            //So, return false to wait more bytes from remore application.
            if (_receiveMemoryStream.Length < 4)
            {
                return false;
            }

            //Read length of the message
            var messageLength = ReadInt32(_receiveMemoryStream);
            if (messageLength > MaxMessageLength)
            {
                throw new Exception("Message is too big (" + messageLength + " bytes). Max allowed length is " + MaxMessageLength + " bytes.");
            }

            //If message is zero-length (It must not be but good approach to check it)
            if (messageLength == 0)
            {
                //if no more bytes, return immediately
                if (_receiveMemoryStream.Length == 4)
                {
                    _receiveMemoryStream = new MemoryStream(); //Clear the stream
                    return false;
                }

                //Create a new memory stream from current except first 4-bytes.
                var bytes = _receiveMemoryStream.ToArray();
                _receiveMemoryStream = new MemoryStream();
                _receiveMemoryStream.Write(bytes, 4, bytes.Length - 4);
                return true;
            }

            //If all bytes of the message is not received yet, return to wait more bytes
            if (_receiveMemoryStream.Length < (4 + messageLength))
            {
                _receiveMemoryStream.Position = _receiveMemoryStream.Length;
                return false;
            }

            //Read bytes of serialized message and deserialize it
            var serializedMessageBytes = ReadByteArray(_receiveMemoryStream, messageLength);
            messages.Add(DeserializeMessage(serializedMessageBytes));

            //Read remaining bytes to an array
            var remainingBytes = ReadByteArray(_receiveMemoryStream, (int)(_receiveMemoryStream.Length - (4 + messageLength)));

            //Re-create the receive memory stream and write remaining bytes
            _receiveMemoryStream = new MemoryStream();
            _receiveMemoryStream.Write(remainingBytes, 0, remainingBytes.Length);
            
            //Return true to re-call this method to try to read next message
            return (remainingBytes.Length > 4);
        }

        /// <summary>
        /// Writes a int value to a byte array from a starting index.
        /// </summary>
        /// <param name="buffer">Byte array to write int value</param>
        /// <param name="startIndex">Start index of byte array to write</param>
        /// <param name="number">An integer value to write</param>
        private static void WriteInt32(byte[] buffer, int startIndex, int number)
        {
            buffer[startIndex] = (byte)((number >> 24) & 0xFF);
            buffer[startIndex + 1] = (byte)((number >> 16) & 0xFF);
            buffer[startIndex + 2] = (byte)((number >> 8) & 0xFF);
            buffer[startIndex + 3] = (byte)((number) & 0xFF);
        }

        /// <summary>
        /// Deserializes and returns a serialized integer.
        /// </summary>
        /// <returns>Deserialized integer</returns>
        private static int ReadInt32(Stream stream)
        {
            var buffer = ReadByteArray(stream, 4);
            return ((buffer[0] << 24) |
                    (buffer[1] << 16) |
                    (buffer[2] << 8) |
                    (buffer[3])
                   );
        }

        /// <summary>
        /// Reads a byte array with specified length.
        /// </summary>
        /// <param name="stream">Stream to read from</param>
        /// <param name="length">Length of the byte array to read</param>
        /// <returns>Read byte array</returns>
        /// <exception cref="EndOfStreamException">Throws EndOfStreamException if can not read from stream.</exception>
        private static byte[] ReadByteArray(Stream stream, int length)
        {
            var buffer = new byte[length];
            var totalRead = 0;
            while (totalRead < length)
            {
                var read = stream.Read(buffer, totalRead, length - totalRead);
                if (read <= 0)
                {
                    throw new EndOfStreamException("Can not read from stream! Input stream is closed.");
                }

                totalRead += read;
            }

            return buffer;
        }

        #endregion

        #region Nested classes

        /// <summary>
        /// This class is used in deserializing to allow deserializing objects that are defined
        /// in assemlies that are load in runtime (like PlugIns).
        /// </summary>
        protected sealed class DeserializationAppDomainBinder : SerializationBinder
        {
            public override Type BindToType(string assemblyName, string typeName)
            {
                var toAssemblyName = assemblyName.Split(',')[0];
                return (from assembly in AppDomain.CurrentDomain.GetAssemblies()
                        where assembly.FullName.Split(',')[0] == toAssemblyName
                        select assembly.GetType(typeName)).FirstOrDefault();
            }
        }

        #endregion
    }
}
#endif
// file ...\IO\Scs\Communication\Protocols\BinarySerialization\BinarySerializationProtocolFactory.cs
#if !MOBILE
namespace Zero5.IO.Scs.Communication.Protocols.BinarySerialization
{
    /// <summary>
    /// This class is used to create Binary Serialization Protocol objects.
    /// </summary>
    public class BinarySerializationProtocolFactory : IScsWireProtocolFactory
    {
        /// <summary>
        /// Creates a new Wire Protocol object.
        /// </summary>
        /// <returns>Newly created wire protocol object</returns>
        public IScsWireProtocol CreateWireProtocol()
        {
            return new BinarySerializationProtocol();
        }
    }
}
#endif
// file ...\IO\Scs\Server\IScsServer.cs
#if !MOBILE

namespace Zero5.IO.Scs.Server
{
    /// <summary>
    /// Represents a SCS server that is used to accept and manage client connections.
    /// </summary>
    public interface IScsServer
    {
        /// <summary>
        /// This event is raised when a new client connected to the server.
        /// </summary>
        event EventHandler<ServerClientEventArgs> ClientConnected;

        /// <summary>
        /// This event is raised when a client disconnected from the server.
        /// </summary>
        event EventHandler<ServerClientEventArgs> ClientDisconnected;

        /// <summary>
        /// Gets/sets wire protocol factory to create IWireProtocol objects.
        /// </summary>
        IScsWireProtocolFactory WireProtocolFactory { get; set; }

        /// <summary>
        /// A collection of clients that are connected to the server.
        /// </summary>
        ThreadSafeSortedList<long, IScsServerClient> Clients { get; }
        
        /// <summary>
        /// Starts the server.
        /// </summary>
        void Start();

        /// <summary>
        /// Stops the server.
        /// </summary>
        void Stop();
    }
}
#endif
// file ...\IO\Scs\Server\IScsServerClient.cs
#if !MOBILE

namespace Zero5.IO.Scs.Server
{
    /// <summary>
    /// Represents a client from a perspective of a server.
    /// </summary>
    public interface IScsServerClient : IMessenger
    {
        /// <summary>
        /// This event is raised when client disconnected from server.
        /// </summary>
        event EventHandler Disconnected;
        
        /// <summary>
        /// Unique identifier for this client in server.
        /// </summary>
        long ClientId { get; }

        ///<summary>
        /// Gets endpoint of remote application.
        ///</summary>
        ScsEndPoint RemoteEndPoint { get; }

        /// <summary>
        /// Gets the current communication state.
        /// </summary>
        CommunicationStates CommunicationState { get; }

        /// <summary>
        /// Disconnects from server.
        /// </summary>
        void Disconnect();
    }
}
#endif
// file ...\IO\Scs\Server\ScsServerBase.cs
#if !MOBILE

namespace Zero5.IO.Scs.Server
{
    /// <summary>
    /// This class provides base functionality for server classes.
    /// </summary>
    public abstract class ScsServerBase : IScsServer
    {
        #region Public events

        /// <summary>
        /// This event is raised when a new client is connected.
        /// </summary>
        public event EventHandler<ServerClientEventArgs> ClientConnected;

        /// <summary>
        /// This event is raised when a client disconnected from the server.
        /// </summary>
        public event EventHandler<ServerClientEventArgs> ClientDisconnected;

        #endregion

        #region Public properties

        /// <summary>
        /// Gets/sets wire protocol that is used while reading and writing messages.
        /// </summary>
        public IScsWireProtocolFactory WireProtocolFactory { get; set; }

        /// <summary>
        /// A collection of clients that are connected to the server.
        /// </summary>
        public ThreadSafeSortedList<long, IScsServerClient> Clients { get; private set; }

        #endregion

        #region Private properties

        /// <summary>
        /// This object is used to listen incoming connections.
        /// </summary>
        private IConnectionListener _connectionListener;

        #endregion

        #region Constructor

        /// <summary>
        /// Constructor.
        /// </summary>
        protected ScsServerBase()
        {
            Clients = new ThreadSafeSortedList<long, IScsServerClient>();
            WireProtocolFactory = WireProtocolManager.GetDefaultWireProtocolFactory();
        }

        #endregion

        #region Public methods

        /// <summary>
        /// Starts the server.
        /// </summary>
        public virtual void Start()
        {
            _connectionListener = CreateConnectionListener();
            _connectionListener.CommunicationChannelConnected += ConnectionListener_CommunicationChannelConnected;
            _connectionListener.Start();
        }

        /// <summary>
        /// Stops the server.
        /// </summary>
        public virtual void Stop()
        {
            if (_connectionListener != null)
            {
                _connectionListener.Stop();
            }

            foreach (var client in Clients.GetAllItems())
            {
                client.Disconnect();
            }
        }

        #endregion

        #region Protected abstract methods

        /// <summary>
        /// This method is implemented by derived classes to create appropriate connection listener to listen incoming connection requets.
        /// </summary>
        /// <returns></returns>
        protected abstract IConnectionListener CreateConnectionListener();

        #endregion

        #region Private methods

        /// <summary>
        /// Handles CommunicationChannelConnected event of _connectionListener object.
        /// </summary>
        /// <param name="sender">Source of event</param>
        /// <param name="e">Event arguments</param>
        private void ConnectionListener_CommunicationChannelConnected(object sender, CommunicationChannelEventArgs e)
        {
            var client = new ScsServerClient(e.Channel)
            {
                ClientId = ScsServerManager.GetClientId(),
                WireProtocol = WireProtocolFactory.CreateWireProtocol()
            };

            client.Disconnected += Client_Disconnected;
            Clients[client.ClientId] = client;
            OnClientConnected(client);
            e.Channel.Start();
        }

        /// <summary>
        /// Handles Disconnected events of all connected clients.
        /// </summary>
        /// <param name="sender">Source of event</param>
        /// <param name="e">Event arguments</param>
        private void Client_Disconnected(object sender, EventArgs e)
        {
            var client = (IScsServerClient) sender;
            Clients.Remove(client.ClientId);
            OnClientDisconnected(client);
        }

        #endregion

        #region Event raising methods

        /// <summary>
        /// Raises ClientConnected event.
        /// </summary>
        /// <param name="client">Connected client</param>
        protected virtual void OnClientConnected(IScsServerClient client)
        {
            var handler = ClientConnected;
            if (handler != null)
            {
                handler(this, new ServerClientEventArgs(client));
            }
        }

        /// <summary>
        /// Raises ClientDisconnected event.
        /// </summary>
        /// <param name="client">Disconnected client</param>
        protected virtual void OnClientDisconnected(IScsServerClient client)
        {
            var handler = ClientDisconnected;
            if (handler != null)
            {
                handler(this, new ServerClientEventArgs(client));
            }
        }

        #endregion
    }
}
#endif
// file ...\IO\Scs\Server\ScsServerClient.cs
#if !MOBILE

namespace Zero5.IO.Scs.Server
{
    /// <summary>
    /// This class represents a client in server side.
    /// </summary>
    public class ScsServerClient : IScsServerClient
    {
        #region Public events

        /// <summary>
        /// This event is raised when a new message is received.
        /// </summary>
        public event EventHandler<MessageEventArgs> MessageReceived;

        /// <summary>
        /// This event is raised when a new message is sent without any error.
        /// It does not guaranties that message is properly handled and processed by remote application.
        /// </summary>
        public event EventHandler<MessageEventArgs> MessageSent;

        /// <summary>
        /// This event is raised when client is disconnected from server.
        /// </summary>
        public event EventHandler Disconnected;

        #endregion

        #region Public properties

        /// <summary>
        /// Unique identifier for this client in server.
        /// </summary>
        public long ClientId { get; set; }

        /// <summary>
        /// Gets the communication state of the Client.
        /// </summary>
        public CommunicationStates CommunicationState
        {
            get
            {
                return _communicationChannel.CommunicationState;
            }
        }
        
        /// <summary>
        /// Gets/sets wire protocol that is used while reading and writing messages.
        /// </summary>
        public IScsWireProtocol WireProtocol
        {
            get { return _communicationChannel.WireProtocol; }
            set { _communicationChannel.WireProtocol = value; }
        }

        ///<summary>
        /// Gets endpoint of remote application.
        ///</summary>
        public ScsEndPoint RemoteEndPoint
        {
            get { return _communicationChannel.RemoteEndPoint; }
        }

        /// <summary>
        /// Gets the time of the last succesfully received message.
        /// </summary>
        public DateTime LastReceivedMessageTime
        {
            get
            {
                return _communicationChannel.LastReceivedMessageTime;
            }
        }

        /// <summary>
        /// Gets the time of the last succesfully received message.
        /// </summary>
        public DateTime LastSentMessageTime
        {
            get
            {
                return _communicationChannel.LastSentMessageTime;
            }
        }

        #endregion

        #region Private fields

        /// <summary>
        /// The communication channel that is used by client to send and receive messages.
        /// </summary>
        private readonly ICommunicationChannel _communicationChannel;

        #endregion

        #region Constructor

        /// <summary>
        /// Creates a new ScsClient object.
        /// </summary>
        /// <param name="communicationChannel">The communication channel that is used by client to send and receive messages</param>
        public ScsServerClient(ICommunicationChannel communicationChannel)
        {
            _communicationChannel = communicationChannel;
            _communicationChannel.MessageReceived += CommunicationChannel_MessageReceived;
            _communicationChannel.MessageSent += CommunicationChannel_MessageSent;
            _communicationChannel.Disconnected += CommunicationChannel_Disconnected;
        }

        #endregion

        #region Public methods

        /// <summary>
        /// Disconnects from client and closes underlying communication channel.
        /// </summary>
        public void Disconnect()
        {
            _communicationChannel.Disconnect();
        }

        /// <summary>
        /// Sends a message to the client.
        /// </summary>
        /// <param name="message">Message to be sent</param>
        public void SendMessage(IScsMessage message)
        {
            _communicationChannel.SendMessage(message);
        }

        #endregion

        #region Private methods
        
        /// <summary>
        /// Handles Disconnected event of _communicationChannel object.
        /// </summary>
        /// <param name="sender">Source of event</param>
        /// <param name="e">Event arguments</param>
        private void CommunicationChannel_Disconnected(object sender, EventArgs e)
        {
            OnDisconnected();
        }

        /// <summary>
        /// Handles MessageReceived event of _communicationChannel object.
        /// </summary>
        /// <param name="sender">Source of event</param>
        /// <param name="e">Event arguments</param>
        private void CommunicationChannel_MessageReceived(object sender, MessageEventArgs e)
        {
            var message = e.Message;
            if (message is ScsPingMessage)
            {
                _communicationChannel.SendMessage(new ScsPingMessage { RepliedMessageId = message.MessageId });
                return;
            }

            OnMessageReceived(message);
        }

        /// <summary>
        /// Handles MessageSent event of _communicationChannel object.
        /// </summary>
        /// <param name="sender">Source of event</param>
        /// <param name="e">Event arguments</param>
        private void CommunicationChannel_MessageSent(object sender, MessageEventArgs e)
        {
            OnMessageSent(e.Message);
        }

        #endregion

        #region Event raising methods

        /// <summary>
        /// Raises Disconnected event.
        /// </summary>
        private void OnDisconnected()
        {
            var handler = Disconnected;
            if (handler != null)
            {
                handler(this, EventArgs.Empty);
            }
        }

        /// <summary>
        /// Raises MessageReceived event.
        /// </summary>
        /// <param name="message">Received message</param>
        private void OnMessageReceived(IScsMessage message)
        {
            var handler = MessageReceived;
            if (handler != null)
            {
                handler(this, new MessageEventArgs(message));
            }
        }

        /// <summary>
        /// Raises MessageSent event.
        /// </summary>
        /// <param name="message">Received message</param>
        protected virtual void OnMessageSent(IScsMessage message)
        {
            var handler = MessageSent;
            if (handler != null)
            {
                handler(this, new MessageEventArgs(message));
            }
        }

        #endregion
    }
}
#endif
// file ...\IO\Scs\Server\ScsServerFactory.cs
#if !MOBILE

namespace Zero5.IO.Scs.Server
{
    /// <summary>
    /// This class is used to create SCS servers.
    /// </summary>
    public static class ScsServerFactory
    {
        /// <summary>
        /// Creates a new SCS Server using an EndPoint.
        /// </summary>
        /// <param name="endPoint">Endpoint that represents address of the server</param>
        /// <returns>Created TCP server</returns>
        public static IScsServer CreateServer(ScsEndPoint endPoint)
        {
            return endPoint.CreateServer();
        }
    }
}
#endif
// file ...\IO\Scs\Server\ScsServerManager.cs
#if !MOBILE

namespace Zero5.IO.Scs.Server
{
    /// <summary>
    /// Provides some functionality that are used by servers.
    /// </summary>
    public static class ScsServerManager
    {
        /// <summary>
        /// Used to set an auto incremential unique identifier to clients.
        /// </summary>
        private static long _lastClientId;

        /// <summary>
        /// Gets an unique number to be used as idenfitier of a client.
        /// </summary>
        /// <returns></returns>
        public static long GetClientId()
        {
            return Interlocked.Increment(ref _lastClientId);
        }
    }
}
#endif
// file ...\IO\Scs\Server\ServerClientEventArgs.cs
#if !MOBILE

namespace Zero5.IO.Scs.Server
{
    /// <summary>
    /// Stores client information to be used by an event.
    /// </summary>
    public class ServerClientEventArgs : EventArgs
    {
        /// <summary>
        /// Client that is associated with this event.
        /// </summary>
        public IScsServerClient Client { get; private set; }

        /// <summary>
        /// Creates a new ServerClientEventArgs object.
        /// </summary>
        /// <param name="client">Client that is associated with this event</param>
        public ServerClientEventArgs(IScsServerClient client)
        {
            Client = client;
        }
    }
}
#endif
// file ...\IO\Scs\Server\Tcp\ScsTcpServer.cs
#if !MOBILE

namespace Zero5.IO.Scs.Server.Tcp
{
    /// <summary>
    /// This class is used to create a TCP server.
    /// </summary>
    public class ScsTcpServer : ScsServerBase
    {
        /// <summary>
        /// The endpoint address of the server to listen incoming connections.
        /// </summary>
        private readonly ScsTcpEndPoint _endPoint;

        /// <summary>
        /// Creates a new ScsTcpServer object.
        /// </summary>
        /// <param name="endPoint">The endpoint address of the server to listen incoming connections</param>
        public ScsTcpServer(ScsTcpEndPoint endPoint)
        {
            _endPoint = endPoint;
        }

        /// <summary>
        /// Creates a TCP connection listener.
        /// </summary>
        /// <returns>Created listener object</returns>
        protected override IConnectionListener CreateConnectionListener()
        {
            return new TcpConnectionListener(_endPoint);
        }
    }
}
#endif
// file ...\License\ProductModules.cs

namespace Zero5.License
{
    public enum ProductModules
    {
        // ALLON4 20.000 < x < 64.000
        //AllOn4X_AllOn_5 = 21332,
        //AllOn4X_AllOn_10 = 32343,
        //AllOn4X_AllOn_15 = 23986,
        //AllOn4X_AllOn_20 = 36487,
        //AllOn4X_AllOn_Unlimited = 39746,

        //AllOn4X_AllOnProduzione = 23343,
        //AllOn4X_AllOnLogistica = 53210,
        //AllOn4X_AllOnTracciabilita = 53450,
        //AllOn4X_AllOnProgrammazione = 26548,
        //AllOn4X_AllOnVendite = 28546,
        //AllOn4X_AllOnQualita = 24956,
        //AllOn4X_AllOnStatistiche = 25553,

        //AllOn4X_AllOnCNCLink = 63743,
        //AllOn4X_AllOnSMS = 45334,
        //AllOn4X_AllOnSpy = 34324,
        //AllOn4X_AllOnSkorpio = 29763,
        //AllOn4X_AllOnFrameFlow = 23112,
        //AllOn4X_AllOnCamCounter = 27485,

        //AllOn4X_AllOnAllegati = 43323,
        //AllOn4X_AllOnFocas = 43222,
        //AllOn4X_AllOnNotifiche = 32132,
        //AllOn4X_AllOnScambioDati = 39223,
        //AllOn4X_AllOnMazak = 30292,

        //AllOn4X_AllOnAvanzatoProduzione = 29128,

        // PHASE5 100.000 < x < 200.000
        Phase5_MES_ServerProduzione = 100001,
        Phase5_MES_ServerLogistica = 100002,
        Phase5_MES_ServerProgrammazione = 100003,
        Phase5_MES_ServerQualita = 100004,
        Phase5_MES_ServerManutenzione = 100005,
        //Phase5_MES_SPYIV = 100006,
        Phase5_MES_TTS = 100007,
        //Phase5_MES_Skorpio = 100008,
        //Phase5_MES_FanucFocas = 100009,
        //Phase5_MES_PhaseBoard = 100010,
        //Phase5_MES_Mazak = 100011,
        //Phase5_MES_Trasmissione = 100012,
        Phase5_MES_Desktop = 100013,
        Phase5_MES_PhaseSolo = 100014,
        Phase5_MES_Dispositivi = 100015,

        Phase5_MES_ServerIntegrazioneDati = 100016,
        Phase5_MES_Visualizzazione = 100017,
        Phase5_MES_ServerOneTechnology = 100018,
        //Phase5_RS_Server = 110000,
        //Phase5_RS_Skorpio = 110001,
        //Phase5_RS_FanucFocas = 110002,
        //Phase5_RS_PhaseBoard = 110003,
        //Phase5_RS_Mazak = 110004,

        //Phase5_P6 = 200001

    }
}
// file ...\Performance\StatoDispositivi.cs

namespace Zero5.Performance
{
    public class StatoDispositivi
    {
        public Dictionary<int, RecordStato> Records = new Dictionary<int, RecordStato>();

        public class RecordStato
        {
            public enum eStatoComunicazione
            {
                unknown = 0,
                offline = 1,
                connectionFail = 2, 
                data_fail = 3,
                standBy = 4,
                active = 5
            }

            const int buffLen = 6 * 60 * 60 / 5; // h*m*s/5
            public DateTime IstanteRiferimento;
            public DateTime IstanteUltimo;

            int[] PingRoundTrip = new int[buffLen];
            byte[] StatoComunicazione = new byte[buffLen];
            int[] ByteRicevuti = new int[buffLen];
            int[] ByteInviati = new int[buffLen];
            byte[] InterrogazioniBuone = new byte[buffLen];
            byte[] InterrogazioniFallite = new byte[buffLen];

            public RecordStato()
            {
                IstanteRiferimento = RoundDate5Seconds(DateTime.Now.AddSeconds(1 - buffLen * 5));
                IstanteUltimo = IstanteRiferimento;
            }

            private DateTime RoundDate5Seconds(DateTime dt)
            {
                return new DateTime(dt.Ticks / 50000000 * 50000000);
            }

            private int GetPos(DateTime dt)
            {
                return (int)((new TimeSpan(RoundDate5Seconds(dt).Ticks - IstanteRiferimento.Ticks)).TotalSeconds / 5) % buffLen;
            }

            private void ImpostaValore(int[] array, DateTime dt, int valore, bool incrementa, bool perpetua)
            {
                lock (this)
                {
                    dt = RoundDate5Seconds(dt);
                    for (; ; )
                    {
                        if (dt <= IstanteUltimo) break;
                        IstanteUltimo = IstanteUltimo.AddSeconds(5);
                        int lastpos = GetPos(IstanteUltimo);

                        array[lastpos] = 0;
                        IstanteUltimo = dt;
                    }

                    int pos = GetPos(dt);
                    if (incrementa)
                        array[pos] += valore;
                    else
                        array[pos] = valore;

                    //if (perpetua)
                    //    array[(pos + 1) % buffLen] = array[pos];
                    //else
                    //    array[(pos + 1) % buffLen] = 0;
                }
            }

            private void ImpostaValore(byte[] array, DateTime dt, byte valore, bool incrementa, bool perpetua)
            {
                lock (this)
                {
                    dt = RoundDate5Seconds(dt);
                    for (; ; )
                    {
                        if (dt <= IstanteUltimo) break;
                        IstanteUltimo = IstanteUltimo.AddSeconds(5);
                        int lastpos = GetPos(IstanteUltimo);

                        array[lastpos] = 0;
                        IstanteUltimo = dt;
                    }

                    int pos = GetPos(dt);
                    if (incrementa)
                        array[pos] += valore;
                    else
                        array[pos] = valore;

                    //if (perpetua)
                    //    array[(pos + 1) % buffLen] = array[pos];
                    //else
                    //    array[(pos + 1) % buffLen] = 0;
                }
            }

            public void ImpostaStatoComunicazione(eStatoComunicazione stato)
            {
                ImpostaStatoComunicazione(DateTime.Now, stato);
            }
            public void ImpostaStatoComunicazione(DateTime dt, eStatoComunicazione stato)
            {
                ImpostaValore(StatoComunicazione, dt, (byte)stato, false, true);
            }

            public void ImpostaPingRoundTrip(int pingRoundTripMilliseconds)
            {
                ImpostaPingRoundTrip(DateTime.Now, pingRoundTripMilliseconds);
            }
            public void ImpostaPingRoundTrip(DateTime dt, int pingRoundTripMilliseconds)
            {
                ImpostaValore(PingRoundTrip, dt, pingRoundTripMilliseconds, false, false);
            }

            public void IncrementaContatoreBytesInviati(int byteInviati)
            {
                IncrementaContatoreBytesInviati(DateTime.Now, byteInviati);
            }
            public void IncrementaContatoreBytesInviati(DateTime dt, int byteInviati)
            {
                ImpostaValore(ByteInviati, dt, byteInviati, true, false);
            }
            public void ImpostaContatoreBytesInviati(DateTime dt, int byteInviati)
            {
                ImpostaValore(ByteInviati, dt, byteInviati, false, false);
            }

            public void IncrementaContatoreBytesRicevuti(int byteRicevuti)
            {
                IncrementaContatoreBytesRicevuti(DateTime.Now, byteRicevuti);
            }
            public void IncrementaContatoreBytesRicevuti(DateTime dt, int byteRicevuti)
            {
                ImpostaValore(ByteRicevuti, dt, byteRicevuti, true, false);
            }
            public void ImpostaContatoreBytesRicevuti(DateTime dt, int byteRicevuti)
            {
                ImpostaValore(ByteRicevuti, dt, byteRicevuti, false, false);
            }

            public void IncrementaInterrogazioniBuone(byte interrogazioni)
            {
                IncrementaInterrogazioniBuone(DateTime.Now, interrogazioni);
            }
            public void IncrementaInterrogazioniBuone(DateTime dt, byte interrogazioni)
            {
                ImpostaValore(InterrogazioniBuone, dt, interrogazioni, true, false);
            }
            public void ImpostaInterrogazioniBuone(DateTime dt, byte interrogazioni)
            {
                ImpostaValore(InterrogazioniBuone, dt, interrogazioni, false, false);
            }

            public void IncrementaInterrogazioniFallite(byte interrogazioni)
            {
                IncrementaInterrogazioniFallite(DateTime.Now, interrogazioni);
            }
            public void IncrementaInterrogazioniFallite(DateTime dt, byte interrogazioni)
            {
                ImpostaValore(InterrogazioniFallite, dt, interrogazioni, true, false);
            }
            public void ImpostaInterrogazioniFallite(DateTime dt, byte interrogazioni)
            {
                ImpostaValore(InterrogazioniFallite, dt, interrogazioni, false, false);
            }

            public object[][] GetLastData(DateTime dt, int records)
            {
                lock (this)
                {
                    dt = RoundDate5Seconds(dt);

                    object[][] data = new object[records][];

                    for (int i = 0; i < records; i++)
                    {
                        DateTime dtRef = dt.AddSeconds(-5 * i);

                        data[i] = new object[7];
                        int iPos = GetPos(dtRef);

                        data[i][0] = dtRef;
                        data[i][1] = PingRoundTrip[iPos];
                        data[i][2] = StatoComunicazione[iPos];
                        data[i][3] = ByteRicevuti[iPos];
                        data[i][4] = ByteInviati[iPos];
                        data[i][5] = InterrogazioniBuone[iPos];
                        data[i][6] = InterrogazioniFallite[iPos];
                    }

                    return data;
                }
            }
        }
    }

}
// file ...\Performance\StopWatch.cs

namespace Zero5.Performance
{
    class StopWatch :
        IDisposable
    {
        private DateTime dtStart;
        public string Name;
        private int MilliSecondLimit;
        private string LogFileName;

        public StopWatch(string name, int milliSecondLimit)
            : this(name, milliSecondLimit, "")
        { }

        public StopWatch(string name, int milliSecondLimit, string logfilename)
        {
            this.Name = name;
            this.MilliSecondLimit = milliSecondLimit;
            this.dtStart = DateTime.Now;
            this.LogFileName = logfilename;
        }

        public long TicksElapsed
        {
            get { return DateTime.Now.Ticks - dtStart.Ticks; }
        }

        public double SecondsElapsed
        {
            get { return (DateTime.Now - dtStart).TotalSeconds; }
        }

        public void Dispose()
        {
            double seconds = TimeSpan.FromTicks(DateTime.Now.Ticks - dtStart.Ticks).TotalSeconds;
            if (seconds * 1000 > this.MilliSecondLimit)
            {
                //System.Diagnostics.Debug.WriteLine("StopWatch Limit on " + this.Name + " with " + seconds.ToString("0.000") + "s");
                if (LogFileName == "")
                    Zero5.Util.Log.WriteLog("StopWatch Limit with " + seconds.ToString("0.000") + "s on " + this.Name);
                else
                    Zero5.Util.Log.WriteLog(LogFileName, "StopWatch Limit with " + seconds.ToString("0.000") + "s on " + this.Name);
            }
        }
    }
}
// file ...\Performance\Trace.cs

namespace Zero5.Performance
{
    class Trace : IDisposable
    {
        private string LogMessage;
        private string LogFileName;
        private DateTime dtStart;
        private static CommonLibrary.FileConfigurazione FileConfigurazione = new CommonLibrary.FileConfigurazione();

        public Trace(string logfilename, string logMessage)
        {
            this.LogMessage = logMessage;
            this.LogFileName = logfilename;
            this.dtStart = DateTime.Now;

            if (FileConfigurazione.AbilitaTrace)
            {
                if (LogFileName == "")
                    Zero5.Util.Log.WriteLog("1 " + this.LogMessage);
                else
                    Zero5.Util.Log.WriteLog(LogFileName, "1 " + this.LogMessage);
            }
        }

        public void Dispose()
        {
            if (FileConfigurazione.AbilitaTrace)
            {
                TimeSpan ts = TimeSpan.FromTicks(DateTime.Now.Ticks - dtStart.Ticks);
                string tempo = (ts.Hours * 60 + ts.Minutes).ToString("00") + ":" + ts.Seconds.ToString("00") + "." + ts.Milliseconds.ToString("0000");
                if (LogFileName == "")
                    Zero5.Util.Log.WriteLog("2 " + this.LogMessage + " T " + tempo);
                else
                    Zero5.Util.Log.WriteLog(LogFileName, "2 " + this.LogMessage + " T " + tempo);
            }
        }
    }
}
// file ...\Printing\Intermec.cs

namespace Zero5.Printing
{
    class Intermec
    {
#if !MOBILE && !CORE
        //Example Zero5.Printing.Zebra.SendImageLabelToNetworkPrinter(new System.Drawing.Bitmap("C:\\Untitled.png"), "10.20.30.65", 9100);

        public static void SendImageLabelToNetworkPrinter(System.Drawing.Bitmap bmp, string ipAddress, int port, long byteLenght)
        {
            SendImageLabelToNetworkPrinter(bmp, new System.Net.IPEndPoint(System.Net.IPAddress.Parse(ipAddress), port), byteLenght);
        }

        public static void SendImageLabelToNetworkPrinter(System.Drawing.Bitmap bmp, System.Net.IPEndPoint endPoint, long byteLenght)
        {
            System.Net.Sockets.TcpClient client = new System.Net.Sockets.TcpClient();
            client.Connect(endPoint);

            byte[] data = System.Text.ASCIIEncoding.ASCII.GetBytes(CreateImageLabel(bmp, byteLenght));

            client.GetStream().Write(data, 0, data.Length);

            client.Close();
        }

        public static string CreateImageLabel(System.Drawing.Bitmap bmp, long byteLenght)
        {
            return CreateImageLabel(0, 0, bmp, byteLenght);
        }

        public static string CreateImageLabel(int imagePosX, int imagePosY, System.Drawing.Bitmap bmp, long byteLenght)
        {
            return "CLL:PP 64,57:PRBUF " + byteLenght + " @" + CreateRLLFormat(bmp) + " PRINTFEED";
        }

        public static string CreateRLLFormat(System.Drawing.Bitmap bmp)
        {
            System.Drawing.Imaging.BitmapData imgData = null;
            System.Text.StringBuilder sb = new StringBuilder();
            System.Text.StringBuilder sbLine = new StringBuilder();

            int x = 0;
            int y = 0;
            int width = 0;

            string lineaPrecedente = "";
            int counterLineeUguali = 1;
            try
            {
                for (y = 0; y < bmp.Height; y++)
                {
                    string binario = "";
                    for (x = bmp.Width - 1; x >= 0; x--)
                    {
                        if (bmp.GetPixel(x, y).Name == "ffffffff")
                            binario += "0";
                        else
                            binario += "1";
                    }
                    sbLine.Clear();
                    bool chkCercaZero = true;
                    bool chkCercaUno = false;
                    while (binario.Length > 0)
                    {
                        if (chkCercaZero)
                            CercaZero(ref sbLine, ref binario, ref chkCercaZero, ref chkCercaUno);
                        if (chkCercaUno)
                            CercaUno(ref sbLine, ref binario, ref chkCercaZero, ref chkCercaUno);
                        if (chkCercaZero)
                            CercaZero(ref sbLine, ref binario, ref chkCercaZero, ref chkCercaUno);
                    }
                    sbLine.Remove(sbLine.Length - 1, 1);

                    if (sbLine.ToString() == lineaPrecedente)
                        counterLineeUguali++;
                    else
                    {
                        if (counterLineeUguali > 1 || counterLineeUguali == 128)
                        {
                            string lineaTemp = "-" + counterLineeUguali.ToString() + ",";
                            lineaTemp += lineaPrecedente.ToString() + ",-" + counterLineeUguali.ToString();
                            sb.AppendLine(lineaTemp);
                            counterLineeUguali = 1;
                        }
                        sb.AppendLine(sbLine.ToString());
                    }
                    lineaPrecedente = sbLine.ToString();
                }

                if (counterLineeUguali == y)
                {
                    sb.Clear();
                    while (counterLineeUguali > 128)
                    {
                        string lineaTemp = "-128,";
                        lineaTemp += lineaPrecedente.ToString() + ",-128";
                        sb.AppendLine(lineaTemp);
                        counterLineeUguali -= 128;
                    }
                    sb.AppendLine("-" + counterLineeUguali.ToString() + "," + lineaPrecedente.ToString() + ",-" + counterLineeUguali.ToString());
                }
            }
            finally
            {
                if (bmp != null)
                {
                    if (imgData != null) bmp.UnlockBits(imgData);
                    //bmp.Dispose();
                }
            }

            return sb.ToString();
        }

        private static int ContaOccorrenze(char carattereDaRicercare, string stringa)
        {
            int result = 0;

            foreach (char c in stringa)
            {
                if (c == carattereDaRicercare)
                    result++;
                else
                    break;
            }
            return result;
        }

        private static void CercaZero(ref StringBuilder sbLine, ref string binario, ref bool chkCercaZero, ref bool chkCercaUno)
        {
            int resultCercaZero = ContaOccorrenze('0', binario);
            while (resultCercaZero > 255)
            {
                sbLine.Append("255,0,");
                resultCercaZero = ContaOccorrenze('0', binario);
                if (resultCercaZero > 255)
                    binario = binario.Substring(255);

                resultCercaZero = ContaOccorrenze('0', binario);
            }

            sbLine.Append(resultCercaZero.ToString() + ",");
            binario = binario.Substring(resultCercaZero);

            chkCercaZero = false;
            chkCercaUno = true;
        }

        private static void CercaUno(ref StringBuilder sbLine, ref string binario, ref bool chkCercaZero, ref bool chkCercaUno)
        {
            int resultCercaUno = ContaOccorrenze('1', binario);
            while (resultCercaUno > 255)
            {
                sbLine.Append("255,0,");
                resultCercaUno = ContaOccorrenze('1', binario);
                if (resultCercaUno > 255)
                    binario = binario.Substring(255);

                resultCercaUno = ContaOccorrenze('1', binario);
            }

            sbLine.Append(resultCercaUno.ToString() + ",");
            binario = binario.Substring(resultCercaUno);

            chkCercaZero = true;
            chkCercaUno = false;
        }
#endif
    }
}
// file ...\Printing\Zebra.cs

namespace Zero5.Printing
{
    class Zebra
    {
#if !MOBILE && !CORE
        //Example Zero5.Printing.Zebra.SendImageLabelToNetworkPrinter(new System.Drawing.Bitmap("C:\\Untitled.png"), "10.20.30.65", 9100);

        public static void SendImageLabelToNetworkPrinter(System.Drawing.Bitmap bmp, string ipAddress, int port, int printSpeed, int printDarkness, string streamPrefix)
        {
            SendImageLabelToNetworkPrinter(bmp, new System.Net.IPEndPoint(System.Net.IPAddress.Parse(ipAddress), port), printSpeed, printDarkness, streamPrefix);
        }

        public static void SendImageLabelToNetworkPrinter(System.Drawing.Bitmap bmp, System.Net.IPEndPoint endPoint, int printSpeed, int printDarkness, string streamPrefix)
        {
            System.Net.Sockets.TcpClient client = new System.Net.Sockets.TcpClient();
            client.Connect(endPoint);

            byte[] data = System.Text.ASCIIEncoding.ASCII.GetBytes(CreateImageLabel(0, 0, bmp, printSpeed, printDarkness, streamPrefix));

            client.GetStream().Write(data, 0, data.Length);

            client.Close();
        }

        public static string CreateImageLabel(System.Drawing.Bitmap bmp)
        {
            return CreateImageLabel(0, 0, bmp, 0, 0, "");
        }

        public static string CreateImageLabel(int imagePosX, int imagePosY, System.Drawing.Bitmap bmp, int printSpeed, int printDarkness, string streamPrefix)
        {
            string result = "^XA";
            if (printSpeed >= 2)
            {
                if (printSpeed > 12) printSpeed = 12;
                result += "^PR" + printSpeed.ToString() + "," + printSpeed.ToString() + "," + printSpeed.ToString();
            }
            result += "^FO" + imagePosX.ToString() + "," + imagePosY.ToString();

            if (printDarkness > 30) printDarkness = 30;
            if (printDarkness > 0) result += "~SD" + printDarkness.ToString("00");

            if (streamPrefix.Length > 0)
                result = streamPrefix + result;

            return result + CreateGRF(bmp, "") + " ^XZ";
        }

        public static string CreateGRF(System.Drawing.Bitmap bmp, string imageNameToStore)
        {
            System.Drawing.Imaging.BitmapData imgData = null;
            System.Text.StringBuilder sb = null;
            int x = 0;
            int y = 0;
            int width = 0;

            try
            {

                imgData = bmp.LockBits(new System.Drawing.Rectangle(0, 0, bmp.Width, bmp.Height), System.Drawing.Imaging.ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format1bppIndexed);

                width = (bmp.Width + 7) / 8;
                byte[] pixels = new byte[width];

                sb = new System.Text.StringBuilder(width * bmp.Height * 2);
                System.Text.StringBuilder sbLine = new System.Text.StringBuilder(width * 2);
                IntPtr ptr = imgData.Scan0;

                string lastLine = "";
                string currLine = "";

                for (y = 0; y < bmp.Height; y++)
                {
                    System.Runtime.InteropServices.Marshal.Copy(ptr, pixels, 0, width);

                    sbLine.Clear();
                    for (x = 0; x < width - 1; x++)
                    {
                        sbLine.AppendFormat("{0:X2}", (byte)~pixels[x]);
                    }
                    sbLine.AppendFormat("{0:X2}", 0);

                    currLine = sbLine.ToString();

                    if (lastLine == currLine)
                    {
                        sb.Append(":");
                    }
                    else
                    {
                        char lastChar = currLine[0];
                        char currChar = ' ';
                        int count = 0;
                        for (int c = 1; c < currLine.Length; c++)
                        {
                            currChar = currLine[c];
                            count++;

                            if (lastChar != currChar)
                            {
                                if (count > 1)
                                {
                                    if (count > 400) sb.Append(new string('z', (count / 400)));
                                    if (count >= 20) sb.Append((char)(((byte)'f') + (count / 20)));
                                    if (count % 20 != 0) sb.Append((char)(((byte)'F') + (count % 20)));
                                }
                                sb.Append(lastChar);
                                lastChar = currChar;
                                count = 0;
                            }

                        }

                        if (lastChar == '0')
                        {
                            sb.Append(",");
                        }
                        else
                        {
                            if (count > 1)
                            {
                                if (count > 400) sb.Append(new string('z', (count / 400)));
                                if (count >= 20) sb.Append((char)(((byte)'f') + (count / 20)));
                                if (count % 20 != 0) sb.Append((char)(((byte)'F') + (count % 20)));
                            }
                            sb.Append(lastChar);
                        }
                    }

                    lastLine = currLine;

                    ptr = (IntPtr)(ptr.ToInt64() + imgData.Stride);
                }
            }
            finally
            {
                if (bmp != null)
                {
                    if (imgData != null) bmp.UnlockBits(imgData);
                    //bmp.Dispose();
                }
            }

            if (imageNameToStore == "")
                return String.Format("^GFA,{0},{1},{2},", width * y, width * y, width) + sb.ToString();
            else
                return String.Format("~DG{0}.GRF,{1},{2},", imageNameToStore, width * y, width) + sb.ToString();
        }
#endif
    }
}

// file ...\Process\Impersonator.cs
#if !MOBILE && !CORE
#if !CORE

namespace Zero5.Process
{
    #region Using directives.
    // ----------------------------------------------------------------------

    using System;
    using System.Security.Principal;
    using System.Runtime.InteropServices;
    using System.ComponentModel;

    // ----------------------------------------------------------------------
    #endregion

    /////////////////////////////////////////////////////////////////////////

    /// <summary>
    /// Impersonation of a user. Allows to execute code under another
    /// user context.
    /// Please note that the account that instantiates the Impersonator class
    /// needs to have the 'Act as part of operating system' privilege set.
    /// </summary>
    /// <remarks>	
    /// This class is based on the information in the Microsoft knowledge base
    /// article http://support.microsoft.com/default.aspx?scid=kb;en-us;Q306158
    /// 
    /// Encapsulate an instance into a using-directive like e.g.:
    /// 
    ///		...
    ///		using ( new Impersonator( "myUsername", "myDomainname", "myPassword" ) )
    ///		{
    ///			...
    ///			[code that executes under the new context]
    ///			...
    ///		}
    ///		...
    /// 
    /// Please contact the author Uwe Keim (mailto:uwe.keim@zeta-software.de)
    /// for questions regarding this class.
    /// </remarks>
    public class Impersonator :
        IDisposable
    {
        #region Public methods.
        // ------------------------------------------------------------------

        /// <summary>
        /// Constructor. Starts the impersonation with the given credentials.
        /// Please note that the account that instantiates the Impersonator class
        /// needs to have the 'Act as part of operating system' privilege set.
        /// </summary>
        /// <param name="userName">The name of the user to act as.</param>
        /// <param name="domainName">The domain name of the user to act as.</param>
        /// <param name="password">The password of the user to act as.</param>
        public Impersonator(
            string userName,
            string domainName,
            string password)
        {
            ImpersonateValidUser(userName, domainName, password);
        }

        // ------------------------------------------------------------------
        #endregion

        #region IDisposable member.
        // ------------------------------------------------------------------

        public void Dispose()
        {
            UndoImpersonation();
        }

        // ------------------------------------------------------------------
        #endregion

        #region P/Invoke.
        // ------------------------------------------------------------------

        [DllImport("advapi32.dll", SetLastError = true)]
        private static extern int LogonUser(
            string lpszUserName,
            string lpszDomain,
            string lpszPassword,
            int dwLogonType,
            int dwLogonProvider,
            ref IntPtr phToken);

        [DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern int DuplicateToken(
            IntPtr hToken,
            int impersonationLevel,
            ref IntPtr hNewToken);

        [DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern bool RevertToSelf();

        [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
        private static extern bool CloseHandle(
            IntPtr handle);

        private const int LOGON32_LOGON_INTERACTIVE = 2;
        private const int LOGON32_PROVIDER_DEFAULT = 0;

        // ------------------------------------------------------------------
        #endregion

        #region Private member.
        // ------------------------------------------------------------------

        /// <summary>
        /// Does the actual impersonation.
        /// </summary>
        /// <param name="userName">The name of the user to act as.</param>
        /// <param name="domainName">The domain name of the user to act as.</param>
        /// <param name="password">The password of the user to act as.</param>
        private void ImpersonateValidUser(
            string userName,
            string domain,
            string password)
        {
            WindowsIdentity tempWindowsIdentity = null;
            IntPtr token = IntPtr.Zero;
            IntPtr tokenDuplicate = IntPtr.Zero;

            try
            {
                if (RevertToSelf())
                {
                    if (LogonUser(
                        userName,
                        domain,
                        password,
                        LOGON32_LOGON_INTERACTIVE,
                        LOGON32_PROVIDER_DEFAULT,
                        ref token) != 0)
                    {
                        if (DuplicateToken(token, 2, ref tokenDuplicate) != 0)
                        {
                            tempWindowsIdentity = new WindowsIdentity(tokenDuplicate);
                            impersonationContext = tempWindowsIdentity.Impersonate();
                        }
                        else
                        {
                            throw new Win32Exception(Marshal.GetLastWin32Error());
                        }
                    }
                    else
                    {
                        throw new Win32Exception(Marshal.GetLastWin32Error());
                    }
                }
                else
                {
                    throw new Win32Exception(Marshal.GetLastWin32Error());
                }
            }
            finally
            {
                if (token != IntPtr.Zero)
                {
                    CloseHandle(token);
                }
                if (tokenDuplicate != IntPtr.Zero)
                {
                    CloseHandle(tokenDuplicate);
                }
            }
        }

        /// <summary>
        /// Reverts the impersonation.
        /// </summary>
        private void UndoImpersonation()
        {
            if (impersonationContext != null)
            {
                impersonationContext.Undo();
            }
        }

        private WindowsImpersonationContext impersonationContext = null;

        // ------------------------------------------------------------------
        #endregion
    }

    /////////////////////////////////////////////////////////////////////////
}
#endif
#endif
// file ...\RFID\Tag125InsertModel.cs
#if !CORE

namespace Zero5.RFID
{
    class Tag125InsertModel : TagAsyncSerialReader
    {

        public Tag125InsertModel(string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits, System.IO.Ports.StopBits stopBits)
            : base(portName, baudRate, parity, dataBits, stopBits)
        { }

        public delegate void TagInsertedHandler(string tag);
        public event TagInsertedHandler TagInserted;
        public delegate void TagRemovedHandler(string tag);
        public event TagRemovedHandler TagRemoved;
        public delegate void TagBeepedHandler(string tag);
        public event TagBeepedHandler TagBeeped;

        private string currentActiveTag = "";
        private int currentActiveTagCounterToConfirm = 0;
        private string currentConfirmedTag = "";

        protected override byte[] ManageProtocol(byte receivedByte, byte[] currentBuffer)
        {
            byte[] newBuffer = new byte[currentBuffer.Length + 1];
            currentBuffer.CopyTo(newBuffer, 0);
            newBuffer[newBuffer.Length - 1] = receivedByte;

            if (newBuffer.Length == 2)
                if (newBuffer[0] == 0xFF && newBuffer[1] == 0x01) // tag removed
                {
                    if (currentConfirmedTag != "")
                    {
                        if (TagRemoved != null) TagRemoved(currentConfirmedTag);
                        currentConfirmedTag = "";
                        currentActiveTag = "";
                        currentActiveTagCounterToConfirm = 0;
                    }
                    else
                        if (currentActiveTag != "")
                        {
                            if (TagBeeped != null) TagBeeped(currentActiveTag);
                            currentActiveTag = "";
                            currentActiveTagCounterToConfirm = 0;
                        }

                    newBuffer = new byte[0];
                }

            if (newBuffer.Length == 7)
            {
                if (newBuffer[0] == 0x00) // status
                {
                    string tag = "";
                    for (int i = 1; i < 6; i++)
                    {
                        tag += newBuffer[i].ToString("X2"); //HEX
                    }
                    if (CheckSumBCC(newBuffer, 0, 6) == newBuffer[6])
                    {
                        if (currentActiveTag == tag) //già impostato
                        {
                            currentActiveTagCounterToConfirm++;
                        }
                        currentActiveTag = tag;
                    }
                    if (currentActiveTagCounterToConfirm > 2)
                    {
                        if (currentConfirmedTag != currentActiveTag)
                        {
                            if (TagInserted != null) TagInserted(currentActiveTag);
                        }
                        currentConfirmedTag = currentActiveTag;
                    }
                }
                newBuffer = new byte[0];
            }

            return newBuffer;
        }

        private byte CheckSumBCC(byte[] data, int index, int lenght)
        {
            int bcc = 0;
            for (int i = index; i < lenght - index; i++)
            {
                bcc += data[i];
            }
            return (byte)(256 - (bcc % 256));
        }



    }
}
#endif
// file ...\RFID\TagAsyncSerialReader.cs
#if !CORE

namespace Zero5.RFID
{
    class TagAsyncSerialReader
    {
        private System.IO.Ports.SerialPort serialPort;
        public TagAsyncSerialReader(string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits, System.IO.Ports.StopBits stopBits)
        {
            serialPort = new System.IO.Ports.SerialPort(portName, baudRate, parity, dataBits, stopBits);
        }

        public void Activate()
        {
            Deactivate();
            System.Threading.Thread thWorker = new System.Threading.Thread(new System.Threading.ThreadStart(thWorkerMethod));
            thWorker.Start();
        }

        public void Deactivate()
        {
            if (thWorker != null) thWorker.Abort();
        }

        public delegate void ErrorHandler(Exception ex);
        public event ErrorHandler Error;

        public delegate void DataReceivedHandler(byte[] data);
        public event DataReceivedHandler DataReceived;

        System.Threading.Thread thWorker;
        private void thWorkerMethod()
        {
            try
            {
                byte[] buffer = new byte[0];
                for (;;)
                {
                    try
                    {
                        if (!serialPort.IsOpen) serialPort.Open();

                        if (serialPort.BytesToRead > 0)
                        {
                            buffer = ManageProtocol((byte)serialPort.ReadByte(), buffer);
                        }
                    }
                    catch (Exception exManaged)
                    {
                        if (Error != null) Error(exManaged);
                        System.Threading.Thread.Sleep(1000);
                    }
                }
            }
            catch (Exception ex)
            {
                //ignore thread exception                
            }
        }

        protected virtual byte[] ManageProtocol(byte receivedByte, byte[] currentBuffer)
        {
            byte[] newBuffer = new byte[currentBuffer.Length + 1];
            currentBuffer.CopyTo(newBuffer, 0);
            newBuffer[newBuffer.Length - 1] = receivedByte;

            if (newBuffer.Length > 1)
                if (newBuffer[currentBuffer.Length - 2] == '\r' && newBuffer[currentBuffer.Length - 1] == '\n')
                {
                    if (DataReceived != null) DataReceived(newBuffer);
                    newBuffer = new byte[0];
                }

            return newBuffer;
        }
    }
}
#endif
// file ...\Services\ServiceInstaller.cs

namespace Zero5.Services
{
#if SERVICE
    public partial class ServiceInstaller : System.Configuration.Install.Installer
    {       
        private System.ServiceProcess.ServiceProcessInstaller serviceProcessInstaller1;
        private System.ServiceProcess.ServiceInstaller serviceInstaller;
     
        public ServiceInstaller(string serviceName)
        {
            this.serviceProcessInstaller1 = new System.ServiceProcess.ServiceProcessInstaller();
            this.serviceInstaller = new System.ServiceProcess.ServiceInstaller();

            this.serviceProcessInstaller1.Account = System.ServiceProcess.ServiceAccount.LocalSystem;
            this.serviceProcessInstaller1.Password = null;
            this.serviceProcessInstaller1.Username = null;

            this.serviceInstaller.Description = serviceName;
            this.serviceInstaller.DisplayName = serviceName;
            this.serviceInstaller.ServiceName = serviceName;

            this.serviceInstaller.StartType = System.ServiceProcess.ServiceStartMode.Automatic;
            
            this.Installers.AddRange(new System.Configuration.Install.Installer[] {this.serviceProcessInstaller1, this.serviceInstaller});

        }
    }
#endif
}
// file ...\Services\ServiceManager.cs
#if SERVICE

namespace Zero5.Services
{
    public enum ServiceManagerCommand
    {
        Unknown,
        Application,
        Install,
        UnInstall,
        Start,
        Stop,
        Setup
    }
 
    public class ServiceManager
    {
        private string _serviceName;

        public string ServiceName
        {
            get { return _serviceName; }
            set { _serviceName = value; }
        }

        public ServiceManager(string serviceName)
        {
            _serviceName = serviceName;
        }

        public Dictionary<string, Zero5.Services.ServiceManagerCommand> GetStandardCommandList()
        {
            Dictionary<string, Zero5.Services.ServiceManagerCommand> commands = new Dictionary<string,ServiceManagerCommand>();

            commands.Add("-setup", ServiceManagerCommand.Application);
            commands.Add("-process", ServiceManagerCommand.Application);
            commands.Add("-p", ServiceManagerCommand.Application);
            commands.Add("-install", ServiceManagerCommand.Install);
            commands.Add("-i", ServiceManagerCommand.Install);
            commands.Add("-uninstall", ServiceManagerCommand.UnInstall);
            commands.Add("-u", ServiceManagerCommand.UnInstall);
            commands.Add("-start", ServiceManagerCommand.Start);
            commands.Add("-stop", ServiceManagerCommand.Stop);

            return commands;
        }

        public bool TryParseCommandLine(string[] args, Dictionary<string, Zero5.Services.ServiceManagerCommand> commands, out Zero5.Services.ServiceManagerCommand command)
        {
            command = Zero5.Services.ServiceManagerCommand.Unknown;
            if (args.Length > 1)
                return false;
            string commandLineArg = args[0];
            if (commands.ContainsKey(commandLineArg))
            {
                command = commands[commandLineArg];
                return true;
            }
            return false;
        }


        public void RunCommand(ServiceManagerCommand command)
        {
            switch (command)
            {
                case ServiceManagerCommand.Application:
                    break;
                case ServiceManagerCommand.Install:
                    this.InstallService();
                    break;
                case ServiceManagerCommand.UnInstall:
                    this.UninstallService();
                    break;
                case ServiceManagerCommand.Start:
                    this.StartService();
                    break;
                case ServiceManagerCommand.Stop:
                    Zero5.Threading.ProcessMutex pmx = new Zero5.Threading.ProcessMutex(this._serviceName);
                    if (pmx.Open())
                    {
                        pmx.LockAndUnLock(500);
                        pmx.Close();
                    }
                    this.StopService();
                    break;
                default:
                    break;
            }
        }
 
        public virtual bool IsServiceInstalled()
        {
            using (System.ServiceProcess.ServiceController serviceController = new System.ServiceProcess.ServiceController(_serviceName))
            {
                try
                {
                    System.ServiceProcess.ServiceControllerStatus status = serviceController.Status;
                }
                catch (InvalidOperationException)
                {
                    return false;
                }
                catch (Exception ex)
                {
                    EventLog.WriteEntry("ServiceManager", ex.ToString(), EventLogEntryType.Error);
                    return false;
                }
                return true;
            }
        }
 
        public bool IsServiceRunning()
        {
            using (System.ServiceProcess.ServiceController serviceController = new System.ServiceProcess.ServiceController(_serviceName))
            {
                if (!IsServiceInstalled()) return false;
                return (serviceController.Status == System.ServiceProcess.ServiceControllerStatus.Running);
            }
        }
 
        protected virtual void InstallService()
        {
            if (IsServiceInstalled())
                return;
            try
            {
                string[] commandLine = new string[1];
                //commandLine[0] = "Test install";
                IDictionary mySavedState = new Hashtable();
                System.Configuration.Install.AssemblyInstaller installer = GetAssemblyInstaller(commandLine);
                try
                {
                    installer.Install(mySavedState);
                    installer.Commit(mySavedState);
                }
                catch (Exception ex)
                {
                    installer.Rollback(mySavedState);
                    EventLog.WriteEntry("ServiceManager", 
                                        ex.ToString(), EventLogEntryType.Error);
                }
            }
            catch (Exception ex)
            {
                EventLog.WriteEntry("ServiceManager", ex.ToString());
            }
        }

        private System.Configuration.Install.AssemblyInstaller GetAssemblyInstaller(string[] commandLine)
        {
            //AssemblyInstaller installer = new AssemblyInstaller();
            //installer.Path = Environment.GetCommandLineArgs()[0];
            //installer.CommandLine = commandLine;

            System.Configuration.Install.AssemblyInstaller installer =
                new System.Configuration.Install.AssemblyInstaller(System.Reflection.Assembly.GetEntryAssembly(), null);

            installer.UseNewContext = true;
            return installer;
        }
 
        protected virtual void UninstallService()
        {
            if (!IsServiceInstalled())
                return;

            string[] commandLine = new string[1];
            //commandLine[0] = "Test install";
            IDictionary mySavedState = new Hashtable();
            mySavedState.Clear();
                
            System.Configuration.Install.AssemblyInstaller installer = GetAssemblyInstaller(commandLine);            
            try
            {
                installer.Uninstall(mySavedState);
            }
            catch (Exception ex)
            {
                EventLog.WriteEntry("ServiceManager", 
                                    ex.ToString(), EventLogEntryType.Error);
            }
        }
 
        protected virtual void StartService()
        {
            if (!IsServiceInstalled())
                return;
            using (System.ServiceProcess.ServiceController serviceController = new System.ServiceProcess.ServiceController(_serviceName))
            {
                if (serviceController.Status == System.ServiceProcess.ServiceControllerStatus.Stopped)
                {
                    try
                    {
                        serviceController.Start();
                        WaitForStatusChange(serviceController, System.ServiceProcess.ServiceControllerStatus.Running);
                    }
                    catch (InvalidOperationException ex)
                    {
                        EventLog.WriteEntry("ServiceManager",
                                            ex.ToString(), EventLogEntryType.Error);
                    }
                }
            }
        }
 
        protected virtual void StopService()
        {
            if (!IsServiceInstalled())
                return;
            using (System.ServiceProcess.ServiceController serviceController = new System.ServiceProcess.ServiceController(_serviceName))
            {
                if (serviceController.Status != System.ServiceProcess.ServiceControllerStatus.Running)
                    return;
                serviceController.Stop();
                WaitForStatusChange(serviceController, System.ServiceProcess.ServiceControllerStatus.Stopped);
            }
        }

        private static void WaitForStatusChange(System.ServiceProcess.ServiceController serviceController,
                                                System.ServiceProcess.ServiceControllerStatus newStatus)
        {
            int count = 0;
            while (serviceController.Status != newStatus && count < 30)
            {
                Thread.Sleep(1000);
                serviceController.Refresh();
                count++;
            }
            if (serviceController.Status != newStatus)
            {
                throw new Exception("Failed to change status of service. New status: " + newStatus);
            }
        }
    }
}
    
#endif
// file ...\Services\ServiceServer.cs

namespace Zero5.Services
{
#if SERVICE
    partial class ServiceServer : System.ServiceProcess.ServiceBase
    {
        public ServiceServer(string serviceName)
        {
            InitializeComponent();
            this.ServiceName = serviceName;
        }

        protected override void OnStart(string[] args)
        {
            StartServiceServer();
        }

        protected override void OnStop()
        {
            StopServiceServer();
        }

        public virtual void StartServiceServer()
        { }

        public virtual void StopServiceServer()
        { }
        
        public void RunAsApplication()
        {

            Zero5.Util.Log.WriteLog("Start App Mode");

            try
            {

                Zero5.Threading.ProcessMutex pmx = new Zero5.Threading.ProcessMutex(this.ServiceName);
                if (pmx.Exist())
                {
                    Zero5.Util.Log.WriteLog("Double Instance, closing.");
                    return;
                }
                pmx.Create();

                this.StartServiceServer();

                try
                {
                    while (true)
                        if (!pmx.LockAndUnLock(100)) break;
                }
                catch (Exception exW)
                {
                    Zero5.Util.Log.WriteLog("Wait Error: " + exW.Message.ToString());
                }

                this.StopServiceServer();

                pmx.Close();
            }
            catch (Exception ex)
            {
                Zero5.Util.Log.WriteLog(ex.ToString());
            }

            Zero5.Util.Log.WriteLog("Stop App Mode");
        }

    }
#endif
}
// file ...\Services\ServiceServer.designer.cs
namespace Zero5.Services 
{
#if SERVICE
    partial class ServiceServer 
    {
        /// <summary> 
        /// Variabile di progettazione necessaria.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Liberare le risorse in uso.
        /// </summary>
        /// <param name="disposing">ha valore true se le risorse gestite devono essere eliminate, false in caso contrario.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Codice generato da Progettazione componenti

        /// <summary> 
        /// Metodo necessario per il supporto della finestra di progettazione. Non modificare 
        /// il contenuto del metodo con l'editor di codice.
        /// </summary>
        private void InitializeComponent()
        {
            components = new System.ComponentModel.Container();
            this.ServiceName = "AllOnServer";
        }

        #endregion
    }
#endif
}
// file ...\Sistema\Const.cs

namespace Zero5.Sistema
{
    public class Const
    {
        public static int TimeoutMilliseconds = 30000;
    }
}
// file ...\TextFileEdit\ucHexParam.cs
#if !MOBILE && !CORE

namespace TextFileEdit
{
    public partial class ucHexParam : UserControl
    {
        public ucHexParam()
        {
            if (!DesignMode)
            {
                InitializeComponent();
                txtHex.TextChanged += new EventHandler(txtHex_TextChanged);
                txtAscii.TextChanged += new EventHandler(txtAscii_TextChanged);
            }
        }

        void txtAscii_TextChanged(object sender, EventArgs e)
        {
            if (manualSetting) return; 
            if (!txtAscii.ContainsFocus) return;
            txtHex.Text = Zero5.Encryption.Utils.ToFatHex(System.Text.ASCIIEncoding.UTF8.GetBytes(txtAscii.Text));
        }

        void txtHex_TextChanged(object sender, EventArgs e)
        {
            if (manualSetting) return;
            if (!txtHex.ContainsFocus) return;
            try
            {
                if (txtHex.Text != "")
                    txtAscii.Text = System.Text.ASCIIEncoding.UTF8.GetString(Zero5.Encryption.Utils.FromFatHex(txtHex.Text));
                else
                    txtAscii.Text = "";
            }
            catch (Exception)
            {
            }
        }

        bool manualSetting = false;
        public string HexValue
        {
            get { return txtHex.Text; }
            set
            {
                manualSetting = true;
                txtHex.Text = value;

                txtAscii.Text = "";
                try
                {
                    if (txtHex.Text != "")
                        txtAscii.Text = System.Text.ASCIIEncoding.UTF8.GetString(Zero5.Encryption.Utils.FromFatHex(txtHex.Text));
                }
                catch { }
                manualSetting = false;
            }
        }

        public byte[] ByteArrayValue
        {
            get 
            {
                return Zero5.Encryption.Utils.FromFatHex(txtHex.Text);
            }

            set 
            {
                HexValue = Zero5.Encryption.Utils.ToFatHex(value);
            }
        }

    }
}

#endif
// file ...\TextFileEdit\ucHexParam.designer.cs
#if !MOBILE && !CORE
namespace TextFileEdit
{
    partial class ucHexParam
    {
        /// <summary> 
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

#region Component Designer generated code

        /// <summary> 
        /// Required method for Designer support - do not modify 
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.txtHex = new System.Windows.Forms.TextBox();
            this.txtAscii = new TextFileEdit.TextEditorControl();
            this.SuspendLayout();
            // 
            // txtHex
            // 
            this.txtHex.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
            this.txtHex.Location = new System.Drawing.Point(3, 226);
            this.txtHex.Multiline = true;
            this.txtHex.Name = "txtHex";
            this.txtHex.ScrollBars = System.Windows.Forms.ScrollBars.Both;
            this.txtHex.Size = new System.Drawing.Size(717, 81);
            this.txtHex.TabIndex = 1;
            // 
            // txtAscii
            // 
            this.txtAscii.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
            this.txtAscii.EnableFolding = false;
            this.txtAscii.IndentStyle = TextFileEdit.Document.IndentStyle.None;
            this.txtAscii.IsReadOnly = false;
            this.txtAscii.Location = new System.Drawing.Point(3, 3);
            this.txtAscii.Name = "txtAscii";
            this.txtAscii.ShowInvalidLines = true;
            this.txtAscii.ShowLineNumbers = false;
            this.txtAscii.ShowSpaces = true;
            this.txtAscii.Size = new System.Drawing.Size(717, 217);
            this.txtAscii.TabIndex = 0;
            // 
            // ucHexParam
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.Controls.Add(this.txtHex);
            this.Controls.Add(this.txtAscii);
            this.Name = "ucHexParam";
            this.Size = new System.Drawing.Size(723, 310);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

#endregion

        private TextFileEdit.TextEditorControl txtAscii;
        private System.Windows.Forms.TextBox txtHex;
    }
}

#endif
// file ...\TextFileEdit\Actions\BookmarkActions.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3272 $</version>
// </file>


namespace TextFileEdit.Actions 
{
    public class ToggleBookmark : AbstractEditAction
    {
        public override void Execute(TextArea textArea)
        {
            textArea.Document.BookmarkManager.ToggleMarkAt(textArea.Caret.Position);
            textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.SingleLine, textArea.Caret.Line));
            textArea.Document.CommitUpdate();
            
        }
    }
    
    public class GotoPrevBookmark : AbstractEditAction
    {
        Predicate<TextFileEdit.Document.Bookmark> predicate = null;

        public GotoPrevBookmark(Predicate<TextFileEdit.Document.Bookmark> predicate)
        {
            this.predicate = predicate;
        }
        
        public override void Execute(TextArea textArea)
        {
            TextFileEdit.Document.Bookmark mark = textArea.Document.BookmarkManager.GetPrevMark(textArea.Caret.Line, predicate);
            if (mark != null) {
                textArea.Caret.Position = mark.Location;
                textArea.SelectionManager.ClearSelection();
                textArea.SetDesiredColumn();
            }
        }
    }
    
    public class GotoNextBookmark : AbstractEditAction
    {
        Predicate<TextFileEdit.Document.Bookmark> predicate = null;

        public GotoNextBookmark(Predicate<TextFileEdit.Document.Bookmark> predicate)
        {
            this.predicate = predicate;
        }
        
        public override void Execute(TextArea textArea)
        {
            TextFileEdit.Document.Bookmark mark = textArea.Document.BookmarkManager.GetNextMark(textArea.Caret.Line, predicate);
            if (mark != null) {
                textArea.Caret.Position = mark.Location;
                textArea.SelectionManager.ClearSelection();
                textArea.SetDesiredColumn();
            }
        }
    }
    
    public class ClearAllBookmarks : AbstractEditAction
    {
        Predicate<TextFileEdit.Document.Bookmark> predicate = null;

        public ClearAllBookmarks(Predicate<TextFileEdit.Document.Bookmark> predicate)
        {
            this.predicate = predicate;
        }
        
        public override void Execute(TextArea textArea)
        {
            textArea.Document.BookmarkManager.RemoveMarks(predicate);
            textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.WholeTextArea));
            textArea.Document.CommitUpdate();
        }
    }
}

#endif
// file ...\TextFileEdit\Actions\CaretActions.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2681 $</version>
// </file>


namespace TextFileEdit.Actions
{
    public class CaretLeft : AbstractEditAction
    {
        public override void Execute(TextArea textArea)
        {
            TextLocation position = textArea.Caret.Position;
            List<TextFileEdit.Document.FoldMarker> foldings = textArea.Document.FoldingManager.GetFoldedFoldingsWithEnd(position.Y);
            TextFileEdit.Document.FoldMarker justBeforeCaret = null;
            foreach (TextFileEdit.Document.FoldMarker fm in foldings)
            {
                if (fm.EndColumn == position.X) {
                    justBeforeCaret = fm;
                    break; // the first folding found is the folding with the smallest Startposition
                }
            }
            
            if (justBeforeCaret != null) {
                position.Y = justBeforeCaret.StartLine;
                position.X = justBeforeCaret.StartColumn;
            } else {
                if (position.X > 0) {
                    --position.X;
                } else if (position.Y  > 0) {
                    TextFileEdit.Document.LineSegment lineAbove = textArea.Document.GetLineSegment(position.Y - 1);
                    position = new TextLocation(lineAbove.Length, position.Y - 1);
                }
            }
            
            textArea.Caret.Position = position;
            textArea.SetDesiredColumn();
        }
    }
    
    public class CaretRight : AbstractEditAction
    {
        public override void Execute(TextArea textArea)
        {
            TextFileEdit.Document.LineSegment curLine = textArea.Document.GetLineSegment(textArea.Caret.Line);
            TextLocation position = textArea.Caret.Position;
            List<TextFileEdit.Document.FoldMarker> foldings = textArea.Document.FoldingManager.GetFoldedFoldingsWithStart(position.Y);
            TextFileEdit.Document.FoldMarker justBehindCaret = null;
            foreach (TextFileEdit.Document.FoldMarker fm in foldings)
            {
                if (fm.StartColumn == position.X) {
                    justBehindCaret = fm;
                    break;
                }
            }
            if (justBehindCaret != null) {
                position.Y = justBehindCaret.EndLine;
                position.X = justBehindCaret.EndColumn;
            } else { // no folding is interesting
                if (position.X < curLine.Length || textArea.TextEditorProperties.AllowCaretBeyondEOL) {
                    ++position.X;
                } else if (position.Y + 1 < textArea.Document.TotalNumberOfLines) {
                    ++position.Y;
                    position.X = 0;
                }
            }
            textArea.Caret.Position = position;
            textArea.SetDesiredColumn();
        }
    }
    
    public class CaretUp : AbstractEditAction
    {
        public override void Execute(TextArea textArea)
        {
            TextLocation position = textArea.Caret.Position;
            int lineNr = position.Y;
            int visualLine = textArea.Document.GetVisibleLine(lineNr);
            if (visualLine > 0) {
                Point pos = new Point(textArea.TextView.GetDrawingXPos(lineNr, position.X),
                                      textArea.TextView.DrawingPosition.Y + (visualLine - 1) * textArea.TextView.FontHeight - textArea.TextView.TextArea.VirtualTop.Y);
                textArea.Caret.Position = textArea.TextView.GetLogicalPosition(pos);
                textArea.SetCaretToDesiredColumn();
            }
//          if (textArea.Caret.Line  > 0) {
//              textArea.SetCaretToDesiredColumn(textArea.Caret.Line - 1);
//          }
        }
    }
    
    public class CaretDown : AbstractEditAction
    {
        public override void Execute(TextArea textArea)
        {
            TextLocation position = textArea.Caret.Position;
            int lineNr = position.Y;
            int visualLine = textArea.Document.GetVisibleLine(lineNr);
            if (visualLine < textArea.Document.GetVisibleLine(textArea.Document.TotalNumberOfLines)) {
                Point pos = new Point(textArea.TextView.GetDrawingXPos(lineNr, position.X),
                                      textArea.TextView.DrawingPosition.Y
                                      + (visualLine + 1) * textArea.TextView.FontHeight
                                      - textArea.TextView.TextArea.VirtualTop.Y);
                textArea.Caret.Position = textArea.TextView.GetLogicalPosition(pos);
                textArea.SetCaretToDesiredColumn();
            }
//          if (textArea.Caret.Line + 1 < textArea.Document.TotalNumberOfLines) {
//              textArea.SetCaretToDesiredColumn(textArea.Caret.Line + 1);
//          }
        }
    }
    
    public class WordRight : CaretRight
    {
        public override void Execute(TextArea textArea)
        {
            TextFileEdit.Document.LineSegment line = textArea.Document.GetLineSegment(textArea.Caret.Position.Y);
            TextLocation oldPos = textArea.Caret.Position;
            TextLocation newPos;
            if (textArea.Caret.Column >= line.Length) {
                newPos = new TextLocation(0, textArea.Caret.Line + 1);
            } else {
                int nextWordStart = TextFileEdit.Document.TextUtilities.FindNextWordStart(textArea.Document, textArea.Caret.Offset);
                newPos = textArea.Document.OffsetToPosition(nextWordStart);
            }
            
            // handle fold markers
            List<TextFileEdit.Document.FoldMarker> foldings = textArea.Document.FoldingManager.GetFoldingsFromPosition(newPos.Y, newPos.X);
            foreach (TextFileEdit.Document.FoldMarker marker in foldings)
            {
                if (marker.IsFolded) {
                    if (oldPos.X == marker.StartColumn && oldPos.Y == marker.StartLine) {
                        newPos = new TextLocation(marker.EndColumn, marker.EndLine);
                    } else {
                        newPos = new TextLocation(marker.StartColumn, marker.StartLine);
                    }
                    break;
                }
            }
            
            textArea.Caret.Position = newPos;
            textArea.SetDesiredColumn();
        }
    }
    
    public class WordLeft : CaretLeft
    {
        public override void Execute(TextArea textArea)
        {
            TextLocation oldPos = textArea.Caret.Position;
            if (textArea.Caret.Column == 0) {
                base.Execute(textArea);
            } else {
                TextFileEdit.Document.LineSegment line = textArea.Document.GetLineSegment(textArea.Caret.Position.Y);

                int prevWordStart = TextFileEdit.Document.TextUtilities.FindPrevWordStart(textArea.Document, textArea.Caret.Offset);
                
                TextLocation newPos = textArea.Document.OffsetToPosition(prevWordStart);
                
                // handle fold markers
                List<TextFileEdit.Document.FoldMarker> foldings = textArea.Document.FoldingManager.GetFoldingsFromPosition(newPos.Y, newPos.X);
                foreach (TextFileEdit.Document.FoldMarker marker in foldings)
                {
                    if (marker.IsFolded) {
                        if (oldPos.X == marker.EndColumn && oldPos.Y == marker.EndLine) {
                            newPos = new TextLocation(marker.StartColumn, marker.StartLine);
                        } else {
                            newPos = new TextLocation(marker.EndColumn, marker.EndLine);
                        }
                        break;
                    }
                }
                textArea.Caret.Position = newPos;
                textArea.SetDesiredColumn();
            }
            
            
        }
    }
    
    public class ScrollLineUp : AbstractEditAction
    {
        public override void Execute(TextArea textArea)
        {
            textArea.AutoClearSelection = false;
            
            textArea.MotherTextAreaControl.VScrollBar.Value = Math.Max(textArea.MotherTextAreaControl.VScrollBar.Minimum,
                                                                       textArea.VirtualTop.Y - textArea.TextView.FontHeight);
        }
    }
    
    public class ScrollLineDown : AbstractEditAction
    {
        public override void Execute(TextArea textArea)
        {
            textArea.AutoClearSelection = false;
            textArea.MotherTextAreaControl.VScrollBar.Value = Math.Min(textArea.MotherTextAreaControl.VScrollBar.Maximum,
                                                                       textArea.VirtualTop.Y + textArea.TextView.FontHeight);
        }
    }
}

#endif
// file ...\TextFileEdit\Actions\ClipBoardActions.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1965 $</version>
// </file>


namespace TextFileEdit.Actions 
{
    public class Cut : AbstractEditAction
    {
        public override void Execute(TextArea textArea)
        {
            if (textArea.Document.ReadOnly) {
                return;
            }
            textArea.ClipboardHandler.Cut(null, null);
        }
    }
    
    public class Copy : AbstractEditAction
    {
        public override void Execute(TextArea textArea)
        {
            textArea.AutoClearSelection = false;
            textArea.ClipboardHandler.Copy(null, null);
        }
    }

    public class Paste : AbstractEditAction
    {
        public override void Execute(TextArea textArea)
        {
            if (textArea.Document.ReadOnly) {
                return;
            }
            textArea.ClipboardHandler.Paste(null, null);
        }
    }
}

#endif
// file ...\TextFileEdit\Actions\FoldActions.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2972 $</version>
// </file>


namespace TextFileEdit.Actions
{
	public class ToggleFolding : AbstractEditAction
	{
		public override void Execute(TextArea textArea)
		{
            List<TextFileEdit.Document.FoldMarker> foldMarkers = textArea.Document.FoldingManager.GetFoldingsWithStart(textArea.Caret.Line);
			if (foldMarkers.Count != 0) {
                foreach (TextFileEdit.Document.FoldMarker fm in foldMarkers)
					fm.IsFolded = !fm.IsFolded;
			} else {
				foldMarkers = textArea.Document.FoldingManager.GetFoldingsContainsLineNumber(textArea.Caret.Line);
				if (foldMarkers.Count != 0) {
                    TextFileEdit.Document.FoldMarker innerMost = foldMarkers[0];
					for (int i = 1; i < foldMarkers.Count; i++) {
						if (new TextLocation(foldMarkers[i].StartColumn, foldMarkers[i].StartLine) >
						    new TextLocation(innerMost.StartColumn, innerMost.StartLine))
						{
							innerMost = foldMarkers[i];
						}
					}
					innerMost.IsFolded = !innerMost.IsFolded;
				}
			}
			textArea.Document.FoldingManager.NotifyFoldingsChanged(EventArgs.Empty);
		}
	}
	
	public class ToggleAllFoldings : AbstractEditAction
	{
		public override void Execute(TextArea textArea)
		{
			bool doFold = true;
            foreach (TextFileEdit.Document.FoldMarker fm in textArea.Document.FoldingManager.FoldMarker)
            {
				if (fm.IsFolded) {
					doFold = false;
					break;
				}
			}
            foreach (TextFileEdit.Document.FoldMarker fm in textArea.Document.FoldingManager.FoldMarker)
            {
				fm.IsFolded = doFold;
			}
			textArea.Document.FoldingManager.NotifyFoldingsChanged(EventArgs.Empty);
		}
	}
	
	public class ShowDefinitionsOnly : AbstractEditAction
	{
		public override void Execute(TextArea textArea)
		{
            foreach (TextFileEdit.Document.FoldMarker fm in textArea.Document.FoldingManager.FoldMarker)
            {
                fm.IsFolded = fm.FoldType == TextFileEdit.Document.FoldType.MemberBody || fm.FoldType == TextFileEdit.Document.FoldType.Region;
			}
			textArea.Document.FoldingManager.NotifyFoldingsChanged(EventArgs.Empty);
		}
	}
}

#endif
// file ...\TextFileEdit\Actions\FormatActions.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3537 $</version>
// </file>


namespace TextFileEdit.Actions
{
	public abstract class AbstractLineFormatAction : AbstractEditAction
	{
		protected TextArea textArea;
        abstract protected void Convert(TextFileEdit.Document.IDocument document, int startLine, int endLine);
		
		public override void Execute(TextArea textArea)
		{
			if (textArea.SelectionManager.SelectionIsReadonly) {
				return;
			}
			this.textArea = textArea;
			textArea.BeginUpdate();
			textArea.Document.UndoStack.StartUndoGroup();
			if (textArea.SelectionManager.HasSomethingSelected) {
                foreach (TextFileEdit.Document.ISelection selection in textArea.SelectionManager.SelectionCollection)
                {
					Convert(textArea.Document, selection.StartPosition.Y, selection.EndPosition.Y);
				}
			} else {
				Convert(textArea.Document, 0, textArea.Document.TotalNumberOfLines - 1);
			}
			textArea.Document.UndoStack.EndUndoGroup();
			textArea.Caret.ValidateCaretPos();
			textArea.EndUpdate();
			textArea.Refresh();
		}
	}
	
	public abstract class AbstractSelectionFormatAction : AbstractEditAction
	{
		protected TextArea textArea;
        abstract protected void Convert(TextFileEdit.Document.IDocument document, int offset, int length);
		
		public override void Execute(TextArea textArea)
		{
			if (textArea.SelectionManager.SelectionIsReadonly) {
				return;
			}
			this.textArea = textArea;
			textArea.BeginUpdate();
			if (textArea.SelectionManager.HasSomethingSelected) {
                foreach (TextFileEdit.Document.ISelection selection in textArea.SelectionManager.SelectionCollection)
                {
					Convert(textArea.Document, selection.Offset, selection.Length);
				}
			} else {
				Convert(textArea.Document, 0, textArea.Document.TextLength);
			}
			textArea.Caret.ValidateCaretPos();
			textArea.EndUpdate();
			textArea.Refresh();
		}
	}
	
	public class RemoveLeadingWS : AbstractLineFormatAction
	{
        protected override void Convert(TextFileEdit.Document.IDocument document, int y1, int y2)
		{
			for (int i = y1; i < y2; ++i) {
                TextFileEdit.Document.LineSegment line = document.GetLineSegment(i);
				int removeNumber = 0;
				for (int x = line.Offset; x < line.Offset + line.Length && Char.IsWhiteSpace(document.GetCharAt(x)); ++x) {
					++removeNumber;
				}
				if (removeNumber > 0) {
					document.Remove(line.Offset, removeNumber);
				}
			}
		}
	}
	
	public class RemoveTrailingWS : AbstractLineFormatAction
	{
        protected override void Convert(TextFileEdit.Document.IDocument document, int y1, int y2)
		{
			for (int i = y2 - 1; i >= y1; --i) {
                TextFileEdit.Document.LineSegment line = document.GetLineSegment(i);
				int removeNumber = 0;
				for (int x = line.Offset + line.Length - 1; x >= line.Offset && Char.IsWhiteSpace(document.GetCharAt(x)); --x) {
					++removeNumber;
				}
				if (removeNumber > 0) {
					document.Remove(line.Offset + line.Length - removeNumber, removeNumber);
				}
			}
		}
	}
	
	
	public class ToUpperCase : AbstractSelectionFormatAction
	{
        protected override void Convert(TextFileEdit.Document.IDocument document, int startOffset, int length)
		{
			string what = document.GetText(startOffset, length).ToUpper();
			document.Replace(startOffset, length, what);
		}
	}
	
	public class ToLowerCase : AbstractSelectionFormatAction
	{
        protected override void Convert(TextFileEdit.Document.IDocument document, int startOffset, int length)
		{
			string what = document.GetText(startOffset, length).ToLower();
			document.Replace(startOffset, length, what);
		}
	}
	
	public class InvertCaseAction : AbstractSelectionFormatAction
	{
        protected override void Convert(TextFileEdit.Document.IDocument document, int startOffset, int length)
		{
			StringBuilder what = new StringBuilder(document.GetText(startOffset, length));
			
			for (int i = 0; i < what.Length; ++i) {
				what[i] = Char.IsUpper(what[i]) ? Char.ToLower(what[i]) : Char.ToUpper(what[i]);
			}
			
			document.Replace(startOffset, length, what.ToString());
		}
	}
	
	public class CapitalizeAction : AbstractSelectionFormatAction
	{
        protected override void Convert(TextFileEdit.Document.IDocument document, int startOffset, int length)
		{
			StringBuilder what = new StringBuilder(document.GetText(startOffset, length));
			
			for (int i = 0; i < what.Length; ++i) {
				if (!Char.IsLetter(what[i]) && i < what.Length - 1) {
					what[i + 1] = Char.ToUpper(what[i + 1]);
				}
			}
			document.Replace(startOffset, length, what.ToString());
		}
		
	}
	
	public class ConvertTabsToSpaces : AbstractSelectionFormatAction
	{
        protected override void Convert(TextFileEdit.Document.IDocument document, int startOffset, int length)
		{
			string what = document.GetText(startOffset, length);
			string spaces = new string(' ', document.TextEditorProperties.TabIndent);
			document.Replace(startOffset, length, what.Replace("\t", spaces));
		}
	}
	
	public class ConvertSpacesToTabs : AbstractSelectionFormatAction
	{
        protected override void Convert(TextFileEdit.Document.IDocument document, int startOffset, int length)
		{
			string what = document.GetText(startOffset, length);
			string spaces = new string(' ', document.TextEditorProperties.TabIndent);
			document.Replace(startOffset, length, what.Replace(spaces, "\t"));
		}
	}
	
	public class ConvertLeadingTabsToSpaces : AbstractLineFormatAction
	{
        protected override void Convert(TextFileEdit.Document.IDocument document, int y1, int y2)
		{
			for (int i = y2; i >= y1; --i) {
                TextFileEdit.Document.LineSegment line = document.GetLineSegment(i);
				
				if(line.Length > 0) {
					// count how many whitespace characters there are at the start
					int whiteSpace = 0;
					for(whiteSpace = 0; whiteSpace < line.Length && Char.IsWhiteSpace(document.GetCharAt(line.Offset + whiteSpace)); whiteSpace++) {
						// deliberately empty
					}
					if(whiteSpace > 0) {
						string newLine = document.GetText(line.Offset,whiteSpace);
						string newPrefix = newLine.Replace("\t",new string(' ', document.TextEditorProperties.TabIndent));
						document.Replace(line.Offset,whiteSpace,newPrefix);
					}
				}
			}
		}
	}
	
	public class ConvertLeadingSpacesToTabs : AbstractLineFormatAction
	{
        protected override void Convert(TextFileEdit.Document.IDocument document, int y1, int y2)
		{
			for (int i = y2; i >= y1; --i) {
                TextFileEdit.Document.LineSegment line = document.GetLineSegment(i);
				if(line.Length > 0) {
					// note: some users may prefer a more radical ConvertLeadingSpacesToTabs that
					// means there can be no spaces before the first character even if the spaces
					// didn't add up to a whole number of tabs
                    string newLine = TextFileEdit.Document.TextUtilities.LeadingWhiteSpaceToTabs(document.GetText(line.Offset, line.Length), document.TextEditorProperties.TabIndent);
					document.Replace(line.Offset,line.Length,newLine);
				}
			}
		}
	}

	/// <summary>
	/// This is a sample editaction plugin, it indents the selected area.
	/// </summary>
	public class IndentSelection : AbstractLineFormatAction
	{
        protected override void Convert(TextFileEdit.Document.IDocument document, int startLine, int endLine)
		{
			document.FormattingStrategy.IndentLines(textArea, startLine, endLine);
		}
	}
}

#endif
// file ...\TextFileEdit\Actions\HomeEndActions.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2659 $</version>
// </file>


namespace TextFileEdit.Actions
{
    public class Home : AbstractEditAction
    {
        public override void Execute(TextArea textArea)
        {
            TextFileEdit.Document.LineSegment curLine;
            TextLocation       newPos = textArea.Caret.Position;
            bool        jumpedIntoFolding = false;
            do {
                curLine = textArea.Document.GetLineSegment(newPos.Y);

                if (TextFileEdit.Document.TextUtilities.IsEmptyLine(textArea.Document, newPos.Y))
                {
                    if (newPos.X != 0) {
                        newPos.X = 0;
                    } else  {
                        newPos.X = curLine.Length;
                    }
                } else {
                    int firstCharOffset = TextFileEdit.Document.TextUtilities.GetFirstNonWSChar(textArea.Document, curLine.Offset);
                    int firstCharColumn = firstCharOffset - curLine.Offset;
                    
                    if (newPos.X == firstCharColumn) {
                        newPos.X = 0;
                    } else {
                        newPos.X = firstCharColumn;
                    }
                }
                List<TextFileEdit.Document.FoldMarker> foldings = textArea.Document.FoldingManager.GetFoldingsFromPosition(newPos.Y, newPos.X);
                jumpedIntoFolding = false;
                foreach (TextFileEdit.Document.FoldMarker foldMarker in foldings)
                {
                    if (foldMarker.IsFolded) {
                        newPos = new TextLocation(foldMarker.StartColumn, foldMarker.StartLine);
                        jumpedIntoFolding = true;
                        break;
                    }
                }
                
            } while (jumpedIntoFolding);
            
            if (newPos != textArea.Caret.Position) {
                textArea.Caret.Position = newPos;
                textArea.SetDesiredColumn();
            }
        }
    }
    
    public class End : AbstractEditAction
    {
        public override void Execute(TextArea textArea)
        {
            TextFileEdit.Document.LineSegment curLine;
            TextLocation newPos = textArea.Caret.Position;
            bool jumpedIntoFolding = false;
            do {
                curLine  = textArea.Document.GetLineSegment(newPos.Y);
                newPos.X = curLine.Length;

                List<TextFileEdit.Document.FoldMarker> foldings = textArea.Document.FoldingManager.GetFoldingsFromPosition(newPos.Y, newPos.X);
                jumpedIntoFolding = false;
                foreach (TextFileEdit.Document.FoldMarker foldMarker in foldings)
                {
                    if (foldMarker.IsFolded) {
                        newPos = new TextLocation(foldMarker.EndColumn, foldMarker.EndLine);
                        jumpedIntoFolding = true;
                        break;
                    }
                }
            } while (jumpedIntoFolding);
            
            if (newPos != textArea.Caret.Position) {
                textArea.Caret.Position = newPos;
                textArea.SetDesiredColumn();
            }
        }
    }
    
    
    public class MoveToStart : AbstractEditAction
    {
        public override void Execute(TextArea textArea)
        {
            if (textArea.Caret.Line != 0 || textArea.Caret.Column != 0) {
                textArea.Caret.Position = new TextLocation(0, 0);
                textArea.SetDesiredColumn();
            }
        }
    }
    
    
    public class MoveToEnd : AbstractEditAction
    {
        public override void Execute(TextArea textArea)
        {
            TextLocation endPos = textArea.Document.OffsetToPosition(textArea.Document.TextLength);
            if (textArea.Caret.Position != endPos) {
                textArea.Caret.Position = endPos;
                textArea.SetDesiredColumn();
            }
        }
    }
}

#endif
// file ...\TextFileEdit\Actions\IEditAction.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1965 $</version>
// </file>


namespace TextFileEdit.Actions
{
    /// <summary>
    /// To define a new key for the textarea, you must write a class which
    /// implements this interface.
    /// </summary>
    public interface IEditAction
    {
        /// <value>
        /// An array of keys on which this edit action occurs.
        /// </value>
        Keys[] Keys {
            get;
            set;
        }
        
        /// <remarks>
        /// When the key which is defined per XML is pressed, this method will be launched.
        /// </remarks>
        void Execute(TextArea textArea);
    }
    
    /// <summary>
    /// To define a new key for the textarea, you must write a class which
    /// implements this interface.
    /// </summary>
    public abstract class AbstractEditAction : IEditAction
    {
        Keys[] keys = null;
        
        /// <value>
        /// An array of keys on which this edit action occurs.
        /// </value>
        public Keys[] Keys {
            get {
                return keys;
            }
            set {
                keys = value;
            }
        }
        
        /// <remarks>
        /// When the key which is defined per XML is pressed, this method will be launched.
        /// </remarks>
        public abstract void Execute(TextArea textArea);
    }       
}

#endif
// file ...\TextFileEdit\Actions\MiscActions.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3537 $</version>
// </file>


namespace TextFileEdit.Actions
{
	public class Tab : AbstractEditAction
	{
        public static string GetIndentationString(TextFileEdit.Document.IDocument document)
		{
			return GetIndentationString(document, null);
		}

        public static string GetIndentationString(TextFileEdit.Document.IDocument document, TextArea textArea)
		{
			StringBuilder indent = new StringBuilder();
			
			if (document.TextEditorProperties.ConvertTabsToSpaces) {
				int tabIndent = document.TextEditorProperties.IndentationSize;
				if (textArea != null) {
					int column = textArea.TextView.GetVisualColumn(textArea.Caret.Line, textArea.Caret.Column);
					indent.Append(new String(' ', tabIndent - column % tabIndent));
				} else {
					indent.Append(new String(' ', tabIndent));
				}
			} else {
				indent.Append('\t');
			}
			return indent.ToString();
		}

        void InsertTabs(TextFileEdit.Document.IDocument document, TextFileEdit.Document.ISelection selection, int y1, int y2)
		{
			string indentationString = GetIndentationString(document);
			for (int i = y2; i >= y1; --i) {
                TextFileEdit.Document.LineSegment line = document.GetLineSegment(i);
				if (i == y2 && i == selection.EndPosition.Y && selection.EndPosition.X  == 0) {
					continue;
				}
				
				// this bit is optional - but useful if you are using block tabbing to sort out
				// a source file with a mixture of tabs and spaces
//				string newLine = document.GetText(line.Offset,line.Length);
//				document.Replace(line.Offset,line.Length,newLine);
				
				document.Insert(line.Offset, indentationString);
			}
		}
		
		void InsertTabAtCaretPosition(TextArea textArea)
		{
			switch (textArea.Caret.CaretMode) {
				case CaretMode.InsertMode:
					textArea.InsertString(GetIndentationString(textArea.Document, textArea));
					break;
				case CaretMode.OverwriteMode:
					string indentStr = GetIndentationString(textArea.Document, textArea);
					textArea.ReplaceChar(indentStr[0]);
					if (indentStr.Length > 1) {
						textArea.InsertString(indentStr.Substring(1));
					}
					break;
			}
			textArea.SetDesiredColumn();
		}
		/// <remarks>
		/// Executes this edit action
		/// </remarks>
		/// <param name="textArea">The <see cref="ItextArea"/> which is used for callback purposes</param>
		public override void Execute(TextArea textArea)
		{
			if (textArea.SelectionManager.SelectionIsReadonly) {
				return;
			}
			textArea.Document.UndoStack.StartUndoGroup();
			if (textArea.SelectionManager.HasSomethingSelected) {
                foreach (TextFileEdit.Document.ISelection selection in textArea.SelectionManager.SelectionCollection)
                {
					int startLine = selection.StartPosition.Y;
					int endLine   = selection.EndPosition.Y;
					if (startLine != endLine) {
						textArea.BeginUpdate();
						InsertTabs(textArea.Document, selection, startLine, endLine);
						textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.LinesBetween, startLine, endLine));
						textArea.EndUpdate();
					} else {
						InsertTabAtCaretPosition(textArea);
						break;
					}
				}
				textArea.Document.CommitUpdate();
				textArea.AutoClearSelection = false;
			} else {
				InsertTabAtCaretPosition(textArea);
			}
			textArea.Document.UndoStack.EndUndoGroup();
		}
	}
	
	public class ShiftTab : AbstractEditAction
	{
        void RemoveTabs(TextFileEdit.Document.IDocument document, TextFileEdit.Document.ISelection selection, int y1, int y2)
		{
			document.UndoStack.StartUndoGroup();
			for (int i = y2; i >= y1; --i) {
                TextFileEdit.Document.LineSegment line = document.GetLineSegment(i);
				if (i == y2 && line.Offset == selection.EndOffset) {
					continue;
				}
				if (line.Length > 0) {
					/**** TextPad Strategy:
					/// first convert leading whitespace to tabs (controversial! - not all editors work like this)
					string newLine = TextUtilities.LeadingWhiteSpaceToTabs(document.GetText(line.Offset,line.Length),document.Properties.Get("TabIndent", 4));
					if(newLine.Length > 0 && newLine[0] == '\t') {
						document.Replace(line.Offset,line.Length,newLine.Substring(1));
						++redocounter;
					}
					else if(newLine.Length > 0 && newLine[0] == ' ') {
						/// there were just some leading spaces but less than TabIndent of them
						int leadingSpaces = 1;
						for(leadingSpaces = 1; leadingSpaces < newLine.Length && newLine[leadingSpaces] == ' '; leadingSpaces++) {
							/// deliberately empty
						}
						document.Replace(line.Offset,line.Length,newLine.Substring(leadingSpaces));
						++redocounter;
					}
					/// else
					/// there were no leading tabs or spaces on this line so do nothing
					/// MS Visual Studio 6 strategy:
					 ****/
//					string temp = document.GetText(line.Offset,line.Length);
					if (line.Length > 0) {
						int charactersToRemove = 0;
						if(document.GetCharAt(line.Offset) == '\t') { // first character is a tab - just remove it
							charactersToRemove = 1;
						} else if(document.GetCharAt(line.Offset) == ' ') {
							int leadingSpaces = 1;
							int tabIndent = document.TextEditorProperties.IndentationSize;
							for (leadingSpaces = 1; leadingSpaces < line.Length && document.GetCharAt(line.Offset + leadingSpaces) == ' '; leadingSpaces++) {
								// deliberately empty
							}
							if(leadingSpaces >= tabIndent) {
								// just remove tabIndent
								charactersToRemove = tabIndent;
							}
							else if(line.Length > leadingSpaces && document.GetCharAt(line.Offset + leadingSpaces) == '\t') {
								// remove the leading spaces and the following tab as they add up
								// to just one tab stop
								charactersToRemove = leadingSpaces+1;
							}
							else {
								// just remove the leading spaces
								charactersToRemove = leadingSpaces;
							}
						}
						if (charactersToRemove > 0) {
							document.Remove(line.Offset,charactersToRemove);
						}
					}
				}
			}
			document.UndoStack.EndUndoGroup();
		}
		
		/// <remarks>
		/// Executes this edit action
		/// </remarks>
		/// <param name="textArea">The <see cref="ItextArea"/> which is used for callback purposes</param>
		public override void Execute(TextArea textArea)
		{
			if (textArea.SelectionManager.HasSomethingSelected) {
                foreach (TextFileEdit.Document.ISelection selection in textArea.SelectionManager.SelectionCollection)
                {
					int startLine = selection.StartPosition.Y;
					int endLine   = selection.EndPosition.Y;
					textArea.BeginUpdate();
					RemoveTabs(textArea.Document, selection, startLine, endLine);
					textArea.Document.UpdateQueue.Clear();
					textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.LinesBetween, startLine, endLine));
					textArea.EndUpdate();
					
				}
				textArea.AutoClearSelection = false;
			} else {
				// Pressing Shift-Tab with nothing selected the cursor will move back to the
				// previous tab stop. It will stop at the beginning of the line. Also, the desired
				// column is updated to that column.
                TextFileEdit.Document.LineSegment line = textArea.Document.GetLineSegmentForOffset(textArea.Caret.Offset);
				string startOfLine = textArea.Document.GetText(line.Offset,textArea.Caret.Offset - line.Offset);
				int tabIndent = textArea.Document.TextEditorProperties.IndentationSize;
				int currentColumn = textArea.Caret.Column;
				int remainder = currentColumn % tabIndent;
				if (remainder == 0) {
					textArea.Caret.DesiredColumn = Math.Max(0, currentColumn - tabIndent);
				} else {
					textArea.Caret.DesiredColumn = Math.Max(0, currentColumn - remainder);
				}
				textArea.SetCaretToDesiredColumn();
			}
		}
	}
	
	public class ToggleComment : AbstractEditAction
	{
		/// <remarks>
		/// Executes this edit action
		/// </remarks>
		/// <param name="textArea">The <see cref="ItextArea"/> which is used for callback purposes</param>
		public override void Execute(TextArea textArea)
		{
			if (textArea.Document.ReadOnly) {
				return;
			}
			
			if (textArea.Document.HighlightingStrategy.Properties.ContainsKey("LineComment")) {
				new ToggleLineComment().Execute(textArea);
			} else if (textArea.Document.HighlightingStrategy.Properties.ContainsKey("BlockCommentBegin") &&
			           textArea.Document.HighlightingStrategy.Properties.ContainsKey("BlockCommentBegin")) {
				new ToggleBlockComment().Execute(textArea);
			}
		}
	}
	
	public class ToggleLineComment : AbstractEditAction
	{
		int firstLine;
		int lastLine;

        void RemoveCommentAt(TextFileEdit.Document.IDocument document, string comment, TextFileEdit.Document.ISelection selection, int y1, int y2)
		{
			firstLine = y1;
			lastLine  = y2;
			
			for (int i = y2; i >= y1; --i) {
                TextFileEdit.Document.LineSegment line = document.GetLineSegment(i);
				if (selection != null && i == y2 && line.Offset == selection.Offset + selection.Length) {
					--lastLine;
					continue;
				}
				
				string lineText = document.GetText(line.Offset, line.Length);
				if (lineText.Trim().StartsWith(comment)) {
					document.Remove(line.Offset + lineText.IndexOf(comment), comment.Length);
				}
			}
		}

        void SetCommentAt(TextFileEdit.Document.IDocument document, string comment, TextFileEdit.Document.ISelection selection, int y1, int y2)
		{
			firstLine = y1;
			lastLine  = y2;
			
			for (int i = y2; i >= y1; --i) {
                TextFileEdit.Document.LineSegment line = document.GetLineSegment(i);
				if (selection != null && i == y2 && line.Offset == selection.Offset + selection.Length) {
					--lastLine;
					continue;
				}
				
				string lineText = document.GetText(line.Offset, line.Length);
				document.Insert(line.Offset, comment);
			}
		}

        bool ShouldComment(TextFileEdit.Document.IDocument document, string comment, TextFileEdit.Document.ISelection selection, int startLine, int endLine)
		{
			for (int i = endLine; i >= startLine; --i) {
                TextFileEdit.Document.LineSegment line = document.GetLineSegment(i);
				if (selection != null && i == endLine && line.Offset == selection.Offset + selection.Length) {
					--lastLine;
					continue;
				}
				string lineText = document.GetText(line.Offset, line.Length);
				if (!lineText.Trim().StartsWith(comment)) {
					return true;
				}
			}
			return false;
		}
		
		/// <remarks>
		/// Executes this edit action
		/// </remarks>
		/// <param name="textArea">The <see cref="ItextArea"/> which is used for callback purposes</param>
		public override void Execute(TextArea textArea)
		{
			if (textArea.Document.ReadOnly) {
				return;
			}
			
			string comment = null;
			if (textArea.Document.HighlightingStrategy.Properties.ContainsKey("LineComment")) {
				comment = textArea.Document.HighlightingStrategy.Properties["LineComment"].ToString();
			}
			
			if (comment == null || comment.Length == 0) {
				return;
			}
			
			textArea.Document.UndoStack.StartUndoGroup();
			if (textArea.SelectionManager.HasSomethingSelected) {
				bool shouldComment = true;
                foreach (TextFileEdit.Document.ISelection selection in textArea.SelectionManager.SelectionCollection)
                {
					if (!ShouldComment(textArea.Document, comment, selection, selection.StartPosition.Y, selection.EndPosition.Y)) {
						shouldComment = false;
						break;
					}
				}

                foreach (TextFileEdit.Document.ISelection selection in textArea.SelectionManager.SelectionCollection)
                {
					textArea.BeginUpdate();
					if (shouldComment) {
						SetCommentAt(textArea.Document, comment, selection, selection.StartPosition.Y, selection.EndPosition.Y);
					} else {
						RemoveCommentAt(textArea.Document, comment, selection, selection.StartPosition.Y, selection.EndPosition.Y);
					}
					textArea.Document.UpdateQueue.Clear();
					textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.LinesBetween, firstLine, lastLine));
					textArea.EndUpdate();
				}
				textArea.Document.CommitUpdate();
				textArea.AutoClearSelection = false;
			} else {
				textArea.BeginUpdate();
				int caretLine = textArea.Caret.Line;
				if (ShouldComment(textArea.Document, comment, null, caretLine, caretLine)) {
					SetCommentAt(textArea.Document, comment, null, caretLine, caretLine);
				} else {
					RemoveCommentAt(textArea.Document, comment, null, caretLine, caretLine);
				}
				textArea.Document.UpdateQueue.Clear();
				textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.SingleLine, caretLine));
				textArea.EndUpdate();
			}
			textArea.Document.UndoStack.EndUndoGroup();
		}
	}
	
	public class ToggleBlockComment : AbstractEditAction
	{
		/// <remarks>
		/// Executes this edit action
		/// </remarks>
		/// <param name="textArea">The <see cref="ItextArea"/> which is used for callback purposes</param>
		public override void Execute(TextArea textArea)
		{
			if (textArea.Document.ReadOnly) {
				return;
			}
			
			string commentStart = null;
			if (textArea.Document.HighlightingStrategy.Properties.ContainsKey("BlockCommentBegin")) {
				commentStart = textArea.Document.HighlightingStrategy.Properties["BlockCommentBegin"].ToString();
			}
			
			string commentEnd = null;
			if (textArea.Document.HighlightingStrategy.Properties.ContainsKey("BlockCommentEnd")) {
				commentEnd = textArea.Document.HighlightingStrategy.Properties["BlockCommentEnd"].ToString();
			}
			
			if (commentStart == null || commentStart.Length == 0 || commentEnd == null || commentEnd.Length == 0) {
				return;
			}
			
			int selectionStartOffset;
			int selectionEndOffset;
			
			if (textArea.SelectionManager.HasSomethingSelected) {
				selectionStartOffset = textArea.SelectionManager.SelectionCollection[0].Offset;
				selectionEndOffset = textArea.SelectionManager.SelectionCollection[textArea.SelectionManager.SelectionCollection.Count - 1].EndOffset;
			} else {
				selectionStartOffset = textArea.Caret.Offset;
				selectionEndOffset = selectionStartOffset;
			}
			
			BlockCommentRegion commentRegion = FindSelectedCommentRegion(textArea.Document, commentStart, commentEnd, selectionStartOffset, selectionEndOffset);
			
			textArea.Document.UndoStack.StartUndoGroup();
			if (commentRegion != null) {
				RemoveComment(textArea.Document, commentRegion);
			} else if (textArea.SelectionManager.HasSomethingSelected) {
				SetCommentAt(textArea.Document, selectionStartOffset, selectionEndOffset, commentStart, commentEnd);
			}
			textArea.Document.UndoStack.EndUndoGroup();
			
			textArea.Document.CommitUpdate();
			textArea.AutoClearSelection = false;
		}

        public static BlockCommentRegion FindSelectedCommentRegion(TextFileEdit.Document.IDocument document, string commentStart, string commentEnd, int selectionStartOffset, int selectionEndOffset)
		{
			if (document.TextLength == 0) {
				return null;
			}
			
			// Find start of comment in selected text.
			
			int commentEndOffset = -1;
			string selectedText = document.GetText(selectionStartOffset, selectionEndOffset - selectionStartOffset);
			
			int commentStartOffset = selectedText.IndexOf(commentStart);
			if (commentStartOffset >= 0) {
				commentStartOffset += selectionStartOffset;
			}

			// Find end of comment in selected text.
			
			if (commentStartOffset >= 0) {
				commentEndOffset = selectedText.IndexOf(commentEnd, commentStartOffset + commentStart.Length - selectionStartOffset);
			} else {
				commentEndOffset = selectedText.IndexOf(commentEnd);
			}
			
			if (commentEndOffset >= 0) {
				commentEndOffset += selectionStartOffset;
			}
			
			// Find start of comment before or partially inside the
			// selected text.
			
			int commentEndBeforeStartOffset = -1;
			if (commentStartOffset == -1) {
				int offset = selectionEndOffset + commentStart.Length - 1;
				if (offset > document.TextLength) {
					offset = document.TextLength;
				}
				string text = document.GetText(0, offset);
				commentStartOffset = text.LastIndexOf(commentStart);
				if (commentStartOffset >= 0) {
					// Find end of comment before comment start.
					commentEndBeforeStartOffset = text.IndexOf(commentEnd, commentStartOffset, selectionStartOffset - commentStartOffset);
					if (commentEndBeforeStartOffset > commentStartOffset) {
						commentStartOffset = -1;
					}
				}
			}
			
			// Find end of comment after or partially after the
			// selected text.
			
			if (commentEndOffset == -1) {
				int offset = selectionStartOffset + 1 - commentEnd.Length;
				if (offset < 0) {
					offset = selectionStartOffset;
				}
				string text = document.GetText(offset, document.TextLength - offset);
				commentEndOffset = text.IndexOf(commentEnd);
				if (commentEndOffset >= 0) {
					commentEndOffset += offset;
				}
			}
			
			if (commentStartOffset != -1 && commentEndOffset != -1) {
				return new BlockCommentRegion(commentStart, commentEnd, commentStartOffset, commentEndOffset);
			}
			
			return null;
		}


        void SetCommentAt(TextFileEdit.Document.IDocument document, int offsetStart, int offsetEnd, string commentStart, string commentEnd)
		{
			document.Insert(offsetEnd, commentEnd);
			document.Insert(offsetStart, commentStart);
		}

        void RemoveComment(TextFileEdit.Document.IDocument document, BlockCommentRegion commentRegion)
		{
			document.Remove(commentRegion.EndOffset, commentRegion.CommentEnd.Length);
			document.Remove(commentRegion.StartOffset, commentRegion.CommentStart.Length);
		}
	}
	
	public class BlockCommentRegion
	{
		string commentStart = String.Empty;
		string commentEnd = String.Empty;
		int startOffset = -1;
		int endOffset = -1;
		
		/// <summary>
		/// The end offset is the offset where the comment end string starts from.
		/// </summary>
		public BlockCommentRegion(string commentStart, string commentEnd, int startOffset, int endOffset)
		{
			this.commentStart = commentStart;
			this.commentEnd = commentEnd;
			this.startOffset = startOffset;
			this.endOffset = endOffset;
		}
		
		public string CommentStart {
			get {
				return commentStart;
			}
		}
		
		public string CommentEnd {
			get {
				return commentEnd;
			}
		}
		
		public int StartOffset {
			get {
				return startOffset;
			}
		}
		
		public int EndOffset {
			get {
				return endOffset;
			}
		}
		
		public override int GetHashCode()
		{
			int hashCode = 0;
			unchecked {
				if (commentStart != null) hashCode += 1000000007 * commentStart.GetHashCode();
				if (commentEnd != null) hashCode += 1000000009 * commentEnd.GetHashCode();
				hashCode += 1000000021 * startOffset.GetHashCode();
				hashCode += 1000000033 * endOffset.GetHashCode();
			}
			return hashCode;
		}
		
		public override bool Equals(object obj)
		{
			BlockCommentRegion other = obj as BlockCommentRegion;
			if (other == null) return false;
			return this.commentStart == other.commentStart && this.commentEnd == other.commentEnd && this.startOffset == other.startOffset && this.endOffset == other.endOffset;
		}
	}
	
	public class Backspace : AbstractEditAction
	{
		/// <remarks>
		/// Executes this edit action
		/// </remarks>
		/// <param name="textArea">The <see cref="ItextArea"/> which is used for callback purposes</param>
		public override void Execute(TextArea textArea)
		{
			if (textArea.SelectionManager.HasSomethingSelected) {
				Delete.DeleteSelection(textArea);
			} else {
				if (textArea.Caret.Offset > 0 && !textArea.IsReadOnly(textArea.Caret.Offset - 1)) {
					textArea.BeginUpdate();
					int curLineNr     = textArea.Document.GetLineNumberForOffset(textArea.Caret.Offset);
					int curLineOffset = textArea.Document.GetLineSegment(curLineNr).Offset;
					
					if (curLineOffset == textArea.Caret.Offset) {
                        TextFileEdit.Document.LineSegment line = textArea.Document.GetLineSegment(curLineNr - 1);
						bool lastLine = curLineNr == textArea.Document.TotalNumberOfLines;
						int lineEndOffset = line.Offset + line.Length;
						int lineLength = line.Length;
						textArea.Document.Remove(lineEndOffset, curLineOffset - lineEndOffset);
						textArea.Caret.Position = new TextLocation(lineLength, curLineNr - 1);
						textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.PositionToEnd, new TextLocation(0, curLineNr - 1)));
					} else {
						int caretOffset = textArea.Caret.Offset - 1;
						textArea.Caret.Position = textArea.Document.OffsetToPosition(caretOffset);
						textArea.Document.Remove(caretOffset, 1);
						
						textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.PositionToLineEnd, new TextLocation(textArea.Caret.Offset - textArea.Document.GetLineSegment(curLineNr).Offset, curLineNr)));
					}
					textArea.EndUpdate();
				}
			}
		}
	}
	
	public class Delete : AbstractEditAction
	{
		internal static void DeleteSelection(TextArea textArea)
		{
			Debug.Assert(textArea.SelectionManager.HasSomethingSelected);
			if (textArea.SelectionManager.SelectionIsReadonly)
				return;
			textArea.BeginUpdate();
			textArea.Caret.Position = textArea.SelectionManager.SelectionCollection[0].StartPosition;
			textArea.SelectionManager.RemoveSelectedText();
			textArea.ScrollToCaret();
			textArea.EndUpdate();
		}
		
		/// <remarks>
		/// Executes this edit action
		/// </remarks>
		/// <param name="textArea">The <see cref="ItextArea"/> which is used for callback purposes</param>
		public override void Execute(TextArea textArea)
		{
			if (textArea.SelectionManager.HasSomethingSelected) {
				DeleteSelection(textArea);
			} else {
				if (textArea.IsReadOnly(textArea.Caret.Offset))
					return;
				
				if (textArea.Caret.Offset < textArea.Document.TextLength) {
					textArea.BeginUpdate();
					int curLineNr   = textArea.Document.GetLineNumberForOffset(textArea.Caret.Offset);
                    TextFileEdit.Document.LineSegment curLine = textArea.Document.GetLineSegment(curLineNr);
					
					if (curLine.Offset + curLine.Length == textArea.Caret.Offset) {
						if (curLineNr + 1 < textArea.Document.TotalNumberOfLines) {
                            TextFileEdit.Document.LineSegment nextLine = textArea.Document.GetLineSegment(curLineNr + 1);
							
							textArea.Document.Remove(textArea.Caret.Offset, nextLine.Offset - textArea.Caret.Offset);
							textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.PositionToEnd, new TextLocation(0, curLineNr)));
						}
					} else {
						textArea.Document.Remove(textArea.Caret.Offset, 1);
//						textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.PositionToLineEnd, new TextLocation(textArea.Caret.Offset - textArea.Document.GetLineSegment(curLineNr).Offset, curLineNr)));
					}
					textArea.UpdateMatchingBracket();
					textArea.EndUpdate();
				}
			}
		}
	}
	
	public class MovePageDown : AbstractEditAction
	{
		/// <remarks>
		/// Executes this edit action
		/// </remarks>
		/// <param name="textArea">The <see cref="ItextArea"/> which is used for callback purposes</param>
		public override void Execute(TextArea textArea)
		{
			int curLineNr           = textArea.Caret.Line;
			int requestedLineNumber = Math.Min(textArea.Document.GetNextVisibleLineAbove(curLineNr, textArea.TextView.VisibleLineCount), textArea.Document.TotalNumberOfLines - 1);
			
			if (curLineNr != requestedLineNumber) {
				textArea.Caret.Position = new TextLocation(0, requestedLineNumber);
				textArea.SetCaretToDesiredColumn();
			}
		}
	}
	
	public class MovePageUp : AbstractEditAction
	{
		/// <remarks>
		/// Executes this edit action
		/// </remarks>
		/// <param name="textArea">The <see cref="ItextArea"/> which is used for callback purposes</param>
		public override void Execute(TextArea textArea)
		{
			int curLineNr           = textArea.Caret.Line;
			int requestedLineNumber = Math.Max(textArea.Document.GetNextVisibleLineBelow(curLineNr, textArea.TextView.VisibleLineCount), 0);
			
			if (curLineNr != requestedLineNumber) {
				textArea.Caret.Position = new TextLocation(0, requestedLineNumber);
				textArea.SetCaretToDesiredColumn();
			}
		}
	}
	public class Return : AbstractEditAction
	{
		/// <remarks>
		/// Executes this edit action
		/// </remarks>
		/// <param name="textArea">The <see cref="TextArea"/> which is used for callback purposes</param>
		public override void Execute(TextArea textArea)
		{
			if (textArea.Document.ReadOnly) {
				return;
			}
			textArea.BeginUpdate();
			textArea.Document.UndoStack.StartUndoGroup();
			try {
				if (textArea.HandleKeyPress('\n'))
					return;
				
				textArea.InsertString(Environment.NewLine);
				
				int curLineNr = textArea.Caret.Line;
				textArea.Document.FormattingStrategy.FormatLine(textArea, curLineNr, textArea.Caret.Offset, '\n');
				textArea.SetDesiredColumn();
				
				textArea.Document.UpdateQueue.Clear();
				textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.PositionToEnd, new TextLocation(0, curLineNr - 1)));
			} finally {
				textArea.Document.UndoStack.EndUndoGroup();
				textArea.EndUpdate();
			}
		}
	}
	
	public class ToggleEditMode : AbstractEditAction
	{
		/// <remarks>
		/// Executes this edit action
		/// </remarks>
		/// <param name="textArea">The <see cref="ItextArea"/> which is used for callback purposes</param>
		public override void Execute(TextArea textArea)
		{
			if (textArea.Document.ReadOnly) {
				return;
			}
			switch (textArea.Caret.CaretMode) {
				case CaretMode.InsertMode:
					textArea.Caret.CaretMode = CaretMode.OverwriteMode;
					break;
				case CaretMode.OverwriteMode:
					textArea.Caret.CaretMode = CaretMode.InsertMode;
					break;
			}
		}
	}
	
	public class Undo : AbstractEditAction
	{
		/// <remarks>
		/// Executes this edit action
		/// </remarks>
		/// <param name="textArea">The <see cref="ItextArea"/> which is used for callback purposes</param>
		public override void Execute(TextArea textArea)
		{
			textArea.MotherTextEditorControl.Undo();
		}
	}
	
	public class Redo : AbstractEditAction
	{
		/// <remarks>
		/// Executes this edit action
		/// </remarks>
		/// <param name="textArea">The <see cref="ItextArea"/> which is used for callback purposes</param>
		public override void Execute(TextArea textArea)
		{
			textArea.MotherTextEditorControl.Redo();
		}
	}
	
	/// <summary>
	/// handles the ctrl-backspace key
	/// functionality attempts to roughly mimic MS Developer studio
	/// I will implement this as deleting back to the point that ctrl-leftarrow would
	/// take you to
	/// </summary>
	public class WordBackspace : AbstractEditAction
	{
		/// <remarks>
		/// Executes this edit action
		/// </remarks>
		/// <param name="textArea">The <see cref="ItextArea"/> which is used for callback purposes</param>
		public override void Execute(TextArea textArea)
		{
			// if anything is selected we will just delete it first
			if (textArea.SelectionManager.HasSomethingSelected) {
				Delete.DeleteSelection(textArea);
				return;
			}
			textArea.BeginUpdate();
			// now delete from the caret to the beginning of the word
            TextFileEdit.Document.LineSegment line =
				textArea.Document.GetLineSegmentForOffset(textArea.Caret.Offset);
			// if we are not at the beginning of a line
			if (textArea.Caret.Offset > line.Offset) {
                int prevWordStart = TextFileEdit.Document.TextUtilities.FindPrevWordStart(textArea.Document,
				                                                    textArea.Caret.Offset);
				if (prevWordStart < textArea.Caret.Offset) {
					if (!textArea.IsReadOnly(prevWordStart, textArea.Caret.Offset - prevWordStart)) {
						textArea.Document.Remove(prevWordStart,
						                         textArea.Caret.Offset - prevWordStart);
						textArea.Caret.Position = textArea.Document.OffsetToPosition(prevWordStart);
					}
				}
			}
			// if we are now at the beginning of a line
			if (textArea.Caret.Offset == line.Offset) {
				// if we are not on the first line
				int curLineNr = textArea.Document.GetLineNumberForOffset(textArea.Caret.Offset);
				if (curLineNr > 0) {
					// move to the end of the line above
                    TextFileEdit.Document.LineSegment lineAbove = textArea.Document.GetLineSegment(curLineNr - 1);
					int endOfLineAbove = lineAbove.Offset + lineAbove.Length;
					int charsToDelete = textArea.Caret.Offset - endOfLineAbove;
					if (!textArea.IsReadOnly(endOfLineAbove, charsToDelete)) {
						textArea.Document.Remove(endOfLineAbove, charsToDelete);
						textArea.Caret.Position = textArea.Document.OffsetToPosition(endOfLineAbove);
					}
				}
			}
			textArea.SetDesiredColumn();
			textArea.EndUpdate();
			// if there are now less lines, we need this or there are redraw problems
			textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.PositionToEnd, new TextLocation(0, textArea.Document.GetLineNumberForOffset(textArea.Caret.Offset))));
			textArea.Document.CommitUpdate();
		}
	}
	
	/// <summary>
	/// handles the ctrl-delete key
	/// functionality attempts to mimic MS Developer studio
	/// I will implement this as deleting forwardto the point that
	/// ctrl-leftarrow would take you to
	/// </summary>
	public class DeleteWord : Delete
	{
		/// <remarks>
		/// Executes this edit action
		/// </remarks>
		/// <param name="textArea">The <see cref="ItextArea"/> which is used for callback purposes</param>
		public override void Execute(TextArea textArea)
		{
			if (textArea.SelectionManager.HasSomethingSelected) {
				DeleteSelection(textArea);
				return;
			}
			// if anything is selected we will just delete it first
			textArea.BeginUpdate();
			// now delete from the caret to the beginning of the word
            TextFileEdit.Document.LineSegment line = textArea.Document.GetLineSegmentForOffset(textArea.Caret.Offset);
			if(textArea.Caret.Offset == line.Offset + line.Length) {
				// if we are at the end of a line
				base.Execute(textArea);
			} else {
                int nextWordStart = TextFileEdit.Document.TextUtilities.FindNextWordStart(textArea.Document,
				                                                    textArea.Caret.Offset);
				if(nextWordStart > textArea.Caret.Offset) {
					if (!textArea.IsReadOnly(textArea.Caret.Offset, nextWordStart - textArea.Caret.Offset)) {
						textArea.Document.Remove(textArea.Caret.Offset, nextWordStart - textArea.Caret.Offset);
						// cursor never moves with this command
					}
				}
			}
			textArea.UpdateMatchingBracket();
			textArea.EndUpdate();
			// if there are now less lines, we need this or there are redraw problems
			textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.PositionToEnd, new TextLocation(0, textArea.Document.GetLineNumberForOffset(textArea.Caret.Offset))));
			textArea.Document.CommitUpdate();
		}
	}
	
	public class DeleteLine : AbstractEditAction
	{
		public override void Execute(TextArea textArea)
		{
			int lineNr = textArea.Caret.Line;
            TextFileEdit.Document.LineSegment line = textArea.Document.GetLineSegment(lineNr);
			if (textArea.IsReadOnly(line.Offset, line.Length))
				return;
			textArea.Document.Remove(line.Offset, line.TotalLength);
			textArea.Caret.Position = textArea.Document.OffsetToPosition(line.Offset);

			textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.PositionToEnd, new TextLocation(0, lineNr)));
			textArea.UpdateMatchingBracket();
			textArea.Document.CommitUpdate();
		}
	}
	
	public class DeleteToLineEnd : AbstractEditAction
	{
		public override void Execute(TextArea textArea)
		{
			int lineNr = textArea.Caret.Line;
            TextFileEdit.Document.LineSegment line = textArea.Document.GetLineSegment(lineNr);
			
			int numRemove = (line.Offset + line.Length) - textArea.Caret.Offset;
			if (numRemove > 0 && !textArea.IsReadOnly(textArea.Caret.Offset, numRemove)) {
				textArea.Document.Remove(textArea.Caret.Offset, numRemove);
				textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.SingleLine, new TextLocation(0, lineNr)));
				textArea.Document.CommitUpdate();
			}
		}
	}
	
	public class GotoMatchingBrace : AbstractEditAction
	{
		public override void Execute(TextArea textArea)
		{
			Highlight highlight = textArea.FindMatchingBracketHighlight();
			if (highlight != null) {
				TextLocation p1 = new TextLocation(highlight.CloseBrace.X + 1, highlight.CloseBrace.Y);
				TextLocation p2 = new TextLocation(highlight.OpenBrace.X + 1, highlight.OpenBrace.Y);
				if (p1 == textArea.Caret.Position) {
                    if (textArea.Document.TextEditorProperties.BracketMatchingStyle == TextFileEdit.Document.BracketMatchingStyle.After)
                    {
						textArea.Caret.Position = p2;
					} else {
						textArea.Caret.Position = new TextLocation(p2.X - 1, p2.Y);
					}
				} else {
                    if (textArea.Document.TextEditorProperties.BracketMatchingStyle == TextFileEdit.Document.BracketMatchingStyle.After)
                    {
						textArea.Caret.Position = p1;
					} else {
						textArea.Caret.Position = new TextLocation(p1.X - 1, p1.Y);
					}
				}
				textArea.SetDesiredColumn();
			}
		}
	}
}

#endif
// file ...\TextFileEdit\Actions\SelectionActions.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2659 $</version>
// </file>


namespace TextFileEdit.Actions
{
	public class ShiftCaretRight : CaretRight
	{
		public override void Execute(TextArea textArea)
		{
			TextLocation oldCaretPos  = textArea.Caret.Position;
			base.Execute(textArea);
			textArea.AutoClearSelection = false;
			textArea.SelectionManager.ExtendSelection(oldCaretPos, textArea.Caret.Position);
		}
	}
	
	public class ShiftCaretLeft : CaretLeft
	{
		public override void Execute(TextArea textArea)
		{
			TextLocation oldCaretPos  = textArea.Caret.Position;
			base.Execute(textArea);
			textArea.AutoClearSelection = false;
			textArea.SelectionManager.ExtendSelection(oldCaretPos, textArea.Caret.Position);
		}
	}
	
	public class ShiftCaretUp : CaretUp
	{
		public override void Execute(TextArea textArea)
		{
			TextLocation oldCaretPos  = textArea.Caret.Position;
			base.Execute(textArea);
			textArea.AutoClearSelection = false;
			textArea.SelectionManager.ExtendSelection(oldCaretPos, textArea.Caret.Position);
		}
	}
	
	public class ShiftCaretDown : CaretDown
	{
		public override void Execute(TextArea textArea)
		{
			TextLocation oldCaretPos  = textArea.Caret.Position;
			base.Execute(textArea);
			textArea.AutoClearSelection = false;
			textArea.SelectionManager.ExtendSelection(oldCaretPos, textArea.Caret.Position);
		}
	}
	
	public class ShiftWordRight : WordRight
	{
		public override void Execute(TextArea textArea)
		{
			TextLocation oldCaretPos  = textArea.Caret.Position;
			base.Execute(textArea);
			textArea.AutoClearSelection = false;
			textArea.SelectionManager.ExtendSelection(oldCaretPos, textArea.Caret.Position);
		}
	}
	
	public class ShiftWordLeft : WordLeft
	{
		public override void Execute(TextArea textArea)
		{
			TextLocation oldCaretPos  = textArea.Caret.Position;
			base.Execute(textArea);
			textArea.AutoClearSelection = false;
			textArea.SelectionManager.ExtendSelection(oldCaretPos, textArea.Caret.Position);
		}
	}
	
	public class ShiftHome : Home
	{
		public override void Execute(TextArea textArea)
		{
			TextLocation oldCaretPos  = textArea.Caret.Position;
			base.Execute(textArea);
			textArea.AutoClearSelection = false;
			textArea.SelectionManager.ExtendSelection(oldCaretPos, textArea.Caret.Position);
		}
	}
	
	public class ShiftEnd : End
	{
		public override void Execute(TextArea textArea)
		{
			TextLocation oldCaretPos  = textArea.Caret.Position;
			base.Execute(textArea);
			textArea.AutoClearSelection = false;
			textArea.SelectionManager.ExtendSelection(oldCaretPos, textArea.Caret.Position);
		}
	}
	
	public class ShiftMoveToStart : MoveToStart
	{
		public override void Execute(TextArea textArea)
		{
			TextLocation oldCaretPos  = textArea.Caret.Position;
			base.Execute(textArea);
			textArea.AutoClearSelection = false;
			textArea.SelectionManager.ExtendSelection(oldCaretPos, textArea.Caret.Position);
		}
	}
	
	public class ShiftMoveToEnd : MoveToEnd
	{
		public override void Execute(TextArea textArea)
		{
			TextLocation oldCaretPos  = textArea.Caret.Position;
			base.Execute(textArea);
			textArea.AutoClearSelection = false;
			textArea.SelectionManager.ExtendSelection(oldCaretPos, textArea.Caret.Position);
		}
	}
	
	public class ShiftMovePageUp : MovePageUp
	{
		public override void Execute(TextArea textArea)
		{
			TextLocation oldCaretPos  = textArea.Caret.Position;
			base.Execute(textArea);
			textArea.AutoClearSelection = false;
			textArea.SelectionManager.ExtendSelection(oldCaretPos, textArea.Caret.Position);
		}
	}
	
	public class ShiftMovePageDown : MovePageDown
	{
		public override void Execute(TextArea textArea)
		{
			TextLocation oldCaretPos  = textArea.Caret.Position;
			base.Execute(textArea);
			textArea.AutoClearSelection = false;
			textArea.SelectionManager.ExtendSelection(oldCaretPos, textArea.Caret.Position);
		}
	}
	
	public class SelectWholeDocument : AbstractEditAction
	{
		public override void Execute(TextArea textArea)
		{
			textArea.AutoClearSelection = false;
			TextLocation startPoint = new TextLocation(0, 0);
			TextLocation endPoint   = textArea.Document.OffsetToPosition(textArea.Document.TextLength);
			if (textArea.SelectionManager.HasSomethingSelected) {
				if (textArea.SelectionManager.SelectionCollection[0].StartPosition == startPoint &&
				    textArea.SelectionManager.SelectionCollection[0].EndPosition   == endPoint) {
					return;
				}
			}
			textArea.Caret.Position = textArea.SelectionManager.NextValidPosition(endPoint.Y);
			textArea.SelectionManager.ExtendSelection(startPoint, endPoint);
			// after a SelectWholeDocument selection, the caret is placed correctly,
			// but it is not positioned internally.  The effect is when the cursor
			// is moved up or down a line, the caret will take on the column that
			// it was in before the SelectWholeDocument
			textArea.SetDesiredColumn();
		}
	}
	
	public class ClearAllSelections : AbstractEditAction
	{
		public override void Execute(TextArea textArea)
		{
			textArea.SelectionManager.ClearSelection();
		}
	}
}

#endif
// file ...\TextFileEdit\Document\AbstractSegment.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1965 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// This interface is used to describe a span inside a text sequence
	/// </summary>
	public class AbstractSegment : ISegment
	{
		[CLSCompliant(false)]
		protected int offset = -1;
		[CLSCompliant(false)]
		protected int length = -1;
		
		#region TextFileEdit.Document.ISegment interface implementation
		public virtual int Offset {
			get {
				return offset;
			}
			set {
				offset = value;
			}
		}
		
		public virtual int Length {
			get {
				return length;
			}
			set {
				length = value;
			}
		}
		
		#endregion
		
		public override string ToString()
		{
			return String.Format("[AbstractSegment: Offset = {0}, Length = {1}]",
			                     Offset,
			                     Length);
		}
		
		
	}
}

#endif
// file ...\TextFileEdit\Document\DefaultDocument.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3205 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// Describes the caret marker
	/// </summary>
	public enum LineViewerStyle {
		/// <summary>
		/// No line viewer will be displayed
		/// </summary>
		None,
		
		/// <summary>
		/// The row in which the caret is will be marked
		/// </summary>
		FullRow
	}
	
	/// <summary>
	/// Describes the indent style
	/// </summary>
	public enum IndentStyle {
		/// <summary>
		/// No indentation occurs
		/// </summary>
		None,
		
		/// <summary>
		/// The indentation from the line above will be
		/// taken to indent the curent line
		/// </summary>
		Auto,
		
		/// <summary>
		/// Inteligent, context sensitive indentation will occur
		/// </summary>
		Smart
	}
	
	/// <summary>
	/// Describes the bracket highlighting style
	/// </summary>
	public enum BracketHighlightingStyle {
		
		/// <summary>
		/// Brackets won't be highlighted
		/// </summary>
		None,
		
		/// <summary>
		/// Brackets will be highlighted if the caret is on the bracket
		/// </summary>
		OnBracket,
		
		/// <summary>
		/// Brackets will be highlighted if the caret is after the bracket
		/// </summary>
		AfterBracket
	}
	
	/// <summary>
	/// Describes the selection mode of the text area
	/// </summary>
	public enum DocumentSelectionMode {
		/// <summary>
		/// The 'normal' selection mode.
		/// </summary>
		Normal,
		
		/// <summary>
		/// Selections will be added to the current selection or new
		/// ones will be created (multi-select mode)
		/// </summary>
		Additive
	}
	
	/// <summary>
	/// The default <see cref="IDocument"/> implementation.
	/// </summary>
	public sealed class DefaultDocument : IDocument
	{
		bool readOnly = false;
		
		LineManager           lineTrackingStrategy;
		BookmarkManager       bookmarkManager;
		ITextBufferStrategy   textBufferStrategy;
		IFormattingStrategy   formattingStrategy;
		FoldingManager        foldingManager;
        TextFileEdit.Undo.UndoStack undoStack = new TextFileEdit.Undo.UndoStack();
		ITextEditorProperties textEditorProperties = new DefaultTextEditorProperties();
		MarkerStrategy        markerStrategy;
		
		public LineManager LineManager {
			get { return lineTrackingStrategy; }
			set { lineTrackingStrategy = value; }
		}
		
		public event EventHandler<LineLengthChangeEventArgs> LineLengthChanged {
			add { lineTrackingStrategy.LineLengthChanged += value; }
			remove { lineTrackingStrategy.LineLengthChanged -= value; }
		}
		public event EventHandler<LineCountChangeEventArgs> LineCountChanged {
			add { lineTrackingStrategy.LineCountChanged += value; }
			remove { lineTrackingStrategy.LineCountChanged -= value; }
		}
		public event EventHandler<LineEventArgs> LineDeleted {
			add { lineTrackingStrategy.LineDeleted += value; }
			remove { lineTrackingStrategy.LineDeleted -= value; }
		}
		
		public MarkerStrategy MarkerStrategy {
			get { return markerStrategy; }
			set { markerStrategy = value; }
		}
		
		public ITextEditorProperties TextEditorProperties {
			get {
				return textEditorProperties;
			}
			set {
				textEditorProperties = value;
			}
		}

        public TextFileEdit.Undo.UndoStack UndoStack
        {
			get {
				return undoStack;
			}
		}
		
		public IList<LineSegment> LineSegmentCollection {
			get {
				return lineTrackingStrategy.LineSegmentCollection;
			}
		}
		
		public bool ReadOnly {
			get {
				return readOnly;
			}
			set {
				readOnly = value;
			}
		}
		
		public ITextBufferStrategy TextBufferStrategy {
			get {
				return textBufferStrategy;
			}
			set {
				textBufferStrategy = value;
			}
		}
		
		public IFormattingStrategy FormattingStrategy {
			get {
				return formattingStrategy;
			}
			set {
				formattingStrategy = value;
			}
		}
		
		public FoldingManager FoldingManager {
			get {
				return foldingManager;
			}
			set {
				foldingManager = value;
			}
		}
		
		public IHighlightingStrategy HighlightingStrategy {
			get {
				return lineTrackingStrategy.HighlightingStrategy;
			}
			set {
				lineTrackingStrategy.HighlightingStrategy = value;
			}
		}
		
		public int TextLength {
			get {
				return textBufferStrategy.Length;
			}
		}
		
		public BookmarkManager BookmarkManager {
			get {
				return bookmarkManager;
			}
			set {
				bookmarkManager = value;
			}
		}
		
		
		public string TextContent {
			get {
				return GetText(0, textBufferStrategy.Length);
			}
			set {
				Debug.Assert(textBufferStrategy != null);
				Debug.Assert(lineTrackingStrategy != null);
				OnDocumentAboutToBeChanged(new DocumentEventArgs(this, 0, 0, value));
				textBufferStrategy.SetContent(value);
				lineTrackingStrategy.SetContent(value);
				undoStack.ClearAll();
				
				OnDocumentChanged(new DocumentEventArgs(this, 0, 0, value));
				OnTextContentChanged(EventArgs.Empty);
			}
		}
		
		public void Insert(int offset, string text)
		{
			if (readOnly) {
				return;
			}
			OnDocumentAboutToBeChanged(new DocumentEventArgs(this, offset, -1, text));
			
			textBufferStrategy.Insert(offset, text);
			lineTrackingStrategy.Insert(offset, text);

            undoStack.Push(new TextFileEdit.Undo.UndoableInsert(this, offset, text));
			
			OnDocumentChanged(new DocumentEventArgs(this, offset, -1, text));
		}
		
		public void Remove(int offset, int length)
		{
			if (readOnly) {
				return;
			}
			OnDocumentAboutToBeChanged(new DocumentEventArgs(this, offset, length));
			undoStack.Push(new TextFileEdit.Undo.UndoableDelete(this, offset, GetText(offset, length)));
			
			textBufferStrategy.Remove(offset, length);
			lineTrackingStrategy.Remove(offset, length);
			
			OnDocumentChanged(new DocumentEventArgs(this, offset, length));
		}
		
		public void Replace(int offset, int length, string text)
		{
			if (readOnly) {
				return;
			}
			OnDocumentAboutToBeChanged(new DocumentEventArgs(this, offset, length, text));
            undoStack.Push(new TextFileEdit.Undo.UndoableReplace(this, offset, GetText(offset, length), text));
			
			textBufferStrategy.Replace(offset, length, text);
			lineTrackingStrategy.Replace(offset, length, text);
			
			OnDocumentChanged(new DocumentEventArgs(this, offset, length, text));
		}
		
		public char GetCharAt(int offset)
		{
			return textBufferStrategy.GetCharAt(offset);
		}
		
		public string GetText(int offset, int length)
		{
			#if DEBUG
			if (length < 0) throw new ArgumentOutOfRangeException("length", length, "length < 0");
			#endif
			return textBufferStrategy.GetText(offset, length);
		}
		public string GetText(ISegment segment)
		{
			return GetText(segment.Offset, segment.Length);
		}
		
		public int TotalNumberOfLines {
			get {
				return lineTrackingStrategy.TotalNumberOfLines;
			}
		}
		
		public int GetLineNumberForOffset(int offset)
		{
			return lineTrackingStrategy.GetLineNumberForOffset(offset);
		}
		
		public LineSegment GetLineSegmentForOffset(int offset)
		{
			return lineTrackingStrategy.GetLineSegmentForOffset(offset);
		}
		
		public LineSegment GetLineSegment(int line)
		{
			return lineTrackingStrategy.GetLineSegment(line);
		}
		
		public int GetFirstLogicalLine(int lineNumber)
		{
			return lineTrackingStrategy.GetFirstLogicalLine(lineNumber);
		}
		
		public int GetLastLogicalLine(int lineNumber)
		{
			return lineTrackingStrategy.GetLastLogicalLine(lineNumber);
		}
		
		public int GetVisibleLine(int lineNumber)
		{
			return lineTrackingStrategy.GetVisibleLine(lineNumber);
		}
		
//		public int GetVisibleColumn(int logicalLine, int logicalColumn)
//		{
//			return lineTrackingStrategy.GetVisibleColumn(logicalLine, logicalColumn);
//		}
//
		public int GetNextVisibleLineAbove(int lineNumber, int lineCount)
		{
			return lineTrackingStrategy.GetNextVisibleLineAbove(lineNumber, lineCount);
		}
		
		public int GetNextVisibleLineBelow(int lineNumber, int lineCount)
		{
			return lineTrackingStrategy.GetNextVisibleLineBelow(lineNumber, lineCount);
		}
		
		public TextLocation OffsetToPosition(int offset)
		{
			int lineNr = GetLineNumberForOffset(offset);
			LineSegment line = GetLineSegment(lineNr);
			return new TextLocation(offset - line.Offset, lineNr);
		}
		
		public int PositionToOffset(TextLocation p)
		{
			if (p.Y >= this.TotalNumberOfLines) {
				return 0;
			}
			LineSegment line = GetLineSegment(p.Y);
			return Math.Min(this.TextLength, line.Offset + Math.Min(line.Length, p.X));
		}
		
		public void UpdateSegmentListOnDocumentChange<T>(List<T> list, DocumentEventArgs e) where T : ISegment
		{
			int removedCharacters = e.Length > 0 ? e.Length : 0;
			int insertedCharacters = e.Text != null ? e.Text.Length : 0;
			for (int i = 0; i < list.Count; ++i) {
				ISegment s = list[i];
				int segmentStart = s.Offset;
				int segmentEnd = s.Offset + s.Length;
				
				if (e.Offset <= segmentStart) {
					segmentStart -= removedCharacters;
					if (segmentStart < e.Offset)
						segmentStart = e.Offset;
				}
				if (e.Offset < segmentEnd) {
					segmentEnd -= removedCharacters;
					if (segmentEnd < e.Offset)
						segmentEnd = e.Offset;
				}
				
				Debug.Assert(segmentStart <= segmentEnd);
				
				if (segmentStart == segmentEnd) {
					list.RemoveAt(i);
					--i;
					continue;
				}
				
				if (e.Offset <= segmentStart)
					segmentStart += insertedCharacters;
				if (e.Offset < segmentEnd)
					segmentEnd += insertedCharacters;
				
				Debug.Assert(segmentStart < segmentEnd);
				
				s.Offset = segmentStart;
				s.Length = segmentEnd - segmentStart;
			}
		}
		
		void OnDocumentAboutToBeChanged(DocumentEventArgs e)
		{
			if (DocumentAboutToBeChanged != null) {
				DocumentAboutToBeChanged(this, e);
			}
		}
		
		void OnDocumentChanged(DocumentEventArgs e)
		{
			if (DocumentChanged != null) {
				DocumentChanged(this, e);
			}
		}
		
		public event DocumentEventHandler DocumentAboutToBeChanged;
		public event DocumentEventHandler DocumentChanged;
		
		// UPDATE STUFF
		List<TextAreaUpdate> updateQueue = new List<TextAreaUpdate>();
		
		public List<TextAreaUpdate> UpdateQueue {
			get {
				return updateQueue;
			}
		}
		
		public void RequestUpdate(TextAreaUpdate update)
		{
			if (updateQueue.Count == 1 && updateQueue[0].TextAreaUpdateType == TextAreaUpdateType.WholeTextArea) {
				// if we're going to update the whole text area, we don't need to store detail updates
				return;
			}
			if (update.TextAreaUpdateType == TextAreaUpdateType.WholeTextArea) {
				// if we're going to update the whole text area, we don't need to store detail updates
				updateQueue.Clear();
			}
			updateQueue.Add(update);
		}
		
		public void CommitUpdate()
		{
			if (UpdateCommited != null) {
				UpdateCommited(this, EventArgs.Empty);
			}
		}
		
		void OnTextContentChanged(EventArgs e)
		{
			if (TextContentChanged != null) {
				TextContentChanged(this, e);
			}
		}
		
		public event EventHandler UpdateCommited;
		public event EventHandler TextContentChanged;
		
		[Conditional("DEBUG")]
		internal static void ValidatePosition(IDocument document, TextLocation position)
		{
			document.GetLineSegment(position.Line);
		}
	}
}

#endif
// file ...\TextFileEdit\Document\DefaultTextEditorProperties.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="none" email=""/>
//     <version>$Revision: 3440 $</version>
// </file>


namespace TextFileEdit.Document
{
	public enum BracketMatchingStyle {
		Before,
		After
	}
	
	public class DefaultTextEditorProperties : ITextEditorProperties
	{
		int                   tabIndent             = 4;
		int                   indentationSize       = 4;
		IndentStyle           indentStyle           = IndentStyle.Smart;
		DocumentSelectionMode documentSelectionMode = DocumentSelectionMode.Normal;
		Encoding              encoding              = System.Text.Encoding.UTF8;
		BracketMatchingStyle  bracketMatchingStyle  = BracketMatchingStyle.After;
		FontContainer fontContainer;
		static Font DefaultFont;
		
		public DefaultTextEditorProperties()
		{
			if (DefaultFont == null) {
				DefaultFont = new Font("Courier New", 10);
			}
			this.fontContainer = new FontContainer(DefaultFont);
		}
		
		bool        allowCaretBeyondEOL = false;

		bool        caretLine           = false;
		
		bool        showMatchingBracket = true;
		bool        showLineNumbers     = true;
		
		bool        showSpaces          = false;
		bool        showTabs            = false;
		bool        showEOLMarker       = false;
		
		bool        showInvalidLines    = false;
		
		bool        isIconBarVisible    = false;
		bool        enableFolding       = true;
		bool        showHorizontalRuler = false;
		bool        showVerticalRuler   = true;
		bool        convertTabsToSpaces = false;
		System.Drawing.Text.TextRenderingHint textRenderingHint = System.Drawing.Text.TextRenderingHint.SystemDefault;
		bool        mouseWheelScrollDown = true;
		bool        mouseWheelTextZoom   = true;
		
		bool        hideMouseCursor      = false;
		bool        cutCopyWholeLine     = true;
		
		int         verticalRulerRow    = 80;
		LineViewerStyle  lineViewerStyle = LineViewerStyle.None;
		string      lineTerminator = "\r\n";
		bool        autoInsertCurlyBracket = true;
		bool        supportReadOnlySegments = false;
		
		public int TabIndent {
			get {
				return tabIndent;
			}
			set {
				tabIndent = value;
			}
		}

		public int IndentationSize {
			get { return indentationSize; }
			set { indentationSize = value; }
		}
		
		public IndentStyle IndentStyle {
			get {
				return indentStyle;
			}
			set {
				indentStyle = value;
			}
		}

		public bool CaretLine {
			get
			{
				return caretLine;
			}
			set
			{
				caretLine = value;
			}
		}

		public DocumentSelectionMode DocumentSelectionMode {
			get {
				return documentSelectionMode;
			}
			set {
				documentSelectionMode = value;
			}
		}
		public bool AllowCaretBeyondEOL {
			get {
				return allowCaretBeyondEOL;
			}
			set {
				allowCaretBeyondEOL = value;
			}
		}
		public bool ShowMatchingBracket {
			get {
				return showMatchingBracket;
			}
			set {
				showMatchingBracket = value;
			}
		}
		public bool ShowLineNumbers {
			get {
				return showLineNumbers;
			}
			set {
				showLineNumbers = value;
			}
		}
		public bool ShowSpaces {
			get {
				return showSpaces;
			}
			set {
				showSpaces = value;
			}
		}
		public bool ShowTabs {
			get {
				return showTabs;
			}
			set {
				showTabs = value;
			}
		}
		public bool ShowEOLMarker {
			get {
				return showEOLMarker;
			}
			set {
				showEOLMarker = value;
			}
		}
		public bool ShowInvalidLines {
			get {
				return showInvalidLines;
			}
			set {
				showInvalidLines = value;
			}
		}
		public bool IsIconBarVisible {
			get {
				return isIconBarVisible;
			}
			set {
				isIconBarVisible = value;
			}
		}
		public bool EnableFolding {
			get {
				return enableFolding;
			}
			set {
				enableFolding = value;
			}
		}
		public bool ShowHorizontalRuler {
			get {
				return showHorizontalRuler;
			}
			set {
				showHorizontalRuler = value;
			}
		}
		public bool ShowVerticalRuler {
			get {
				return showVerticalRuler;
			}
			set {
				showVerticalRuler = value;
			}
		}
		public bool ConvertTabsToSpaces {
			get {
				return convertTabsToSpaces;
			}
			set {
				convertTabsToSpaces = value;
			}
		}
		public System.Drawing.Text.TextRenderingHint TextRenderingHint {
			get { return textRenderingHint; }
			set { textRenderingHint = value; }
		}
		
		public bool MouseWheelScrollDown {
			get {
				return mouseWheelScrollDown;
			}
			set {
				mouseWheelScrollDown = value;
			}
		}
		public bool MouseWheelTextZoom {
			get {
				return mouseWheelTextZoom;
			}
			set {
				mouseWheelTextZoom = value;
			}
		}
		
		public bool HideMouseCursor {
			get {
				return hideMouseCursor;
			}
			set {
				hideMouseCursor = value;
			}
		}

		public bool CutCopyWholeLine {
			get {
				return cutCopyWholeLine;
			}
			set {
				cutCopyWholeLine = value;
			}
		}

		public Encoding Encoding {
			get {
				return encoding;
			}
			set {
				encoding = value;
			}
		}
		public int VerticalRulerRow {
			get {
				return verticalRulerRow;
			}
			set {
				verticalRulerRow = value;
			}
		}
		public LineViewerStyle LineViewerStyle {
			get {
				return lineViewerStyle;
			}
			set {
				lineViewerStyle = value;
			}
		}
		public string LineTerminator {
			get {
				return lineTerminator;
			}
			set {
				lineTerminator = value;
			}
		}
		public bool AutoInsertCurlyBracket {
			get {
				return autoInsertCurlyBracket;
			}
			set {
				autoInsertCurlyBracket = value;
			}
		}
		
		public Font Font {
			get {
				return fontContainer.DefaultFont;
			}
			set {
				fontContainer.DefaultFont = value;
			}
		}
		
		public FontContainer FontContainer {
			get {
				return fontContainer;
			}
		}
		
		public BracketMatchingStyle  BracketMatchingStyle {
			get {
				return bracketMatchingStyle;
			}
			set {
				bracketMatchingStyle = value;
			}
		}
		
		public bool SupportReadOnlySegments {
			get {
				return supportReadOnlySegments;
			}
			set {
				supportReadOnlySegments = value;
			}
		}
	}
}

#endif
// file ...\TextFileEdit\Document\DocumentEventArgs.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 915 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// This delegate is used for document events.
	/// </summary>
	public delegate void DocumentEventHandler(object sender, DocumentEventArgs e);
	
	/// <summary>
	/// This class contains more information on a document event
	/// </summary>
	public class DocumentEventArgs : EventArgs
	{
		IDocument document;
		int       offset;
		int       length;
		string    text;
		
		/// <returns>
		/// always a valid Document which is related to the Event.
		/// </returns>
		public IDocument Document {
			get {
				return document;
			}
		}
		
		/// <returns>
		/// -1 if no offset was specified for this event
		/// </returns>
		public int Offset {
			get {
				return offset;
			}
		}
		
		/// <returns>
		/// null if no text was specified for this event
		/// </returns>
		public string Text {
			get {
				return text;
			}
		}
		
		/// <returns>
		/// -1 if no length was specified for this event
		/// </returns>
		public int Length {
			get {
				return length;
			}
		}
		
		/// <summary>
		/// Creates a new instance off <see cref="DocumentEventArgs"/>
		/// </summary>
		public DocumentEventArgs(IDocument document) : this(document, -1, -1, null)
		{
		}
		
		/// <summary>
		/// Creates a new instance off <see cref="DocumentEventArgs"/>
		/// </summary>
		public DocumentEventArgs(IDocument document, int offset) : this(document, offset, -1, null)
		{
		}
		
		/// <summary>
		/// Creates a new instance off <see cref="DocumentEventArgs"/>
		/// </summary>
		public DocumentEventArgs(IDocument document, int offset, int length) : this(document, offset, length, null)
		{
		}
		
		/// <summary>
		/// Creates a new instance off <see cref="DocumentEventArgs"/>
		/// </summary>
		public DocumentEventArgs(IDocument document, int offset, int length, string text)
		{
			this.document = document;
			this.offset   = offset;
			this.length   = length;
			this.text     = text;
		}
		public override string ToString()
		{
			return String.Format("[DocumentEventArgs: Document = {0}, Offset = {1}, Text = {2}, Length = {3}]",
			                     Document,
			                     Offset,
			                     Text,
			                     Length);
		}
	}
}

#endif
// file ...\TextFileEdit\Document\DocumentFactory.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3205 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// This interface represents a container which holds a text sequence and
	/// all necessary information about it. It is used as the base for a text editor.
	/// </summary>
	public class DocumentFactory
	{
		/// <remarks>
		/// Creates a new <see cref="IDocument"/> object. Only create
		/// <see cref="IDocument"/> with this method.
		/// </remarks>
		public IDocument CreateDocument()
		{
			DefaultDocument doc = new DefaultDocument();
			doc.TextBufferStrategy  = new GapTextBufferStrategy();
			doc.FormattingStrategy  = new DefaultFormattingStrategy();
			doc.LineManager         = new LineManager(doc, null);
			doc.FoldingManager      = new FoldingManager(doc, doc.LineManager);
			doc.FoldingManager.FoldingStrategy       = null; //new ParserFoldingStrategy();
			doc.MarkerStrategy      = new MarkerStrategy(doc);
			doc.BookmarkManager     = new BookmarkManager(doc, doc.LineManager);
			return doc;
		}
		
		/// <summary>
		/// Creates a new document and loads the given file
		/// </summary>
		public IDocument CreateFromTextBuffer(ITextBufferStrategy textBuffer)
		{
			DefaultDocument doc = (DefaultDocument)CreateDocument();
			doc.TextContent = textBuffer.GetText(0, textBuffer.Length);
			doc.TextBufferStrategy = textBuffer;
			return doc;
		}
		
		/// <summary>
		/// Creates a new document and loads the given file
		/// </summary>
		public IDocument CreateFromFile(string fileName)
		{
			IDocument document = CreateDocument();
			document.TextContent = Util.FileReader.ReadFileContent(fileName, Encoding.Default);
			return document;
		}
	}
}

#endif
// file ...\TextFileEdit\Document\IDocument.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3205 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// This interface represents a container which holds a text sequence and
	/// all necessary information about it. It is used as the base for a text editor.
	/// </summary>
	public interface IDocument
	{
		ITextEditorProperties TextEditorProperties {
			get;
			set;
		}

        TextFileEdit.Undo.UndoStack UndoStack
        {
			get;
		}
		/// <value>
		/// If true the document can't be altered
		/// </value>
		bool ReadOnly {
			get;
			set;
		}
		
		/// <summary>
		/// The <see cref="IFormattingStrategy"/> attached to the <see cref="IDocument"/> instance
		/// </summary>
		IFormattingStrategy FormattingStrategy {
			get;
			set;
		}
		
		/// <summary>
		/// The <see cref="ITextBufferStrategy"/> attached to the <see cref="IDocument"/> instance
		/// </summary>
		ITextBufferStrategy TextBufferStrategy {
			get;
		}
		
		/// <summary>
		/// The <see cref="FoldingManager"/> attached to the <see cref="IDocument"/> instance
		/// </summary>
		FoldingManager FoldingManager {
			get;
		}
		
		/// <summary>
		/// The <see cref="IHighlightingStrategy"/> attached to the <see cref="IDocument"/> instance
		/// </summary>
		IHighlightingStrategy HighlightingStrategy {
			get;
			set;
		}
		
		/// <summary>
		/// The <see cref="IBookMarkManager"/> attached to the <see cref="IDocument"/> instance
		/// </summary>
		BookmarkManager BookmarkManager {
			get;
		}
		
		MarkerStrategy MarkerStrategy {
			get;
		}
		
//		/// <summary>
//		/// The <see cref="SelectionManager"/> attached to the <see cref="IDocument"/> instance
//		/// </summary>
//		SelectionManager SelectionManager {
//			get;
//		}
		
		#region ILineManager interface
		/// <value>
		/// A collection of all line segments
		/// </value>
		/// <remarks>
		/// The collection should only be used if you're aware
		/// of the 'last line ends with a delimiter problem'. Otherwise
		/// the <see cref="GetLineSegment"/> method should be used.
		/// </remarks>
		IList<LineSegment> LineSegmentCollection {
			get;
		}
		
		/// <value>
		/// The total number of lines in the document.
		/// </value>
		int TotalNumberOfLines {
			get;
		}
		
		/// <remarks>
		/// Returns a valid line number for the given offset.
		/// </remarks>
		/// <param name="offset">
		/// A offset which points to a character in the line which
		/// line number is returned.
		/// </param>
		/// <returns>
		/// An int which value is the line number.
		/// </returns>
		/// <exception cref="System.ArgumentException">If offset points not to a valid position</exception>
		int GetLineNumberForOffset(int offset);
		
		/// <remarks>
		/// Returns a <see cref="LineSegment"/> for the given offset.
		/// </remarks>
		/// <param name="offset">
		/// A offset which points to a character in the line which
		/// is returned.
		/// </param>
		/// <returns>
		/// A <see cref="LineSegment"/> object.
		/// </returns>
		/// <exception cref="System.ArgumentException">If offset points not to a valid position</exception>
		LineSegment GetLineSegmentForOffset(int offset);
		
		/// <remarks>
		/// Returns a <see cref="LineSegment"/> for the given line number.
		/// This function should be used to get a line instead of getting the
		/// line using the <see cref="ArrayList"/>.
		/// </remarks>
		/// <param name="lineNumber">
		/// The line number which is requested.
		/// </param>
		/// <returns>
		/// A <see cref="LineSegment"/> object.
		/// </returns>
		/// <exception cref="System.ArgumentException">If offset points not to a valid position</exception>
		LineSegment GetLineSegment(int lineNumber);
		
		/// <remarks>
		/// Get the first logical line for a given visible line.
		/// example : lineNumber == 100 foldings are in the linetracker
		/// between 0..1 (2 folded, invisible lines) this method returns 102
		/// the 'logical' line number
		/// </remarks>
		int GetFirstLogicalLine(int lineNumber);
		
		/// <remarks>
		/// Get the last logical line for a given visible line.
		/// example : lineNumber == 100 foldings are in the linetracker
		/// between 0..1 (2 folded, invisible lines) this method returns 102
		/// the 'logical' line number
		/// </remarks>
		int GetLastLogicalLine(int lineNumber);
		
		/// <remarks>
		/// Get the visible line for a given logical line.
		/// example : lineNumber == 100 foldings are in the linetracker
		/// between 0..1 (2 folded, invisible lines) this method returns 98
		/// the 'visible' line number
		/// </remarks>
		int GetVisibleLine(int lineNumber);
		
//		/// <remarks>
//		/// Get the visible column for a given logical line and logical column.
//		/// </remarks>
//		int GetVisibleColumn(int logicalLine, int logicalColumn);
		
		/// <remarks>
		/// Get the next visible line after lineNumber
		/// </remarks>
		int GetNextVisibleLineAbove(int lineNumber, int lineCount);
		
		/// <remarks>
		/// Get the next visible line below lineNumber
		/// </remarks>
		int GetNextVisibleLineBelow(int lineNumber, int lineCount);
		
		event EventHandler<LineLengthChangeEventArgs> LineLengthChanged;
		event EventHandler<LineCountChangeEventArgs> LineCountChanged;
		event EventHandler<LineEventArgs> LineDeleted;
		#endregion

		#region ITextBufferStrategy interface
		/// <value>
		/// Get the whole text as string.
		/// When setting the text using the TextContent property, the undo stack is cleared.
		/// Set TextContent only for actions such as loading a file; if you want to change the current document
		/// use the Replace method instead.
		/// </value>
		string TextContent {
			get;
			set;
		}
		
		/// <value>
		/// The current length of the sequence of characters that can be edited.
		/// </value>
		int TextLength {
			get;
		}
		
		/// <summary>
		/// Inserts a string of characters into the sequence.
		/// </summary>
		/// <param name="offset">
		/// offset where to insert the string.
		/// </param>
		/// <param name="text">
		/// text to be inserted.
		/// </param>
		void Insert(int offset, string text);
		
		/// <summary>
		/// Removes some portion of the sequence.
		/// </summary>
		/// <param name="offset">
		/// offset of the remove.
		/// </param>
		/// <param name="length">
		/// number of characters to remove.
		/// </param>
		void Remove(int offset, int length);
		
		/// <summary>
		/// Replace some portion of the sequence.
		/// </summary>
		/// <param name="offset">
		/// offset.
		/// </param>
		/// <param name="length">
		/// number of characters to replace.
		/// </param>
		/// <param name="text">
		/// text to be replaced with.
		/// </param>
		void Replace(int offset, int length, string text);
		
		/// <summary>
		/// Returns a specific char of the sequence.
		/// </summary>
		/// <param name="offset">
		/// Offset of the char to get.
		/// </param>
		char GetCharAt(int offset);
		
		/// <summary>
		/// Fetches a string of characters contained in the sequence.
		/// </summary>
		/// <param name="offset">
		/// Offset into the sequence to fetch
		/// </param>
		/// <param name="length">
		/// number of characters to copy.
		/// </param>
		string GetText(int offset, int length);
		#endregion
		string GetText(ISegment segment);
		
		#region ITextModel interface
		/// <summary>
		/// returns the logical line/column position from an offset
		/// </summary>
		TextLocation OffsetToPosition(int offset);
		
		/// <summary>
		/// returns the offset from a logical line/column position
		/// </summary>
		int PositionToOffset(TextLocation p);
		#endregion
		/// <value>
		/// A container where all TextAreaUpdate objects get stored
		/// </value>
		List<TextAreaUpdate> UpdateQueue {
			get;
		}
		
		/// <remarks>
		/// Requests an update of the textarea
		/// </remarks>
		void RequestUpdate(TextAreaUpdate update);
		
		/// <remarks>
		/// Commits all updates in the queue to the textarea (the
		/// textarea will be painted)
		/// </remarks>
		void CommitUpdate();
		
		/// <summary>
		/// Moves, Resizes, Removes a list of segments on insert/remove/replace events.
		/// </summary>
		void UpdateSegmentListOnDocumentChange<T>(List<T> list, DocumentEventArgs e) where T : ISegment;
		
		/// <summary>
		/// Is fired when CommitUpdate is called
		/// </summary>
		event EventHandler UpdateCommited;
		
		/// <summary>
		/// </summary>
		event DocumentEventHandler DocumentAboutToBeChanged;
		
		/// <summary>
		/// </summary>
		event DocumentEventHandler DocumentChanged;
		
		event EventHandler TextContentChanged;
	}
}

#endif
// file ...\TextFileEdit\Document\ISegment.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1966 $</version>
// </file>

namespace TextFileEdit.Document
{
	/// <summary>
	/// This interface is used to describe a span inside a text sequence
	/// </summary>
	public interface ISegment
	{
		/// <value>
		/// The offset where the span begins
		/// </value>
		int Offset {
			get;
			set;
		}
		
		/// <value>
		/// The length of the span
		/// </value>
		int Length {
			get;
			set;
		}
	}
	
}

#endif
// file ...\TextFileEdit\Document\ITextEditorProperties.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="none" email=""/>
//     <version>$Revision: 3440 $</version>
// </file>


namespace TextFileEdit.Document
{
	public interface ITextEditorProperties
	{
		bool CaretLine
		{
			get;
			set;
		}

		bool AutoInsertCurlyBracket { // is wrapped in text editor control
			get;
			set;
		}
		
		bool HideMouseCursor { // is wrapped in text editor control
			get;
			set;
		}
		
		bool IsIconBarVisible { // is wrapped in text editor control
			get;
			set;
		}
		
		bool AllowCaretBeyondEOL {
			get;
			set;
		}
		
		bool ShowMatchingBracket { // is wrapped in text editor control
			get;
			set;
		}
		
		bool CutCopyWholeLine {
			get;
			set;
		}

		System.Drawing.Text.TextRenderingHint TextRenderingHint { // is wrapped in text editor control
			get;
			set;
		}
		
		bool MouseWheelScrollDown {
			get;
			set;
		}
		
		bool MouseWheelTextZoom {
			get;
			set;
		}
		
		string LineTerminator {
			get;
			set;
		}
		
		LineViewerStyle LineViewerStyle { // is wrapped in text editor control
			get;
			set;
		}
		
		bool ShowInvalidLines { // is wrapped in text editor control
			get;
			set;
		}
		
		int VerticalRulerRow { // is wrapped in text editor control
			get;
			set;
		}
		
		bool ShowSpaces { // is wrapped in text editor control
			get;
			set;
		}
		
		bool ShowTabs { // is wrapped in text editor control
			get;
			set;
		}
		
		bool ShowEOLMarker { // is wrapped in text editor control
			get;
			set;
		}
		
		bool ConvertTabsToSpaces { // is wrapped in text editor control
			get;
			set;
		}
		
		bool ShowHorizontalRuler { // is wrapped in text editor control
			get;
			set;
		}
		
		bool ShowVerticalRuler { // is wrapped in text editor control
			get;
			set;
		}
		
		Encoding Encoding {
			get;
			set;
		}
		
		bool EnableFolding { // is wrapped in text editor control
			get;
			set;
		}
		
		bool ShowLineNumbers { // is wrapped in text editor control
			get;
			set;
		}
		
		/// <summary>
		/// The width of a tab.
		/// </summary>
		int TabIndent { // is wrapped in text editor control
			get;
			set;
		}
		
		/// <summary>
		/// The amount of spaces a tab is converted to if ConvertTabsToSpaces is true.
		/// </summary>
		int IndentationSize {
			get;
			set;
		}
		
		IndentStyle IndentStyle { // is wrapped in text editor control
			get;
			set;
		}
		
		DocumentSelectionMode DocumentSelectionMode {
			get;
			set;
		}
		
		Font Font { // is wrapped in text editor control
			get;
			set;
		}
		
		FontContainer FontContainer {
			get;
		}
		
		BracketMatchingStyle  BracketMatchingStyle { // is wrapped in text editor control
			get;
			set;
		}
		
		bool SupportReadOnlySegments {
			get;
			set;
		}
	}
}

#endif
// file ...\TextFileEdit\Document\TextAnchor.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Daniel Grunwald" email="daniel@danielgrunwald.de"/>
//     <version>$Revision: 3272 $</version>
// </file>


namespace TextFileEdit.Document
{
	public enum AnchorMovementType
	{
		/// <summary>
		/// Behaves like a start marker - when text is inserted at the anchor position, the anchor will stay
		/// before the inserted text.
		/// </summary>
		BeforeInsertion,
		/// <summary>
		/// Behave like an end marker - when text is insered at the anchor position, the anchor will move
		/// after the inserted text.
		/// </summary>
		AfterInsertion
	}
	
	/// <summary>
	/// An anchor that can be put into a document and moves around when the document is changed.
	/// </summary>
	public sealed class TextAnchor
	{
		static Exception AnchorDeletedError()
		{
			return new InvalidOperationException("The text containing the anchor was deleted");
		}
		
		LineSegment lineSegment;
		int columnNumber;
		
		public LineSegment Line {
			get {
				if (lineSegment == null) throw AnchorDeletedError();
				return lineSegment;
			}
			internal set {
				lineSegment = value;
			}
		}
		
		public bool IsDeleted {
			get {
				return lineSegment == null;
			}
		}
		
		public int LineNumber {
			get {
				return this.Line.LineNumber;
			}
		}
		
		public int ColumnNumber {
			get {
				if (lineSegment == null) throw AnchorDeletedError();
				return columnNumber;
			}
			internal set {
				columnNumber = value;
			}
		}
		
		public TextLocation Location {
			get {
				return new TextLocation(this.ColumnNumber, this.LineNumber);
			}
		}
		
		public int Offset {
			get {
				return this.Line.Offset + columnNumber;
			}
		}
		
		/// <summary>
		/// Controls how the anchor moves.
		/// </summary>
		public AnchorMovementType MovementType { get; set; }
		
		public event EventHandler Deleted;
		
		internal void Delete(ref DeferredEventList deferredEventList)
		{
			// we cannot fire an event here because this method is called while the LineManager adjusts the
			// lineCollection, so an event handler could see inconsistent state
			lineSegment = null;
			deferredEventList.AddDeletedAnchor(this);
		}
		
		internal void RaiseDeleted()
		{
			if (Deleted != null)
				Deleted(this, EventArgs.Empty);
		}
		
		internal TextAnchor(LineSegment lineSegment, int columnNumber)
		{
			this.lineSegment = lineSegment;
			this.columnNumber = columnNumber;
		}
		
		public override string ToString()
		{
			if (this.IsDeleted)
				return "[TextAnchor (deleted)]";
			else
				return "[TextAnchor " + this.Location.ToString() + "]";
		}
	}
}

#endif
// file ...\TextFileEdit\Document\TextLocation.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Daniel Grunwald" email="daniel@danielgrunwald.de"/>
//     <version>$Revision: 2658$</version>
// </file>


namespace TextFileEdit
{
	/// <summary>
	/// A line/column position.
	/// Text editor lines/columns are counting from zero.
	/// </summary>
	public struct TextLocation : IComparable<TextLocation>, IEquatable<TextLocation>
	{
		/// <summary>
		/// Represents no text location (-1, -1).
		/// </summary>
		public static readonly TextLocation Empty = new TextLocation(-1, -1);
		
		public TextLocation(int column, int line)
		{
			x = column;
			y = line;
		}
		
		int x, y;
		
		public int X {
			get { return x; }
			set { x = value; }
		}
		
		public int Y {
			get { return y; }
			set { y = value; }
		}
		
		public int Line {
			get { return y; }
			set { y = value; }
		}
		
		public int Column {
			get { return x; }
			set { x = value; }
		}
		
		public bool IsEmpty {
			get {
				return x <= 0 && y <= 0;
			}
		}
		
		public override string ToString()
		{
			return string.Format("(Line {1}, Col {0})", this.x, this.y);
		}
		
		public override int GetHashCode()
		{
			return unchecked (87 * x.GetHashCode() ^ y.GetHashCode());
		}
		
		public override bool Equals(object obj)
		{
			if (!(obj is TextLocation)) return false;
			return (TextLocation)obj == this;
		}
		
		public bool Equals(TextLocation other)
		{
			return this == other;
		}
		
		public static bool operator ==(TextLocation a, TextLocation b)
		{
			return a.x == b.x && a.y == b.y;
		}
		
		public static bool operator !=(TextLocation a, TextLocation b)
		{
			return a.x != b.x || a.y != b.y;
		}
		
		public static bool operator <(TextLocation a, TextLocation b)
		{
			if (a.y < b.y)
				return true;
			else if (a.y == b.y)
				return a.x < b.x;
			else
				return false;
		}
		
		public static bool operator >(TextLocation a, TextLocation b)
		{
			if (a.y > b.y)
				return true;
			else if (a.y == b.y)
				return a.x > b.x;
			else
				return false;
		}
		
		public static bool operator <=(TextLocation a, TextLocation b)
		{
			return !(a > b);
		}
		
		public static bool operator >=(TextLocation a, TextLocation b)
		{
			return !(a < b);
		}
		
		public int CompareTo(TextLocation other)
		{
			if (this == other)
				return 0;
			if (this < other)
				return -1;
			else
				return 1;
		}
	}
}

#endif
// file ...\TextFileEdit\Document\TextUtilities.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3020 $</version>
// </file>


namespace TextFileEdit.Document
{
	
	public sealed class TextUtilities
	{
		/// <remarks>
		/// This function takes a string and converts the whitespace in front of
		/// it to tabs. If the length of the whitespace at the start of the string
		/// was not a whole number of tabs then there will still be some spaces just
		/// before the text starts.
		/// the output string will be of the form:
		/// 1. zero or more tabs
		/// 2. zero or more spaces (less than tabIndent)
		/// 3. the rest of the line
		/// </remarks>
		public static string LeadingWhiteSpaceToTabs(string line, int tabIndent) {
			StringBuilder sb = new StringBuilder(line.Length);
			int consecutiveSpaces = 0;
			int i = 0;
			for(i = 0; i < line.Length; i++) {
				if(line[i] == ' ') {
					consecutiveSpaces++;
					if(consecutiveSpaces == tabIndent) {
						sb.Append('\t');
						consecutiveSpaces = 0;
					}
				}
				else if(line[i] == '\t') {
					sb.Append('\t');
					// if we had say 3 spaces then a tab and tabIndent was 4 then
					// we would want to simply replace all of that with 1 tab
					consecutiveSpaces = 0;
				}
				else {
					break;
				}
			}
			
			if(i < line.Length) {
				sb.Append(line.Substring(i-consecutiveSpaces));
			}
			return sb.ToString();
		}
		
		public static bool IsLetterDigitOrUnderscore(char c)
		{
			if(!Char.IsLetterOrDigit(c)) {
				return c == '_';
			}
			return true;
		}
		
		public enum CharacterType {
			LetterDigitOrUnderscore,
			WhiteSpace,
			Other
		}
		
		/// <remarks>
		/// This method returns the expression before a specified offset.
		/// That method is used in code completion to determine the expression given
		/// to the parser for type resolve.
		/// </remarks>
		public static string GetExpressionBeforeOffset(TextArea textArea, int initialOffset)
		{
			IDocument document = textArea.Document;
			int offset = initialOffset;
			while (offset - 1 > 0) {
				switch (document.GetCharAt(offset - 1)) {
					case '\n':
					case '\r':
					case '}':
						goto done;
//						offset = SearchBracketBackward(document, offset - 2, '{','}');
//						break;
					case ']':
						offset = SearchBracketBackward(document, offset - 2, '[',']');
						break;
					case ')':
						offset = SearchBracketBackward(document, offset - 2, '(',')');
						break;
					case '.':
						--offset;
						break;
					case '"':
						if (offset < initialOffset - 1) {
							return null;
						}
						return "\"\"";
					case '\'':
						if (offset < initialOffset - 1) {
							return null;
						}
						return "'a'";
					case '>':
						if (document.GetCharAt(offset - 2) == '-') {
							offset -= 2;
							break;
						}
						goto done;
					default:
						if (Char.IsWhiteSpace(document.GetCharAt(offset - 1))) {
							--offset;
							break;
						}
						int start = offset - 1;
						if (!IsLetterDigitOrUnderscore(document.GetCharAt(start))) {
							goto done;
						}
						
						while (start > 0 && IsLetterDigitOrUnderscore(document.GetCharAt(start - 1))) {
							--start;
						}
						string word = document.GetText(start, offset - start).Trim();
						switch (word) {
							case "ref":
							case "out":
							case "in":
							case "return":
							case "throw":
							case "case":
								goto done;
						}
						
						if (word.Length > 0 && !IsLetterDigitOrUnderscore(word[0])) {
							goto done;
						}
						offset = start;
						break;
				}
			}
		done:
			//// simple exit fails when : is inside comment line or any other character
			//// we have to check if we got several ids in resulting line, which usually happens when
			//// id. is typed on next line after comment one
			//// Would be better if lexer would parse properly such expressions. However this will cause
			//// modifications in this area too - to get full comment line and remove it afterwards
			if (offset < 0)
				return string.Empty;
			
			string resText=document.GetText(offset, textArea.Caret.Offset - offset ).Trim();
			int pos=resText.LastIndexOf('\n');
			if (pos>=0) {
				offset+=pos+1;
				//// whitespaces and tabs, which might be inside, will be skipped by trim below
			}
			string expression = document.GetText(offset, textArea.Caret.Offset - offset ).Trim();
			return expression;
		}
		
		
		public static CharacterType GetCharacterType(char c)
		{
			if(IsLetterDigitOrUnderscore(c))
				return CharacterType.LetterDigitOrUnderscore;
			if(Char.IsWhiteSpace(c))
				return CharacterType.WhiteSpace;
			return CharacterType.Other;
		}
		
		public static int GetFirstNonWSChar(IDocument document, int offset)
		{
			while (offset < document.TextLength && Char.IsWhiteSpace(document.GetCharAt(offset))) {
				++offset;
			}
			return offset;
		}
		
		public static int FindWordEnd(IDocument document, int offset)
		{
			LineSegment line   = document.GetLineSegmentForOffset(offset);
			int     endPos = line.Offset + line.Length;
			while (offset < endPos && IsLetterDigitOrUnderscore(document.GetCharAt(offset))) {
				++offset;
			}
			
			return offset;
		}
		
		public static int FindWordStart(IDocument document, int offset)
		{
			LineSegment line = document.GetLineSegmentForOffset(offset);
			int lineOffset = line.Offset;
			while (offset > lineOffset && IsLetterDigitOrUnderscore(document.GetCharAt(offset - 1))) {
				--offset;
			}
			
			return offset;
		}
		
		// go forward to the start of the next word
		// if the cursor is at the start or in the middle of a word we move to the end of the word
		// and then past any whitespace that follows it
		// if the cursor is at the start or in the middle of some whitespace we move to the start of the
		// next word
		public static int FindNextWordStart(IDocument document, int offset)
		{
			int originalOffset = offset;
			LineSegment line   = document.GetLineSegmentForOffset(offset);
			int     endPos = line.Offset + line.Length;
			// lets go to the end of the word, whitespace or operator
			CharacterType t = GetCharacterType(document.GetCharAt(offset));
			while (offset < endPos && GetCharacterType(document.GetCharAt(offset)) == t) {
				++offset;
			}
			
			// now we're at the end of the word, lets find the start of the next one by skipping whitespace
			while (offset < endPos && GetCharacterType(document.GetCharAt(offset)) == CharacterType.WhiteSpace) {
				++offset;
			}

			return offset;
		}
		
		// go back to the start of the word we are on
		// if we are already at the start of a word or if we are in whitespace, then go back
		// to the start of the previous word
		public static int FindPrevWordStart(IDocument document, int offset)
		{
			int originalOffset = offset;
			if (offset > 0) {
				LineSegment line = document.GetLineSegmentForOffset(offset);
				CharacterType t = GetCharacterType(document.GetCharAt(offset - 1));
				while (offset > line.Offset && GetCharacterType(document.GetCharAt(offset - 1)) == t) {
					--offset;
				}
				
				// if we were in whitespace, and now we're at the end of a word or operator, go back to the beginning of it
				if(t == CharacterType.WhiteSpace && offset > line.Offset) {
					t = GetCharacterType(document.GetCharAt(offset - 1));
					while (offset > line.Offset && GetCharacterType(document.GetCharAt(offset - 1)) == t) {
						--offset;
					}
				}
			}
			
			return offset;
		}
		
		public static string GetLineAsString(IDocument document, int lineNumber)
		{
			LineSegment line = document.GetLineSegment(lineNumber);
			return document.GetText(line.Offset, line.Length);
		}
		
		public static int SearchBracketBackward(IDocument document, int offset, char openBracket, char closingBracket)
		{
			return document.FormattingStrategy.SearchBracketBackward(document, offset, openBracket, closingBracket);
		}
		
		public static int SearchBracketForward(IDocument document, int offset, char openBracket, char closingBracket)
		{
			return document.FormattingStrategy.SearchBracketForward(document, offset, openBracket, closingBracket);
		}
		
		/// <remarks>
		/// Returns true, if the line lineNumber is empty or filled with whitespaces.
		/// </remarks>
		public static bool IsEmptyLine(IDocument document, int lineNumber)
		{
			return IsEmptyLine(document, document.GetLineSegment(lineNumber));
		}

		/// <remarks>
		/// Returns true, if the line lineNumber is empty or filled with whitespaces.
		/// </remarks>
		public static bool IsEmptyLine(IDocument document, LineSegment line)
		{
			for (int i = line.Offset; i < line.Offset + line.Length; ++i) {
				char ch = document.GetCharAt(i);
				if (!Char.IsWhiteSpace(ch)) {
					return false;
				}
			}
			return true;
		}
		
		static bool IsWordPart(char ch)
		{
			return IsLetterDigitOrUnderscore(ch) || ch == '.';
		}
		
		public static string GetWordAt(IDocument document, int offset)
		{
			if (offset < 0 || offset >= document.TextLength - 1 || !IsWordPart(document.GetCharAt(offset))) {
				return String.Empty;
			}
			int startOffset = offset;
			int endOffset   = offset;
			while (startOffset > 0 && IsWordPart(document.GetCharAt(startOffset - 1))) {
				--startOffset;
			}
			
			while (endOffset < document.TextLength - 1 && IsWordPart(document.GetCharAt(endOffset + 1))) {
				++endOffset;
			}
			
			Debug.Assert(endOffset >= startOffset);
			return document.GetText(startOffset, endOffset - startOffset + 1);
		}
	}
}

#endif
// file ...\TextFileEdit\Document\BookmarkManager\Bookmark.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3272 $</version>
// </file>


namespace TextFileEdit.Document
{
    /// <summary>
    /// Description of Bookmark.
    /// </summary>
    public class Bookmark
    {
        IDocument document;
        TextAnchor anchor;
        TextLocation location;
        bool isEnabled = true;
        
        public IDocument Document {
            get {
                return document;
            }
            set {
                if (document != value) {
                    if (anchor != null) {
                        location = anchor.Location;
                        anchor = null;
                    }
                    document = value;
                    CreateAnchor();
                    OnDocumentChanged(EventArgs.Empty);
                }
            }
        }
        
        void CreateAnchor()
        {
            if (document != null) {
                LineSegment line = document.GetLineSegment(Math.Max(0, Math.Min(location.Line, document.TotalNumberOfLines-1)));
                anchor = line.CreateAnchor(Math.Max(0, Math.Min(location.Column, line.Length)));
                // after insertion: keep bookmarks after the initial whitespace (see DefaultFormattingStrategy.SmartReplaceLine)
                anchor.MovementType = AnchorMovementType.AfterInsertion;
                anchor.Deleted += AnchorDeleted;
            }
        }
        
        void AnchorDeleted(object sender, EventArgs e)
        {
            document.BookmarkManager.RemoveMark(this);
        }
        
        /// <summary>
        /// Gets the TextAnchor used for this bookmark.
        /// Is null if the bookmark is not connected to a document.
        /// </summary>
        public TextAnchor Anchor {
            get { return anchor; }
        }
        
        public TextLocation Location {
            get {
                if (anchor != null)
                    return anchor.Location;
                else
                    return location;
            }
            set {
                location = value;
                CreateAnchor();
            }
        }
        
        public event EventHandler DocumentChanged;
        
        protected virtual void OnDocumentChanged(EventArgs e)
        {
            if (DocumentChanged != null) {
                DocumentChanged(this, e);
            }
        }
        
        public bool IsEnabled {
            get {
                return isEnabled;
            }
            set {
                if (isEnabled != value) {
                    isEnabled = value;
                    if (document != null) {
                        document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.SingleLine, LineNumber));
                        document.CommitUpdate();
                    }
                    OnIsEnabledChanged(EventArgs.Empty);
                }
            }
        }
        
        public event EventHandler IsEnabledChanged;
        
        protected virtual void OnIsEnabledChanged(EventArgs e)
        {
            if (IsEnabledChanged != null) {
                IsEnabledChanged(this, e);
            }
        }
        
        public int LineNumber {
            get {
                if (anchor != null)
                    return anchor.LineNumber;
                else
                    return location.Line;
            }
        }
        
        public int ColumnNumber {
            get {
                if (anchor != null)
                    return anchor.ColumnNumber;
                else
                    return location.Column;
            }
        }
        
        /// <summary>
        /// Gets if the bookmark can be toggled off using the 'set/unset bookmark' command.
        /// </summary>
        public virtual bool CanToggle {
            get {
                return true;
            }
        }
        
        public Bookmark(IDocument document, TextLocation location) : this(document, location, true)
        {
        }
        
        public Bookmark(IDocument document, TextLocation location, bool isEnabled)
        {
            this.document = document;
            this.isEnabled = isEnabled;
            this.Location = location;
        }
        
        public virtual bool Click(SWF.Control parent, SWF.MouseEventArgs e)
        {
            if (e.Button == SWF.MouseButtons.Left && CanToggle) {
                document.BookmarkManager.RemoveMark(this);
                return true;
            }
            return false;
        }
        
        public virtual void Draw(IconBarMargin margin, Graphics g, Point p)
        {
            margin.DrawBookmark(g, p.Y, isEnabled);
        }
    }
}

#endif
// file ...\TextFileEdit\Document\BookmarkManager\BookmarkEventHandler.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 915 $</version>
// </file>


namespace TextFileEdit.Document
{
	public delegate void BookmarkEventHandler(object sender, BookmarkEventArgs e);
	
	/// <summary>
	/// Description of BookmarkEventHandler.
	/// </summary>
	public class BookmarkEventArgs : EventArgs
	{
		Bookmark bookmark;
		
		public Bookmark Bookmark {
			get {
				return bookmark;
			}
		}
		
		public BookmarkEventArgs(Bookmark bookmark)
		{
			this.bookmark = bookmark;
		}
	}
}

#endif
// file ...\TextFileEdit\Document\BookmarkManager\BookmarkManager.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3272 $</version>
// </file>


namespace TextFileEdit.Document
{
	public interface IBookmarkFactory
	{
		Bookmark CreateBookmark(IDocument document, TextLocation location);
	}
	
	/// <summary>
	/// This class handles the bookmarks for a buffer
	/// </summary>
	public class BookmarkManager
	{
		IDocument      document;
		#if DEBUG
		IList<Bookmark> bookmark = new TextFileEdit.Util.CheckedList<Bookmark>();
		#else
		List<Bookmark> bookmark = new List<Bookmark>();
		#endif
		
		/// <value>
		/// Contains all bookmarks
		/// </value>
		public ReadOnlyCollection<Bookmark> Marks {
			get {
				return new ReadOnlyCollection<Bookmark>(bookmark);
			}
		}
		
		public IDocument Document {
			get {
				return document;
			}
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="BookmarkManager"/>
		/// </summary>
		internal BookmarkManager(IDocument document, LineManager lineTracker)
		{
			this.document = document;
		}
		
		/// <summary>
		/// Gets/Sets the bookmark factory used to create bookmarks for "ToggleMarkAt".
		/// </summary>
		public IBookmarkFactory Factory { get; set;}
		
		/// <summary>
		/// Sets the mark at the line <code>location.Line</code> if it is not set, if the
		/// line is already marked the mark is cleared.
		/// </summary>
		public void ToggleMarkAt(TextLocation location)
		{
			Bookmark newMark;
			if (Factory != null) {
				newMark = Factory.CreateBookmark(document, location);
			} else {
				newMark = new Bookmark(document, location);
			}
			
			Type newMarkType = newMark.GetType();
			
			for (int i = 0; i < bookmark.Count; ++i) {
				Bookmark mark = bookmark[i];
				
				if (mark.LineNumber == location.Line && mark.CanToggle && mark.GetType() == newMarkType) {
					bookmark.RemoveAt(i);
					OnRemoved(new BookmarkEventArgs(mark));
					return;
				}
			}
			
			bookmark.Add(newMark);
			OnAdded(new BookmarkEventArgs(newMark));
		}
		
		public void AddMark(Bookmark mark)
		{
			bookmark.Add(mark);
			OnAdded(new BookmarkEventArgs(mark));
		}
		
		public void RemoveMark(Bookmark mark)
		{
			bookmark.Remove(mark);
			OnRemoved(new BookmarkEventArgs(mark));
		}
		
		public void RemoveMarks(Predicate<Bookmark> predicate)
		{
			for (int i = 0; i < bookmark.Count; ++i) {
				Bookmark bm = bookmark[i];
				if (predicate(bm)) {
					bookmark.RemoveAt(i--);
					OnRemoved(new BookmarkEventArgs(bm));
				}
			}
		}
		
		/// <returns>
		/// true, if a mark at mark exists, otherwise false
		/// </returns>
		public bool IsMarked(int lineNr)
		{
			for (int i = 0; i < bookmark.Count; ++i) {
				if (bookmark[i].LineNumber == lineNr) {
					return true;
				}
			}
			return false;
		}
		
		/// <remarks>
		/// Clears all bookmark
		/// </remarks>
		public void Clear()
		{
			foreach (Bookmark mark in bookmark) {
				OnRemoved(new BookmarkEventArgs(mark));
			}
			bookmark.Clear();
		}
		
		/// <value>
		/// The lowest mark, if no marks exists it returns -1
		/// </value>
		public Bookmark GetFirstMark(Predicate<Bookmark> predicate)
		{
			if (bookmark.Count < 1) {
				return null;
			}
			Bookmark first = null;
			for (int i = 0; i < bookmark.Count; ++i) {
				if (predicate(bookmark[i]) && bookmark[i].IsEnabled && (first == null || bookmark[i].LineNumber < first.LineNumber)) {
					first = bookmark[i];
				}
			}
			return first;
		}
		
		/// <value>
		/// The highest mark, if no marks exists it returns -1
		/// </value>
		public Bookmark GetLastMark(Predicate<Bookmark> predicate)
		{
			if (bookmark.Count < 1) {
				return null;
			}
			Bookmark last = null;
			for (int i = 0; i < bookmark.Count; ++i) {
				if (predicate(bookmark[i]) && bookmark[i].IsEnabled && (last == null || bookmark[i].LineNumber > last.LineNumber)) {
					last = bookmark[i];
				}
			}
			return last;
		}
		bool AcceptAnyMarkPredicate(Bookmark mark)
		{
			return true;
		}
		public Bookmark GetNextMark(int curLineNr)
		{
			return GetNextMark(curLineNr, AcceptAnyMarkPredicate);
		}
		
		/// <remarks>
		/// returns first mark higher than <code>lineNr</code>
		/// </remarks>
		/// <returns>
		/// returns the next mark > cur, if it not exists it returns FirstMark()
		/// </returns>
		public Bookmark GetNextMark(int curLineNr, Predicate<Bookmark> predicate)
		{
			if (bookmark.Count == 0) {
				return null;
			}
			
			Bookmark next = GetFirstMark(predicate);
			foreach (Bookmark mark in bookmark) {
				if (predicate(mark) && mark.IsEnabled && mark.LineNumber > curLineNr) {
					if (mark.LineNumber < next.LineNumber || next.LineNumber <= curLineNr) {
						next = mark;
					}
				}
			}
			return next;
		}
		
		public Bookmark GetPrevMark(int curLineNr)
		{
			return GetPrevMark(curLineNr, AcceptAnyMarkPredicate);
		}
		/// <remarks>
		/// returns first mark lower than <code>lineNr</code>
		/// </remarks>
		/// <returns>
		/// returns the next mark lower than cur, if it not exists it returns LastMark()
		/// </returns>
		public Bookmark GetPrevMark(int curLineNr, Predicate<Bookmark> predicate)
		{
			if (bookmark.Count == 0) {
				return null;
			}
			
			Bookmark prev = GetLastMark(predicate);
			
			foreach (Bookmark mark in bookmark) {
				if (predicate(mark) && mark.IsEnabled && mark.LineNumber < curLineNr) {
					if (mark.LineNumber > prev.LineNumber || prev.LineNumber >= curLineNr) {
						prev = mark;
					}
				}
			}
			return prev;
		}
		
		protected virtual void OnRemoved(BookmarkEventArgs e)
		{
			if (Removed != null) {
				Removed(this, e);
			}
		}
		
		protected virtual void OnAdded(BookmarkEventArgs e)
		{
			if (Added != null) {
				Added(this, e);
			}
		}
		
		public event BookmarkEventHandler Removed;
		public event BookmarkEventHandler Added;
	}
}

#endif
// file ...\TextFileEdit\Document\BookmarkManager\BookmarkManagerMemento.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 915 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// This class is used for storing the state of a bookmark manager 
	/// </summary>
	public class BookmarkManagerMemento
	{
		List<int> bookmarks = new List<int>();
		
		/// <value>
		/// Contains all bookmarks as int values
		/// </value>
		public List<int> Bookmarks {
			get {
				return bookmarks;
			}
			set {
				bookmarks = value;
			}
		}
		
		/// <summary>
		/// Validates all bookmarks if they're in range of the document.
		/// (removing all bookmarks &lt; 0 and bookmarks &gt; max. line number
		/// </summary>
		public void CheckMemento(IDocument document)
		{
			for (int i = 0; i < bookmarks.Count; ++i) {
				int mark = (int)bookmarks[i];
				if (mark < 0 || mark >= document.TotalNumberOfLines) {
					bookmarks.RemoveAt(i);
					--i;
				}
			}
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="BookmarkManagerMemento"/>
		/// </summary>
		public BookmarkManagerMemento()
		{
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="BookmarkManagerMemento"/>
		/// </summary>
		public BookmarkManagerMemento(XmlElement element)
		{
			foreach (XmlElement el in element.ChildNodes) {
				bookmarks.Add(Int32.Parse(el.Attributes["line"].InnerText));
			}
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="BookmarkManagerMemento"/>
		/// </summary>
		public BookmarkManagerMemento(List<int> bookmarks)
		{
			this.bookmarks = bookmarks;
		}
		
		/// <summary>
		/// Converts a xml element to a <see cref="BookmarkManagerMemento"/> object
		/// </summary>
		public object FromXmlElement(XmlElement element)
		{
			return new BookmarkManagerMemento(element);
		}
		
		/// <summary>
		/// Converts this <see cref="BookmarkManagerMemento"/> to a xml element
		/// </summary>
		public XmlElement ToXmlElement(XmlDocument doc)
		{
			XmlElement bookmarknode  = doc.CreateElement("Bookmarks");
			
			foreach (int line in bookmarks) {
				XmlElement markNode = doc.CreateElement("Mark");
				
				XmlAttribute lineAttr = doc.CreateAttribute("line");
				lineAttr.InnerText = line.ToString();
				markNode.Attributes.Append(lineAttr);
						
				bookmarknode.AppendChild(markNode);
			}
			
			return bookmarknode;
		}
	}
}

#endif
// file ...\TextFileEdit\Document\FoldingStrategy\FoldingManager.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2691 $</version>
// </file>


namespace TextFileEdit.Document
{
	public class FoldingManager
	{
		List<FoldMarker>    foldMarker      = new List<FoldMarker>();
		List<FoldMarker>    foldMarkerByEnd = new List<FoldMarker>();
		IFoldingStrategy    foldingStrategy = null;
		IDocument document;
		
		public IList<FoldMarker> FoldMarker {
			get {
				return foldMarker.AsReadOnly();
			}
		}
		
		public IFoldingStrategy FoldingStrategy {
			get {
				return foldingStrategy;
			}
			set {
				foldingStrategy = value;
			}
		}
		
		internal FoldingManager(IDocument document, LineManager lineTracker)
		{
			this.document = document;
			document.DocumentChanged += new DocumentEventHandler(DocumentChanged);
			
//			lineTracker.LineCountChanged  += new LineManagerEventHandler(LineManagerLineCountChanged);
//			lineTracker.LineLengthChanged += new LineLengthEventHandler(LineManagerLineLengthChanged);
//			foldMarker.Add(new FoldMarker(0, 5, 3, 5));
//
//			foldMarker.Add(new FoldMarker(5, 5, 10, 3));
//			foldMarker.Add(new FoldMarker(6, 0, 8, 2));
//
//			FoldMarker fm1 = new FoldMarker(10, 4, 10, 7);
//			FoldMarker fm2 = new FoldMarker(10, 10, 10, 14);
//
//			fm1.IsFolded = true;
//			fm2.IsFolded = true;
//
//			foldMarker.Add(fm1);
//			foldMarker.Add(fm2);
//			foldMarker.Sort();
		}
		
		void DocumentChanged(object sender, DocumentEventArgs e)
		{
			int oldCount = foldMarker.Count;
			document.UpdateSegmentListOnDocumentChange(foldMarker, e);
			if (oldCount != foldMarker.Count) {
				document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.WholeTextArea));
			}
		}
		
		public List<FoldMarker> GetFoldingsFromPosition(int line, int column)
		{
			List<FoldMarker> foldings = new List<FoldMarker>();
			if (foldMarker != null) {
				for (int i = 0; i < foldMarker.Count; ++i) {
					FoldMarker fm = foldMarker[i];
					if ((fm.StartLine == line && column > fm.StartColumn && !(fm.EndLine == line && column >= fm.EndColumn)) ||
					    (fm.EndLine == line && column < fm.EndColumn && !(fm.StartLine == line && column <= fm.StartColumn)) ||
					    (line > fm.StartLine && line < fm.EndLine)) {
						foldings.Add(fm);
					}
				}
			}
			return foldings;
		}
		
		class StartComparer : IComparer<FoldMarker>
		{
			public readonly static StartComparer Instance = new StartComparer();
			
			public int Compare(FoldMarker x, FoldMarker y)
			{
				if (x.StartLine < y.StartLine)
					return -1;
				else if (x.StartLine == y.StartLine)
					return x.StartColumn.CompareTo(y.StartColumn);
				else
					return 1;
			}
		}
		
		class EndComparer : IComparer<FoldMarker>
		{
			public readonly static EndComparer Instance = new EndComparer();
			
			public int Compare(FoldMarker x, FoldMarker y)
			{
				if (x.EndLine < y.EndLine)
					return -1;
				else if (x.EndLine == y.EndLine)
					return x.EndColumn.CompareTo(y.EndColumn);
				else
					return 1;
			}
		}
		
		List<FoldMarker> GetFoldingsByStartAfterColumn(int lineNumber, int column, bool forceFolded)
		{
			List<FoldMarker> foldings = new List<FoldMarker>();
			
			if (foldMarker != null) {
				int index = foldMarker.BinarySearch(
					new FoldMarker(document, lineNumber, column, lineNumber, column),
					StartComparer.Instance);
				if (index < 0) index = ~index;
				
				for (; index < foldMarker.Count; index++) {
					FoldMarker fm = foldMarker[index];
					if (fm.StartLine > lineNumber)
						break;
					if (fm.StartColumn <= column)
						continue;
					if (!forceFolded || fm.IsFolded)
						foldings.Add(fm);
				}
			}
			return foldings;
		}
		
		public List<FoldMarker> GetFoldingsWithStart(int lineNumber)
		{
			return GetFoldingsByStartAfterColumn(lineNumber, -1, false);
		}
		
		public List<FoldMarker> GetFoldedFoldingsWithStart(int lineNumber)
		{
			return GetFoldingsByStartAfterColumn(lineNumber, -1, true);
		}
		
		public List<FoldMarker> GetFoldedFoldingsWithStartAfterColumn(int lineNumber, int column)
		{
			return GetFoldingsByStartAfterColumn(lineNumber, column, true);
		}
		
		List<FoldMarker> GetFoldingsByEndAfterColumn(int lineNumber, int column, bool forceFolded)
		{
			List<FoldMarker> foldings = new List<FoldMarker>();
			
			if (foldMarker != null) {
				int index =  foldMarkerByEnd.BinarySearch(
					new FoldMarker(document, lineNumber, column, lineNumber, column),
					EndComparer.Instance);
				if (index < 0) index = ~index;
				
				for (; index < foldMarkerByEnd.Count; index++) {
					FoldMarker fm = foldMarkerByEnd[index];
					if (fm.EndLine > lineNumber)
						break;
					if (fm.EndColumn <= column)
						continue;
					if (!forceFolded || fm.IsFolded)
						foldings.Add(fm);
				}
			}
			return foldings;
		}
		
		public List<FoldMarker> GetFoldingsWithEnd(int lineNumber)
		{
			return GetFoldingsByEndAfterColumn(lineNumber, -1, false);
		}
		
		public List<FoldMarker> GetFoldedFoldingsWithEnd(int lineNumber)
		{
			return GetFoldingsByEndAfterColumn(lineNumber, -1, true);
		}
		
		public bool IsFoldStart(int lineNumber)
		{
			return GetFoldingsWithStart(lineNumber).Count > 0;
		}
		
		public bool IsFoldEnd(int lineNumber)
		{
			return GetFoldingsWithEnd(lineNumber).Count > 0;
		}
		
		public List<FoldMarker> GetFoldingsContainsLineNumber(int lineNumber)
		{
			List<FoldMarker> foldings = new List<FoldMarker>();
			if (foldMarker != null) {
				foreach (FoldMarker fm in foldMarker) {
					if (fm.StartLine < lineNumber && lineNumber < fm.EndLine) {
						foldings.Add(fm);
					}
				}
			}
			return foldings;
		}
		
		public bool IsBetweenFolding(int lineNumber)
		{
			return GetFoldingsContainsLineNumber(lineNumber).Count > 0;
		}
		
		public bool IsLineVisible(int lineNumber)
		{
			foreach (FoldMarker fm in GetFoldingsContainsLineNumber(lineNumber)) {
				if (fm.IsFolded)
					return false;
			}
			return true;
		}
		
		public List<FoldMarker> GetTopLevelFoldedFoldings()
		{
			List<FoldMarker> foldings = new List<FoldMarker>();
			if (foldMarker != null) {
				Point end = new Point(0, 0);
				foreach (FoldMarker fm in foldMarker) {
					if (fm.IsFolded && (fm.StartLine > end.Y || fm.StartLine == end.Y && fm.StartColumn >= end.X)) {
						foldings.Add(fm);
						end = new Point(fm.EndColumn, fm.EndLine);
					}
				}
			}
			return foldings;
		}
		
		public void UpdateFoldings(string fileName, object parseInfo)
		{
			UpdateFoldings(foldingStrategy.GenerateFoldMarkers(document, fileName, parseInfo));
		}
		
		public void UpdateFoldings(List<FoldMarker> newFoldings)
		{
			int oldFoldingsCount = foldMarker.Count;
			lock (this) {
				if (newFoldings != null && newFoldings.Count != 0) {
					newFoldings.Sort();
					if (foldMarker.Count == newFoldings.Count) {
						for (int i = 0; i < foldMarker.Count; ++i) {
							newFoldings[i].IsFolded = foldMarker[i].IsFolded;
						}
						foldMarker = newFoldings;
					} else {
						for (int i = 0, j = 0; i < foldMarker.Count && j < newFoldings.Count;) {
							int n = newFoldings[j].CompareTo(foldMarker[i]);
							if (n > 0) {
								++i;
							} else {
								if (n == 0) {
									newFoldings[j].IsFolded = foldMarker[i].IsFolded;
								}
								++j;
							}
						}
					}
				}
				if (newFoldings != null) {
					foldMarker = newFoldings;
					foldMarkerByEnd = new List<FoldMarker>(newFoldings);
					foldMarkerByEnd.Sort(EndComparer.Instance);
				} else {
					foldMarker.Clear();
					foldMarkerByEnd.Clear();
				}
			}
			if (oldFoldingsCount != foldMarker.Count) {
				document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.WholeTextArea));
				document.CommitUpdate();
			}
		}
		
		public string SerializeToString()
		{
			StringBuilder sb = new StringBuilder();
			foreach (FoldMarker marker in this.foldMarker) {
				sb.Append(marker.Offset);sb.Append("\n");
				sb.Append(marker.Length);sb.Append("\n");
				sb.Append(marker.FoldText);sb.Append("\n");
				sb.Append(marker.IsFolded);sb.Append("\n");
			}
			return sb.ToString();
		}
		
		public void DeserializeFromString(string str)
		{
			try {
				string[] lines = str.Split('\n');
				for (int i = 0; i < lines.Length && lines[i].Length > 0; i += 4) {
					int    offset = Int32.Parse(lines[i]);
					int    length = Int32.Parse(lines[i + 1]);
					string text   = lines[i + 2];
					bool isFolded = Boolean.Parse(lines[i + 3]);
					bool found    = false;
					foreach (FoldMarker marker in foldMarker) {
						if (marker.Offset == offset && marker.Length == length) {
							marker.IsFolded = isFolded;
							found = true;
							break;
						}
					}
					if (!found) {
						foldMarker.Add(new FoldMarker(document, offset, length, text, isFolded));
					}
				}
				if (lines.Length > 0) {
					NotifyFoldingsChanged(EventArgs.Empty);
				}
			} catch (Exception) {
			}
		}
		
		public void NotifyFoldingsChanged(EventArgs e)
		{
			if (FoldingsChanged != null) {
				FoldingsChanged(this, e);
			}
		}
		
		
		public event EventHandler FoldingsChanged;
	}
}

#endif
// file ...\TextFileEdit\Document\FoldingStrategy\FoldMarker.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2063 $</version>
// </file>


namespace TextFileEdit.Document
{
	public enum FoldType {
		Unspecified,
		MemberBody,
		Region,
		TypeBody
	}
	
	public class FoldMarker : AbstractSegment, IComparable
	{
		bool      isFolded = false;
		string    foldText = "...";
		FoldType  foldType = FoldType.Unspecified;
		IDocument document = null;
		int startLine = -1, startColumn, endLine = -1, endColumn;
		
		static void GetPointForOffset(IDocument document, int offset, out int line, out int column)
		{
			if (offset > document.TextLength) {
				line = document.TotalNumberOfLines + 1;
				column = 1;
			} else if (offset < 0) {
				line = -1;
				column = -1;
			} else {
				line = document.GetLineNumberForOffset(offset);
				column = offset - document.GetLineSegment(line).Offset;
			}
		}
		
		public FoldType FoldType {
			get { return foldType; }
			set { foldType = value; }
		}
		
		public int StartLine {
			get {
				if (startLine < 0) {
					GetPointForOffset(document, offset, out startLine, out startColumn);
				}
				return startLine;
			}
		}
		
		public int StartColumn {
			get {
				if (startLine < 0) {
					GetPointForOffset(document, offset, out startLine, out startColumn);
				}
				return startColumn;
			}
		}
		
		public int EndLine {
			get {
				if (endLine < 0) {
					GetPointForOffset(document, offset + length, out endLine, out endColumn);
				}
				return endLine;
			}
		}
		
		public int EndColumn {
			get {
				if (endLine < 0) {
					GetPointForOffset(document, offset + length, out endLine, out endColumn);
				}
				return endColumn;
			}
		}
		
		public override int Offset {
			get { return base.Offset; }
			set {
				base.Offset = value;
				startLine = -1; endLine = -1;
			}
		}
		public override int Length {
			get { return base.Length; }
			set {
				base.Length = value;
				endLine = -1;
			}
		}
		
		public bool IsFolded {
			get {
				return isFolded;
			}
			set {
				isFolded = value;
			}
		}
		
		public string FoldText {
			get {
				return foldText;
			}
		}
		
		public string InnerText {
			get {
				return document.GetText(offset, length);
			}
		}
		
		public FoldMarker(IDocument document, int offset, int length, string foldText, bool isFolded)
		{
			this.document = document;
			this.offset   = offset;
			this.length   = length;
			this.foldText = foldText;
			this.isFolded = isFolded;
		}
		
		public FoldMarker(IDocument document, int startLine, int startColumn, int endLine, int endColumn) : this(document, startLine, startColumn, endLine, endColumn, FoldType.Unspecified)
		{
		}
		
		public FoldMarker(IDocument document, int startLine, int startColumn, int endLine, int endColumn, FoldType foldType)  : this(document, startLine, startColumn, endLine, endColumn, foldType, "...")
		{
		}
		
		public FoldMarker(IDocument document, int startLine, int startColumn, int endLine, int endColumn, FoldType foldType, string foldText) : this(document, startLine, startColumn, endLine, endColumn, foldType, foldText, false)
		{
		}
		
		public FoldMarker(IDocument document, int startLine, int startColumn, int endLine, int endColumn, FoldType foldType, string foldText, bool isFolded)
		{
			this.document = document;
			
			startLine = Math.Min(document.TotalNumberOfLines - 1, Math.Max(startLine, 0));
			ISegment startLineSegment = document.GetLineSegment(startLine);
			
			endLine = Math.Min(document.TotalNumberOfLines - 1, Math.Max(endLine, 0));
			ISegment endLineSegment   = document.GetLineSegment(endLine);
			
			// Prevent the region from completely disappearing
			if (string.IsNullOrEmpty(foldText)) {
				foldText = "...";
			}
			
			this.FoldType = foldType;
			this.foldText = foldText;
			this.offset = startLineSegment.Offset + Math.Min(startColumn, startLineSegment.Length);
			this.length = (endLineSegment.Offset + Math.Min(endColumn, endLineSegment.Length)) - this.offset;
			this.isFolded = isFolded;
		}
		
		public int CompareTo(object o)
		{
			if (!(o is FoldMarker)) {
				throw new ArgumentException();
			}
			FoldMarker f = (FoldMarker)o;
			if (offset != f.offset) {
				return offset.CompareTo(f.offset);
			}
			
			return length.CompareTo(f.length);
		}
	}
}

#endif
// file ...\TextFileEdit\Document\FoldingStrategy\IFoldingStrategy.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1965 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// This interface is used for the folding capabilities
	/// of the textarea.
	/// </summary>
	public interface IFoldingStrategy
	{
		/// <remarks>
		/// Calculates the fold level of a specific line.
		/// </remarks>
		List<FoldMarker> GenerateFoldMarkers(IDocument document, string fileName, object parseInformation);
	}
}

#endif
// file ...\TextFileEdit\Document\FoldingStrategy\IndentFoldingStrategy.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 915 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// A simple folding strategy which calculates the folding level
	/// using the indent level of the line.
	/// </summary>
	public class IndentFoldingStrategy : IFoldingStrategy
	{
		public List<FoldMarker> GenerateFoldMarkers(IDocument document, string fileName, object parseInformation)
		{
			List<FoldMarker> l = new List<FoldMarker>();
			Stack<int> offsetStack = new Stack<int>();
			Stack<string> textStack = new Stack<string>();
			//int level = 0;
			//foreach (LineSegment segment in document.LineSegmentCollection) {
			//	
			//}
			return l;
		}
		
		int GetLevel(IDocument document, int offset)
		{
			int level = 0;
			int spaces = 0;
			for (int i = offset; i < document.TextLength; ++i) {
				char c = document.GetCharAt(i);
				if (c == '\t' || (c == ' ' && ++spaces == 4)) {
					spaces = 0;
					++level;
				} else {
					break;
				}
			}
			return level;
		}
	}
}

#endif
// file ...\TextFileEdit\Document\FormattingStrategy\DefaultFormattingStrategy.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3272 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// This class handles the auto and smart indenting in the textbuffer while
	/// you type.
	/// </summary>
	public class DefaultFormattingStrategy : IFormattingStrategy
	{
		/// <summary>
		/// Creates a new instance off <see cref="DefaultFormattingStrategy"/>
		/// </summary>
		public DefaultFormattingStrategy()
		{
		}
		
		/// <summary>
		/// returns the whitespaces which are before a non white space character in the line line
		/// as a string.
		/// </summary>
		protected string GetIndentation(TextArea textArea, int lineNumber)
		{
			if (lineNumber < 0 || lineNumber > textArea.Document.TotalNumberOfLines) {
				throw new ArgumentOutOfRangeException("lineNumber");
			}
			
			string lineText = TextUtilities.GetLineAsString(textArea.Document, lineNumber);
			StringBuilder whitespaces = new StringBuilder();
			
			foreach (char ch in lineText) {
				if (Char.IsWhiteSpace(ch)) {
					whitespaces.Append(ch);
				} else {
					break;
				}
			}
			return whitespaces.ToString();
		}
		
		/// <summary>
		/// Could be overwritten to define more complex indenting.
		/// </summary>
		protected virtual int AutoIndentLine(TextArea textArea, int lineNumber)
		{
			string indentation = lineNumber != 0 ? GetIndentation(textArea, lineNumber - 1) : "";
			if(indentation.Length > 0) {
				string newLineText = indentation + TextUtilities.GetLineAsString(textArea.Document, lineNumber).Trim();
				LineSegment oldLine  = textArea.Document.GetLineSegment(lineNumber);
				SmartReplaceLine(textArea.Document, oldLine, newLineText);
			}
			return indentation.Length;
		}
		
		static readonly char[] whitespaceChars = {' ', '\t'};
		
		/// <summary>
		/// Replaces the text in a line.
		/// If only whitespace at the beginning and end of the line was changed, this method
		/// only adjusts the whitespace and doesn't replace the other text.
		/// </summary>
		public static void SmartReplaceLine(IDocument document, LineSegment line, string newLineText)
		{
			if (document == null)
				throw new ArgumentNullException("document");
			if (line == null)
				throw new ArgumentNullException("line");
			if (newLineText == null)
				throw new ArgumentNullException("newLineText");
			string newLineTextTrim = newLineText.Trim(whitespaceChars);
			string oldLineText = document.GetText(line);
			if (oldLineText == newLineText)
				return;
			int pos = oldLineText.IndexOf(newLineTextTrim);
			if (newLineTextTrim.Length > 0 && pos >= 0) {
				document.UndoStack.StartUndoGroup();
				try {
					// find whitespace at beginning
					int startWhitespaceLength = 0;
					while (startWhitespaceLength < newLineText.Length) {
						char c = newLineText[startWhitespaceLength];
						if (c != ' ' && c != '\t')
							break;
						startWhitespaceLength++;
					}
					// find whitespace at end
					int endWhitespaceLength = newLineText.Length - newLineTextTrim.Length - startWhitespaceLength;
					
					// replace whitespace sections
					int lineOffset = line.Offset;
					document.Replace(lineOffset + pos + newLineTextTrim.Length, line.Length - pos - newLineTextTrim.Length, newLineText.Substring(newLineText.Length - endWhitespaceLength));
					document.Replace(lineOffset, pos, newLineText.Substring(0, startWhitespaceLength));
				} finally {
					document.UndoStack.EndUndoGroup();
				}
			} else {
				document.Replace(line.Offset, line.Length, newLineText);
			}
		}
		
		/// <summary>
		/// Could be overwritten to define more complex indenting.
		/// </summary>
		protected virtual int SmartIndentLine(TextArea textArea, int line)
		{
			return AutoIndentLine(textArea, line); // smart = autoindent in normal texts
		}
		
		/// <summary>
		/// This function formats a specific line after <code>ch</code> is pressed.
		/// </summary>
		/// <returns>
		/// the caret delta position the caret will be moved this number
		/// of bytes (e.g. the number of bytes inserted before the caret, or
		/// removed, if this number is negative)
		/// </returns>
		public virtual void FormatLine(TextArea textArea, int line, int cursorOffset, char ch)
		{
			if (ch == '\n') {
				textArea.Caret.Column = IndentLine(textArea, line);
			}
		}
		
		/// <summary>
		/// This function sets the indentation level in a specific line
		/// </summary>
		/// <returns>
		/// the number of inserted characters.
		/// </returns>
		public int IndentLine(TextArea textArea, int line)
		{
			textArea.Document.UndoStack.StartUndoGroup();
			int result;
			switch (textArea.Document.TextEditorProperties.IndentStyle) {
				case IndentStyle.None:
					result = 0;
					break;
				case IndentStyle.Auto:
					result = AutoIndentLine(textArea, line);
					break;
				case IndentStyle.Smart:
					result = SmartIndentLine(textArea, line);
					break;
				default:
					throw new NotSupportedException("Unsupported value for IndentStyle: " + textArea.Document.TextEditorProperties.IndentStyle);
			}
			textArea.Document.UndoStack.EndUndoGroup();
			return result;
		}
		
		/// <summary>
		/// This function sets the indentlevel in a range of lines.
		/// </summary>
		public virtual void IndentLines(TextArea textArea, int begin, int end)
		{
			textArea.Document.UndoStack.StartUndoGroup();
			for (int i = begin; i <= end; ++i) {
				IndentLine(textArea, i);
			}
			textArea.Document.UndoStack.EndUndoGroup();
		}
		
		public virtual int SearchBracketBackward(IDocument document, int offset, char openBracket, char closingBracket)
		{
			int brackets = -1;
			// first try "quick find" - find the matching bracket if there is no string/comment in the way
			for (int i = offset; i >= 0; --i) {
				char ch = document.GetCharAt(i);
				if (ch == openBracket) {
					++brackets;
					if (brackets == 0) return i;
				} else if (ch == closingBracket) {
					--brackets;
				} else if (ch == '"') {
					break;
				} else if (ch == '\'') {
					break;
				} else if (ch == '/' && i > 0) {
					if (document.GetCharAt(i - 1) == '/') break;
					if (document.GetCharAt(i - 1) == '*') break;
				}
			}
			return -1;
		}
		
		public virtual int SearchBracketForward(IDocument document, int offset, char openBracket, char closingBracket)
		{
			int brackets = 1;
			// try "quick find" - find the matching bracket if there is no string/comment in the way
			for (int i = offset; i < document.TextLength; ++i) {
				char ch = document.GetCharAt(i);
				if (ch == openBracket) {
					++brackets;
				} else if (ch == closingBracket) {
					--brackets;
					if (brackets == 0) return i;
				} else if (ch == '"') {
					break;
				} else if (ch == '\'') {
					break;
				} else if (ch == '/' && i > 0) {
					if (document.GetCharAt(i - 1) == '/') break;
				} else if (ch == '*' && i > 0) {
					if (document.GetCharAt(i - 1) == '/') break;
				}
			}
			return -1;
		}
	}
}

#endif
// file ...\TextFileEdit\Document\FormattingStrategy\IFormattingStrategy.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2640 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// This interface handles the auto and smart indenting and formating
	/// in the document while  you type. Language bindings could overwrite this 
	/// interface and define their own indentation/formating.
	/// </summary>
	public interface IFormattingStrategy
	{
		/// <summary>
		/// This function formats a specific line after <code>ch</code> is pressed.
		/// </summary>
		void FormatLine(TextArea textArea, int line, int caretOffset, char charTyped);
		
		/// <summary>
		/// This function sets the indentation level in a specific line
		/// </summary>
		/// <returns>
		/// The target caret position (length of new indentation).
		/// </returns>
		int IndentLine(TextArea textArea, int line);
		
		/// <summary>
		/// This function sets the indentlevel in a range of lines.
		/// </summary>
		void IndentLines(TextArea textArea, int begin, int end);
		
		/// <summary>
		/// Finds the offset of the opening bracket in the block defined by offset skipping
		/// brackets in strings and comments.
		/// </summary>
		/// <param name="document">The document to search in.</param>
		/// <param name="offset">The offset of an position in the block or the offset of the closing bracket.</param>
		/// <param name="openBracket">The character for the opening bracket.</param>
		/// <param name="closingBracket">The character for the closing bracket.</param>
		/// <returns>Returns the offset of the opening bracket or -1 if no matching bracket was found.</returns>
		int SearchBracketBackward(IDocument document, int offset, char openBracket, char closingBracket);
		
		/// <summary>
		/// Finds the offset of the closing bracket in the block defined by offset skipping
		/// brackets in strings and comments.
		/// </summary>
		/// <param name="document">The document to search in.</param>
		/// <param name="offset">The offset of an position in the block or the offset of the opening bracket.</param>
		/// <param name="openBracket">The character for the opening bracket.</param>
		/// <param name="closingBracket">The character for the closing bracket.</param>
		/// <returns>Returns the offset of the closing bracket or -1 if no matching bracket was found.</returns>
		int SearchBracketForward(IDocument document, int offset, char openBracket, char closingBracket);
	}
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3658 $</version>
// </file>


namespace TextFileEdit.Document
{
    public class DefaultHighlightingStrategy : IHighlightingStrategyUsingRuleSets
    {
        string    name;
        List<HighlightRuleSet> rules = new List<HighlightRuleSet>();
        
        Dictionary<string, HighlightColor> environmentColors = new Dictionary<string, HighlightColor>();
        Dictionary<string, string> properties       = new Dictionary<string, string>();
        string[]  extensions;
        
        HighlightColor   digitColor;
        HighlightRuleSet defaultRuleSet = null;
        
        public HighlightColor DigitColor {
            get {
                return digitColor;
            }
            set {
                digitColor = value;
            }
        }
        
        public IEnumerable<KeyValuePair<string, HighlightColor>> EnvironmentColors {
            get {
                return environmentColors;
            }
        }
        
        protected void ImportSettingsFrom(DefaultHighlightingStrategy source)
        {
            if (source == null)
                throw new ArgumentNullException("source");
            properties = source.properties;
            extensions = source.extensions;
            digitColor = source.digitColor;
            defaultRuleSet = source.defaultRuleSet;
            name = source.name;
            rules = source.rules;
            environmentColors = source.environmentColors;
            defaultTextColor = source.defaultTextColor;
        }
        
        public DefaultHighlightingStrategy() : this("Default")
        {
        }
        
        public DefaultHighlightingStrategy(string name)
        {
            this.name = name;
            
            digitColor       = new HighlightColor(SystemColors.WindowText, false, false);
            defaultTextColor = new HighlightColor(SystemColors.WindowText, false, false);
            
            // set small 'default color environment'
            environmentColors["Default"]          = new HighlightBackground("WindowText", "Window", false, false);
            environmentColors["Selection"]        = new HighlightColor("HighlightText", "Highlight", false, false);
            environmentColors["VRuler"]           = new HighlightColor("ControlLight", "Window", false, false);
            environmentColors["InvalidLines"]     = new HighlightColor(Color.Red, false, false);
            environmentColors["CaretMarker"]      = new HighlightColor(Color.Yellow, false, false);
            environmentColors["CaretLine"] = new HighlightBackground("ControlLight", "Window", false, false);
            environmentColors["LineNumbers"] = new HighlightBackground("ControlDark", "Window", false, false);
            
            environmentColors["FoldLine"]         = new HighlightColor("ControlDark", false, false);
            environmentColors["FoldMarker"]       = new HighlightColor("WindowText", "Window", false, false);
            environmentColors["SelectedFoldLine"] = new HighlightColor("WindowText", false, false);
            environmentColors["EOLMarkers"]       = new HighlightColor("ControlLight", "Window", false, false);
            environmentColors["SpaceMarkers"]     = new HighlightColor("ControlLight", "Window", false, false);
            environmentColors["TabMarkers"]       = new HighlightColor("ControlLight", "Window", false, false);
            
        }
        
        public Dictionary<string, string> Properties {
            get {
                return properties;
            }
        }
        
        public string Name
        {
            get {
                return name;
            }
        }
        
        public string[] Extensions
        {
            set {
                extensions = value;
            }
            get {
                return extensions;
            }
        }
        
        public List<HighlightRuleSet> Rules {
            get {
                return rules;
            }
        }
        
        public HighlightRuleSet FindHighlightRuleSet(string name)
        {
            foreach(HighlightRuleSet ruleSet in rules) {
                if (ruleSet.Name == name) {
                    return ruleSet;
                }
            }
            return null;
        }
        
        public void AddRuleSet(HighlightRuleSet aRuleSet)
        {
            HighlightRuleSet existing = FindHighlightRuleSet(aRuleSet.Name);
            if (existing != null) {
                existing.MergeFrom(aRuleSet);
            } else {
                rules.Add(aRuleSet);
            }
        }
        
        public void ResolveReferences()
        {
            // Resolve references from Span definitions to RuleSets
            ResolveRuleSetReferences();
            // Resolve references from RuleSet defintitions to Highlighters defined in an external mode file
            ResolveExternalReferences();
        }
        
        void ResolveRuleSetReferences()
        {
            foreach (HighlightRuleSet ruleSet in Rules) {
                if (ruleSet.Name == null) {
                    defaultRuleSet = ruleSet;
                }
                
                foreach (Span aSpan in ruleSet.Spans) {
                    if (aSpan.Rule != null) {
                        bool found = false;
                        foreach (HighlightRuleSet refSet in Rules) {
                            if (refSet.Name == aSpan.Rule) {
                                found = true;
                                aSpan.RuleSet = refSet;
                                break;
                            }
                        }
                        if (!found) {
                            aSpan.RuleSet = null;
                            throw new HighlightingDefinitionInvalidException("The RuleSet " + aSpan.Rule + " could not be found in mode definition " + this.Name);
                        }
                    } else {
                        aSpan.RuleSet = null;
                    }
                }
            }
            
            if (defaultRuleSet == null) {
                throw new HighlightingDefinitionInvalidException("No default RuleSet is defined for mode definition " + this.Name);
            }
        }
        
        void ResolveExternalReferences()
        {
            foreach (HighlightRuleSet ruleSet in Rules) {
                ruleSet.Highlighter = this;
                if (ruleSet.Reference != null) {
                    IHighlightingStrategy highlighter = HighlightingManager.Manager.FindHighlighter (ruleSet.Reference);
                    
                    if (highlighter == null)
                        throw new HighlightingDefinitionInvalidException("The mode defintion " + ruleSet.Reference + " which is refered from the " + this.Name + " mode definition could not be found");
                    if (highlighter is IHighlightingStrategyUsingRuleSets)
                        ruleSet.Highlighter = (IHighlightingStrategyUsingRuleSets)highlighter;
                    else
                        throw new HighlightingDefinitionInvalidException("The mode defintion " + ruleSet.Reference + " which is refered from the " + this.Name + " mode definition does not implement IHighlightingStrategyUsingRuleSets");
                }
            }
        }
        
//      internal void SetDefaultColor(HighlightBackground color)
//      {
//          return (HighlightColor)environmentColors[name];
//          defaultColor = color;
//      }
        
        HighlightColor defaultTextColor;
        
        public HighlightColor DefaultTextColor {
            get {
                return defaultTextColor;
            }
        }
        
        public void SetColorFor(string name, HighlightColor color)
        {
            if (name == "Default")
                defaultTextColor = new HighlightColor(color.Color, color.Bold, color.Italic);
            environmentColors[name] = color;
        }

        public HighlightColor GetColorFor(string name)
        {
            HighlightColor color;
            if (environmentColors.TryGetValue(name, out color))
                return color;
            else
                return defaultTextColor;
        }
        
        public HighlightColor GetColor(IDocument document, LineSegment currentSegment, int currentOffset, int currentLength)
        {
            return GetColor(defaultRuleSet, document, currentSegment, currentOffset, currentLength);
        }

        protected virtual HighlightColor GetColor(HighlightRuleSet ruleSet, IDocument document, LineSegment currentSegment, int currentOffset, int currentLength)
        {
            if (ruleSet != null) {
                if (ruleSet.Reference != null) {
                    return ruleSet.Highlighter.GetColor(document, currentSegment, currentOffset, currentLength);
                } else {
                    return (HighlightColor)ruleSet.KeyWords[document,  currentSegment, currentOffset, currentLength];
                }
            }
            return null;
        }
        
        public HighlightRuleSet GetRuleSet(Span aSpan)
        {
            if (aSpan == null) {
                return this.defaultRuleSet;
            } else {
                if (aSpan.RuleSet != null)
                {
                    if (aSpan.RuleSet.Reference != null) {
                        return aSpan.RuleSet.Highlighter.GetRuleSet(null);
                    } else {
                        return aSpan.RuleSet;
                    }
                } else {
                    return null;
                }
            }
        }

        // Line state variable
        protected LineSegment currentLine;
        protected int currentLineNumber;
        
        // Span stack state variable
        protected SpanStack currentSpanStack;

        public virtual void MarkTokens(IDocument document)
        {
            if (Rules.Count == 0) {
                return;
            }
            
            int lineNumber = 0;
            
            while (lineNumber < document.TotalNumberOfLines) {
                LineSegment previousLine = (lineNumber > 0 ? document.GetLineSegment(lineNumber - 1) : null);
                if (lineNumber >= document.LineSegmentCollection.Count) { // may be, if the last line ends with a delimiter
                    break;                                                // then the last line is not in the collection :)
                }
                
                currentSpanStack = ((previousLine != null && previousLine.HighlightSpanStack != null) ? previousLine.HighlightSpanStack.Clone() : null);
                
                if (currentSpanStack != null) {
                    while (!currentSpanStack.IsEmpty && currentSpanStack.Peek().StopEOL)
                    {
                        currentSpanStack.Pop();
                    }
                    if (currentSpanStack.IsEmpty) currentSpanStack = null;
                }
                
                currentLine = (LineSegment)document.LineSegmentCollection[lineNumber];
                
                if (currentLine.Length == -1) { // happens when buffer is empty !
                    return;
                }
                
                currentLineNumber = lineNumber;
                List<TextWord> words = ParseLine(document);
                // Alex: clear old words
                if (currentLine.Words != null) {
                    currentLine.Words.Clear();
                }
                currentLine.Words = words;
                currentLine.HighlightSpanStack = (currentSpanStack==null || currentSpanStack.IsEmpty) ? null : currentSpanStack;
                
                ++lineNumber;
            }
            document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.WholeTextArea));
            document.CommitUpdate();
            currentLine = null;
        }
        
        bool MarkTokensInLine(IDocument document, int lineNumber, ref bool spanChanged)
        {
            currentLineNumber = lineNumber;
            bool processNextLine = false;
            LineSegment previousLine = (lineNumber > 0 ? document.GetLineSegment(lineNumber - 1) : null);
            
            currentSpanStack = ((previousLine != null && previousLine.HighlightSpanStack != null) ? previousLine.HighlightSpanStack.Clone() : null);
            if (currentSpanStack != null) {
                while (!currentSpanStack.IsEmpty && currentSpanStack.Peek().StopEOL) {
                    currentSpanStack.Pop();
                }
                if (currentSpanStack.IsEmpty) {
                    currentSpanStack = null;
                }
            }
            
            currentLine = (LineSegment)document.LineSegmentCollection[lineNumber];
            
            if (currentLine.Length == -1) { // happens when buffer is empty !
                return false;
            }
            
            List<TextWord> words = ParseLine(document);
            
            if (currentSpanStack != null && currentSpanStack.IsEmpty) {
                currentSpanStack = null;
            }
            
            // Check if the span state has changed, if so we must re-render the next line
            // This check may seem utterly complicated but I didn't want to introduce any function calls
            // or allocations here for perf reasons.
            if(currentLine.HighlightSpanStack != currentSpanStack) {
                if (currentLine.HighlightSpanStack == null) {
                    processNextLine = false;
                    foreach (Span sp in currentSpanStack) {
                        if (!sp.StopEOL) {
                            spanChanged = true;
                            processNextLine = true;
                            break;
                        }
                    }
                } else if (currentSpanStack == null) {
                    processNextLine = false;
                    foreach (Span sp in currentLine.HighlightSpanStack) {
                        if (!sp.StopEOL) {
                            spanChanged = true;
                            processNextLine = true;
                            break;
                        }
                    }
                } else {
                    SpanStack.Enumerator e1 = currentSpanStack.GetEnumerator();
                    SpanStack.Enumerator e2 = currentLine.HighlightSpanStack.GetEnumerator();
                    bool done = false;
                    while (!done) {
                        bool blockSpanIn1 = false;
                        while (e1.MoveNext()) {
                            if (!((Span)e1.Current).StopEOL) {
                                blockSpanIn1 = true;
                                break;
                            }
                        }
                        bool blockSpanIn2 = false;
                        while (e2.MoveNext()) {
                            if (!((Span)e2.Current).StopEOL) {
                                blockSpanIn2 = true;
                                break;
                            }
                        }
                        if (blockSpanIn1 || blockSpanIn2) {
                            if (blockSpanIn1 && blockSpanIn2) {
                                if (e1.Current != e2.Current) {
                                    done = true;
                                    processNextLine = true;
                                    spanChanged = true;
                                }
                            } else {
                                spanChanged = true;
                                done = true;
                                processNextLine = true;
                            }
                        } else {
                            done = true;
                            processNextLine = false;
                        }
                    }
                }
            } else {
                processNextLine = false;
            }
            
            //// Alex: remove old words
            if (currentLine.Words!=null) currentLine.Words.Clear();
            currentLine.Words = words;
            currentLine.HighlightSpanStack = (currentSpanStack != null && !currentSpanStack.IsEmpty) ? currentSpanStack : null;
            
            return processNextLine;
        }
        
        public virtual void MarkTokens(IDocument document, List<LineSegment> inputLines)
        {
            if (Rules.Count == 0) {
                return;
            }
            
            Dictionary<LineSegment, bool> processedLines = new Dictionary<LineSegment, bool>();
            
            bool spanChanged = false;
            int documentLineSegmentCount = document.LineSegmentCollection.Count;
            
            foreach (LineSegment lineToProcess in inputLines) {
                if (!processedLines.ContainsKey(lineToProcess)) {
                    int lineNumber = lineToProcess.LineNumber;
                    bool processNextLine = true;
                    
                    if (lineNumber != -1) {
                        while (processNextLine && lineNumber < documentLineSegmentCount) {
                            processNextLine = MarkTokensInLine(document, lineNumber, ref spanChanged);
                            processedLines[currentLine] = true;
                            ++lineNumber;
                        }
                    }
                }
            }
            
            if (spanChanged || inputLines.Count > 20) {
                // if the span was changed (more than inputLines lines had to be reevaluated)
                // or if there are many lines in inputLines, it's faster to update the whole
                // text area instead of many small segments
                document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.WholeTextArea));
            } else {
//              document.Caret.ValidateCaretPos();
//              document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.SingleLine, document.GetLineNumberForOffset(document.Caret.Offset)));
//
                foreach (LineSegment lineToProcess in inputLines) {
                    document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.SingleLine, lineToProcess.LineNumber));
                }
                
            }
            document.CommitUpdate();
            currentLine = null;
        }
        
        // Span state variables
        protected bool inSpan;
        protected Span activeSpan;
        protected HighlightRuleSet activeRuleSet;
        
        // Line scanning state variables
        protected int currentOffset;
        protected int currentLength;
        
        void UpdateSpanStateVariables()
        {
            inSpan = (currentSpanStack != null && !currentSpanStack.IsEmpty);
            activeSpan = inSpan ? currentSpanStack.Peek() : null;
            activeRuleSet = GetRuleSet(activeSpan);
        }

        List<TextWord> ParseLine(IDocument document)
        {
            List<TextWord> words = new List<TextWord>();
            HighlightColor markNext = null;
            
            currentOffset = 0;
            currentLength = 0;
            UpdateSpanStateVariables();
            
            int currentLineLength = currentLine.Length;
            int currentLineOffset = currentLine.Offset;
            
            for (int i = 0; i < currentLineLength; ++i) {
                char ch = document.GetCharAt(currentLineOffset + i);
                switch (ch) {
                    case '\n':
                    case '\r':
                        PushCurWord(document, ref markNext, words);
                        ++currentOffset;
                        break;
                    case ' ':
                        PushCurWord(document, ref markNext, words);
                        if (activeSpan != null && activeSpan.Color.HasBackground) {
                            words.Add(new TextWord.SpaceTextWord(activeSpan.Color));
                        } else {
                            words.Add(TextWord.Space);
                        }
                        ++currentOffset;
                        break;
                    case '\t':
                        PushCurWord(document, ref markNext, words);
                        if (activeSpan != null && activeSpan.Color.HasBackground) {
                            words.Add(new TextWord.TabTextWord(activeSpan.Color));
                        } else {
                            words.Add(TextWord.Tab);
                        }
                        ++currentOffset;
                        break;
                    case '\x0000': //NULL(Null character)
                    case '\x0001': //SOH(Start of Header)
                    case '\x0002': //STX(Start of Text)
                    case '\x0003': //ETX(End of Text)
                    case '\x0004': //EOT(End of Trans.)
                    case '\x0005': //ENQ(Enquiry)
                    case '\x0006': //ACK(Acknowledgement)
                    case '\x0007': //BEL(Bell)
                    case '\x0008': //BS(Backspace)
                    //case '\x0009': //HT(Horizontal Tab)
                    //case '\x000A': //LF(Line feed)
                    case '\x000B': //VT(Vertical Tab)
                    case '\x000C': //FF(Form feed)
                    //case '\x000D': //CR(Carriage return)
                    case '\x000E': //SO(Shift Out)
                    case '\x000F': //SI(Shift In)
                    case '\x0010': //DLE(Data link escape)
                    case '\x0011': //DC1(Device control 1)
                    case '\x0012': //DC2(Device control 2)
                    case '\x0013': //DC3(Device control 3)
                    case '\x0014': //DC4(Device control 4)
                    case '\x0015': //NAK(Negative acknowl.)
                    case '\x0016': //SYN(Synchronous idle)
                    case '\x0017': //ETB(End of trans. block)
                    case '\x0018': //CAN(Cancel)
                    case '\x0019': //EM(End of medium)
                    case '\x001A': //SUB(Substitute)
                    case '\x001B': //ESC(Escape)
                    case '\x001C': //FS(File separator)
                    case '\x001D': //GS(Group separator)
                    case '\x001E': //RS(Record separator)
                    case '\x001F': //US(Unit separator)
                    case '\x007F': //DEL(Delete)
                        PushCurWord(document, ref markNext, words);
                        if (activeSpan != null && activeSpan.Color.HasBackground)
                        {
                            words.Add(new TextWord.NullTextWord(ch.ToString(), activeSpan.Color));
                        }
                        else
                        {
                            words.Add(new TextWord.NullTextWord(ch.ToString()));
                        }
                        ++currentOffset;
                        break;
                    default:
                        {
                            // handle escape characters
                            char escapeCharacter = '\0';
                            if (activeSpan != null && activeSpan.EscapeCharacter != '\0') {
                                escapeCharacter = activeSpan.EscapeCharacter;
                            } else if (activeRuleSet != null) {
                                escapeCharacter = activeRuleSet.EscapeCharacter;
                            }
                            if (escapeCharacter != '\0' && escapeCharacter == ch) {
                                // we found the escape character
                                if (activeSpan != null && activeSpan.End != null && activeSpan.End.Length == 1
                                    && escapeCharacter == activeSpan.End[0])
                                {
                                    // the escape character is a end-doubling escape character
                                    // it may count as escape only when the next character is the escape, too
                                    if (i + 1 < currentLineLength) {
                                        if (document.GetCharAt(currentLineOffset + i + 1) == escapeCharacter) {
                                            currentLength += 2;
                                            PushCurWord(document, ref markNext, words);
                                            ++i;
                                            continue;
                                        }
                                    }
                                } else {
                                    // this is a normal \-style escape
                                    ++currentLength;
                                    if (i + 1 < currentLineLength) {
                                        ++currentLength;
                                    }
                                    PushCurWord(document, ref markNext, words);
                                    ++i;
                                    continue;
                                }
                            }
                            
                            // highlight digits
                            if (!inSpan && (Char.IsDigit(ch) || (ch == '.' && i + 1 < currentLineLength && Char.IsDigit(document.GetCharAt(currentLineOffset + i + 1)))) && currentLength == 0) {
                                bool ishex = false;
                                bool isfloatingpoint = false;
                                
                                if (ch == '0' && i + 1 < currentLineLength && Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)) == 'X') { // hex digits
                                    const string hex = "0123456789ABCDEF";
                                    ++currentLength;
                                    ++i; // skip 'x'
                                    ++currentLength;
                                    ishex = true;
                                    while (i + 1 < currentLineLength && hex.IndexOf(Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1))) != -1) {
                                        ++i;
                                        ++currentLength;
                                    }
                                } else {
                                    ++currentLength;
                                    while (i + 1 < currentLineLength && Char.IsDigit(document.GetCharAt(currentLineOffset + i + 1))) {
                                        ++i;
                                        ++currentLength;
                                    }
                                }
                                if (!ishex && i + 1 < currentLineLength && document.GetCharAt(currentLineOffset + i + 1) == '.') {
                                    isfloatingpoint = true;
                                    ++i;
                                    ++currentLength;
                                    while (i + 1 < currentLineLength && Char.IsDigit(document.GetCharAt(currentLineOffset + i + 1))) {
                                        ++i;
                                        ++currentLength;
                                    }
                                }
                                
                                if (i + 1 < currentLineLength && Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)) == 'E') {
                                    isfloatingpoint = true;
                                    ++i;
                                    ++currentLength;
                                    if (i + 1 < currentLineLength && (document.GetCharAt(currentLineOffset + i + 1) == '+' || document.GetCharAt(currentLine.Offset + i + 1) == '-')) {
                                        ++i;
                                        ++currentLength;
                                    }
                                    while (i + 1 < currentLine.Length && Char.IsDigit(document.GetCharAt(currentLineOffset + i + 1))) {
                                        ++i;
                                        ++currentLength;
                                    }
                                }
                                
                                if (i + 1 < currentLine.Length) {
                                    char nextch = Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1));
                                    if (nextch == 'F' || nextch == 'M' || nextch == 'D') {
                                        isfloatingpoint = true;
                                        ++i;
                                        ++currentLength;
                                    }
                                }
                                
                                if (!isfloatingpoint) {
                                    bool isunsigned = false;
                                    if (i + 1 < currentLineLength && Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)) == 'U') {
                                        ++i;
                                        ++currentLength;
                                        isunsigned = true;
                                    }
                                    if (i + 1 < currentLineLength && Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)) == 'L') {
                                        ++i;
                                        ++currentLength;
                                        if (!isunsigned && i + 1 < currentLineLength && Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)) == 'U') {
                                            ++i;
                                            ++currentLength;
                                        }
                                    }
                                }
                                
                                words.Add(new TextWord(document, currentLine, currentOffset, currentLength, DigitColor, false));
                                currentOffset += currentLength;
                                currentLength = 0;
                                continue;
                            }

                            // Check for SPAN ENDs
                            if (inSpan) {
                                if (activeSpan.End != null && activeSpan.End.Length > 0) {
                                    if (MatchExpr(currentLine, activeSpan.End, i, document, activeSpan.IgnoreCase)) {
                                        PushCurWord(document, ref markNext, words);
                                        string regex = GetRegString(currentLine, activeSpan.End, i, document);
                                        currentLength += regex.Length;
                                        words.Add(new TextWord(document, currentLine, currentOffset, currentLength, activeSpan.EndColor, false));
                                        currentOffset += currentLength;
                                        currentLength = 0;
                                        i += regex.Length - 1;
                                        currentSpanStack.Pop();
                                        UpdateSpanStateVariables();
                                        continue;
                                    }
                                }
                            }
                            
                            // check for SPAN BEGIN
                            if (activeRuleSet != null) {
                                foreach (Span span in activeRuleSet.Spans) {
                                    if ((!span.IsBeginSingleWord || currentLength == 0)
                                        && (!span.IsBeginStartOfLine.HasValue || span.IsBeginStartOfLine.Value == (currentLength == 0 && words.TrueForAll(delegate(TextWord textWord) { return textWord.Type != TextWordType.Word; })))
                                        && MatchExpr(currentLine, span.Begin, i, document, activeRuleSet.IgnoreCase)) {
                                        PushCurWord(document, ref markNext, words);
                                        string regex = GetRegString(currentLine, span.Begin, i, document);
                                        
                                        if (!OverrideSpan(regex, document, words, span, ref i)) {
                                            currentLength += regex.Length;
                                            words.Add(new TextWord(document, currentLine, currentOffset, currentLength, span.BeginColor, false));
                                            currentOffset += currentLength;
                                            currentLength = 0;
                                            
                                            i += regex.Length - 1;
                                            if (currentSpanStack == null) {
                                                currentSpanStack = new SpanStack();
                                            }
                                            currentSpanStack.Push(span);
                                            span.IgnoreCase = activeRuleSet.IgnoreCase;
                                            
                                            UpdateSpanStateVariables();
                                        }
                                        
                                        goto skip;
                                    }
                                }
                            }
                            
                            // check if the char is a delimiter
                            if (activeRuleSet != null && (int)ch < 256 && activeRuleSet.Delimiters[(int)ch]) {
                                PushCurWord(document, ref markNext, words);
                                if (currentOffset + currentLength +1 < currentLine.Length) {
                                    ++currentLength;
                                    PushCurWord(document, ref markNext, words);
                                    goto skip;
                                }
                            }
                            
                            ++currentLength;
                            skip: continue;
                        }
                }
            }
            
            PushCurWord(document, ref markNext, words);
            
            OnParsedLine(document, currentLine, words);
            
            return words;
        }
        
        protected virtual void OnParsedLine(IDocument document, LineSegment currentLine, List<TextWord> words)
        {
        }
        
        protected virtual bool OverrideSpan(string spanBegin, IDocument document, List<TextWord> words, Span span, ref int lineOffset)
        {
            return false;
        }
        
        /// <summary>
        /// pushes the curWord string on the word list, with the
        /// correct color.
        /// </summary>
        void PushCurWord(IDocument document, ref HighlightColor markNext, List<TextWord> words)
        {
            // Svante Lidman : Need to look through the next prev logic.
            if (currentLength > 0) {
                if (words.Count > 0 && activeRuleSet != null) {
                    TextWord prevWord = null;
                    int pInd = words.Count - 1;
                    while (pInd >= 0) {
                        if (!((TextWord)words[pInd]).IsWhiteSpace) {
                            prevWord = (TextWord)words[pInd];
                            if (prevWord.HasDefaultColor) {
                                PrevMarker marker = (PrevMarker)activeRuleSet.PrevMarkers[document, currentLine, currentOffset, currentLength];
                                if (marker != null) {
                                    prevWord.SyntaxColor = marker.Color;
//                                  document.Caret.ValidateCaretPos();
//                                  document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.SingleLine, document.GetLineNumberForOffset(document.Caret.Offset)));
                                }
                            }
                            break;
                        }
                        pInd--;
                    }
                }
                
                if (inSpan) {
                    HighlightColor c = null;
                    bool hasDefaultColor = true;
                    if (activeSpan.Rule == null) {
                        c = activeSpan.Color;
                    } else {
                        c = GetColor(activeRuleSet, document, currentLine, currentOffset, currentLength);
                        hasDefaultColor = false;
                    }
                    
                    if (c == null) {
                        c = activeSpan.Color;
                        if (c.Color == Color.Transparent) {
                            c = this.DefaultTextColor;
                        }
                        hasDefaultColor = true;
                    }
                    words.Add(new TextWord(document, currentLine, currentOffset, currentLength, markNext != null ? markNext : c, hasDefaultColor));
                } else {
                    HighlightColor c = markNext != null ? markNext : GetColor(activeRuleSet, document, currentLine, currentOffset, currentLength);
                    if (c == null) {
                        words.Add(new TextWord(document, currentLine, currentOffset, currentLength, this.DefaultTextColor, true));
                    } else {
                        words.Add(new TextWord(document, currentLine, currentOffset, currentLength, c, false));
                    }
                }
                
                if (activeRuleSet != null) {
                    NextMarker nextMarker = (NextMarker)activeRuleSet.NextMarkers[document, currentLine, currentOffset, currentLength];
                    if (nextMarker != null) {
                        if (nextMarker.MarkMarker && words.Count > 0) {
                            TextWord prevword = ((TextWord)words[words.Count - 1]);
                            prevword.SyntaxColor = nextMarker.Color;
                        }
                        markNext = nextMarker.Color;
                    } else {
                        markNext = null;
                    }
                }
                currentOffset += currentLength;
                currentLength = 0;
            }
        }
        
#region Matching
        /// <summary>
        /// get the string, which matches the regular expression expr,
        /// in string s2 at index
        /// </summary>
        static string GetRegString(LineSegment lineSegment, char[] expr, int index, IDocument document)
        {
            int j = 0;
            StringBuilder regexpr = new StringBuilder();
            
            for (int i = 0; i < expr.Length; ++i, ++j) {
                if (index + j >= lineSegment.Length)
                    break;
                
                switch (expr[i]) {
                    case '@': // "special" meaning
                        ++i;
                        if (i == expr.Length)
                            throw new HighlightingDefinitionInvalidException("Unexpected end of @ sequence, use @@ to look for a single @.");
                        switch (expr[i]) {
                            case '!': // don't match the following expression
                                StringBuilder whatmatch = new StringBuilder();
                                ++i;
                                while (i < expr.Length && expr[i] != '@') {
                                    whatmatch.Append(expr[i++]);
                                }
                                break;
                            case '@': // matches @
                                regexpr.Append(document.GetCharAt(lineSegment.Offset + index + j));
                                break;
                        }
                        break;
                    default:
                        if (expr[i] != document.GetCharAt(lineSegment.Offset + index + j)) {
                            return regexpr.ToString();
                        }
                        regexpr.Append(document.GetCharAt(lineSegment.Offset + index + j));
                        break;
                }
            }
            return regexpr.ToString();
        }
        
        /// <summary>
        /// returns true, if the get the string s2 at index matches the expression expr
        /// </summary>
        static bool MatchExpr(LineSegment lineSegment, char[] expr, int index, IDocument document, bool ignoreCase)
        {
            for (int i = 0, j = 0; i < expr.Length; ++i, ++j) {
                switch (expr[i]) {
                    case '@': // "special" meaning
                        ++i;
                        if (i == expr.Length)
                            throw new HighlightingDefinitionInvalidException("Unexpected end of @ sequence, use @@ to look for a single @.");
                        switch (expr[i]) {
                            case 'C': // match whitespace or punctuation
                                if (index + j == lineSegment.Offset || index + j >= lineSegment.Offset + lineSegment.Length) {
                                    // nothing (EOL or SOL)
                                } else {
                                    char ch = document.GetCharAt(lineSegment.Offset + index + j);
                                    if (!Char.IsWhiteSpace(ch) && !Char.IsPunctuation(ch)) {
                                        return false;
                                    }
                                }
                                break;
                            case '!': // don't match the following expression
                                {
                                    StringBuilder whatmatch = new StringBuilder();
                                    ++i;
                                    while (i < expr.Length && expr[i] != '@') {
                                        whatmatch.Append(expr[i++]);
                                    }
                                    if (lineSegment.Offset + index + j + whatmatch.Length < document.TextLength) {
                                        int k = 0;
                                        for (; k < whatmatch.Length; ++k) {
                                            char docChar = ignoreCase ? Char.ToUpperInvariant(document.GetCharAt(lineSegment.Offset + index + j + k)) : document.GetCharAt(lineSegment.Offset + index + j + k);
                                            char spanChar = ignoreCase ? Char.ToUpperInvariant(whatmatch[k]) : whatmatch[k];
                                            if (docChar != spanChar) {
                                                break;
                                            }
                                        }
                                        if (k >= whatmatch.Length) {
                                            return false;
                                        }
                                    }
//                                  --j;
                                    break;
                                }
                            case '-': // don't match the  expression before
                                {
                                    StringBuilder whatmatch = new StringBuilder();
                                    ++i;
                                    while (i < expr.Length && expr[i] != '@') {
                                        whatmatch.Append(expr[i++]);
                                    }
                                    if (index - whatmatch.Length >= 0) {
                                        int k = 0;
                                        for (; k < whatmatch.Length; ++k) {
                                            char docChar = ignoreCase ? Char.ToUpperInvariant(document.GetCharAt(lineSegment.Offset + index - whatmatch.Length + k)) : document.GetCharAt(lineSegment.Offset + index - whatmatch.Length + k);
                                            char spanChar = ignoreCase ? Char.ToUpperInvariant(whatmatch[k]) : whatmatch[k];
                                            if (docChar != spanChar)
                                                break;
                                        }
                                        if (k >= whatmatch.Length) {
                                            return false;
                                        }
                                    }
//                                  --j;
                                    break;
                                }
                            case '@': // matches @
                                if (index + j >= lineSegment.Length || '@' != document.GetCharAt(lineSegment.Offset + index + j)) {
                                    return false;
                                }
                                break;
                        }
                        break;
                    default:
                        {
                            if (index + j >= lineSegment.Length) {
                                return false;
                            }
                            char docChar = ignoreCase ? Char.ToUpperInvariant(document.GetCharAt(lineSegment.Offset + index + j)) : document.GetCharAt(lineSegment.Offset + index + j);
                            char spanChar = ignoreCase ? Char.ToUpperInvariant(expr[i]) : expr[i];
                            if (docChar != spanChar) {
                                return false;
                            }
                            break;
                        }
                }
            }
            return true;
        }
#endregion
    }
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\FontContainer.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3358 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// This class is used to generate bold, italic and bold/italic fonts out
	/// of a base font.
	/// </summary>
	public class FontContainer
	{
		Font defaultFont;
		Font regularfont, boldfont, italicfont, bolditalicfont;
		
		/// <value>
		/// The scaled, regular version of the base font
		/// </value>
		public Font RegularFont {
			get {
				return regularfont;
			}
		}
		
		/// <value>
		/// The scaled, bold version of the base font
		/// </value>
		public Font BoldFont {
			get {
				return boldfont;
			}
		}
		
		/// <value>
		/// The scaled, italic version of the base font
		/// </value>
		public Font ItalicFont {
			get {
				return italicfont;
			}
		}
		
		/// <value>
		/// The scaled, bold/italic version of the base font
		/// </value>
		public Font BoldItalicFont {
			get {
				return bolditalicfont;
			}
		}
		
		static float twipsPerPixelY;
		
		public static float TwipsPerPixelY {
			get {
				if (twipsPerPixelY == 0) {
					using (Bitmap bmp = new Bitmap(1,1)) {
						using (Graphics g = Graphics.FromImage(bmp)) {
							twipsPerPixelY = 1440 / g.DpiY;
						}
					}
				}
				return twipsPerPixelY;
			}
		}
		
		/// <value>
		/// The base font
		/// </value>
		public Font DefaultFont {
			get {
				return defaultFont;
			}
			set {
				// 1440 twips is one inch
				float pixelSize = (float)Math.Round(value.SizeInPoints * 20 / TwipsPerPixelY);
				
				defaultFont    = value;
				regularfont    = new Font(value.FontFamily, pixelSize * TwipsPerPixelY / 20f, FontStyle.Regular);
				boldfont       = new Font(regularfont, FontStyle.Bold);
				italicfont     = new Font(regularfont, FontStyle.Italic);
				bolditalicfont = new Font(regularfont, FontStyle.Bold | FontStyle.Italic);
			}
		}
		
		public static Font ParseFont(string font)
		{
			string[] descr = font.Split(new char[]{',', '='});
			return new Font(descr[1], Single.Parse(descr[3]));
		}
		
		public FontContainer(Font defaultFont)
		{
			this.DefaultFont = defaultFont;
		}
	}
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\HighlightBackground.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1965 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// Extens the highlighting color with a background image.
	/// </summary>
	public class HighlightBackground : HighlightColor
	{
		Image backgroundImage;
		
		/// <value>
		/// The image used as background
		/// </value>
		public Image BackgroundImage {
			get {
				return backgroundImage;
			}
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="HighlightBackground"/>
		/// </summary>
		public HighlightBackground(XmlElement el) : base(el)
		{
			if (el.Attributes["image"] != null) {
				backgroundImage = new Bitmap(el.Attributes["image"].InnerText);
			}
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="HighlightBackground"/>
		/// </summary>
		public HighlightBackground(Color color, Color backgroundcolor, bool bold, bool italic) : base(color, backgroundcolor, bold, italic)
		{
		}
		
		public HighlightBackground(string systemColor, string systemBackgroundColor, bool bold, bool italic) : base(systemColor, systemBackgroundColor, bold, italic)
		{
		}
	}
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\HighlightColor.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3672 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// A color used for highlighting
	/// </summary>
	public class HighlightColor
	{
		Color  color;
		Color  backgroundcolor = System.Drawing.Color.WhiteSmoke;
		
		bool   bold   = false;
		bool   italic = false;
		bool   hasForeground = false;
		bool   hasBackground = false;
		
		public bool HasForeground {
			get {
				return hasForeground;
			}
		}
		
		public bool HasBackground {
			get {
				return hasBackground;
			}
		}
		
		
		/// <value>
		/// If true the font will be displayed bold style
		/// </value>
		public bool Bold {
			get {
				return bold;
			}
		}
		
		/// <value>
		/// If true the font will be displayed italic style
		/// </value>
		public bool Italic {
			get {
				return italic;
			}
		}
		
		/// <value>
		/// The background color used
		/// </value>
		public Color BackgroundColor {
			get {
				return backgroundcolor;
			}
		}
		
		/// <value>
		/// The foreground color used
		/// </value>
		public Color Color {
			get {
				return color;
			}
		}
		
		/// <value>
		/// The font used
		/// </value>
		public Font GetFont(FontContainer fontContainer)
		{
			if (Bold) {
				return Italic ? fontContainer.BoldItalicFont : fontContainer.BoldFont;
			}
			return Italic ? fontContainer.ItalicFont : fontContainer.RegularFont;
		}
		
		Color ParseColorString(string colorName)
		{
			string[] cNames = colorName.Split('*');
			PropertyInfo myPropInfo = typeof(System.Drawing.SystemColors).GetProperty(cNames[0], BindingFlags.Public |
			                                                                          BindingFlags.Instance |
			                                                                          BindingFlags.Static);
			Color c = (Color)myPropInfo.GetValue(null, null);
			
			if (cNames.Length == 2) {
				//OneCodeHACK : can't figure out how to parse doubles with '.' (culture info might set the '.' to ',')
				double factor = Double.Parse(cNames[1]) / 100;
				c = Color.FromArgb((int)((double)c.R * factor), (int)((double)c.G * factor), (int)((double)c.B * factor));
			}
			
			return c;
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="HighlightColor"/>
		/// </summary>
		public HighlightColor(XmlElement el)
		{
			Debug.Assert(el != null, "TextFileEdit.Document.SyntaxColor(XmlElement el) : el == null");
			if (el.Attributes["bold"] != null) {
				bold = Boolean.Parse(el.Attributes["bold"].InnerText);
			}
			
			if (el.Attributes["italic"] != null) {
				italic = Boolean.Parse(el.Attributes["italic"].InnerText);
			}
			
			if (el.Attributes["color"] != null) {
				string c = el.Attributes["color"].InnerText;
				if (c[0] == '#') {
					color = ParseColor(c);
				} else if (c.StartsWith("SystemColors.")) {
					color = ParseColorString(c.Substring("SystemColors.".Length));
				} else {
					color = (Color)(Color.GetType()).InvokeMember(c, BindingFlags.GetProperty, null, Color, new object[0]);
				}
				hasForeground = true;
			} else {
				color = Color.Transparent; // to set it to the default value.
			}
			
			if (el.Attributes["bgcolor"] != null) {
				string c = el.Attributes["bgcolor"].InnerText;
				if (c[0] == '#') {
					backgroundcolor = ParseColor(c);
				} else if (c.StartsWith("SystemColors.")) {
					backgroundcolor = ParseColorString(c.Substring("SystemColors.".Length));
				} else {
					backgroundcolor = (Color)(Color.GetType()).InvokeMember(c, BindingFlags.GetProperty, null, Color, new object[0]);
				}
				hasBackground = true;
			}
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="HighlightColor"/>
		/// </summary>
		public HighlightColor(XmlElement el, HighlightColor defaultColor)
		{
			Debug.Assert(el != null, "TextFileEdit.Document.SyntaxColor(XmlElement el) : el == null");
			if (el.Attributes["bold"] != null) {
				bold = Boolean.Parse(el.Attributes["bold"].InnerText);
			} else {
				bold = defaultColor.Bold;
			}
			
			if (el.Attributes["italic"] != null) {
				italic = Boolean.Parse(el.Attributes["italic"].InnerText);
			} else {
				italic = defaultColor.Italic;
			}
			
			if (el.Attributes["color"] != null) {
				string c = el.Attributes["color"].InnerText;
				if (c[0] == '#') {
					color = ParseColor(c);
				} else if (c.StartsWith("SystemColors.")) {
					color = ParseColorString(c.Substring("SystemColors.".Length));
				} else {
					color = (Color)(Color.GetType()).InvokeMember(c, BindingFlags.GetProperty, null, Color, new object[0]);
				}
				hasForeground = true;
			} else {
				color = defaultColor.color;
			}
			
			if (el.Attributes["bgcolor"] != null) {
				string c = el.Attributes["bgcolor"].InnerText;
				if (c[0] == '#') {
					backgroundcolor = ParseColor(c);
				} else if (c.StartsWith("SystemColors.")) {
					backgroundcolor = ParseColorString(c.Substring("SystemColors.".Length));
				} else {
					backgroundcolor = (Color)(Color.GetType()).InvokeMember(c, BindingFlags.GetProperty, null, Color, new object[0]);
				}
				hasBackground = true;
			} else {
				backgroundcolor = defaultColor.BackgroundColor;
			}
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="HighlightColor"/>
		/// </summary>
		public HighlightColor(Color color, bool bold, bool italic)
		{
			hasForeground = true;
			this.color  = color;
			this.bold   = bold;
			this.italic = italic;
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="HighlightColor"/>
		/// </summary>
		public HighlightColor(Color color, Color backgroundcolor, bool bold, bool italic)
		{
			hasForeground = true;
			hasBackground  = true;
			this.color            = color;
			this.backgroundcolor  = backgroundcolor;
			this.bold             = bold;
			this.italic           = italic;
		}
		
		
		/// <summary>
		/// Creates a new instance of <see cref="HighlightColor"/>
		/// </summary>
		public HighlightColor(string systemColor, string systemBackgroundColor, bool bold, bool italic)
		{
			hasForeground = true;
			hasBackground  = true;
			
			this.color = ParseColorString(systemColor);
			this.backgroundcolor = ParseColorString(systemBackgroundColor);
			
			this.bold         = bold;
			this.italic       = italic;
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="HighlightColor"/>
		/// </summary>
		public HighlightColor(string systemColor, bool bold, bool italic)
		{
			hasForeground = true;
			
			this.color = ParseColorString(systemColor);
			
			this.bold         = bold;
			this.italic       = italic;
		}
		
		static Color ParseColor(string c)
		{
			int a = 255;
			int offset = 0;
			if (c.Length > 7) {
				offset = 2;
				a = Int32.Parse(c.Substring(1,2), NumberStyles.HexNumber);
			}
			
			int r = Int32.Parse(c.Substring(1 + offset,2), NumberStyles.HexNumber);
			int g = Int32.Parse(c.Substring(3 + offset,2), NumberStyles.HexNumber);
			int b = Int32.Parse(c.Substring(5 + offset,2), NumberStyles.HexNumber);
			return Color.FromArgb(a, r, g, b);
		}
		
		/// <summary>
		/// Converts a <see cref="HighlightColor"/> instance to string (for debug purposes)
		/// </summary>
		public override string ToString()
		{
			return "[HighlightColor: Bold = " + Bold +
				", Italic = " + Italic +
				", Color = " + Color +
				", BackgroundColor = " + BackgroundColor + "]";
		}
	}
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\HighlightInfo.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1965 $</version>
// </file>


namespace TextFileEdit.Document
{
	public class HighlightInfo
	{
		public bool BlockSpanOn = false;
		public bool Span        = false;
		public Span CurSpan     = null;
		
		public HighlightInfo(Span curSpan, bool span, bool blockSpanOn)
		{
			this.CurSpan     = curSpan;
			this.Span        = span;
			this.BlockSpanOn = blockSpanOn;
		}
	}
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\HighlightingColorNotFoundException.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1624 $</version>
// </file>


namespace TextFileEdit.Document
{
	[Serializable()]
	public class HighlightingColorNotFoundException : Exception
	{
		public HighlightingColorNotFoundException() : base()
		{
		}
		
		public HighlightingColorNotFoundException(string message) : base(message)
		{
		}
		
		public HighlightingColorNotFoundException(string message, Exception innerException) : base(message, innerException)
		{
		}
		
		protected HighlightingColorNotFoundException(SerializationInfo info, StreamingContext context) : base(info, context)
		{
		}
	}
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\HighlightingDefinitionInvalidException.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2533 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// Indicates that the highlighting definition that was tried to load was invalid.
	/// You get this exception only once per highlighting definition, after that the definition
	/// is replaced with the default highlighter.
	/// </summary>
	[Serializable()]
	public class HighlightingDefinitionInvalidException : Exception
	{
		public HighlightingDefinitionInvalidException() : base()
		{
		}
		
		public HighlightingDefinitionInvalidException(string message) : base(message)
		{
		}
		
		public HighlightingDefinitionInvalidException(string message, Exception innerException) : base(message, innerException)
		{
		}
		
		protected HighlightingDefinitionInvalidException(SerializationInfo info, StreamingContext context) : base(info, context)
		{
		}
	}
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\HighlightingDefinitionParser.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2533 $</version>
// </file>


namespace TextFileEdit.Document
{
    public static class HighlightingDefinitionParser
    {
        public static DefaultHighlightingStrategy Parse(SyntaxMode syntaxMode, XmlReader xmlReader)
        {
            return Parse(null, syntaxMode, xmlReader);
        }

        public static DefaultHighlightingStrategy Parse(DefaultHighlightingStrategy highlighter, SyntaxMode syntaxMode, XmlReader xmlReader)
        {
            if (syntaxMode == null)
                throw new ArgumentNullException("syntaxMode");
            if (xmlReader == null)
                throw new ArgumentNullException("xmlTextReader");
            try {
                List<ValidationEventArgs> errors = null;
                XmlReaderSettings settings = new XmlReaderSettings();
                Stream shemaStream = typeof(HighlightingDefinitionParser).Assembly.GetManifestResourceStream("TextFileEdit.Resources.Mode.xsd");
                settings.Schemas.Add("", new XmlTextReader(shemaStream));
                settings.Schemas.ValidationEventHandler += delegate(object sender, ValidationEventArgs args) {
                    if (errors == null) {
                        errors = new List<ValidationEventArgs>();
                    }
                    errors.Add(args);
                };
                settings.ValidationType = ValidationType.Schema;
                XmlReader validatingReader = XmlReader.Create(xmlReader, settings);

                XmlDocument doc = new XmlDocument();
                doc.Load(validatingReader);
                
                if (highlighter == null)
                    highlighter = new DefaultHighlightingStrategy(doc.DocumentElement.Attributes["name"].InnerText);
                
                if (doc.DocumentElement.HasAttribute("extends")) {
                    KeyValuePair<SyntaxMode, ISyntaxModeFileProvider> entry = HighlightingManager.Manager.FindHighlighterEntry(doc.DocumentElement.GetAttribute("extends"));
                    if (entry.Key == null) {
                        throw new HighlightingDefinitionInvalidException("Cannot find referenced highlighting source " + doc.DocumentElement.GetAttribute("extends"));
                    } else {
                        highlighter = Parse(highlighter, entry.Key, entry.Value.GetSyntaxModeFile(entry.Key));
                        if (highlighter == null) return null;
                    }
                }
                if (doc.DocumentElement.HasAttribute("extensions")) {
                    highlighter.Extensions = doc.DocumentElement.GetAttribute("extensions").Split(new char[] { ';', '|' });
                }
                
                XmlElement environment = doc.DocumentElement["Environment"];
                if (environment != null) {
                    foreach (XmlNode node in environment.ChildNodes) {
                        if (node is XmlElement) {
                            XmlElement el = (XmlElement)node;
                            if (el.Name == "Custom") {
                                highlighter.SetColorFor(el.GetAttribute("name"), el.HasAttribute("bgcolor") ? new HighlightBackground(el) : new HighlightColor(el));
                            } else {
                                highlighter.SetColorFor(el.Name, el.HasAttribute("bgcolor") ? new HighlightBackground(el) : new HighlightColor(el));
                            }
                        }
                    }
                }
                
                // parse properties
                if (doc.DocumentElement["Properties"]!= null) {
                    foreach (XmlElement propertyElement in doc.DocumentElement["Properties"].ChildNodes) {
                        highlighter.Properties[propertyElement.Attributes["name"].InnerText] =  propertyElement.Attributes["value"].InnerText;
                    }
                }
                
                if (doc.DocumentElement["Digits"]!= null) {
                    highlighter.DigitColor = new HighlightColor(doc.DocumentElement["Digits"]);
                }
                
                XmlNodeList nodes = doc.DocumentElement.GetElementsByTagName("RuleSet");
                foreach (XmlElement element in nodes) {
                    highlighter.AddRuleSet(new HighlightRuleSet(element));
                }
                
                xmlReader.Close();
                
                if (errors != null) {
                    StringBuilder msg = new StringBuilder();
                    foreach (ValidationEventArgs args in errors) {
                        msg.AppendLine(args.Message);
                    }
                    throw new HighlightingDefinitionInvalidException(msg.ToString());
                } else {
                    return highlighter;
                }
            } catch (Exception e) {
                throw new HighlightingDefinitionInvalidException("Could not load mode definition file '" + syntaxMode.FileName + "'.\n", e);
            }
        }
    }
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\HighlightingManager.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3209 $</version>
// </file>


namespace TextFileEdit.Document
{
    public class HighlightingManager
    {
        ArrayList syntaxModeFileProviders = new ArrayList();
        static HighlightingManager highlightingManager;
        
        // hash table from extension name to highlighting definition,
        // OR from extension name to Pair SyntaxMode,ISyntaxModeFileProvider
        Hashtable highlightingDefs = new Hashtable();
        
        Hashtable extensionsToName = new Hashtable();
        
        public Hashtable HighlightingDefinitions {
            get {
                return highlightingDefs;
            }
        }
        
        public static HighlightingManager Manager {
            get {
                return highlightingManager;
            }
        }
        
        static HighlightingManager()
        {
            highlightingManager = new HighlightingManager();
            highlightingManager.AddSyntaxModeFileProvider(new ResourceSyntaxModeProvider());
        }
        
        public HighlightingManager()
        {
            CreateDefaultHighlightingStrategy();
        }
        
        public void AddSyntaxModeFileProvider(ISyntaxModeFileProvider syntaxModeFileProvider)
        {
            foreach (SyntaxMode syntaxMode in syntaxModeFileProvider.SyntaxModes) {
                highlightingDefs[syntaxMode.Name] = new DictionaryEntry(syntaxMode, syntaxModeFileProvider);
                foreach (string extension in syntaxMode.Extensions) {
                    extensionsToName[extension.ToUpperInvariant()] = syntaxMode.Name;
                }
            }
            if (!syntaxModeFileProviders.Contains(syntaxModeFileProvider)) {
                syntaxModeFileProviders.Add(syntaxModeFileProvider);
            }
        }

        public void AddHighlightingStrategy(IHighlightingStrategy highlightingStrategy)
        {
            highlightingDefs[highlightingStrategy.Name] = highlightingStrategy;
            foreach (string extension in highlightingStrategy.Extensions)
            {
                extensionsToName[extension.ToUpperInvariant()] = highlightingStrategy.Name;
            }
        }
        
        public void ReloadSyntaxModes()
        {
            highlightingDefs.Clear();
            extensionsToName.Clear();
            CreateDefaultHighlightingStrategy();
            foreach (ISyntaxModeFileProvider provider in syntaxModeFileProviders) {
                provider.UpdateSyntaxModeList();
                AddSyntaxModeFileProvider(provider);
            }
            OnReloadSyntaxHighlighting(EventArgs.Empty);
        }
        
        void CreateDefaultHighlightingStrategy()
        {
            DefaultHighlightingStrategy defaultHighlightingStrategy = new DefaultHighlightingStrategy();
            defaultHighlightingStrategy.Extensions = new string[] {};
            defaultHighlightingStrategy.Rules.Add(new HighlightRuleSet());
            highlightingDefs["Default"] = defaultHighlightingStrategy;
        }
        
        IHighlightingStrategy LoadDefinition(DictionaryEntry entry)
        {
            SyntaxMode              syntaxMode             = (SyntaxMode)entry.Key;
            ISyntaxModeFileProvider syntaxModeFileProvider = (ISyntaxModeFileProvider)entry.Value;

            DefaultHighlightingStrategy highlightingStrategy = null;
            try {
                var reader = syntaxModeFileProvider.GetSyntaxModeFile(syntaxMode);
                if (reader == null)
                    throw new HighlightingDefinitionInvalidException("Could not get syntax mode file for " + syntaxMode.Name);
                highlightingStrategy = HighlightingDefinitionParser.Parse(syntaxMode, reader);
                if (highlightingStrategy.Name != syntaxMode.Name) {
                    throw new HighlightingDefinitionInvalidException("The name specified in the .xshd '" + highlightingStrategy.Name + "' must be equal the syntax mode name '" + syntaxMode.Name + "'");
                }
            } finally {
                if (highlightingStrategy == null) {
                    highlightingStrategy = DefaultHighlighting;
                }
                highlightingDefs[syntaxMode.Name] = highlightingStrategy;
                highlightingStrategy.ResolveReferences();
            }
            return highlightingStrategy;
        }
        
        public DefaultHighlightingStrategy DefaultHighlighting {
            get {
                return (DefaultHighlightingStrategy)highlightingDefs["Default"];
            }
        }
        
        internal KeyValuePair<SyntaxMode, ISyntaxModeFileProvider> FindHighlighterEntry(string name)
        {
            foreach (ISyntaxModeFileProvider provider in syntaxModeFileProviders) {
                foreach (SyntaxMode mode in provider.SyntaxModes) {
                    if (mode.Name == name) {
                        return new KeyValuePair<SyntaxMode, ISyntaxModeFileProvider>(mode, provider);
                    }
                }
            }
            return new KeyValuePair<SyntaxMode, ISyntaxModeFileProvider>(null, null);
        }
        
        public IHighlightingStrategy FindHighlighter(string name)
        {
            object def = highlightingDefs[name];
            if (def is DictionaryEntry) {
                return LoadDefinition((DictionaryEntry)def);
            }
            return def == null ? DefaultHighlighting : (IHighlightingStrategy)def;
        }
        
        public IHighlightingStrategy FindHighlighterForFile(string fileName)
        {
            string highlighterName = (string)extensionsToName[Path.GetExtension(fileName).ToUpperInvariant()];
            if (highlighterName != null) {
                object def = highlightingDefs[highlighterName];
                if (def is DictionaryEntry) {
                    return LoadDefinition((DictionaryEntry)def);
                }
                return def == null ? DefaultHighlighting : (IHighlightingStrategy)def;
            } else {
                return DefaultHighlighting;
            }
        }
        
        protected virtual void OnReloadSyntaxHighlighting(EventArgs e)
        {
            if (ReloadSyntaxHighlighting != null) {
                ReloadSyntaxHighlighting(this, e);
            }
        }
        
        public event EventHandler ReloadSyntaxHighlighting;
    }
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\HighlightingStrategyFactory.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1965 $</version>
// </file>


namespace TextFileEdit.Document
{
	public class HighlightingStrategyFactory
	{
		public static IHighlightingStrategy CreateHighlightingStrategy()
		{
			return (IHighlightingStrategy)HighlightingManager.Manager.HighlightingDefinitions["Default"];
		}
		
		public static IHighlightingStrategy CreateHighlightingStrategy(string name)
		{
			IHighlightingStrategy highlightingStrategy  = HighlightingManager.Manager.FindHighlighter(name);
			
			if (highlightingStrategy == null) {
				return CreateHighlightingStrategy();
			}
			return highlightingStrategy;
		}
		
		public static IHighlightingStrategy CreateHighlightingStrategyForFile(string fileName)
		{
			IHighlightingStrategy highlightingStrategy  = HighlightingManager.Manager.FindHighlighterForFile(fileName);
			if (highlightingStrategy == null) {
				return CreateHighlightingStrategy();
			}
			return highlightingStrategy;
		}
	}
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\HighlightRuleSet.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3036 $</version>
// </file>


namespace TextFileEdit.Document
{
	public class HighlightRuleSet
	{
		TextFileEdit.Util.LookupTable keyWords;
		ArrayList   spans = new ArrayList();
        TextFileEdit.Util.LookupTable prevMarkers;
        TextFileEdit.Util.LookupTable nextMarkers;
		char escapeCharacter;
		
		bool ignoreCase = false;
		string name     = null;
		
		bool[] delimiters = new bool[256];
		
		string      reference  = null;
		
		public ArrayList Spans {
			get {
				return spans;
			}
		}
		
		internal IHighlightingStrategyUsingRuleSets Highlighter;

        public TextFileEdit.Util.LookupTable KeyWords
        {
			get {
				return keyWords;
			}
		}

        public TextFileEdit.Util.LookupTable PrevMarkers
        {
			get {
				return prevMarkers;
			}
		}

        public TextFileEdit.Util.LookupTable NextMarkers
        {
			get {
				return nextMarkers;
			}
		}
		
		public bool[] Delimiters {
			get {
				return delimiters;
			}
		}
		
		public char EscapeCharacter {
			get {
				return escapeCharacter;
			}
		}
		
		public bool IgnoreCase {
			get {
				return ignoreCase;
			}
		}
		
		public string Name {
			get {
				return name;
			}
			set {
				name = value;
			}
		}
		
		public string Reference {
			get {
				return reference;
			}
		}
		
		public HighlightRuleSet()
		{
            keyWords = new TextFileEdit.Util.LookupTable(false);
            prevMarkers = new TextFileEdit.Util.LookupTable(false);
            nextMarkers = new TextFileEdit.Util.LookupTable(false);
		}
		
		public HighlightRuleSet(XmlElement el)
		{
			XmlNodeList nodes;
			
			if (el.Attributes["name"] != null) {
				Name = el.Attributes["name"].InnerText;
			}
			
			if (el.HasAttribute("escapecharacter")) {
				escapeCharacter = el.GetAttribute("escapecharacter")[0];
			}
			
			if (el.Attributes["reference"] != null) {
				reference = el.Attributes["reference"].InnerText;
			}
			
			if (el.Attributes["ignorecase"] != null) {
				ignoreCase  = Boolean.Parse(el.Attributes["ignorecase"].InnerText);
			}
			
			for (int i  = 0; i < Delimiters.Length; ++i) {
				delimiters[i] = false;
			}
			
			if (el["Delimiters"] != null) {
				string delimiterString = el["Delimiters"].InnerText;
				foreach (char ch in delimiterString) {
					delimiters[(int)ch] = true;
				}
			}
			
//			Spans       = new LookupTable(!IgnoreCase);

            keyWords = new TextFileEdit.Util.LookupTable(!IgnoreCase);
            prevMarkers = new TextFileEdit.Util.LookupTable(!IgnoreCase);
            nextMarkers = new TextFileEdit.Util.LookupTable(!IgnoreCase);
			
			nodes = el.GetElementsByTagName("KeyWords");
			foreach (XmlElement el2 in nodes) {
				HighlightColor color = new HighlightColor(el2);
				
				XmlNodeList keys = el2.GetElementsByTagName("Key");
				foreach (XmlElement node in keys) {
					keyWords[node.Attributes["word"].InnerText] = color;
				}
			}
			
			nodes = el.GetElementsByTagName("Span");
			foreach (XmlElement el2 in nodes) {
				Spans.Add(new Span(el2));
				/*
				Span span = new Span(el2);
				Spans[span.Begin] = span;*/
			}
			
			nodes = el.GetElementsByTagName("MarkPrevious");
			foreach (XmlElement el2 in nodes) {
				PrevMarker prev = new PrevMarker(el2);
				prevMarkers[prev.What] = prev;
			}
			
			nodes = el.GetElementsByTagName("MarkFollowing");
			foreach (XmlElement el2 in nodes) {
				NextMarker next = new NextMarker(el2);
				nextMarkers[next.What] = next;
			}
		}
		
		/// <summary>
		/// Merges spans etc. from the other rule set into this rule set.
		/// </summary>
		public void MergeFrom(HighlightRuleSet ruleSet)
		{
			for (int i = 0; i < delimiters.Length; i++) {
				delimiters[i] |= ruleSet.delimiters[i];
			}
			// insert merged spans in front of old spans
			ArrayList oldSpans = spans;
			spans = (ArrayList)ruleSet.spans.Clone();
			spans.AddRange(oldSpans);
			//keyWords.MergeFrom(ruleSet.keyWords);
			//prevMarkers.MergeFrom(ruleSet.prevMarkers);
			//nextMarkers.MergeFrom(ruleSet.nextMarkers);
		}
	}
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\IHighlightingStrategy.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3037 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// A highlighting strategy for a buffer.
	/// </summary>
	public interface IHighlightingStrategy
	{
		/// <value>
		/// The name of the highlighting strategy, must be unique
		/// </value>
		string Name {
			get;
		}
		
		/// <value>
		/// The file extenstions on which this highlighting strategy gets
		/// used
		/// </value>
		string[] Extensions {
			get;
		}
		
		Dictionary<string, string> Properties {
			get;
		}
		
		// returns special color. (BackGround Color, Cursor Color and so on)
		
		/// <remarks>
		/// Gets the color of an Environment element.
		/// </remarks>
		HighlightColor GetColorFor(string name);
		
		/// <remarks>
		/// Used internally, do not call
		/// </remarks>
		void MarkTokens(IDocument document, List<LineSegment> lines);
		
		/// <remarks>
		/// Used internally, do not call
		/// </remarks>
		void MarkTokens(IDocument document);
	}
	
	public interface IHighlightingStrategyUsingRuleSets : IHighlightingStrategy
	{
		/// <remarks>
		/// Used internally, do not call
		/// </remarks>
		HighlightRuleSet GetRuleSet(Span span);
		
		/// <remarks>
		/// Used internally, do not call
		/// </remarks>
		HighlightColor GetColor(IDocument document, LineSegment keyWord, int index, int length);
	}
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\NextMarker.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1965 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// Used for mark next token
	/// </summary>
	public class NextMarker
	{
		string      what;
		HighlightColor color;
		bool        markMarker = false;
		
		/// <value>
		/// String value to indicate to mark next token
		/// </value>
		public string What {
			get {
				return what;
			}
		}
		
		/// <value>
		/// Color for marking next token
		/// </value>
		public HighlightColor Color {
			get {
				return color;
			}
		}
		
		/// <value>
		/// If true the indication text will be marked with the same color
		/// too
		/// </value>
		public bool MarkMarker {
			get {
				return markMarker;
			}
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="NextMarker"/>
		/// </summary>
		public NextMarker(XmlElement mark)
		{
			color = new HighlightColor(mark);
			what  = mark.InnerText;
			if (mark.Attributes["markmarker"] != null) {
				markMarker = Boolean.Parse(mark.Attributes["markmarker"].InnerText);
			}
		}
	}

}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\PrevMarker.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1965 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// Used for mark previous token
	/// </summary>
	public class PrevMarker
	{
		string      what;
		HighlightColor color;
		bool        markMarker = false;
		
		/// <value>
		/// String value to indicate to mark previous token
		/// </value>
		public string What {
			get {
				return what;
			}
		}
		
		/// <value>
		/// Color for marking previous token
		/// </value>
		public HighlightColor Color {
			get {
				return color;
			}
		}
		
		/// <value>
		/// If true the indication text will be marked with the same color
		/// too
		/// </value>
		public bool MarkMarker {
			get {
				return markMarker;
			}
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="PrevMarker"/>
		/// </summary>
		public PrevMarker(XmlElement mark)
		{
			color = new HighlightColor(mark);
			what  = mark.InnerText;
			if (mark.Attributes["markmarker"] != null) {
				markMarker = Boolean.Parse(mark.Attributes["markmarker"].InnerText);
			}
		}
	}

}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\Span.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2115 $</version>
// </file>


namespace TextFileEdit.Document
{
	public sealed class Span
	{
		bool        stopEOL;
		HighlightColor color;
		HighlightColor beginColor;
		HighlightColor endColor;
		char[]      begin;
		char[]      end;
		string      name;
		string      rule;
		HighlightRuleSet ruleSet;
		char escapeCharacter;
		bool ignoreCase;
		bool isBeginSingleWord;
		bool? isBeginStartOfLine;
		bool isEndSingleWord;
		
		internal HighlightRuleSet RuleSet {
			get {
				return ruleSet;
			}
			set {
				ruleSet = value;
			}
		}

		public bool IgnoreCase	{
			get	{
				return ignoreCase;
			}
			set	{
				ignoreCase = value;
			}
		}

		public bool StopEOL {
			get {
				return stopEOL;
			}
		}
		
		public bool? IsBeginStartOfLine {
			get {
				return isBeginStartOfLine;
			}
		}
		
		public bool IsBeginSingleWord {
			get {
				return isBeginSingleWord;
			}
		}
		
		public bool IsEndSingleWord {
			get {
				return isEndSingleWord;
			}
		}
		
		public HighlightColor Color {
			get {
				return color;
			}
		}
		
		public HighlightColor BeginColor {
			get {
				if(beginColor != null) {
					return beginColor;
				} else {
					return color;
				}
			}
		}
		
		public HighlightColor EndColor {
			get {
				return endColor!=null ? endColor : color;
			}
		}
		
		public char[] Begin {
			get { return begin; }
		}
		
		public char[] End {
			get { return end; }
		}
		
		public string Name {
			get { return name; }
		}
		
		public string Rule {
			get { return rule; }
		}
		
		/// <summary>
		/// Gets the escape character of the span. The escape character is a character that can be used in front
		/// of the span end to make it not end the span. The escape character followed by another escape character
		/// means the escape character was escaped like in @"a "" b" literals in C#.
		/// The default value '\0' means no escape character is allowed.
		/// </summary>
		public char EscapeCharacter {
			get { return escapeCharacter; }
		}
		
		public Span(XmlElement span)
		{
			color   = new HighlightColor(span);
			
			if (span.HasAttribute("rule")) {
				rule = span.GetAttribute("rule");
			}
			
			if (span.HasAttribute("escapecharacter")) {
				escapeCharacter = span.GetAttribute("escapecharacter")[0];
			}
			
			name = span.GetAttribute("name");
			if (span.HasAttribute("stopateol")) {
				stopEOL = Boolean.Parse(span.GetAttribute("stopateol"));
			}
			
			begin   = span["Begin"].InnerText.ToCharArray();
			beginColor = new HighlightColor(span["Begin"], color);
			
			if (span["Begin"].HasAttribute("singleword")) {
				this.isBeginSingleWord = Boolean.Parse(span["Begin"].GetAttribute("singleword"));
			}
			if (span["Begin"].HasAttribute("startofline")) {
				this.isBeginStartOfLine = Boolean.Parse(span["Begin"].GetAttribute("startofline"));
			}
			
			if (span["End"] != null) {
				end  = span["End"].InnerText.ToCharArray();
				endColor = new HighlightColor(span["End"], color);
				if (span["End"].HasAttribute("singleword")) {
					this.isEndSingleWord = Boolean.Parse(span["End"].GetAttribute("singleword"));
				}

			}
		}
	}
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\SpanStack.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Daniel Grunwald" email="daniel@danielgrunwald.de"/>
//     <version>$Revision: 1471 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// A stack of Span instances. Works like Stack&lt;Span&gt;, but can be cloned quickly
	/// because it is implemented as linked list.
	/// </summary>
	public sealed class SpanStack : ICloneable, IEnumerable<Span>
	{
		public sealed class StackNode
		{
			public readonly StackNode Previous;
			public readonly Span Data;
			
			public StackNode(StackNode previous, Span data)
			{
				this.Previous = previous;
				this.Data = data;
			}
		}
		
		StackNode top = null;
		
		public Span Pop()
		{
			Span s = top.Data;
			top = top.Previous;
			return s;
		}
		
		public Span Peek()
		{
			return top.Data;
		}
		
		public void Push(Span s)
		{
			top = new StackNode(top, s);
		}
		
		public bool IsEmpty {
			get {
				return top == null;
			}
		}
		
		public SpanStack Clone()
		{
			SpanStack n = new SpanStack();
			n.top = this.top;
			return n;
		}
		object ICloneable.Clone()
		{
			return this.Clone();
		}
		
		public Enumerator GetEnumerator()
		{
			return new Enumerator(new StackNode(top, null));
		}
		IEnumerator<Span> IEnumerable<Span>.GetEnumerator()
		{
			return this.GetEnumerator();
		}
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
		{
			return this.GetEnumerator();
		}
		
		public struct Enumerator : IEnumerator<Span>
		{
			StackNode c;
			
			internal Enumerator(StackNode node)
			{
				c = node;
			}
			
			public Span Current {
				get {
					return c.Data;
				}
			}
			
			object System.Collections.IEnumerator.Current {
				get {
					return c.Data;
				}
			}
			
			public void Dispose()
			{
				c = null;
			}
			
			public bool MoveNext()
			{
				c = c.Previous;
				return c != null;
			}
			
			public void Reset()
			{
				throw new NotSupportedException();
			}
		}
	}
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\TextWord.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1965 $</version>
// </file>


namespace TextFileEdit.Document
{
	public enum TextWordType {
		Word,
		Space,
		Tab,
        Null
	}
	
	/// <summary>
	/// This class represents single words with color information, two special versions of a word are
	/// spaces and tabs.
	/// </summary>
	public class TextWord
	{
		HighlightColor  color;
		LineSegment     line;
		IDocument       document;
		
		int          offset;
		int          length;
		
		public sealed class SpaceTextWord : TextWord
		{
			public SpaceTextWord()
			{
				length = 1;
			}
			
			public SpaceTextWord(HighlightColor color)
			{
				length = 1;
				base.SyntaxColor = color;
			}
			
			public override Font GetFont(FontContainer fontContainer)
			{
				return null;
			}
			
			public override TextWordType Type {
				get {
					return TextWordType.Space;
				}
			}
			public override bool IsWhiteSpace {
				get {
					return true;
				}
			}
		}
		
		public sealed class TabTextWord : TextWord
		{
			public TabTextWord()
			{
				length = 1;
			}
			public TabTextWord(HighlightColor color)
			{
				length = 1;
				base.SyntaxColor = color;
			}
			
			public override Font GetFont(FontContainer fontContainer)
			{
				return null;
			}
			
			public override TextWordType Type {
				get {
					return TextWordType.Tab;
				}
			}
			public override bool IsWhiteSpace {
				get {
					return true;
				}
			}
		}

        public sealed class NullTextWord : TextWord
        {
            private string word = "";
            public NullTextWord(string text)
            {
                word = text;
                length = 1;
            }
            public NullTextWord(string text, HighlightColor color)
            {
                word = text;
                length = 1;
                base.SyntaxColor = color;
            }

            public override string Word
            {
                get
                {
                    return word;
                }
            }

            public override Font GetFont(FontContainer fontContainer)
            {
                return null;
            }

            public override TextWordType Type
            {
                get
                {
                    return TextWordType.Null;
                }
            }
            public override bool IsWhiteSpace
            {
                get
                {
                    return false;
                }
            }
        }
		
		static TextWord spaceWord = new SpaceTextWord();
        static TextWord tabWord = new TabTextWord();
//        static TextWord nullWord = new NullTextWord();
		
		bool hasDefaultColor;
		
		public static TextWord Space {
			get {
				return spaceWord;
			}
		}
		
		public static TextWord Tab {
			get {
				return tabWord;
			}
		}

        //public static TextWord Null
        //{
        //    get
        //    {
        //        return nullWord;
        //    }
        //}
		
		public int Offset {
			get {
				return offset;
			}
		}
		
		public int Length {
			get {
				return length;
			}
		}
		
		/// <summary>
		/// Splits the <paramref name="word"/> into two parts: the part before <paramref name="pos"/> is assigned to
		/// the reference parameter <paramref name="word"/>, the part after <paramref name="pos"/> is returned.
		/// </summary>
		public static TextWord Split(ref TextWord word, int pos)
		{
			#if DEBUG
			if (word.Type != TextWordType.Word)
				throw new ArgumentException("word.Type must be Word");
			if (pos <= 0)
				throw new ArgumentOutOfRangeException("pos", pos, "pos must be > 0");
			if (pos >= word.Length)
				throw new ArgumentOutOfRangeException("pos", pos, "pos must be < word.Length");
			#endif
			TextWord after = new TextWord(word.document, word.line, word.offset + pos, word.length - pos, word.color, word.hasDefaultColor);
			word = new TextWord(word.document, word.line, word.offset, pos, word.color, word.hasDefaultColor);
			return after;
		}
		
		public bool HasDefaultColor {
			get {
				return hasDefaultColor;
			}
		}
		
		public virtual TextWordType Type {
			get {
				return TextWordType.Word;
			}
		}
		
		public virtual string Word {
			get {
				if (document == null) {
					return String.Empty;
				}
				return document.GetText(line.Offset + offset, length);
			}
		}
		
		public virtual Font GetFont(FontContainer fontContainer)
		{
			return color.GetFont(fontContainer);
		}
		
		public Color Color {
			get {
				if (color == null)
					return Color.Black;
				else
					return color.Color;
			}
		}
		
		public bool Bold {
			get {
				if (color == null)
					return false;
				else
					return color.Bold;
			}
		}
		
		public bool Italic {
			get {
				if (color == null)
					return false;
				else
					return color.Italic;
			}
		}
		
		public HighlightColor SyntaxColor {
			get {
				return color;
			}
			set {
				Debug.Assert(value != null);
				color = value;
			}
		}
		
		public virtual bool IsWhiteSpace {
			get {
				return false;
			}
		}
		
		protected TextWord()
		{
		}
		
		// TAB
		public TextWord(IDocument document, LineSegment line, int offset, int length, HighlightColor color, bool hasDefaultColor)
		{
			Debug.Assert(document != null);
			Debug.Assert(line != null);
			Debug.Assert(color != null);
			
			this.document = document;
			this.line  = line;
			this.offset = offset;
			this.length = length;
			this.color = color;
			this.hasDefaultColor = hasDefaultColor;
		}
		
		/// <summary>
		/// Converts a <see cref="TextWord"/> instance to string (for debug purposes)
		/// </summary>
		public override string ToString()
		{
			return "[TextWord: Word = " + Word + ", Color = " + Color + "]";
		}
	}
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\SyntaxModes\FileSyntaxModeProvider.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2533 $</version>
// </file>


namespace TextFileEdit.Document
{
    public class FileSyntaxModeProvider : ISyntaxModeFileProvider
    {
        string    directory;
        List<SyntaxMode> syntaxModes = null;
        
        public ICollection<SyntaxMode> SyntaxModes {
            get {
                return syntaxModes;
            }
        }
        
        public FileSyntaxModeProvider(string directory)
        {
            this.directory = directory;
            UpdateSyntaxModeList();
        }
        
        public void UpdateSyntaxModeList()
        {
            string syntaxModeFile = Path.Combine(directory, "SyntaxModes.xml");
            if (File.Exists(syntaxModeFile)) {
                Stream s = File.OpenRead(syntaxModeFile);
                syntaxModes = SyntaxMode.GetSyntaxModes(s);
                s.Close();
            } else {
                syntaxModes = ScanDirectory(directory);
            }
        }
        
        public XmlTextReader GetSyntaxModeFile(SyntaxMode syntaxMode)
        {
            string syntaxModeFile = Path.Combine(directory, syntaxMode.FileName);
            if (!File.Exists(syntaxModeFile)) {
                throw new HighlightingDefinitionInvalidException("Can't load highlighting definition " + syntaxModeFile + " (file not found)!");
            }
            return new XmlTextReader(File.OpenRead(syntaxModeFile));
        }
        
        List<SyntaxMode> ScanDirectory(string directory)
        {
            string[] files = Directory.GetFiles(directory);
            List<SyntaxMode> modes = new List<SyntaxMode>();
            foreach (string file in files) {
                if (Path.GetExtension(file).Equals(".XSHD", StringComparison.OrdinalIgnoreCase)) {
                    XmlTextReader reader = new XmlTextReader(file);
                    while (reader.Read()) {
                        if (reader.NodeType == XmlNodeType.Element) {
                            switch (reader.Name) {
                                case "SyntaxDefinition":
                                    string name       = reader.GetAttribute("name");
                                    string extensions = reader.GetAttribute("extensions");
                                    modes.Add(new SyntaxMode(Path.GetFileName(file),
                                                             name,
                                                             extensions));
                                    goto bailout;
                                default:
                                    throw new HighlightingDefinitionInvalidException("Unknown root node in syntax highlighting file :" + reader.Name);
                            }
                        }
                    }
                bailout:
                    reader.Close();
                    
                }
            }
            return modes;
        }
    }
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\SyntaxModes\ISyntaxModeFileProvider.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1301 $</version>
// </file>


namespace TextFileEdit.Document
{
	public interface ISyntaxModeFileProvider
	{
		ICollection<SyntaxMode> SyntaxModes {
			get;
		}
		
		XmlTextReader GetSyntaxModeFile(SyntaxMode syntaxMode);
		void UpdateSyntaxModeList();
	}
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\SyntaxModes\ResourceSyntaxModeProvider.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1965 $</version>
// </file>


namespace TextFileEdit.Document
{
	public class ResourceSyntaxModeProvider : ISyntaxModeFileProvider
	{
		List<SyntaxMode> syntaxModes = null;
		
		public ICollection<SyntaxMode> SyntaxModes {
			get {
				return syntaxModes;
			}
		}
		
		public ResourceSyntaxModeProvider()
		{
			Assembly assembly = typeof(SyntaxMode).Assembly;
			Stream syntaxModeStream = assembly.GetManifestResourceStream("TextFileEdit.Resources.SyntaxModes.xml");
			if (syntaxModeStream != null) {
				syntaxModes = SyntaxMode.GetSyntaxModes(syntaxModeStream);
			} else {
				syntaxModes = new List<SyntaxMode>();
			}
		}
		
		public XmlTextReader GetSyntaxModeFile(SyntaxMode syntaxMode)
		{
			Assembly assembly = typeof(SyntaxMode).Assembly;
			return new XmlTextReader(assembly.GetManifestResourceStream("TextFileEdit.Resources." + syntaxMode.FileName));
		}
		
		public void UpdateSyntaxModeList()
		{
			// resources don't change during runtime
		}
	}
}

#endif
// file ...\TextFileEdit\Document\HighlightingStrategy\SyntaxModes\SyntaxMode.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2533 $</version>
// </file>


namespace TextFileEdit.Document
{
    public class SyntaxMode
    {
        string   fileName;
        string   name;
        string[] extensions;
        
        public string FileName {
            get {
                return fileName;
            }
            set {
                fileName = value;
            }
        }
        
        public string Name {
            get {
                return name;
            }
            set {
                name = value;
            }
        }
        
        public string[] Extensions {
            get {
                return extensions;
            }
            set {
                extensions = value;
            }
        }
        
        public SyntaxMode(string fileName, string name, string extensions)
        {
            this.fileName   = fileName;
            this.name       = name;
            this.extensions = extensions.Split(';', '|', ',');
        }
        
        public SyntaxMode(string fileName, string name, string[] extensions)
        {
            this.fileName = fileName;
            this.name = name;
            this.extensions = extensions;
        }
        
        public static List<SyntaxMode> GetSyntaxModes(Stream xmlSyntaxModeStream)
        {
            XmlTextReader reader = new XmlTextReader(xmlSyntaxModeStream);
            List<SyntaxMode> syntaxModes = new List<SyntaxMode>();
            while (reader.Read()) {
                switch (reader.NodeType) {
                    case XmlNodeType.Element:
                        switch (reader.Name) {
                            case "SyntaxModes":
                                string version = reader.GetAttribute("version");
                                if (version != "1.0") {
                                    throw new HighlightingDefinitionInvalidException("Unknown syntax mode file defininition with version " + version);
                                }
                                break;
                            case "Mode":
                                syntaxModes.Add(new SyntaxMode(reader.GetAttribute("file"), 
                                                               reader.GetAttribute("name"),
                                                               reader.GetAttribute("extensions")));
                                break;
                            default:
                                throw new HighlightingDefinitionInvalidException("Unknown node in syntax mode file :" + reader.Name);
                        }
                        break;
                }
            }
            reader.Close();
            return syntaxModes;
        }
        public override string ToString() 
        {
            return String.Format("[SyntaxMode: FileName={0}, Name={1}, Extensions=({2})]", fileName, name, String.Join(",", extensions));
        }
    }
}

#endif
// file ...\TextFileEdit\Document\LineManager\DeferredEventList.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Daniel Grunwald"/>
//     <version>$Revision$</version>
// </file>

namespace TextFileEdit.Document
{
	/// <summary>
	/// A list of events that are fired after the line manager has finished working.
	/// </summary>
	struct DeferredEventList
	{
		internal List<LineSegment> removedLines;
		internal List<TextAnchor> textAnchor;
		
		public void AddRemovedLine(LineSegment line)
		{
			if (removedLines == null)
				removedLines = new List<LineSegment>();
			removedLines.Add(line);
		}
		
		public void AddDeletedAnchor(TextAnchor anchor)
		{
			if (textAnchor == null)
				textAnchor = new List<TextAnchor>();
			textAnchor.Add(anchor);
		}
		
		public void RaiseEvents()
		{
			// removedLines is raised by the LineManager
			if (textAnchor != null) {
				foreach (TextAnchor a in textAnchor) {
					a.RaiseDeleted();
				}
			}
		}
	}
}

#endif
// file ...\TextFileEdit\Document\LineManager\LineManager.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3544 $</version>
// </file>


namespace TextFileEdit.Document
{
    public sealed class LineManager
    {
        LineSegmentTree lineCollection = new LineSegmentTree();

        IDocument document;
        IHighlightingStrategy highlightingStrategy;

        public IList<LineSegment> LineSegmentCollection
        {
            get
            {
                return lineCollection;
            }
        }

        public int TotalNumberOfLines
        {
            get
            {
                return lineCollection.Count;
            }
        }

        public IHighlightingStrategy HighlightingStrategy
        {
            get
            {
                return highlightingStrategy;
            }
            set
            {
                if (highlightingStrategy != value)
                {
                    highlightingStrategy = value;
                    if (highlightingStrategy != null)
                    {
                        highlightingStrategy.MarkTokens(document);
                    }
                }
            }
        }

        public LineManager(IDocument document, IHighlightingStrategy highlightingStrategy)
        {
            this.document = document;
            this.highlightingStrategy = highlightingStrategy;
        }

        public int GetLineNumberForOffset(int offset)
        {
            return GetLineSegmentForOffset(offset).LineNumber;
        }

        public LineSegment GetLineSegmentForOffset(int offset)
        {
            return lineCollection.GetByOffset(offset);
        }

        public LineSegment GetLineSegment(int lineNr)
        {
            return lineCollection[lineNr];
        }

        public void Insert(int offset, string text)
        {
            Replace(offset, 0, text);
        }

        public void Remove(int offset, int length)
        {
            Replace(offset, length, String.Empty);
        }

        public void Replace(int offset, int length, string text)
        {
            Debug.WriteLine("Replace offset=" + offset + " length=" + length + " text.Length=" + text.Length);
            int lineStart = GetLineNumberForOffset(offset);
            int oldNumberOfLines = this.TotalNumberOfLines;
            DeferredEventList deferredEventList = new DeferredEventList();
            RemoveInternal(ref deferredEventList, offset, length);
            int numberOfLinesAfterRemoving = this.TotalNumberOfLines;
            if (!string.IsNullOrEmpty(text))
            {
                InsertInternal(offset, text);
            }
            //          #if DEBUG
            //          Console.WriteLine("New line collection:");
            //          Console.WriteLine(lineCollection.GetTreeAsString());
            //          Console.WriteLine("New text:");
            //          Console.WriteLine("'" + document.TextContent + "'");
            //          #endif
            // Only fire events after RemoveInternal+InsertInternal finished completely:
            // Otherwise we would expose inconsistent state to the event handlers.
            RunHighlighter(lineStart, 1 + Math.Max(0, this.TotalNumberOfLines - numberOfLinesAfterRemoving));

            if (deferredEventList.removedLines != null)
            {
                foreach (LineSegment ls in deferredEventList.removedLines)
                    OnLineDeleted(new LineEventArgs(document, ls));
            }
            deferredEventList.RaiseEvents();
            if (this.TotalNumberOfLines != oldNumberOfLines)
            {
                OnLineCountChanged(new LineCountChangeEventArgs(document, lineStart, this.TotalNumberOfLines - oldNumberOfLines));
            }
        }

        void RemoveInternal(ref DeferredEventList deferredEventList, int offset, int length)
        {
            Debug.Assert(length >= 0);
            if (length == 0) return;
            LineSegmentTree.Enumerator it = lineCollection.GetEnumeratorForOffset(offset);
            LineSegment startSegment = it.Current;
            int startSegmentOffset = startSegment.Offset;
            if (offset + length < startSegmentOffset + startSegment.TotalLength)
            {
                // just removing a part of this line segment
                startSegment.RemovedLinePart(ref deferredEventList, offset - startSegmentOffset, length);
                SetSegmentLength(startSegment, startSegment.TotalLength - length);
                return;
            }
            // merge startSegment with another line segment because startSegment's delimiter was deleted
            // possibly remove lines in between if multiple delimiters were deleted
            int charactersRemovedInStartLine = startSegmentOffset + startSegment.TotalLength - offset;
            Debug.Assert(charactersRemovedInStartLine > 0);
            startSegment.RemovedLinePart(ref deferredEventList, offset - startSegmentOffset, charactersRemovedInStartLine);


            LineSegment endSegment = lineCollection.GetByOffset(offset + length);
            if (endSegment == startSegment)
            {
                // special case: we are removing a part of the last line up to the
                // end of the document
                SetSegmentLength(startSegment, startSegment.TotalLength - length);
                return;
            }
            int endSegmentOffset = endSegment.Offset;
            int charactersLeftInEndLine = endSegmentOffset + endSegment.TotalLength - (offset + length);
            endSegment.RemovedLinePart(ref deferredEventList, 0, endSegment.TotalLength - charactersLeftInEndLine);
            startSegment.MergedWith(endSegment, offset - startSegmentOffset);
            SetSegmentLength(startSegment, startSegment.TotalLength - charactersRemovedInStartLine + charactersLeftInEndLine);
            startSegment.DelimiterLength = endSegment.DelimiterLength;
            // remove all segments between startSegment (excl.) and endSegment (incl.)
            it.MoveNext();
            LineSegment segmentToRemove;
            do
            {
                segmentToRemove = it.Current;
                it.MoveNext();
                lineCollection.RemoveSegment(segmentToRemove);
                segmentToRemove.Deleted(ref deferredEventList);
            } while (segmentToRemove != endSegment);
        }

        void InsertInternal(int offset, string text)
        {
            LineSegment segment = lineCollection.GetByOffset(offset);
            DelimiterSegment ds = NextDelimiter(text, 0);
            if (ds == null)
            {
                // no newline is being inserted, all text is inserted in a single line
                segment.InsertedLinePart(offset - segment.Offset, text.Length);
                SetSegmentLength(segment, segment.TotalLength + text.Length);
                return;
            }
            LineSegment firstLine = segment;
            firstLine.InsertedLinePart(offset - firstLine.Offset, ds.Offset);
            int lastDelimiterEnd = 0;
            while (ds != null)
            {
                // split line segment at line delimiter
                int lineBreakOffset = offset + ds.Offset + ds.Length;
                int segmentOffset = segment.Offset;
                int lengthAfterInsertionPos = segmentOffset + segment.TotalLength - (offset + lastDelimiterEnd);
                lineCollection.SetSegmentLength(segment, lineBreakOffset - segmentOffset);
                LineSegment newSegment = lineCollection.InsertSegmentAfter(segment, lengthAfterInsertionPos);
                segment.DelimiterLength = ds.Length;

                segment = newSegment;
                lastDelimiterEnd = ds.Offset + ds.Length;

                ds = NextDelimiter(text, lastDelimiterEnd);
            }
            firstLine.SplitTo(segment);
            // insert rest after last delimiter
            if (lastDelimiterEnd != text.Length)
            {
                segment.InsertedLinePart(0, text.Length - lastDelimiterEnd);
                SetSegmentLength(segment, segment.TotalLength + text.Length - lastDelimiterEnd);
            }
        }

        void SetSegmentLength(LineSegment segment, int newTotalLength)
        {
            int delta = newTotalLength - segment.TotalLength;
            if (delta != 0)
            {
                lineCollection.SetSegmentLength(segment, newTotalLength);
                OnLineLengthChanged(new LineLengthChangeEventArgs(document, segment, delta));
            }
        }

        void RunHighlighter(int firstLine, int lineCount)
        {
            if (highlightingStrategy != null)
            {
                List<LineSegment> markLines = new List<LineSegment>();
                LineSegmentTree.Enumerator it = lineCollection.GetEnumeratorForIndex(firstLine);
                for (int i = 0; i < lineCount && it.IsValid; i++)
                {
                    markLines.Add(it.Current);
                    it.MoveNext();
                }
                highlightingStrategy.MarkTokens(document, markLines);
            }
        }

        public void SetContent(string text)
        {
            lineCollection.Clear();
            if (text != null)
            {
                Replace(0, 0, text);
            }
        }

        public int GetVisibleLine(int logicalLineNumber)
        {
            if (!document.TextEditorProperties.EnableFolding)
            {
                return logicalLineNumber;
            }

            int visibleLine = 0;
            int foldEnd = 0;
            List<FoldMarker> foldings = document.FoldingManager.GetTopLevelFoldedFoldings();
            foreach (FoldMarker fm in foldings)
            {
                if (fm.StartLine >= logicalLineNumber)
                {
                    break;
                }
                if (fm.StartLine >= foldEnd)
                {
                    visibleLine += fm.StartLine - foldEnd;
                    if (fm.EndLine > logicalLineNumber)
                    {
                        return visibleLine;
                    }
                    foldEnd = fm.EndLine;
                }
            }
            //          Debug.Assert(logicalLineNumber >= foldEnd);
            visibleLine += logicalLineNumber - foldEnd;
            return visibleLine;
        }

        public int GetFirstLogicalLine(int visibleLineNumber)
        {
            if (!document.TextEditorProperties.EnableFolding)
            {
                return visibleLineNumber;
            }
            int v = 0;
            int foldEnd = 0;
            List<FoldMarker> foldings = document.FoldingManager.GetTopLevelFoldedFoldings();
            foreach (FoldMarker fm in foldings)
            {
                if (fm.StartLine >= foldEnd)
                {
                    if (v + fm.StartLine - foldEnd >= visibleLineNumber)
                    {
                        break;
                    }
                    v += fm.StartLine - foldEnd;
                    foldEnd = fm.EndLine;
                }
            }
            // help GC
            foldings.Clear();
            foldings = null;
            return foldEnd + visibleLineNumber - v;
        }

        public int GetLastLogicalLine(int visibleLineNumber)
        {
            if (!document.TextEditorProperties.EnableFolding)
            {
                return visibleLineNumber;
            }
            return GetFirstLogicalLine(visibleLineNumber + 1) - 1;
        }

        //OneCodeTODO : speedup the next/prev visible line search
        // HOW? : save the foldings in a sorted list and lookup the
        //        line numbers in this list
        public int GetNextVisibleLineAbove(int lineNumber, int lineCount)
        {
            int curLineNumber = lineNumber;
            if (document.TextEditorProperties.EnableFolding)
            {
                for (int i = 0; i < lineCount && curLineNumber < TotalNumberOfLines; ++i)
                {
                    ++curLineNumber;
                    while (curLineNumber < TotalNumberOfLines && (curLineNumber >= lineCollection.Count || !document.FoldingManager.IsLineVisible(curLineNumber)))
                    {
                        ++curLineNumber;
                    }
                }
            }
            else
            {
                curLineNumber += lineCount;
            }
            return Math.Min(TotalNumberOfLines - 1, curLineNumber);
        }

        public int GetNextVisibleLineBelow(int lineNumber, int lineCount)
        {
            int curLineNumber = lineNumber;
            if (document.TextEditorProperties.EnableFolding)
            {
                for (int i = 0; i < lineCount; ++i)
                {
                    --curLineNumber;
                    while (curLineNumber >= 0 && !document.FoldingManager.IsLineVisible(curLineNumber))
                    {
                        --curLineNumber;
                    }
                }
            }
            else
            {
                curLineNumber -= lineCount;
            }
            return Math.Max(0, curLineNumber);
        }

        // use always the same DelimiterSegment object for the NextDelimiter
        DelimiterSegment delimiterSegment = new DelimiterSegment();

        DelimiterSegment NextDelimiter(string text, int offset)
        {
            for (int i = offset; i < text.Length; i++)
            {
                switch (text[i])
                {
                    case '\r':
                        if (i + 1 < text.Length)
                        {
                            if (text[i + 1] == '\n')
                            {
                                delimiterSegment.Offset = i;
                                delimiterSegment.Length = 2;
                                return delimiterSegment;
                            }
                        }
#if DATACONSISTENCYTEST
                        Debug.Assert(false, "Found lone \\r, data consistency problems?");
#endif
                        goto case '\n';
                    case '\n':
                        delimiterSegment.Offset = i;
                        delimiterSegment.Length = 1;
                        return delimiterSegment;
                }
            }
            return null;
        }

        void OnLineCountChanged(LineCountChangeEventArgs e)
        {
            if (LineCountChanged != null)
            {
                LineCountChanged(this, e);
            }
        }

        void OnLineLengthChanged(LineLengthChangeEventArgs e)
        {
            if (LineLengthChanged != null)
            {
                LineLengthChanged(this, e);
            }
        }

        void OnLineDeleted(LineEventArgs e)
        {
            if (LineDeleted != null)
            {
                LineDeleted(this, e);
            }
        }

        public event EventHandler<LineLengthChangeEventArgs> LineLengthChanged;
        public event EventHandler<LineCountChangeEventArgs> LineCountChanged;
        public event EventHandler<LineEventArgs> LineDeleted;

        sealed class DelimiterSegment
        {
            internal int Offset;
            internal int Length;
        }
    }
}

#endif
// file ...\TextFileEdit\Document\LineManager\LineManagerEventArgs.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2691 $</version>
// </file>


namespace TextFileEdit.Document
{
	public class LineCountChangeEventArgs : EventArgs
	{
		IDocument document;
		int       start;
		int       moved;
		
		/// <returns>
		/// always a valid Document which is related to the Event.
		/// </returns>
		public IDocument Document {
			get {
				return document;
			}
		}
		
		/// <returns>
		/// -1 if no offset was specified for this event
		/// </returns>
		public int LineStart {
			get {
				return start;
			}
		}
		
		/// <returns>
		/// -1 if no length was specified for this event
		/// </returns>
		public int LinesMoved {
			get {
				return moved;
			}
		}
		
		public LineCountChangeEventArgs(IDocument document, int lineStart, int linesMoved)
		{
			this.document = document;
			this.start    = lineStart;
			this.moved    = linesMoved;
		}
	}
	
	public class LineEventArgs : EventArgs
	{
		IDocument document;
		LineSegment lineSegment;
		
		public IDocument Document {
			get { return document; }
		}
		
		public LineSegment LineSegment {
			get { return lineSegment; }
		}
		
		public LineEventArgs(IDocument document, LineSegment lineSegment)
		{
			this.document = document;
			this.lineSegment = lineSegment;
		}
		
		public override string ToString()
		{
			return string.Format("[LineEventArgs Document={0} LineSegment={1}]", this.document, this.lineSegment);
		}
	}
	
	public class LineLengthChangeEventArgs : LineEventArgs
	{
		int lengthDelta;
		
		public int LengthDelta {
			get { return lengthDelta; }
		}
		
		public LineLengthChangeEventArgs(IDocument document, LineSegment lineSegment, int moved)
			: base(document, lineSegment)
		{
			this.lengthDelta = moved;
		}
		
		public override string ToString()
		{
			return string.Format("[LineLengthEventArgs Document={0} LineSegment={1} LengthDelta={2}]", this.Document, this.LineSegment, this.lengthDelta);
		}
	}
}

#endif
// file ...\TextFileEdit\Document\LineManager\LineSegment.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3272 $</version>
// </file>


namespace TextFileEdit.Document
{
	public sealed class LineSegment : ISegment
	{
		internal LineSegmentTree.Enumerator treeEntry;
		int totalLength, delimiterLength;
		
		List<TextWord> words;
		SpanStack highlightSpanStack;
		
		public TextWord GetWord(int column)
		{
			int curColumn = 0;
			foreach (TextWord word in words) {
				if (column < curColumn + word.Length) {
					return word;
				}
				curColumn += word.Length;
			}
			return null;
		}
		
		public bool IsDeleted {
			get { return !treeEntry.IsValid; }
		}
		
		public int LineNumber {
			get { return treeEntry.CurrentIndex; }
		}
		
		public int Offset {
			get { return treeEntry.CurrentOffset; }
		}
		
		public int Length {
			get	{ return totalLength - delimiterLength; }
		}
		
		int ISegment.Offset {
			get { return this.Offset; }
			set { throw new NotSupportedException(); }
		}
		int ISegment.Length {
			get { return this.Length; }
			set { throw new NotSupportedException(); }
		}
		
		public int TotalLength {
			get { return totalLength; }
			internal set { totalLength = value; }
		}
		
		public int DelimiterLength {
			get { return delimiterLength; }
			internal set { delimiterLength = value; }
		}
		
		// highlighting information
		public List<TextWord> Words {
			get {
				return words;
			}
			set {
				words = value;
			}
		}
		
		public HighlightColor GetColorForPosition(int x)
		{
			if (Words != null) {
				int xPos = 0;
				foreach (TextWord word in Words) {
					if (x < xPos + word.Length) {
						return word.SyntaxColor;
					}
					xPos += word.Length;
				}
			}
			return new HighlightColor(Color.Black, false, false);
		}
		
		public SpanStack HighlightSpanStack {
			get {
				return highlightSpanStack;
			}
			set {
				highlightSpanStack = value;
			}
		}
		
		/// <summary>
		/// Converts a <see cref="LineSegment"/> instance to string (for debug purposes)
		/// </summary>
		public override string ToString()
		{
			if (IsDeleted)
				return "[LineSegment: (deleted) Length = " + Length + ", TotalLength = " + TotalLength + ", DelimiterLength = " + delimiterLength + "]";
			else
				return "[LineSegment: LineNumber=" + LineNumber + ", Offset = "+ Offset +", Length = " + Length + ", TotalLength = " + TotalLength + ", DelimiterLength = " + delimiterLength + "]";
		}
		
		#region Anchor management
		Util.WeakCollection<TextAnchor> anchors;
		
		public TextAnchor CreateAnchor(int column)
		{
			if (column < 0 || column > Length)
				throw new ArgumentOutOfRangeException("column");
			TextAnchor anchor = new TextAnchor(this, column);
			AddAnchor(anchor);
			return anchor;
		}
		
		void AddAnchor(TextAnchor anchor)
		{
			Debug.Assert(anchor.Line == this);
			
			if (anchors == null)
				anchors = new Util.WeakCollection<TextAnchor>();
			
			anchors.Add(anchor);
		}
		
		/// <summary>
		/// Is called when the LineSegment is deleted.
		/// </summary>
		internal void Deleted(ref DeferredEventList deferredEventList)
		{
			//Console.WriteLine("Deleted");
			treeEntry = LineSegmentTree.Enumerator.Invalid;
			if (anchors != null) {
				foreach (TextAnchor a in anchors) {
					a.Delete(ref deferredEventList);
				}
				anchors = null;
			}
		}
		
		/// <summary>
		/// Is called when a part of the line is removed.
		/// </summary>
		internal void RemovedLinePart(ref DeferredEventList deferredEventList, int startColumn, int length)
		{
			if (length == 0)
				return;
			Debug.Assert(length > 0);
			
			//Console.WriteLine("RemovedLinePart " + startColumn + ", " + length);
			if (anchors != null) {
				List<TextAnchor> deletedAnchors = null;
				foreach (TextAnchor a in anchors) {
					if (a.ColumnNumber > startColumn) {
						if (a.ColumnNumber >= startColumn + length) {
							a.ColumnNumber -= length;
						} else {
							if (deletedAnchors == null)
								deletedAnchors = new List<TextAnchor>();
							a.Delete(ref deferredEventList);
							deletedAnchors.Add(a);
						}
					}
				}
				if (deletedAnchors != null) {
					foreach (TextAnchor a in deletedAnchors) {
						anchors.Remove(a);
					}
				}
			}
		}
		
		/// <summary>
		/// Is called when a part of the line is inserted.
		/// </summary>
		internal void InsertedLinePart(int startColumn, int length)
		{
			if (length == 0)
				return;
			Debug.Assert(length > 0);
			
			//Console.WriteLine("InsertedLinePart " + startColumn + ", " + length);
			if (anchors != null) {
				foreach (TextAnchor a in anchors) {
					if (a.MovementType == AnchorMovementType.BeforeInsertion
					    ? a.ColumnNumber > startColumn
					    : a.ColumnNumber >= startColumn)
					{
						a.ColumnNumber += length;
					}
				}
			}
		}
		
		/// <summary>
		/// Is called after another line's content is appended to this line because the newline in between
		/// was deleted.
		/// The DefaultLineManager will call Deleted() on the deletedLine after the MergedWith call.
		/// 
		/// firstLineLength: the length of the line before the merge.
		/// </summary>
		internal void MergedWith(LineSegment deletedLine, int firstLineLength)
		{
			//Console.WriteLine("MergedWith");
			
			if (deletedLine.anchors != null) {
				foreach (TextAnchor a in deletedLine.anchors) {
					a.Line = this;
					AddAnchor(a);
					a.ColumnNumber += firstLineLength;
				}
				deletedLine.anchors = null;
			}
		}
		
		/// <summary>
		/// Is called after a newline was inserted into this line, splitting it into this and followingLine.
		/// </summary>
		internal void SplitTo(LineSegment followingLine)
		{
			//Console.WriteLine("SplitTo");
			
			if (anchors != null) {
				List<TextAnchor> movedAnchors = null;
				foreach (TextAnchor a in anchors) {
					if (a.MovementType == AnchorMovementType.BeforeInsertion
					    ? a.ColumnNumber > this.Length
					    : a.ColumnNumber >= this.Length)
					{
						a.Line = followingLine;
						followingLine.AddAnchor(a);
						a.ColumnNumber -= this.Length;
						
						if (movedAnchors == null)
							movedAnchors = new List<TextAnchor>();
						movedAnchors.Add(a);
					}
				}
				if (movedAnchors != null) {
					foreach (TextAnchor a in movedAnchors) {
						anchors.Remove(a);
					}
				}
			}
		}
		#endregion
	}
}

#endif
// file ...\TextFileEdit\Document\LineManager\LineSegmentTree.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Daniel Grunwald" email="daniel@danielgrunwald.de"/>
//     <version>$Revision: 2683 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// Data structure for efficient management of the line segments (most operations are O(lg n)).
	/// This implements an augmented red-black tree where each node has fields for the number of
	/// nodes in its subtree (like an order statistics tree) for access by index(=line number).
	/// Additionally, each node knows the total length of all segments in its subtree.
	/// This means we can find nodes by offset in O(lg n) time. Since the offset itself is not stored in
	/// the line segment but computed from the lengths stored in the tree, we adjusting the offsets when
	/// text is inserted in one line means we just have to increment the totalLength of the affected line and
	/// its parent nodes - an O(lg n) operation.
	/// However this means getting the line number or offset from a LineSegment is not a constant time
	/// operation, but takes O(lg n).
	/// 
	/// NOTE: The tree is never empty, Clear() causes it to contain an empty segment.
	/// </summary>
	sealed class LineSegmentTree : IList<LineSegment>
	{
		internal struct RBNode
		{
			internal LineSegment lineSegment;
			internal int count;
			internal int totalLength;
			
			public RBNode(LineSegment lineSegment)
			{
				this.lineSegment = lineSegment;
				this.count = 1;
				this.totalLength = lineSegment.TotalLength;
			}
			
			public override string ToString()
			{
				return "[RBNode count=" + count + " totalLength="+totalLength
					+ " lineSegment.LineNumber=" + lineSegment.LineNumber
					+ " lineSegment.Offset=" + lineSegment.Offset
					+ " lineSegment.TotalLength=" + lineSegment.TotalLength
					+ " lineSegment.DelimiterLength=" + lineSegment.DelimiterLength + "]";
			}
		}
		
		struct MyHost : TextFileEdit.Util.IRedBlackTreeHost<RBNode>
		{
			public int Compare(RBNode x, RBNode y)
			{
				throw new NotImplementedException();
			}
			
			public bool Equals(RBNode a, RBNode b)
			{
				throw new NotImplementedException();
			}

            public void UpdateAfterChildrenChange(TextFileEdit.Util.RedBlackTreeNode<RBNode> node)
			{
				int count = 1;
				int totalLength = node.val.lineSegment.TotalLength;
				if (node.left != null) {
					count += node.left.val.count;
					totalLength += node.left.val.totalLength;
				}
				if (node.right != null) {
					count += node.right.val.count;
					totalLength += node.right.val.totalLength;
				}
				if (count != node.val.count || totalLength != node.val.totalLength) {
					node.val.count = count;
					node.val.totalLength = totalLength;
					if (node.parent != null) UpdateAfterChildrenChange(node.parent);
				}
			}
			
			public void UpdateAfterRotateLeft(TextFileEdit.Util.RedBlackTreeNode<RBNode> node)
			{
				UpdateAfterChildrenChange(node);
				UpdateAfterChildrenChange(node.parent);
			}
			
			public void UpdateAfterRotateRight(TextFileEdit.Util.RedBlackTreeNode<RBNode> node)
			{
				UpdateAfterChildrenChange(node);
				UpdateAfterChildrenChange(node.parent);
			}
		}

        readonly TextFileEdit.Util.AugmentableRedBlackTree<RBNode, MyHost> tree = new TextFileEdit.Util.AugmentableRedBlackTree<RBNode, MyHost>(new MyHost());
		
		TextFileEdit.Util.RedBlackTreeNode<RBNode> GetNode(int index)
		{
			if (index < 0 || index >= tree.Count)
				throw new ArgumentOutOfRangeException("index", index, "index should be between 0 and " + (tree.Count-1));
			TextFileEdit.Util.RedBlackTreeNode<RBNode> node = tree.root;
			while (true) {
				if (node.left != null && index < node.left.val.count) {
					node = node.left;
				} else {
					if (node.left != null) {
						index -= node.left.val.count;
					}
					if (index == 0)
						return node;
					index--;
					node = node.right;
				}
			}
		}
		
		static int GetIndexFromNode(TextFileEdit.Util.RedBlackTreeNode<RBNode> node)
		{
			int index = (node.left != null) ? node.left.val.count : 0;
			while (node.parent != null) {
				if (node == node.parent.right) {
					if (node.parent.left != null)
						index += node.parent.left.val.count;
					index++;
				}
				node = node.parent;
			}
			return index;
		}
		
		TextFileEdit.Util.RedBlackTreeNode<RBNode> GetNodeByOffset(int offset)
		{
			if (offset < 0 || offset > this.TotalLength)
				throw new ArgumentOutOfRangeException("offset", offset, "offset should be between 0 and " + this.TotalLength);
			if (offset == this.TotalLength) {
				if (tree.root == null)
					throw new InvalidOperationException("Cannot call GetNodeByOffset while tree is empty.");
				return tree.root.RightMost;
			}
			TextFileEdit.Util.RedBlackTreeNode<RBNode> node = tree.root;
			while (true) {
				if (node.left != null && offset < node.left.val.totalLength) {
					node = node.left;
				} else {
					if (node.left != null) {
						offset -= node.left.val.totalLength;
					}
					offset -= node.val.lineSegment.TotalLength;
					if (offset < 0)
						return node;
					node = node.right;
				}
			}
		}
		
		static int GetOffsetFromNode(TextFileEdit.Util.RedBlackTreeNode<RBNode> node)
		{
			int offset = (node.left != null) ? node.left.val.totalLength : 0;
			while (node.parent != null) {
				if (node == node.parent.right) {
					if (node.parent.left != null)
						offset += node.parent.left.val.totalLength;
					offset += node.parent.val.lineSegment.TotalLength;
				}
				node = node.parent;
			}
			return offset;
		}
		
		public LineSegment GetByOffset(int offset)
		{
			return GetNodeByOffset(offset).val.lineSegment;
		}
		
		/// <summary>
		/// Gets the total length of all line segments. Runs in O(1).
		/// </summary>
		public int TotalLength {
			get {
				if (tree.root == null)
					return 0;
				else
					return tree.root.val.totalLength;
			}
		}
		
		/// <summary>
		/// Updates the length of a line segment. Runs in O(lg n).
		/// </summary>
		public void SetSegmentLength(LineSegment segment, int newTotalLength)
		{
			if (segment == null)
				throw new ArgumentNullException("segment");
			TextFileEdit.Util.RedBlackTreeNode<RBNode> node = segment.treeEntry.it.node;
			segment.TotalLength = newTotalLength;
			default(MyHost).UpdateAfterChildrenChange(node);
			#if DEBUG
			CheckProperties();
			#endif
		}
		
		public void RemoveSegment(LineSegment segment)
		{
			tree.RemoveAt(segment.treeEntry.it);
			#if DEBUG
			CheckProperties();
			#endif
		}
		
		public LineSegment InsertSegmentAfter(LineSegment segment, int length)
		{
			LineSegment newSegment = new LineSegment();
			newSegment.TotalLength = length;
			newSegment.DelimiterLength = segment.DelimiterLength;
			
			newSegment.treeEntry = InsertAfter(segment.treeEntry.it.node, newSegment);
			return newSegment;
		}
		
		Enumerator InsertAfter(TextFileEdit.Util.RedBlackTreeNode<RBNode> node, LineSegment newSegment)
		{
            TextFileEdit.Util.RedBlackTreeNode<RBNode> newNode = new TextFileEdit.Util.RedBlackTreeNode<RBNode>(new RBNode(newSegment));
			if (node.right == null) {
				tree.InsertAsRight(node, newNode);
			} else {
				tree.InsertAsLeft(node.right.LeftMost, newNode);
			}
			#if DEBUG
			CheckProperties();
			#endif
            return new Enumerator(new TextFileEdit.Util.RedBlackTreeIterator<RBNode>(newNode));
		}
		
		/// <summary>
		/// Gets the number of items in the collections. Runs in O(1).
		/// </summary>
		public int Count {
			get { return tree.Count; }
		}
		
		/// <summary>
		/// Gets or sets an item by index. Runs in O(lg n).
		/// </summary>
		public LineSegment this[int index] {
			get {
				return GetNode(index).val.lineSegment;
			}
			set {
				throw new NotSupportedException();
			}
		}
		
		bool ICollection<LineSegment>.IsReadOnly {
			get { return true; }
		}
		
		/// <summary>
		/// Gets the index of an item. Runs in O(lg n).
		/// </summary>
		public int IndexOf(LineSegment item)
		{
			int index = item.LineNumber;
			if (index < 0 || index >= this.Count)
				return -1;
			if (item != this[index])
				return -1;
			return index;
		}
		
		void IList<LineSegment>.RemoveAt(int index)
		{
			throw new NotSupportedException();
		}
		
		#if DEBUG
		[Conditional("DATACONSISTENCYTEST")]
		void CheckProperties()
		{
			if (tree.root == null) {
				Debug.Assert(this.Count == 0);
			} else {
				Debug.Assert(tree.root.val.count == this.Count);
				CheckProperties(tree.root);
			}
		}

        void CheckProperties(TextFileEdit.Util.RedBlackTreeNode<RBNode> node)
		{
			int count = 1;
			int totalLength = node.val.lineSegment.TotalLength;
			if (node.left != null) {
				CheckProperties(node.left);
				count += node.left.val.count;
				totalLength += node.left.val.totalLength;
			}
			if (node.right != null) {
				CheckProperties(node.right);
				count += node.right.val.count;
				totalLength += node.right.val.totalLength;
			}
			Debug.Assert(node.val.count == count);
			Debug.Assert(node.val.totalLength == totalLength);
		}
		
		public string GetTreeAsString()
		{
			return tree.GetTreeAsString();
		}
		#endif
		
		public LineSegmentTree()
		{
			Clear();
		}
		
		/// <summary>
		/// Clears the list. Runs in O(1).
		/// </summary>
		public void Clear()
		{
			tree.Clear();
			LineSegment emptySegment = new LineSegment();
			emptySegment.TotalLength = 0;
			emptySegment.DelimiterLength = 0;
			tree.Add(new RBNode(emptySegment));
			emptySegment.treeEntry = GetEnumeratorForIndex(0);
			#if DEBUG
			CheckProperties();
			#endif
		}
		
		/// <summary>
		/// Tests whether an item is in the list. Runs in O(n).
		/// </summary>
		public bool Contains(LineSegment item)
		{
			return IndexOf(item) >= 0;
		}
		
		/// <summary>
		/// Copies all elements from the list to the array.
		/// </summary>
		public void CopyTo(LineSegment[] array, int arrayIndex)
		{
			if (array == null) throw new ArgumentNullException("array");
			foreach (LineSegment val in this)
				array[arrayIndex++] = val;
		}
		
		IEnumerator<LineSegment> IEnumerable<LineSegment>.GetEnumerator()
		{
			return this.GetEnumerator();
		}
		
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
		{
			return this.GetEnumerator();
		}
		
		public Enumerator GetEnumerator()
		{
			return new Enumerator(tree.GetEnumerator());
		}
		
		public Enumerator GetEnumeratorForIndex(int index)
		{
            return new Enumerator(new TextFileEdit.Util.RedBlackTreeIterator<RBNode>(GetNode(index)));
		}
		
		public Enumerator GetEnumeratorForOffset(int offset)
		{
			return new Enumerator(new TextFileEdit.Util.RedBlackTreeIterator<RBNode>(GetNodeByOffset(offset)));
		}
		
		public struct Enumerator : IEnumerator<LineSegment>
		{
			/// <summary>
			/// An invalid enumerator value. Calling MoveNext on the invalid enumerator
			/// will always return false, accessing Current will throw an exception.
			/// </summary>
			public static readonly Enumerator Invalid = default(Enumerator);
			
			internal TextFileEdit.Util.RedBlackTreeIterator<RBNode> it;

            internal Enumerator(TextFileEdit.Util.RedBlackTreeIterator<RBNode> it)
			{
				this.it = it;
			}
			
			/// <summary>
			/// Gets the current value. Runs in O(1).
			/// </summary>
			public LineSegment Current {
				get {
					return it.Current.lineSegment;
				}
			}
			
			public bool IsValid {
				get {
					return it.IsValid;
				}
			}
			
			/// <summary>
			/// Gets the index of the current value. Runs in O(lg n).
			/// </summary>
			public int CurrentIndex {
				get {
					if (it.node == null)
						throw new InvalidOperationException();
					return GetIndexFromNode(it.node);
				}
			}
			
			/// <summary>
			/// Gets the offset of the current value. Runs in O(lg n).
			/// </summary>
			public int CurrentOffset {
				get {
					if (it.node == null)
						throw new InvalidOperationException();
					return GetOffsetFromNode(it.node);
				}
			}
			
			object System.Collections.IEnumerator.Current {
				get {
					return it.Current.lineSegment;
				}
			}
			
			public void Dispose()
			{
			}
			
			/// <summary>
			/// Moves to the next index. Runs in O(lg n), but for k calls, the combined time is only O(k+lg n).
			/// </summary>
			public bool MoveNext()
			{
				return it.MoveNext();
			}
			
			/// <summary>
			/// Moves to the previous index. Runs in O(lg n), but for k calls, the combined time is only O(k+lg n).
			/// </summary>
			public bool MoveBack()
			{
				return it.MoveBack();
			}
			
			void System.Collections.IEnumerator.Reset()
			{
				throw new NotSupportedException();
			}
		}
		
		void IList<LineSegment>.Insert(int index, LineSegment item)
		{
			throw new NotSupportedException();
		}
		
		void ICollection<LineSegment>.Add(LineSegment item)
		{
			throw new NotSupportedException();
		}
		
		bool ICollection<LineSegment>.Remove(LineSegment item)
		{
			throw new NotSupportedException();
		}
	}
}

#endif
// file ...\TextFileEdit\Document\MarkerStrategy\MarkerStrategy.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2659 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// Manages the list of markers and provides ways to retrieve markers for specific positions.
	/// </summary>
	public sealed class MarkerStrategy
	{
		List<TextMarker> textMarker = new List<TextMarker>();
		IDocument document;
		
		public IDocument Document {
			get {
				return document;
			}
		}
		
		public IEnumerable<TextMarker> TextMarker {
			get {
				return textMarker.AsReadOnly();
			}
		}
		
		public void AddMarker(TextMarker item)
		{
			markersTable.Clear();
			textMarker.Add(item);
		}
		
		public void InsertMarker(int index, TextMarker item)
		{
			markersTable.Clear();
			textMarker.Insert(index, item);
		}
		
		public void RemoveMarker(TextMarker item)
		{
			markersTable.Clear();
			textMarker.Remove(item);
		}
		
		public void RemoveAll(Predicate<TextMarker> match)
		{
			markersTable.Clear();
			textMarker.RemoveAll(match);
		}
		
		public MarkerStrategy(IDocument document)
		{
			this.document = document;
			document.DocumentChanged += new DocumentEventHandler(DocumentChanged);
		}
		
		Dictionary<int, List<TextMarker>> markersTable = new Dictionary<int, List<TextMarker>>();
		
		public List<TextMarker> GetMarkers(int offset)
		{
			if (!markersTable.ContainsKey(offset)) {
				List<TextMarker> markers = new List<TextMarker>();
				for (int i = 0; i < textMarker.Count; ++i) {
					TextMarker marker = (TextMarker)textMarker[i];
					if (marker.Offset <= offset && offset <= marker.EndOffset) {
						markers.Add(marker);
					}
				}
				markersTable[offset] = markers;
			}
			return markersTable[offset];
		}
		
		public List<TextMarker> GetMarkers(int offset, int length)
		{
			int endOffset = offset + length - 1;
			List<TextMarker> markers = new List<TextMarker>();
			for (int i = 0; i < textMarker.Count; ++i) {
				TextMarker marker = (TextMarker)textMarker[i];
				if (// start in marker region
				    marker.Offset <= offset && offset <= marker.EndOffset ||
				    // end in marker region
				    marker.Offset <= endOffset && endOffset <= marker.EndOffset ||
				    // marker start in region
				    offset <= marker.Offset && marker.Offset <= endOffset ||
				    // marker end in region
				    offset <= marker.EndOffset && marker.EndOffset <= endOffset
				   )
				{
					markers.Add(marker);
				}
			}
			return markers;
		}
		
		public List<TextMarker> GetMarkers(TextLocation position)
		{
			if (position.Y >= document.TotalNumberOfLines || position.Y < 0) {
				return new List<TextMarker>();
			}
			LineSegment segment = document.GetLineSegment(position.Y);
			return GetMarkers(segment.Offset + position.X);
		}
		
		void DocumentChanged(object sender, DocumentEventArgs e)
		{
			// reset markers table
			markersTable.Clear();
			document.UpdateSegmentListOnDocumentChange(textMarker, e);
		}
	}
}

#endif
// file ...\TextFileEdit\Document\MarkerStrategy\TextMarker.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Daniel Grunwald" email="daniel@danielgrunwald.de"/>
//     <version>$Revision: 3206 $</version>
// </file>


namespace TextFileEdit.Document
{
	public enum TextMarkerType
	{
		Invisible,
		SolidBlock,
		Underlined,
		WaveLine
	}
	
	/// <summary>
	/// Marks a part of a document.
	/// </summary>
	public class TextMarker : AbstractSegment
	{
		TextMarkerType textMarkerType;
		Color          color;
		Color          foreColor;
		string         toolTip = null;
		bool           overrideForeColor = false;
		
		public TextMarkerType TextMarkerType {
			get {
				return textMarkerType;
			}
		}
		
		public Color Color {
			get {
				return color;
			}
		}
		
		public Color ForeColor {
			get {
				return foreColor;
			}
		}
		
		public bool OverrideForeColor {
			get {
				return overrideForeColor;
			}
		}
		
		/// <summary>
		/// Marks the text segment as read-only.
		/// </summary>
		public bool IsReadOnly { get; set; }
		
		public string ToolTip {
			get {
				return toolTip;
			}
			set {
				toolTip = value;
			}
		}
		
		/// <summary>
		/// Gets the last offset that is inside the marker region.
		/// </summary>
		public int EndOffset {
			get {
				return Offset + Length - 1;
			}
		}
		
		public TextMarker(int offset, int length, TextMarkerType textMarkerType) : this(offset, length, textMarkerType, Color.Red)
		{
		}
		
		public TextMarker(int offset, int length, TextMarkerType textMarkerType, Color color)
		{
			if (length < 1) length = 1;
			this.offset          = offset;
			this.length          = length;
			this.textMarkerType  = textMarkerType;
			this.color           = color;
		}
		
		public TextMarker(int offset, int length, TextMarkerType textMarkerType, Color color, Color foreColor)
		{
			if (length < 1) length = 1;
			this.offset          = offset;
			this.length          = length;
			this.textMarkerType  = textMarkerType;
			this.color           = color;
			this.foreColor       = foreColor;
			this.overrideForeColor = true;
		}
	}
}

#endif
// file ...\TextFileEdit\Document\Selection\ColumnRange.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1965 $</version>
// </file>


namespace TextFileEdit.Document
{
	public class ColumnRange 
	{
		public static readonly ColumnRange NoColumn    = new ColumnRange(-2, -2);
		public static readonly ColumnRange WholeColumn = new ColumnRange(-1, -1);
		
		int startColumn;
		int endColumn;
		
		public int StartColumn {
			get {
				return startColumn;
			}
			set {
				startColumn = value;
			}
		}
		
		public int EndColumn {
			get {
				return endColumn;
			}
			set {
				endColumn = value;
			}
		}
		
		public ColumnRange(int startColumn, int endColumn)
		{
			this.startColumn = startColumn;
			this.endColumn = endColumn;
			
		}
		
		public override int GetHashCode()
		{
			return startColumn + (endColumn << 16);
		}
		
		public override bool Equals(object obj)
		{
			if (obj is ColumnRange) {
				return ((ColumnRange)obj).startColumn == startColumn &&
				       ((ColumnRange)obj).endColumn == endColumn;
				
			}
			return false;
		}
		
		public override string ToString()
		{
			return String.Format("[ColumnRange: StartColumn={0}, EndColumn={1}]", startColumn, endColumn);
		}
		
	}
}

#endif
// file ...\TextFileEdit\Document\Selection\DefaultSelection.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2679 $</version>
// </file>


namespace TextFileEdit.Document
{
    /// <summary>
    /// Default implementation of the <see cref="TextFileEdit.Document.ISelection"/> interface.
    /// </summary>
    public class DefaultSelection : ISelection
    {
        IDocument document;
        bool isRectangularSelection;
        TextLocation startPosition;
        TextLocation endPosition;

        public TextLocation StartPosition
        {
            get
            {
                return startPosition;
            }
            set
            {
                DefaultDocument.ValidatePosition(document, value);
                startPosition = value;
            }
        }

        public TextLocation EndPosition
        {
            get
            {
                return endPosition;
            }
            set
            {
                DefaultDocument.ValidatePosition(document, value);
                endPosition = value;
            }
        }

        public int Offset
        {
            get
            {
                return document.PositionToOffset(startPosition);
            }
        }

        public int EndOffset
        {
            get
            {
                return document.PositionToOffset(endPosition);
            }
        }

        public int Length
        {
            get
            {
                return EndOffset - Offset;
            }
        }

        /// <value>
        /// Returns true, if the selection is empty
        /// </value>
        public bool IsEmpty
        {
            get
            {
                return startPosition == endPosition;
            }
        }

        /// <value>
        /// Returns true, if the selection is rectangular
        /// </value>
        //OneCodeTODO : make this unused property used.
        public bool IsRectangularSelection
        {
            get
            {
                return isRectangularSelection;
            }
            set
            {
                isRectangularSelection = value;
            }
        }

        /// <value>
        /// The text which is selected by this selection.
        /// </value>
        public string SelectedText
        {
            get
            {
                if (document != null)
                {
                    if (Length < 0)
                    {
                        return null;
                    }
                    return document.GetText(Offset, Length);
                }
                return null;
            }
        }

        /// <summary>
        /// Creates a new instance of <see cref="DefaultSelection"/>
        /// </summary>
        public DefaultSelection(IDocument document, TextLocation startPosition, TextLocation endPosition)
        {
            DefaultDocument.ValidatePosition(document, startPosition);
            DefaultDocument.ValidatePosition(document, endPosition);
            Debug.Assert(startPosition <= endPosition);
            this.document = document;
            this.startPosition = startPosition;
            this.endPosition = endPosition;
        }

        /// <summary>
        /// Converts a <see cref="DefaultSelection"/> instance to string (for debug purposes)
        /// </summary>
        public override string ToString()
        {
            return String.Format("[DefaultSelection : StartPosition={0}, EndPosition={1}]", startPosition, endPosition);
        }
        public bool ContainsPosition(TextLocation position)
        {
            if (this.IsEmpty)
                return false;
            return startPosition.Y < position.Y && position.Y < endPosition.Y ||
                startPosition.Y == position.Y && startPosition.X <= position.X && (startPosition.Y != endPosition.Y || position.X <= endPosition.X) ||
                endPosition.Y == position.Y && startPosition.Y != endPosition.Y && position.X <= endPosition.X;
        }

        public bool ContainsOffset(int offset)
        {
            return Offset <= offset && offset <= EndOffset;
        }
    }
}

#endif
// file ...\TextFileEdit\Document\Selection\ISelection.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2659 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// An interface representing a portion of the current selection.
	/// </summary>
	public interface ISelection
	{
		TextLocation StartPosition {
			get;
			set;
		}
		
		TextLocation EndPosition {
			get;
			set;
		}
		
		int Offset {
			get;
		}
		
		int EndOffset {
			get;
		}
		
		int Length {
			get;
		}
		
		/// <value>
		/// Returns true, if the selection is rectangular
		/// </value>
		bool IsRectangularSelection {
			get;
		}
		
		/// <value>
		/// Returns true, if the selection is empty
		/// </value>
		bool IsEmpty {
			get;
		}

		/// <value>
		/// The text which is selected by this selection.
		/// </value>
		string SelectedText {
			get;
		}
		
		bool ContainsOffset(int offset);
		
		bool ContainsPosition(TextLocation position);
	}
}

#endif
// file ...\TextFileEdit\Document\Selection\SelectionManager.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3205 $</version>
// </file>


namespace TextFileEdit.Document
{
    /// <summary>
    /// This class manages the selections in a document.
    /// </summary>
    public class SelectionManager : IDisposable
    {
        TextLocation selectionStart;

        internal TextLocation SelectionStart
        {
            get { return selectionStart; }
            set
            {
                DefaultDocument.ValidatePosition(document, value);
                selectionStart = value;
            }
        }
        IDocument document;
        TextArea textArea;
        internal SelectFrom selectFrom = new SelectFrom();

        internal List<ISelection> selectionCollection = new List<ISelection>();

        /// <value>
        /// A collection containing all selections.
        /// </value>
        public List<ISelection> SelectionCollection
        {
            get
            {
                return selectionCollection;
            }
        }

        /// <value>
        /// true if the <see cref="SelectionCollection"/> is not empty, false otherwise.
        /// </value>
        public bool HasSomethingSelected
        {
            get
            {
                return selectionCollection.Count > 0;
            }
        }

        public bool SelectionIsReadonly
        {
            get
            {
                if (document.ReadOnly)
                    return true;
                foreach (ISelection sel in selectionCollection)
                {
                    if (SelectionIsReadOnly(document, sel))
                        return true;
                }
                return false;
            }
        }

        internal static bool SelectionIsReadOnly(IDocument document, ISelection sel)
        {
            if (document.TextEditorProperties.SupportReadOnlySegments)
                return document.MarkerStrategy.GetMarkers(sel.Offset, sel.Length).Exists(m => m.IsReadOnly);
            else
                return false;
        }

        /// <value>
        /// The text that is currently selected.
        /// </value>
        public string SelectedText
        {
            get
            {
                StringBuilder builder = new StringBuilder();

                //              PriorityQueue queue = new PriorityQueue();

                foreach (ISelection s in selectionCollection)
                {
                    builder.Append(s.SelectedText);
                    //                  queue.Insert(-s.Offset, s);
                }

                //              while (queue.Count > 0) {
                //                  ISelection s = ((ISelection)queue.Remove());
                //                  builder.Append(s.SelectedText);
                //              }

                return builder.ToString();
            }
        }

        /// <summary>
        /// Creates a new instance of <see cref="SelectionManager"/>
        /// </summary>
        public SelectionManager(IDocument document)
        {
            this.document = document;
            document.DocumentChanged += new DocumentEventHandler(DocumentChanged);
        }

        /// <summary>
        /// Creates a new instance of <see cref="SelectionManager"/>
        /// </summary>
        public SelectionManager(IDocument document, TextArea textArea)
        {
            this.document = document;
            this.textArea = textArea;
            document.DocumentChanged += new DocumentEventHandler(DocumentChanged);
        }

        public void Dispose()
        {
            if (this.document != null)
            {
                document.DocumentChanged -= new DocumentEventHandler(DocumentChanged);
                this.document = null;
            }
        }

        void DocumentChanged(object sender, DocumentEventArgs e)
        {
            if (e.Text == null)
            {
                Remove(e.Offset, e.Length);
            }
            else
            {
                if (e.Length < 0)
                {
                    Insert(e.Offset, e.Text);
                }
                else
                {
                    Replace(e.Offset, e.Length, e.Text);
                }
            }
        }

        /// <remarks>
        /// Clears the selection and sets a new selection
        /// using the given <see cref="ISelection"/> object.
        /// </remarks>
        public void SetSelection(ISelection selection)
        {
            //          autoClearSelection = false;
            if (selection != null)
            {
                if (SelectionCollection.Count == 1 &&
                    selection.StartPosition == SelectionCollection[0].StartPosition &&
                    selection.EndPosition == SelectionCollection[0].EndPosition)
                {
                    return;
                }
                ClearWithoutUpdate();
                selectionCollection.Add(selection);
                document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.LinesBetween, selection.StartPosition.Y, selection.EndPosition.Y));
                document.CommitUpdate();
                OnSelectionChanged(EventArgs.Empty);
            }
            else
            {
                ClearSelection();
            }
        }

        public void SetSelection(TextLocation startPosition, TextLocation endPosition)
        {
            SetSelection(new DefaultSelection(document, startPosition, endPosition));
        }

        public bool GreaterEqPos(TextLocation p1, TextLocation p2)
        {
            return p1.Y > p2.Y || p1.Y == p2.Y && p1.X >= p2.X;
        }

        public void ExtendSelection(TextLocation oldPosition, TextLocation newPosition)
        {
            // where oldposition is where the cursor was,
            // and newposition is where it has ended up from a click (both zero based)

            if (oldPosition == newPosition)
            {
                return;
            }

            TextLocation min;
            TextLocation max;
            int oldnewX = newPosition.X;
            bool oldIsGreater = GreaterEqPos(oldPosition, newPosition);
            if (oldIsGreater)
            {
                min = newPosition;
                max = oldPosition;
            }
            else
            {
                min = oldPosition;
                max = newPosition;
            }

            if (min == max)
            {
                return;
            }

            if (!HasSomethingSelected)
            {
                SetSelection(new DefaultSelection(document, min, max));
                // initialise selectFrom for a cursor selection
                if (selectFrom.where == WhereFrom.None)
                    SelectionStart = oldPosition; //textArea.Caret.Position;
                return;
            }

            ISelection selection = this.selectionCollection[0];

            if (min == max)
            {
                //selection.StartPosition = newPosition;
                return;
            }
            else
            {
                // changed selection via gutter
                if (selectFrom.where == WhereFrom.Gutter)
                {
                    // selection new position is always at the left edge for gutter selections
                    newPosition.X = 0;
                }

                if (GreaterEqPos(newPosition, SelectionStart)) // selecting forward
                {
                    selection.StartPosition = SelectionStart;
                    // this handles last line selection
                    if (selectFrom.where == WhereFrom.Gutter) //&& newPosition.Y != oldPosition.Y)
                        selection.EndPosition = new TextLocation(textArea.Caret.Column, textArea.Caret.Line);
                    else
                    {
                        newPosition.X = oldnewX;
                        selection.EndPosition = newPosition;
                    }
                }
                else
                { // selecting back
                    if (selectFrom.where == WhereFrom.Gutter && selectFrom.first == WhereFrom.Gutter)
                    { // gutter selection
                        selection.EndPosition = NextValidPosition(SelectionStart.Y);
                    }
                    else
                    { // internal text selection
                        selection.EndPosition = SelectionStart; //selection.StartPosition;
                    }
                    selection.StartPosition = newPosition;
                }
            }

            document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.LinesBetween, min.Y, max.Y));
            document.CommitUpdate();
            OnSelectionChanged(EventArgs.Empty);
        }

        // retrieve the next available line
        // - checks that there are more lines available after the current one
        // - if there are then the next line is returned
        // - if there are NOT then the last position on the given line is returned
        public TextLocation NextValidPosition(int line)
        {
            if (line < document.TotalNumberOfLines - 1)
                return new TextLocation(0, line + 1);
            else
                return new TextLocation(document.GetLineSegment(document.TotalNumberOfLines - 1).Length + 1, line);
        }

        void ClearWithoutUpdate()
        {
            while (selectionCollection.Count > 0)
            {
                ISelection selection = selectionCollection[selectionCollection.Count - 1];
                selectionCollection.RemoveAt(selectionCollection.Count - 1);
                document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.LinesBetween, selection.StartPosition.Y, selection.EndPosition.Y));
                OnSelectionChanged(EventArgs.Empty);
            }
        }
        /// <remarks>
        /// Clears the selection.
        /// </remarks>
        public void ClearSelection()
        {
            Point mousepos;
            mousepos = textArea.mousepos;
            // this is the most logical place to reset selection starting
            // positions because it is always called before a new selection
            selectFrom.first = selectFrom.where;
            TextLocation newSelectionStart = textArea.TextView.GetLogicalPosition(mousepos.X - textArea.TextView.DrawingPosition.X, mousepos.Y - textArea.TextView.DrawingPosition.Y);
            if (selectFrom.where == WhereFrom.Gutter)
            {
                newSelectionStart.X = 0;
                //              selectionStart.Y = -1;
            }
            if (newSelectionStart.Line >= document.TotalNumberOfLines)
            {
                newSelectionStart.Line = document.TotalNumberOfLines - 1;
                newSelectionStart.Column = document.GetLineSegment(document.TotalNumberOfLines - 1).Length;
            }
            this.SelectionStart = newSelectionStart;

            ClearWithoutUpdate();
            document.CommitUpdate();
        }

        /// <remarks>
        /// Removes the selected text from the buffer and clears
        /// the selection.
        /// </remarks>
        public void RemoveSelectedText()
        {
            if (SelectionIsReadonly)
            {
                ClearSelection();
                return;
            }
            List<int> lines = new List<int>();
            int offset = -1;
            bool oneLine = true;
            //          PriorityQueue queue = new PriorityQueue();
            foreach (ISelection s in selectionCollection)
            {
                //              ISelection s = ((ISelection)queue.Remove());
                if (oneLine)
                {
                    int lineBegin = s.StartPosition.Y;
                    if (lineBegin != s.EndPosition.Y)
                    {
                        oneLine = false;
                    }
                    else
                    {
                        lines.Add(lineBegin);
                    }
                }
                offset = s.Offset;
                document.Remove(s.Offset, s.Length);

                //              queue.Insert(-s.Offset, s);
            }
            ClearSelection();
            if (offset >= 0)
            {
                //OneCodeTODO:
                //              document.Caret.Offset = offset;
            }
            if (offset != -1)
            {
                if (oneLine)
                {
                    foreach (int i in lines)
                    {
                        document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.SingleLine, i));
                    }
                }
                else
                {
                    document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.WholeTextArea));
                }
                document.CommitUpdate();
            }
        }


        bool SelectionsOverlap(ISelection s1, ISelection s2)
        {
            return (s1.Offset <= s2.Offset && s2.Offset <= s1.Offset + s1.Length) ||
                (s1.Offset <= s2.Offset + s2.Length && s2.Offset + s2.Length <= s1.Offset + s1.Length) ||
                (s1.Offset >= s2.Offset && s1.Offset + s1.Length <= s2.Offset + s2.Length);
        }

        /// <remarks>
        /// Returns true if the given offset points to a section which is
        /// selected.
        /// </remarks>
        public bool IsSelected(int offset)
        {
            return GetSelectionAt(offset) != null;
        }

        /// <remarks>
        /// Returns a <see cref="ISelection"/> object giving the selection in which
        /// the offset points to.
        /// </remarks>
        /// <returns>
        /// <code>null</code> if the offset doesn't point to a selection
        /// </returns>
        public ISelection GetSelectionAt(int offset)
        {
            foreach (ISelection s in selectionCollection)
            {
                if (s.ContainsOffset(offset))
                {
                    return s;
                }
            }
            return null;
        }

        /// <remarks>
        /// Used internally, do not call.
        /// </remarks>
        internal void Insert(int offset, string text)
        {
            //          foreach (ISelection selection in SelectionCollection) {
            //              if (selection.Offset > offset) {
            //                  selection.Offset += text.Length;
            //              } else if (selection.Offset + selection.Length > offset) {
            //                  selection.Length += text.Length;
            //              }
            //          }
        }

        /// <remarks>
        /// Used internally, do not call.
        /// </remarks>
        internal void Remove(int offset, int length)
        {
            //          foreach (ISelection selection in selectionCollection) {
            //              if (selection.Offset > offset) {
            //                  selection.Offset -= length;
            //              } else if (selection.Offset + selection.Length > offset) {
            //                  selection.Length -= length;
            //              }
            //          }
        }

        /// <remarks>
        /// Used internally, do not call.
        /// </remarks>
        internal void Replace(int offset, int length, string text)
        {
            //          foreach (ISelection selection in selectionCollection) {
            //              if (selection.Offset > offset) {
            //                  selection.Offset = selection.Offset - length + text.Length;
            //              } else if (selection.Offset + selection.Length > offset) {
            //                  selection.Length = selection.Length - length + text.Length;
            //              }
            //          }
        }

        public ColumnRange GetSelectionAtLine(int lineNumber)
        {
            foreach (ISelection selection in selectionCollection)
            {
                int startLine = selection.StartPosition.Y;
                int endLine = selection.EndPosition.Y;
                if (startLine < lineNumber && lineNumber < endLine)
                {
                    return ColumnRange.WholeColumn;
                }

                if (startLine == lineNumber)
                {
                    LineSegment line = document.GetLineSegment(startLine);
                    int startColumn = selection.StartPosition.X;
                    int endColumn = endLine == lineNumber ? selection.EndPosition.X : line.Length + 1;
                    return new ColumnRange(startColumn, endColumn);
                }

                if (endLine == lineNumber)
                {
                    int endColumn = selection.EndPosition.X;
                    return new ColumnRange(0, endColumn);
                }
            }

            return ColumnRange.NoColumn;
        }

        public void FireSelectionChanged()
        {
            OnSelectionChanged(EventArgs.Empty);
        }
        protected virtual void OnSelectionChanged(EventArgs e)
        {
            if (SelectionChanged != null)
            {
                SelectionChanged(this, e);
            }
        }

        public event EventHandler SelectionChanged;
    }

    // selection initiated from...
    public class SelectFrom
    {
        public int where = WhereFrom.None; // last selection initiator
        public int first = WhereFrom.None; // first selection initiator

        public SelectFrom()
        {
        }
    }

    // selection initiated from type...
    public class WhereFrom
    {
        public const int None = 0;
        public const int Gutter = 1;
        public const int TArea = 2;
    }
}

#endif
// file ...\TextFileEdit\Document\TextBufferStrategy\GapTextBufferStrategy.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3463 $</version>
// </file>


namespace TextFileEdit.Document
{
	public class GapTextBufferStrategy : ITextBufferStrategy
	{
		#if DEBUG
		int creatorThread = System.Threading.Thread.CurrentThread.ManagedThreadId;
		
		void CheckThread()
		{
			if (System.Threading.Thread.CurrentThread.ManagedThreadId != creatorThread)
				throw new InvalidOperationException("GapTextBufferStategy is not thread-safe!");
		}
		#endif
		
		char[] buffer = new char[0];
		string cachedContent;
		
		int gapBeginOffset = 0;
		int gapEndOffset = 0;
		int gapLength = 0; // gapLength == gapEndOffset - gapBeginOffset
		
		const int minGapLength = 128;
		const int maxGapLength = 2048;
		
		public int Length {
			get {
				return buffer.Length - gapLength;
			}
		}
		
		public void SetContent(string text)
		{
			if (text == null) {
				text = String.Empty;
			}
			cachedContent = text;
			buffer = text.ToCharArray();
			gapBeginOffset = gapEndOffset = gapLength = 0;
		}
		
		public char GetCharAt(int offset)
		{
			#if DEBUG
			CheckThread();
			#endif
			
			if (offset < 0 || offset >= Length) {
				throw new ArgumentOutOfRangeException("offset", offset, "0 <= offset < " + Length.ToString());
			}
			
			return offset < gapBeginOffset ? buffer[offset] : buffer[offset + gapLength];
		}
		
		public string GetText(int offset, int length)
		{
			#if DEBUG
			CheckThread();
			#endif
			
			if (offset < 0 || offset > Length) {
				throw new ArgumentOutOfRangeException("offset", offset, "0 <= offset <= " + Length.ToString());
			}
			if (length < 0 || offset + length > Length) {
				throw new ArgumentOutOfRangeException("length", length, "0 <= length, offset(" + offset + ")+length <= " + Length.ToString());
			}
			if (offset == 0 && length == Length) {
				if (cachedContent != null)
					return cachedContent;
				else
					return cachedContent = GetTextInternal(offset, length);
			} else {
				return GetTextInternal(offset, length);
			}
		}
		
		string GetTextInternal(int offset, int length)
		{
			int end = offset + length;
			
			if (end < gapBeginOffset) {
				return new string(buffer, offset, length);
			}
			
			if (offset > gapBeginOffset) {
				return new string(buffer, offset + gapLength, length);
			}
			
			int block1Size = gapBeginOffset - offset;
			int block2Size = end - gapBeginOffset;
			
			StringBuilder buf = new StringBuilder(block1Size + block2Size);
			buf.Append(buffer, offset,       block1Size);
			buf.Append(buffer, gapEndOffset, block2Size);
			return buf.ToString();
		}
		
		public void Insert(int offset, string text)
		{
			Replace(offset, 0, text);
		}
		
		public void Remove(int offset, int length)
		{
			Replace(offset, length, String.Empty);
		}
		
		public void Replace(int offset, int length, string text)
		{
			if (text == null) {
				text = String.Empty;
			}
			
			#if DEBUG
			CheckThread();
			#endif
			
			if (offset < 0 || offset > Length) {
				throw new ArgumentOutOfRangeException("offset", offset, "0 <= offset <= " + Length.ToString());
			}
			if (length < 0 || offset + length > Length) {
				throw new ArgumentOutOfRangeException("length", length, "0 <= length, offset+length <= " + Length.ToString());
			}
			
			cachedContent = null;
			
			// Math.Max is used so that if we need to resize the array
			// the new array has enough space for all old chars
			PlaceGap(offset, text.Length - length);
			gapEndOffset += length; // delete removed text
			text.CopyTo(0, buffer, gapBeginOffset, text.Length);
			gapBeginOffset += text.Length;
			gapLength = gapEndOffset - gapBeginOffset;
			if (gapLength > maxGapLength) {
				MakeNewBuffer(gapBeginOffset, minGapLength);
			}
		}
		
		void PlaceGap(int newGapOffset, int minRequiredGapLength)
		{
			if (gapLength < minRequiredGapLength) {
				// enlarge gap
				MakeNewBuffer(newGapOffset, minRequiredGapLength);
			} else {
				while (newGapOffset < gapBeginOffset) {
					buffer[--gapEndOffset] = buffer[--gapBeginOffset];
				}
				while (newGapOffset > gapBeginOffset) {
					buffer[gapBeginOffset++] = buffer[gapEndOffset++];
				}
			}
		}
		
		void MakeNewBuffer(int newGapOffset, int newGapLength)
		{
			if (newGapLength < minGapLength) newGapLength = minGapLength;
			
			char[] newBuffer = new char[Length + newGapLength];
			if (newGapOffset < gapBeginOffset) {
				// gap is moving backwards
				
				// first part:
				Array.Copy(buffer, 0, newBuffer, 0, newGapOffset);
				// moving middle part:
				Array.Copy(buffer, newGapOffset, newBuffer, newGapOffset + newGapLength, gapBeginOffset - newGapOffset);
				// last part:
				Array.Copy(buffer, gapEndOffset, newBuffer, newBuffer.Length - (buffer.Length - gapEndOffset), buffer.Length - gapEndOffset);
			} else {
				// gap is moving forwards
				// first part:
				Array.Copy(buffer, 0, newBuffer, 0, gapBeginOffset);
				// moving middle part:
				Array.Copy(buffer, gapEndOffset, newBuffer, gapBeginOffset, newGapOffset - gapBeginOffset);
				// last part:
				int lastPartLength = newBuffer.Length - (newGapOffset + newGapLength);
				Array.Copy(buffer, buffer.Length - lastPartLength, newBuffer, newGapOffset + newGapLength, lastPartLength);
			}
			
			gapBeginOffset = newGapOffset;
			gapEndOffset = newGapOffset + newGapLength;
			gapLength = newGapLength;
			buffer = newBuffer;
		}
	}
}

#endif
// file ...\TextFileEdit\Document\TextBufferStrategy\ITextBufferStrategy.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1966 $</version>
// </file>

namespace TextFileEdit.Document
{
	/// <summary>
	/// Interface to describe a sequence of characters that can be edited. 	
	/// </summary>
	public interface ITextBufferStrategy
	{
		/// <value>
		/// The current length of the sequence of characters that can be edited.
		/// </value>
		int Length {
			get;
		}
		
		/// <summary>
		/// Inserts a string of characters into the sequence.
		/// </summary>
		/// <param name="offset">
		/// offset where to insert the string.
		/// </param>
		/// <param name="text">
		/// text to be inserted.
		/// </param>
		void Insert(int offset, string text);
		
		/// <summary>
		/// Removes some portion of the sequence.
		/// </summary>
		/// <param name="offset">
		/// offset of the remove.
		/// </param>
		/// <param name="length">
		/// number of characters to remove.
		/// </param>
		void Remove(int offset, int length);
		
		/// <summary>
		/// Replace some portion of the sequence.
		/// </summary>
		/// <param name="offset">
		/// offset.
		/// </param>
		/// <param name="length">
		/// number of characters to replace.
		/// </param>
		/// <param name="text">
		/// text to be replaced with.
		/// </param>
		void Replace(int offset, int length, string text);
		
		/// <summary>
		/// Fetches a string of characters contained in the sequence.
		/// </summary>
		/// <param name="offset">
		/// Offset into the sequence to fetch
		/// </param>
		/// <param name="length">
		/// number of characters to copy.
		/// </param>
		string GetText(int offset, int length);
		
		/// <summary>
		/// Returns a specific char of the sequence.
		/// </summary>
		/// <param name="offset">
		/// Offset of the char to get.
		/// </param>
		char GetCharAt(int offset);
		
		/// <summary>
		/// This method sets the stored content.
		/// </summary>
		/// <param name="text">
		/// The string that represents the character sequence.
		/// </param>
		void SetContent(string text);
	}
}

#endif
// file ...\TextFileEdit\Document\TextBufferStrategy\StringTextBufferStrategy.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2682 $</version>
// </file>


namespace TextFileEdit.Document
{
	/// <summary>
	/// Simple implementation of the ITextBuffer interface implemented using a
	/// string.
	/// Only for fall-back purposes.
	/// </summary>
	public class StringTextBufferStrategy : ITextBufferStrategy
	{
		string storedText = "";
		
		public int Length {
			get {
				return storedText.Length;
			}
		}
		
		public void Insert(int offset, string text)
		{
			if (text != null) {
				storedText = storedText.Insert(offset, text);
			}
		}
		
		public void Remove(int offset, int length)
		{
			storedText = storedText.Remove(offset, length);
		}
		
		public void Replace(int offset, int length, string text)
		{
			Remove(offset, length);
			Insert(offset, text);
		}
		
		public string GetText(int offset, int length)
		{
			if (length == 0) {
				return "";
			}
			if (offset == 0 && length >= storedText.Length) {
				return storedText;
			}
			return storedText.Substring(offset, Math.Min(length, storedText.Length - offset));
		}
		
		public char GetCharAt(int offset)
		{
			if (offset == Length) {
				return '\0';
			}
			return storedText[offset];
		}
		
		public void SetContent(string text)
		{
			storedText = text;
		}
		
		public StringTextBufferStrategy()
		{
		}
		
		public static ITextBufferStrategy CreateTextBufferFromFile(string fileName)
		{
			if (!File.Exists(fileName)) {
				throw new System.IO.FileNotFoundException(fileName);
			}
			StringTextBufferStrategy s = new StringTextBufferStrategy();
			s.SetContent(Util.FileReader.ReadFileContent(fileName, Encoding.Default));
			return s;
		}
	}
}

#endif
// file ...\TextFileEdit\Gui\AbstractMargin.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1965 $</version>
// </file>


namespace TextFileEdit
{
	public delegate void MarginMouseEventHandler(AbstractMargin sender, Point mousepos, System.Windows.Forms.MouseButtons mouseButtons);
	public delegate void MarginPaintEventHandler(AbstractMargin sender, Graphics g, Rectangle rect);
	
	/// <summary>
	/// This class views the line numbers and folding markers.
	/// </summary>
	public abstract class AbstractMargin
	{
		System.Windows.Forms.Cursor cursor = System.Windows.Forms.Cursors.Default;
		
		[CLSCompliant(false)]
		protected Rectangle drawingPosition = new Rectangle(0, 0, 0, 0);
		[CLSCompliant(false)]
		protected TextArea textArea;
		
		public Rectangle DrawingPosition {
			get {
				return drawingPosition;
			}
			set {
				drawingPosition = value;
			}
		}
		
		public TextArea TextArea {
			get {
				return textArea;
			}
		}
		
		public TextFileEdit.Document.IDocument Document {
			get {
				return textArea.Document;
			}
		}

        public TextFileEdit.Document.ITextEditorProperties TextEditorProperties
        {
			get {
				return textArea.Document.TextEditorProperties;
			}
		}
		
		public virtual System.Windows.Forms.Cursor Cursor {
			get {
				return cursor;
			}
			set {
				cursor = value;
			}
		}
		
		public virtual Size Size {
			get {
				return new Size(-1, -1);
			}
		}
		
		public virtual bool IsVisible {
			get {
				return true;
			}
		}
		
		protected AbstractMargin(TextArea textArea)
		{
			this.textArea = textArea;
		}
		
		public virtual void HandleMouseDown(Point mousepos, System.Windows.Forms.MouseButtons mouseButtons)
		{
			if (MouseDown != null) {
				MouseDown(this, mousepos, mouseButtons);
			}
		}
		public virtual void HandleMouseMove(Point mousepos, System.Windows.Forms.MouseButtons mouseButtons)
		{
			if (MouseMove != null) {
				MouseMove(this, mousepos, mouseButtons);
			}
		}
		public virtual void HandleMouseLeave(EventArgs e)
		{
			if (MouseLeave != null) {
				MouseLeave(this, e);
			}
		}
		
		public virtual void Paint(Graphics g, Rectangle rect)
		{
			if (Painted != null) {
				Painted(this, g, rect);
			}
		}
		
		public event MarginPaintEventHandler Painted;
		public event MarginMouseEventHandler MouseDown;
		public event MarginMouseEventHandler MouseMove;
		public event EventHandler            MouseLeave;
	}
}

#endif
// file ...\TextFileEdit\Gui\BracketHighlighter.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2659 $</version>
// </file>


namespace TextFileEdit
{
	public class Highlight
	{
		public TextLocation OpenBrace { get; set; }
		public TextLocation CloseBrace { get; set; }
		
		public Highlight(TextLocation openBrace, TextLocation closeBrace)
		{
			this.OpenBrace = openBrace;
			this.CloseBrace = closeBrace;
		}
	}
	
	public class BracketHighlightingSheme
	{
		char opentag;
		char closingtag;
		
		public char OpenTag {
			get {
				return opentag;
			}
			set {
				opentag = value;
			}
		}
		
		public char ClosingTag {
			get {
				return closingtag;
			}
			set {
				closingtag = value;
			}
		}
		
		public BracketHighlightingSheme(char opentag, char closingtag)
		{
			this.opentag    = opentag;
			this.closingtag = closingtag;
		}

        public Highlight GetHighlight(TextFileEdit.Document.IDocument document, int offset)
		{
			int searchOffset;
            if (document.TextEditorProperties.BracketMatchingStyle == TextFileEdit.Document.BracketMatchingStyle.After)
            {
				searchOffset = offset;
			} else {
				searchOffset = offset + 1;
			}
			char word = document.GetCharAt(Math.Max(0, Math.Min(document.TextLength - 1, searchOffset)));
			
			TextLocation endP = document.OffsetToPosition(searchOffset);
			if (word == opentag) {
				if (searchOffset < document.TextLength) {
                    int bracketOffset = TextFileEdit.Document.TextUtilities.SearchBracketForward(document, searchOffset + 1, opentag, closingtag);
					if (bracketOffset >= 0) {
						TextLocation p = document.OffsetToPosition(bracketOffset);
						return new Highlight(p, endP);
					}
				}
			} else if (word == closingtag) {
				if (searchOffset > 0) {
                    int bracketOffset = TextFileEdit.Document.TextUtilities.SearchBracketBackward(document, searchOffset - 1, opentag, closingtag);
					if (bracketOffset >= 0) {
						TextLocation p = document.OffsetToPosition(bracketOffset);
						return new Highlight(p, endP);
					}
				}
			}
			return null;
		}
	}
}

#endif
// file ...\TextFileEdit\Gui\BrushRegistry.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3673 $</version>
// </file>


namespace TextFileEdit
{
	/// <summary>
	/// Contains brushes/pens for the text editor to speed up drawing. Re-Creation of brushes and pens
	/// seems too costly.
	/// </summary>
	public class BrushRegistry
	{
		static Dictionary<Color, Brush> brushes = new Dictionary<Color, Brush>();
		static Dictionary<Color, Pen> pens = new Dictionary<Color, Pen>();
		static Dictionary<Color, Pen> dotPens = new Dictionary<Color, Pen>();
		
		public static Brush GetBrush(Color color)
		{
			lock (brushes) {
				Brush brush;
				if (!brushes.TryGetValue(color, out brush)) {
					brush = new SolidBrush(color);
					brushes.Add(color, brush);
				}
				return brush;
			}
		}
		
		public static Pen GetPen(Color color)
		{
			lock (pens) {
				Pen pen;
				if (!pens.TryGetValue(color, out pen)) {
					pen = new Pen(color);
					pens.Add(color, pen);
				}
				return pen;
			}
		}
		
		static readonly float[] dotPattern = { 1, 1, 1, 1 };
		
		public static Pen GetDotPen(Color color)
		{
			lock (dotPens) {
				Pen pen;
				if (!dotPens.TryGetValue(color, out pen)) {
					pen = new Pen(color);
					pen.DashPattern = dotPattern;
					dotPens.Add(color, pen);
				}
				return pen;
			}
		}
	}
}

#endif
// file ...\TextFileEdit\Gui\Caret.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3673 $</version>
// </file>


namespace TextFileEdit
{
    /// <summary>
    /// In this enumeration are all caret modes listed.
    /// </summary>
    public enum CaretMode {
        /// <summary>
        /// If the caret is in insert mode typed characters will be
        /// inserted at the caret position
        /// </summary>
        InsertMode,
        
        /// <summary>
        /// If the caret is in overwirte mode typed characters will
        /// overwrite the character at the caret position
        /// </summary>
        OverwriteMode
    }
    
    
    public class Caret : System.IDisposable
    {
        int       line          = 0;
        int       column        = 0;
        int       desiredXPos   = 0;
        CaretMode caretMode;
        
        static bool     caretCreated = false;
        bool     hidden       = true;
        TextArea textArea;
        Point    currentPos   = new Point(-1, -1);
        Ime      ime          = null;
        CaretImplementation caretImplementation;
        
        /// <value>
        /// The 'prefered' xPos in which the caret moves, when it is moved
        /// up/down. Measured in pixels, not in characters!
        /// </value>
        public int DesiredColumn {
            get {
                return desiredXPos;
            }
            set {
                desiredXPos = value;
            }
        }
        
        /// <value>
        /// The current caret mode.
        /// </value>
        public CaretMode CaretMode {
            get {
                return caretMode;
            }
            set {
                caretMode = value;
                OnCaretModeChanged(EventArgs.Empty);
            }
        }
        
        public int Line {
            get {
                return line;
            }
            set {
                line = value;
                ValidateCaretPos();
                UpdateCaretPosition();
                OnPositionChanged(EventArgs.Empty);
            }
        }
        
        public int Column {
            get {
                return column;
            }
            set {
                column = value;
                ValidateCaretPos();
                UpdateCaretPosition();
                OnPositionChanged(EventArgs.Empty);
            }
        }
        
        public TextLocation Position {
            get {
                return new TextLocation(column, line);
            }
            set {
                line   = value.Y;
                column = value.X;
                ValidateCaretPos();
                UpdateCaretPosition();
                OnPositionChanged(EventArgs.Empty);
            }
        }
        
        public int Offset {
            get {
                return textArea.Document.PositionToOffset(Position);
            }
        }
        
        public Caret(TextArea textArea)
        {
            this.textArea = textArea;
            textArea.GotFocus  += new EventHandler(GotFocus);
            textArea.LostFocus += new EventHandler(LostFocus);
            if (Environment.OSVersion.Platform == PlatformID.Unix)
                caretImplementation = new ManagedCaret(this);
            else
                caretImplementation = new Win32Caret(this);
        }
        
        public void Dispose()
        {
            textArea.GotFocus  -= new EventHandler(GotFocus);
            textArea.LostFocus -= new EventHandler(LostFocus);
            textArea = null;
            caretImplementation.Dispose();
        }
        
        public TextLocation ValidatePosition(TextLocation pos)
        {
            int line   = Math.Max(0, Math.Min(textArea.Document.TotalNumberOfLines - 1, pos.Y));
            int column = Math.Max(0, pos.X);
            
            if (column == int.MaxValue || !textArea.TextEditorProperties.AllowCaretBeyondEOL) {
                TextFileEdit.Document.LineSegment lineSegment = textArea.Document.GetLineSegment(line);
                column = Math.Min(column, lineSegment.Length);
            }
            return new TextLocation(column, line);
        }
        
        /// <remarks>
        /// If the caret position is outside the document text bounds
        /// it is set to the correct position by calling ValidateCaretPos.
        /// </remarks>
        public void ValidateCaretPos()
        {
            line = Math.Max(0, Math.Min(textArea.Document.TotalNumberOfLines - 1, line));
            column = Math.Max(0, column);
            
            if (column == int.MaxValue || !textArea.TextEditorProperties.AllowCaretBeyondEOL) {
                TextFileEdit.Document.LineSegment lineSegment = textArea.Document.GetLineSegment(line);
                column = Math.Min(column, lineSegment.Length);
            }
        }
        
        void CreateCaret()
        {
            while (!caretCreated) {
                switch (caretMode) {
                    case CaretMode.InsertMode:
                        caretCreated = caretImplementation.Create(2, textArea.TextView.FontHeight);
                        break;
                    case CaretMode.OverwriteMode:
                        caretCreated = caretImplementation.Create((int)textArea.TextView.SpaceWidth, textArea.TextView.FontHeight);
                        break;
                }
            }
            if (currentPos.X  < 0) {
                ValidateCaretPos();
                currentPos = ScreenPosition;
            }
            caretImplementation.SetPosition(currentPos.X, currentPos.Y);
            caretImplementation.Show();
        }
        
        public void RecreateCaret()
        {
            Log("RecreateCaret");
            DisposeCaret();
            if (!hidden) {
                CreateCaret();
            }
        }
        
        void DisposeCaret()
        {
            if (caretCreated) {
                caretCreated = false;
                caretImplementation.Hide();
                caretImplementation.Destroy();
            }
        }
        
        void GotFocus(object sender, EventArgs e)
        {
            Log("GotFocus, IsInUpdate=" + textArea.MotherTextEditorControl.IsInUpdate);
            hidden = false;
            if (!textArea.MotherTextEditorControl.IsInUpdate) {
                CreateCaret();
                UpdateCaretPosition();
            }
        }
        
        void LostFocus(object sender, EventArgs e)
        {
            Log("LostFocus");
            hidden = true;
            DisposeCaret();
        }
        
        public Point ScreenPosition {
            get {
                int xpos = textArea.TextView.GetDrawingXPos(this.line, this.column);
                return new Point(textArea.TextView.DrawingPosition.X + xpos,
                                 textArea.TextView.DrawingPosition.Y
                                 + (textArea.Document.GetVisibleLine(this.line)) * textArea.TextView.FontHeight
                                 - textArea.TextView.TextArea.VirtualTop.Y);
            }
        }
        int oldLine = -1;
        bool outstandingUpdate;
        
        internal void OnEndUpdate()
        {
            if (outstandingUpdate)
                UpdateCaretPosition();
        }

        void PaintCaretLine(Graphics g)
        {
            if (!textArea.Document.TextEditorProperties.CaretLine)
                return;

            TextFileEdit.Document.HighlightColor caretLineColor = textArea.Document.HighlightingStrategy.GetColorFor("CaretLine");

            g.DrawLine(BrushRegistry.GetDotPen(caretLineColor.Color),
                       currentPos.X,
                       0,
                       currentPos.X,
                       textArea.DisplayRectangle.Height);
        }

        public void UpdateCaretPosition()
        {
            Log("UpdateCaretPosition");
            
            if (textArea.TextEditorProperties.CaretLine) {
                textArea.Invalidate();
            } else {
                if (caretImplementation.RequireRedrawOnPositionChange) {
                    textArea.UpdateLine(oldLine);
                    if (line != oldLine)
                        textArea.UpdateLine(line);
                } else {
                    if (textArea.MotherTextAreaControl.TextEditorProperties.LineViewerStyle == TextFileEdit.Document.LineViewerStyle.FullRow && oldLine != line)
                    {
                        textArea.UpdateLine(oldLine);
                        textArea.UpdateLine(line);
                    }
                }
            }
            oldLine = line;
            
            
            if (hidden || textArea.MotherTextEditorControl.IsInUpdate) {
                outstandingUpdate = true;
                return;
            } else {
                outstandingUpdate = false;
            }
            ValidateCaretPos();
            int lineNr = this.line;
            int xpos = textArea.TextView.GetDrawingXPos(lineNr, this.column);
            //LineSegment lineSegment = textArea.Document.GetLineSegment(lineNr);
            Point pos = ScreenPosition;
            if (xpos >= 0) {
                CreateCaret();
                bool success = caretImplementation.SetPosition(pos.X, pos.Y);
                if (!success) {
                    caretImplementation.Destroy();
                    caretCreated = false;
                    UpdateCaretPosition();
                }
            } else {
                caretImplementation.Destroy();
            }
            
            // set the input method editor location
            if (ime == null) {
                ime = new Ime(textArea.Handle, textArea.Document.TextEditorProperties.Font);
            } else {
                ime.HWnd = textArea.Handle;
                ime.Font = textArea.Document.TextEditorProperties.Font;
            }
            ime.SetIMEWindowLocation(pos.X, pos.Y);
            
            currentPos = pos;
        }

        [Conditional("DEBUG")]
        static void Log(string text)
        {
            //Console.WriteLine(text);
        }
        
#region Caret implementation
        internal void PaintCaret(Graphics g)
        {
            caretImplementation.PaintCaret(g);
            PaintCaretLine(g);
        }
        
        abstract class CaretImplementation : IDisposable
        {
            public bool RequireRedrawOnPositionChange;
            
            public abstract bool Create(int width, int height);
            public abstract void Hide();
            public abstract void Show();
            public abstract bool SetPosition(int x, int y);
            public abstract void PaintCaret(Graphics g);
            public abstract void Destroy();
            
            public virtual void Dispose()
            {
                Destroy();
            }
        }
        
        class ManagedCaret : CaretImplementation
        {
            System.Windows.Forms.Timer timer = new System.Windows.Forms.Timer { Interval = 300 };
            bool visible;
            bool blink = true;
            int x, y, width, height;
            TextArea textArea;
            Caret parentCaret;
            
            public ManagedCaret(Caret caret)
            {
                base.RequireRedrawOnPositionChange = true;
                this.textArea = caret.textArea;
                this.parentCaret = caret;
                timer.Tick += CaretTimerTick;
            }
            
            void CaretTimerTick(object sender, EventArgs e)
            {
                blink = !blink;
                if (visible)
                    textArea.UpdateLine(parentCaret.Line);
            }
            
            public override bool Create(int width, int height)
            {
                this.visible = true;
                this.width = width - 2;
                this.height = height;
                timer.Enabled = true;
                return true;
            }
            public override void Hide()
            {
                visible = false;
            }
            public override void Show()
            {
                visible = true;
            }
            public override bool SetPosition(int x, int y)
            {
                this.x = x - 1;
                this.y = y;
                return true;
            }
            public override void PaintCaret(Graphics g)
            {
                if (visible && blink)
                    g.DrawRectangle(Pens.Gray, x, y, width, height);
            }
            public override void Destroy()
            {
                visible = false;
                timer.Enabled = false;
            }
            public override void Dispose()
            {
                base.Dispose();
                timer.Dispose();
            }
        }
        
        class Win32Caret : CaretImplementation
        {
            [DllImport("User32.dll")]
            static extern bool CreateCaret(IntPtr hWnd, int hBitmap, int nWidth, int nHeight);
            
            [DllImport("User32.dll")]
            static extern bool SetCaretPos(int x, int y);
            
            [DllImport("User32.dll")]
            static extern bool DestroyCaret();
            
            [DllImport("User32.dll")]
            static extern bool ShowCaret(IntPtr hWnd);
            
            [DllImport("User32.dll")]
            static extern bool HideCaret(IntPtr hWnd);
            
            TextArea textArea;
            
            public Win32Caret(Caret caret)
            {
                this.textArea = caret.textArea;
            }
            
            public override bool Create(int width, int height)
            {
                return CreateCaret(textArea.Handle, 0, width, height);
            }
            public override void Hide()
            {
                HideCaret(textArea.Handle);
            }
            public override void Show()
            {
                ShowCaret(textArea.Handle);
            }
            public override bool SetPosition(int x, int y)
            {
                return SetCaretPos(x, y);
            }
            public override void PaintCaret(Graphics g)
            {
            }
            public override void Destroy()
            {
                DestroyCaret();
            }
        }
#endregion
        
        bool firePositionChangedAfterUpdateEnd;
        
        void FirePositionChangedAfterUpdateEnd(object sender, EventArgs e)
        {
            OnPositionChanged(EventArgs.Empty);
        }
        
        protected virtual void OnPositionChanged(EventArgs e)
        {
            if (this.textArea.MotherTextEditorControl.IsInUpdate) {
                if (firePositionChangedAfterUpdateEnd == false) {
                    firePositionChangedAfterUpdateEnd = true;
                    this.textArea.Document.UpdateCommited += FirePositionChangedAfterUpdateEnd;
                }
                return;
            } else if (firePositionChangedAfterUpdateEnd) {
                this.textArea.Document.UpdateCommited -= FirePositionChangedAfterUpdateEnd;
                firePositionChangedAfterUpdateEnd = false;
            }

            List<TextFileEdit.Document.FoldMarker> foldings = textArea.Document.FoldingManager.GetFoldingsFromPosition(line, column);
            bool  shouldUpdate = false;
            foreach (TextFileEdit.Document.FoldMarker foldMarker in foldings) {
                shouldUpdate |= foldMarker.IsFolded;
                foldMarker.IsFolded = false;
            }
            
            if (shouldUpdate) {
                textArea.Document.FoldingManager.NotifyFoldingsChanged(EventArgs.Empty);
            }
            
            if (PositionChanged != null) {
                PositionChanged(this, e);
            }
            textArea.ScrollToCaret();
        }
        
        protected virtual void OnCaretModeChanged(EventArgs e)
        {
            if (CaretModeChanged != null) {
                CaretModeChanged(this, e);
            }
            caretImplementation.Hide();
            caretImplementation.Destroy();
            caretCreated = false;
            CreateCaret();
            caretImplementation.Show();
        }
        
        /// <remarks>
        /// Is called each time the caret is moved.
        /// </remarks>
        public event EventHandler PositionChanged;
        
        /// <remarks>
        /// Is called each time the CaretMode has changed.
        /// </remarks>
        public event EventHandler CaretModeChanged;
    }
}

#endif
// file ...\TextFileEdit\Gui\DrawableLine.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Daniel Grunwald" email="daniel@danielgrunwald.de"/>
//     <version>$Revision: 1965 $</version>
// </file>


namespace TextFileEdit
{
	/// <summary>
	/// A class that is able to draw a line on any control (outside the text editor)
	/// </summary>
	public class DrawableLine
	{
		static StringFormat sf = (StringFormat)System.Drawing.StringFormat.GenericTypographic.Clone();
		
		List<SimpleTextWord> words = new List<SimpleTextWord>();
		SizeF spaceSize;
		Font monospacedFont;
		Font boldMonospacedFont;
		
		private class SimpleTextWord {
            internal TextFileEdit.Document.TextWordType Type;
			internal string       Word;
			internal bool         Bold;
			internal Color        Color;

            public SimpleTextWord(TextFileEdit.Document.TextWordType Type, string Word, bool Bold, Color Color)
			{
				this.Type = Type;
				this.Word = Word;
				this.Bold = Bold;
				this.Color = Color;
			}

            internal readonly static SimpleTextWord Space = new SimpleTextWord(TextFileEdit.Document.TextWordType.Space, " ", false, Color.Black);
            internal readonly static SimpleTextWord Tab = new SimpleTextWord(TextFileEdit.Document.TextWordType.Tab, "\t", false, Color.Black);
            internal readonly static SimpleTextWord Null = new SimpleTextWord(TextFileEdit.Document.TextWordType.Null, "\x0000", true, Color.Green);
        }

        public DrawableLine(TextFileEdit.Document.IDocument document, TextFileEdit.Document.LineSegment line, Font monospacedFont, Font boldMonospacedFont)
		{
			this.monospacedFont = monospacedFont;
			this.boldMonospacedFont = boldMonospacedFont;
			if (line.Words != null) {
				foreach (TextFileEdit.Document.TextWord word in line.Words) {
                    if (word.Type == TextFileEdit.Document.TextWordType.Space)
                    {
						words.Add(SimpleTextWord.Space);
                    }
                    else if (word.Type == TextFileEdit.Document.TextWordType.Tab)
                    {
						words.Add(SimpleTextWord.Tab);
                    }
                    else if (word.Type == TextFileEdit.Document.TextWordType.Null)
                    {
                        words.Add(SimpleTextWord.Null);
                    }
                    else
                    {
                        words.Add(new SimpleTextWord(TextFileEdit.Document.TextWordType.Word, word.Word, word.Bold, word.Color));
                    }
				}
			} else {
                words.Add(new SimpleTextWord(TextFileEdit.Document.TextWordType.Word, document.GetText(line), false, Color.Black));
			}
		}
		
		public int LineLength {
			get {
				int length = 0;
				foreach (SimpleTextWord word in words) {
					length += word.Word.Length;
				}
				return length;
			}
		}
		
		public void SetBold(int startIndex, int endIndex, bool bold)
		{
			if (startIndex < 0)
				throw new ArgumentException("startIndex must be >= 0");
			if (startIndex > endIndex)
				throw new ArgumentException("startIndex must be <= endIndex");
			if (startIndex == endIndex) return;
			int pos = 0;
			for (int i = 0; i < words.Count; i++) {
				SimpleTextWord word = words[i];
				if (pos >= endIndex)
					break;
				int wordEnd = pos + word.Word.Length;
				// 3 possibilities:
				if (startIndex <= pos && endIndex >= wordEnd) {
					// word is fully in region:
					word.Bold = bold;
				} else if (startIndex <= pos) {
					// beginning of word is in region
					int inRegionLength = endIndex - pos;
					SimpleTextWord newWord = new SimpleTextWord(word.Type, word.Word.Substring(inRegionLength), word.Bold, word.Color);
					words.Insert(i + 1, newWord);
					
					word.Bold = bold;
					word.Word = word.Word.Substring(0, inRegionLength);
				} else if (startIndex < wordEnd) {
					// end of word is in region (or middle of word is in region)
					int notInRegionLength = startIndex - pos;
					
					SimpleTextWord newWord = new SimpleTextWord(word.Type, word.Word.Substring(notInRegionLength), word.Bold, word.Color);
					// newWord.Bold will be set in the next iteration
					words.Insert(i + 1, newWord);
					
					word.Word = word.Word.Substring(0, notInRegionLength);
				}
				pos = wordEnd;
			}
		}
		
		public static float DrawDocumentWord(Graphics g, string word, PointF position, Font font, Color foreColor)
		{
			if (word == null || word.Length == 0) {
				return 0f;
			}
			SizeF wordSize = g.MeasureString(word, font, 32768, sf);
			
			g.DrawString(word,
			             font,
			             BrushRegistry.GetBrush(foreColor),
			             position,
			             sf);
			return wordSize.Width;
		}
		
		public SizeF GetSpaceSize(Graphics g)
		{
			if (spaceSize.IsEmpty) {
				spaceSize = g.MeasureString("-", boldMonospacedFont,  new PointF(0, 0), sf);
			}
			return spaceSize;
		}
		
		public void DrawLine(Graphics g, ref float xPos, float xOffset, float yPos, Color c)
		{
			SizeF spaceSize = GetSpaceSize(g);
			foreach (SimpleTextWord word in words) {
				switch (word.Type) {
                    case TextFileEdit.Document.TextWordType.Space:
						xPos += spaceSize.Width;
						break;
                    case TextFileEdit.Document.TextWordType.Tab:
						float tabWidth = spaceSize.Width * 4;
						xPos += tabWidth;
						xPos = (int)((xPos + 2) / tabWidth) * tabWidth;
						break;
                    case TextFileEdit.Document.TextWordType.Null:
                        xPos += spaceSize.Width * 3;
                        break;
                    case TextFileEdit.Document.TextWordType.Word:
						xPos += DrawDocumentWord(g,
						                         word.Word,
						                         new PointF(xPos + xOffset, yPos),
						                         word.Bold ? boldMonospacedFont : monospacedFont,
						                         c == Color.Empty ? word.Color : c
						                        );
						break;
				}
			}
		}
		
		public void DrawLine(Graphics g, ref float xPos, float xOffset, float yPos)
		{
			DrawLine(g, ref xPos, xOffset, yPos, Color.Empty);
		}
		
		public float MeasureWidth(Graphics g, float xPos)
		{
			SizeF spaceSize = GetSpaceSize(g);
			foreach (SimpleTextWord word in words) {
				switch (word.Type) {
                    case TextFileEdit.Document.TextWordType.Space:
						xPos += spaceSize.Width;
						break;
                    case TextFileEdit.Document.TextWordType.Tab:
						float tabWidth = spaceSize.Width * 4;
						xPos += tabWidth;
						xPos = (int)((xPos + 2) / tabWidth) * tabWidth;
						break;
                    case TextFileEdit.Document.TextWordType.Null:
                        xPos += spaceSize.Width * 3;
                        break;
                    case TextFileEdit.Document.TextWordType.Word:
						if (word.Word != null && word.Word.Length > 0) {
							xPos += g.MeasureString(word.Word, word.Bold ? boldMonospacedFont : monospacedFont, 32768, sf).Width;
						}
						break;
				}
			}
			return xPos;
		}
	}
}

#endif
// file ...\TextFileEdit\Gui\FoldMargin.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3673 $</version>
// </file>


namespace TextFileEdit
{
    /// <summary>
    /// This class views the line numbers and folding markers.
    /// </summary>
    public class FoldMargin : AbstractMargin
    {
        int selectedFoldLine = -1;
        
        public override Size Size {
            get {
                return new Size((int)(textArea.TextView.FontHeight),
                                -1);
            }
        }
        
        public override bool IsVisible {
            get {
                return textArea.TextEditorProperties.EnableFolding;
            }
        }
        
        public FoldMargin(TextArea textArea) : base(textArea)
        {
        }
        
        public override void Paint(Graphics g, Rectangle rect)
        {
            if (rect.Width <= 0 || rect.Height <= 0) {
                return;
            }
            TextFileEdit.Document.HighlightColor lineNumberPainterColor = textArea.Document.HighlightingStrategy.GetColorFor("LineNumbers");
            
            
            for (int y = 0; y < (DrawingPosition.Height + textArea.TextView.VisibleLineDrawingRemainder) / textArea.TextView.FontHeight + 1; ++y) {
                Rectangle markerRectangle = new Rectangle(DrawingPosition.X,
                                                          DrawingPosition.Top + y * textArea.TextView.FontHeight - textArea.TextView.VisibleLineDrawingRemainder,
                                                          DrawingPosition.Width,
                                                          textArea.TextView.FontHeight);
                
                if (rect.IntersectsWith(markerRectangle)) {
                    // draw dotted separator line
                    if (textArea.Document.TextEditorProperties.ShowLineNumbers) {
                        g.FillRectangle(BrushRegistry.GetBrush(textArea.Enabled ? lineNumberPainterColor.BackgroundColor : SystemColors.InactiveBorder),
                                        markerRectangle);
                        
                        g.DrawLine(BrushRegistry.GetDotPen(lineNumberPainterColor.Color),
                                   base.drawingPosition.X,
                                   markerRectangle.Y,
                                   base.drawingPosition.X,
                                   markerRectangle.Bottom);
                    } else {
                        g.FillRectangle(BrushRegistry.GetBrush(textArea.Enabled ? lineNumberPainterColor.BackgroundColor : SystemColors.InactiveBorder), markerRectangle);
                    }
                    
                    int currentLine = textArea.Document.GetFirstLogicalLine(textArea.TextView.FirstPhysicalLine + y);
                    if (currentLine < textArea.Document.TotalNumberOfLines) {
                        PaintFoldMarker(g, currentLine, markerRectangle);
                    }
                }
            }
        }

        bool SelectedFoldingFrom(List<TextFileEdit.Document.FoldMarker> list)
        {
            if (list != null) {
                for (int i = 0; i < list.Count; ++i) {
                    if (this.selectedFoldLine == list[i].StartLine) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        void PaintFoldMarker(Graphics g, int lineNumber, Rectangle drawingRectangle)
        {
            TextFileEdit.Document.HighlightColor foldLineColor = textArea.Document.HighlightingStrategy.GetColorFor("FoldLine");
            TextFileEdit.Document.HighlightColor selectedFoldLine = textArea.Document.HighlightingStrategy.GetColorFor("SelectedFoldLine");

            List<TextFileEdit.Document.FoldMarker> foldingsWithStart = textArea.Document.FoldingManager.GetFoldingsWithStart(lineNumber);
            List<TextFileEdit.Document.FoldMarker> foldingsBetween = textArea.Document.FoldingManager.GetFoldingsContainsLineNumber(lineNumber);
            List<TextFileEdit.Document.FoldMarker> foldingsWithEnd = textArea.Document.FoldingManager.GetFoldingsWithEnd(lineNumber);
            
            bool isFoldStart = foldingsWithStart.Count > 0;
            bool isBetween   = foldingsBetween.Count > 0;
            bool isFoldEnd   = foldingsWithEnd.Count > 0;
            
            bool isStartSelected   = SelectedFoldingFrom(foldingsWithStart);
            bool isBetweenSelected = SelectedFoldingFrom(foldingsBetween);
            bool isEndSelected     = SelectedFoldingFrom(foldingsWithEnd);
            
            int foldMarkerSize = (int)Math.Round(textArea.TextView.FontHeight * 0.57f);
            foldMarkerSize -= (foldMarkerSize) % 2;
            int foldMarkerYPos = drawingRectangle.Y + (int)((drawingRectangle.Height - foldMarkerSize) / 2);
            int xPos = drawingRectangle.X + (drawingRectangle.Width - foldMarkerSize) / 2 + foldMarkerSize / 2;
            
            
            if (isFoldStart) {
                bool isVisible         = true;
                bool moreLinedOpenFold = false;
                foreach (TextFileEdit.Document.FoldMarker foldMarker in foldingsWithStart)
                {
                    if (foldMarker.IsFolded) {
                        isVisible = false;
                    } else {
                        moreLinedOpenFold = foldMarker.EndLine > foldMarker.StartLine;
                    }
                }
                
                bool isFoldEndFromUpperFold = false;
                foreach (TextFileEdit.Document.FoldMarker foldMarker in foldingsWithEnd)
                {
                    if (foldMarker.EndLine > foldMarker.StartLine && !foldMarker.IsFolded) {
                        isFoldEndFromUpperFold = true;
                    }
                }
                
                DrawFoldMarker(g, new RectangleF(drawingRectangle.X + (drawingRectangle.Width - foldMarkerSize) / 2,
                                                 foldMarkerYPos,
                                                 foldMarkerSize,
                                                 foldMarkerSize),
                               isVisible,
                               isStartSelected
                              );
                
                // draw line above fold marker
                if (isBetween || isFoldEndFromUpperFold) {
                    g.DrawLine(BrushRegistry.GetPen(isBetweenSelected ? selectedFoldLine.Color : foldLineColor.Color),
                               xPos,
                               drawingRectangle.Top,
                               xPos,
                               foldMarkerYPos - 1);
                }
                
                // draw line below fold marker
                if (isBetween || moreLinedOpenFold) {
                    g.DrawLine(BrushRegistry.GetPen(isEndSelected || (isStartSelected && isVisible) || isBetweenSelected ? selectedFoldLine.Color : foldLineColor.Color),
                               xPos,
                               foldMarkerYPos + foldMarkerSize + 1,
                               xPos,
                               drawingRectangle.Bottom);
                }
            } else {
                if (isFoldEnd) {
                    int midy = drawingRectangle.Top + drawingRectangle.Height / 2;
                    
                    // draw fold end marker
                    g.DrawLine(BrushRegistry.GetPen(isEndSelected ? selectedFoldLine.Color : foldLineColor.Color),
                               xPos,
                               midy,
                               xPos + foldMarkerSize / 2,
                               midy);
                    
                    // draw line above fold end marker
                    // must be drawn after fold marker because it might have a different color than the fold marker
                    g.DrawLine(BrushRegistry.GetPen(isBetweenSelected || isEndSelected ? selectedFoldLine.Color : foldLineColor.Color),
                               xPos,
                               drawingRectangle.Top,
                               xPos,
                               midy);
                    
                    // draw line below fold end marker
                    if (isBetween) {
                        g.DrawLine(BrushRegistry.GetPen(isBetweenSelected ? selectedFoldLine.Color : foldLineColor.Color),
                                   xPos,
                                   midy + 1,
                                   xPos,
                                   drawingRectangle.Bottom);
                    }
                } else if (isBetween) {
                    // just draw the line :)
                    g.DrawLine(BrushRegistry.GetPen(isBetweenSelected ? selectedFoldLine.Color : foldLineColor.Color),
                               xPos,
                               drawingRectangle.Top,
                               xPos,
                               drawingRectangle.Bottom);
                }
            }
        }
        
        public override void HandleMouseMove(Point mousepos, MouseButtons mouseButtons)
        {
            bool  showFolding  = textArea.Document.TextEditorProperties.EnableFolding;
            int   physicalLine = + (int)((mousepos.Y + textArea.VirtualTop.Y) / textArea.TextView.FontHeight);
            int   realline     = textArea.Document.GetFirstLogicalLine(physicalLine);
            
            if (!showFolding || realline < 0 || realline + 1 >= textArea.Document.TotalNumberOfLines) {
                return;
            }
            
            List<TextFileEdit.Document.FoldMarker> foldMarkers = textArea.Document.FoldingManager.GetFoldingsWithStart(realline);
            int oldSelection = selectedFoldLine;
            if (foldMarkers.Count > 0) {
                selectedFoldLine = realline;
            } else {
                selectedFoldLine = -1;
            }
            if (oldSelection != selectedFoldLine) {
                textArea.Refresh(this);
            }
        }
        
        public override void HandleMouseDown(Point mousepos, MouseButtons mouseButtons)
        {
            bool  showFolding  = textArea.Document.TextEditorProperties.EnableFolding;
            int   physicalLine = + (int)((mousepos.Y + textArea.VirtualTop.Y) / textArea.TextView.FontHeight);
            int   realline     = textArea.Document.GetFirstLogicalLine(physicalLine);
            
            // focus the textarea if the user clicks on the line number view
            textArea.Focus();
            
            if (!showFolding || realline < 0 || realline + 1 >= textArea.Document.TotalNumberOfLines) {
                return;
            }
            
            List<TextFileEdit.Document.FoldMarker> foldMarkers = textArea.Document.FoldingManager.GetFoldingsWithStart(realline);
            foreach (TextFileEdit.Document.FoldMarker fm in foldMarkers)
            {
                fm.IsFolded = !fm.IsFolded;
            }
            textArea.Document.FoldingManager.NotifyFoldingsChanged(EventArgs.Empty);
        }
        
        public override void HandleMouseLeave(EventArgs e)
        {
            if (selectedFoldLine != -1) {
                selectedFoldLine = -1;
                textArea.Refresh(this);
            }
        }
        
#region Drawing functions
        void DrawFoldMarker(Graphics g, RectangleF rectangle, bool isOpened, bool isSelected)
        {
            TextFileEdit.Document.HighlightColor foldMarkerColor = textArea.Document.HighlightingStrategy.GetColorFor("FoldMarker");
            TextFileEdit.Document.HighlightColor foldLineColor = textArea.Document.HighlightingStrategy.GetColorFor("FoldLine");
            TextFileEdit.Document.HighlightColor selectedFoldLine = textArea.Document.HighlightingStrategy.GetColorFor("SelectedFoldLine");
            
            Rectangle intRect = new Rectangle((int)rectangle.X, (int)rectangle.Y, (int)rectangle.Width, (int)rectangle.Height);
            g.FillRectangle(BrushRegistry.GetBrush(foldMarkerColor.BackgroundColor), intRect);
            g.DrawRectangle(BrushRegistry.GetPen(isSelected ? selectedFoldLine.Color : foldLineColor.Color), intRect);
            
            int space  = (int)Math.Round(((double)rectangle.Height) / 8d) + 1;
            int mid    = intRect.Height / 2 + intRect.Height % 2;
            
            // draw minus
            g.DrawLine(BrushRegistry.GetPen(foldMarkerColor.Color),
                       rectangle.X + space,
                       rectangle.Y + mid,
                       rectangle.X + rectangle.Width - space,
                       rectangle.Y + mid);
            
            // draw plus
            if (!isOpened) {
                g.DrawLine(BrushRegistry.GetPen(foldMarkerColor.Color),
                           rectangle.X + mid,
                           rectangle.Y + space,
                           rectangle.X + mid,
                           rectangle.Y + rectangle.Height - space);
            }
        }
#endregion
    }
}

#endif
// file ...\TextFileEdit\Gui\GutterMargin.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3050 $</version>
// </file>


namespace TextFileEdit
{
	/// <summary>
	/// This class views the line numbers and folding markers.
	/// </summary>
	public class GutterMargin : AbstractMargin, IDisposable
	{
		StringFormat numberStringFormat = (StringFormat)StringFormat.GenericTypographic.Clone();

        public static System.Windows.Forms.Cursor RightLeftCursor;
		
		static GutterMargin()
		{
            //Stream cursorStream = Assembly.GetCallingAssembly().GetManifestResourceStream("TextFileEdit.Resources.RightArrow.cur");
            //if (cursorStream == null) throw new Exception("could not find cursor resource");
            //RightLeftCursor = new Cursor(cursorStream);
            //cursorStream.Close();
		}
		
		public void Dispose()
		{
			numberStringFormat.Dispose();
		}
		
		public override System.Windows.Forms.Cursor Cursor {
			get {
				return RightLeftCursor;
			}
		}
		
		public override Size Size {
			get {
				return new Size((int)(textArea.TextView.WideSpaceWidth
				                      * Math.Max(3, (int)Math.Log10(textArea.Document.TotalNumberOfLines) + 1)),
				                -1);
			}
		}
		
		public override bool IsVisible {
			get {
				return textArea.TextEditorProperties.ShowLineNumbers;
			}
		}
		
		public GutterMargin(TextArea textArea) : base(textArea)
		{
			numberStringFormat.LineAlignment = StringAlignment.Far;
			numberStringFormat.FormatFlags   = StringFormatFlags.MeasureTrailingSpaces | StringFormatFlags.FitBlackBox |
				StringFormatFlags.NoWrap | StringFormatFlags.NoClip;
		}
		
		public override void Paint(Graphics g, Rectangle rect)
		{
			if (rect.Width <= 0 || rect.Height <= 0) {
				return;
			}
			TextFileEdit.Document.HighlightColor lineNumberPainterColor = textArea.Document.HighlightingStrategy.GetColorFor("LineNumbers");
			int fontHeight = textArea.TextView.FontHeight;
			Brush fillBrush = textArea.Enabled ? BrushRegistry.GetBrush(lineNumberPainterColor.BackgroundColor) : SystemBrushes.InactiveBorder;
			Brush drawBrush = BrushRegistry.GetBrush(lineNumberPainterColor.Color);
			for (int y = 0; y < (DrawingPosition.Height + textArea.TextView.VisibleLineDrawingRemainder) / fontHeight + 1; ++y) {
				int ypos = drawingPosition.Y + fontHeight * y  - textArea.TextView.VisibleLineDrawingRemainder;
				Rectangle backgroundRectangle = new Rectangle(drawingPosition.X, ypos, drawingPosition.Width, fontHeight);
				if (rect.IntersectsWith(backgroundRectangle)) {
					g.FillRectangle(fillBrush, backgroundRectangle);
					int curLine = textArea.Document.GetFirstLogicalLine(textArea.Document.GetVisibleLine(textArea.TextView.FirstVisibleLine) + y);
					
					if (curLine < textArea.Document.TotalNumberOfLines) {
						g.DrawString((curLine + 1).ToString(),
						             lineNumberPainterColor.GetFont(TextEditorProperties.FontContainer),
						             drawBrush,
						             backgroundRectangle,
						             numberStringFormat);
					}
				}
			}
		}

        public override void HandleMouseDown(Point mousepos, System.Windows.Forms.MouseButtons mouseButtons)
		{
			TextLocation selectionStartPos;

            textArea.SelectionManager.selectFrom.where = TextFileEdit.Document.WhereFrom.Gutter;
			int realline = textArea.TextView.GetLogicalLine(mousepos.Y);
			if (realline >= 0 && realline < textArea.Document.TotalNumberOfLines) {
				// shift-select
                if ((System.Windows.Forms.Control.ModifierKeys & System.Windows.Forms.Keys.Shift) != 0)
                {
					if(!textArea.SelectionManager.HasSomethingSelected && realline != textArea.Caret.Position.Y) {
						if (realline >= textArea.Caret.Position.Y)
						{ // at or below starting selection, place the cursor on the next line
							// nothing is selected so make a new selection from cursor
							selectionStartPos = textArea.Caret.Position;
							// whole line selection - start of line to start of next line
							if (realline < textArea.Document.TotalNumberOfLines - 1)
							{
								textArea.SelectionManager.SetSelection(new TextFileEdit.Document.DefaultSelection(textArea.Document, selectionStartPos, new TextLocation(0, realline + 1)));
								textArea.Caret.Position = new TextLocation(0, realline + 1);
							}
							else
							{
								textArea.SelectionManager.SetSelection(new TextFileEdit.Document.DefaultSelection(textArea.Document, selectionStartPos, new TextLocation(textArea.Document.GetLineSegment(realline).Length + 1, realline)));
								textArea.Caret.Position = new TextLocation(textArea.Document.GetLineSegment(realline).Length + 1, realline);
							}
						}
						else
						{ // prior lines to starting selection, place the cursor on the same line as the new selection
							// nothing is selected so make a new selection from cursor
							selectionStartPos = textArea.Caret.Position;
							// whole line selection - start of line to start of next line
							textArea.SelectionManager.SetSelection(new TextFileEdit.Document.DefaultSelection(textArea.Document, selectionStartPos, new TextLocation(selectionStartPos.X, selectionStartPos.Y)));
							textArea.SelectionManager.ExtendSelection(new TextLocation(selectionStartPos.X, selectionStartPos.Y), new TextLocation(0, realline));
							textArea.Caret.Position = new TextLocation(0, realline);
						}
					}
					else
					{
						// let MouseMove handle a shift-click in a gutter
                        System.Windows.Forms.MouseEventArgs e = new System.Windows.Forms.MouseEventArgs(mouseButtons, 1, mousepos.X, mousepos.Y, 0);
						textArea.RaiseMouseMove(e);
					}
				} else { // this is a new selection with no shift-key
					// sync the textareamousehandler mouse location
					// (fixes problem with clicking out into a menu then back to the gutter whilst
					// there is a selection)
					textArea.mousepos = mousepos;

					selectionStartPos = new TextLocation(0, realline);
					textArea.SelectionManager.ClearSelection();
					// whole line selection - start of line to start of next line
					if (realline < textArea.Document.TotalNumberOfLines - 1)
					{
						textArea.SelectionManager.SetSelection(new TextFileEdit.Document.DefaultSelection(textArea.Document, selectionStartPos, new TextLocation(selectionStartPos.X, selectionStartPos.Y + 1)));
						textArea.Caret.Position = new TextLocation(selectionStartPos.X, selectionStartPos.Y + 1);
					}
					else
					{
						textArea.SelectionManager.SetSelection(new TextFileEdit.Document.DefaultSelection(textArea.Document, new TextLocation(0, realline), new TextLocation(textArea.Document.GetLineSegment(realline).Length + 1, selectionStartPos.Y)));
						textArea.Caret.Position = new TextLocation(textArea.Document.GetLineSegment(realline).Length + 1, selectionStartPos.Y);
					}
				}
			}
		}
	}
}

#endif
// file ...\TextFileEdit\Gui\HRuler.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1925 $</version>
// </file>


namespace TextFileEdit
{
    /// <summary>
    /// Horizontal ruler - text column measuring ruler at the top of the text area.
    /// </summary>
    public class HRuler : Control
    {
        TextArea textArea;
        
        public HRuler(TextArea textArea)
        {
            this.textArea = textArea;
        }
        
        protected override void OnPaint(System.Windows.Forms.PaintEventArgs e)
        {
            Graphics g = e.Graphics;
            int num = 0;
            for (float x = textArea.TextView.DrawingPosition.Left; x < textArea.TextView.DrawingPosition.Right; x += textArea.TextView.WideSpaceWidth) {
                int offset = (Height * 2) / 3;
                if (num % 5 == 0) {
                    offset = (Height * 4) / 5;
                }
                
                if (num % 10 == 0) {
                    offset = 1;
                }
                ++num;
                g.DrawLine(Pens.Black,
                           (int)x, offset, (int)x, Height - offset);
            }
        }
        
        protected override void OnPaintBackground(System.Windows.Forms.PaintEventArgs e)
        {
            e.Graphics.FillRectangle(Brushes.White,
                                     new Rectangle(0,
                                                   0,
                                                   Width,
                                                   Height));
        }
    }
}

#endif
// file ...\TextFileEdit\Gui\IconBarMargin.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3176 $</version>
// </file>


namespace TextFileEdit
{
    /// <summary>
    /// This class views the line numbers and folding markers.
    /// </summary>
    public class IconBarMargin : AbstractMargin
    {
        const int iconBarWidth = 18;
        
        static readonly Size iconBarSize = new Size(iconBarWidth, -1);
        
        public override Size Size {
            get {
                return iconBarSize;
            }
        }
        
        public override bool IsVisible {
            get {
                return textArea.TextEditorProperties.IsIconBarVisible;
            }
        }
        
        
        public IconBarMargin(TextArea textArea) : base(textArea)
        {
        }
        
        public override void Paint(Graphics g, Rectangle rect)
        {
            if (rect.Width <= 0 || rect.Height <= 0) {
                return;
            }
            // paint background
            g.FillRectangle(SystemBrushes.Control, new Rectangle(drawingPosition.X, rect.Top, drawingPosition.Width - 1, rect.Height));
            g.DrawLine(SystemPens.ControlDark, base.drawingPosition.Right - 1, rect.Top, base.drawingPosition.Right - 1, rect.Bottom);
            
            // paint icons
            foreach (TextFileEdit.Document.Bookmark mark in textArea.Document.BookmarkManager.Marks) {
                int lineNumber = textArea.Document.GetVisibleLine(mark.LineNumber);
                int lineHeight = textArea.TextView.FontHeight;
                int yPos = (int)(lineNumber * lineHeight) - textArea.VirtualTop.Y;
                if (IsLineInsideRegion(yPos, yPos + lineHeight, rect.Y, rect.Bottom)) {
                    if (lineNumber == textArea.Document.GetVisibleLine(mark.LineNumber - 1)) {
                        // marker is inside folded region, do not draw it
                        continue;
                    }
                    mark.Draw(this, g, new Point(0, yPos));
                }
            }
            base.Paint(g, rect);
        }
        
        public override void HandleMouseDown(Point mousePos, MouseButtons mouseButtons)
        {
            int clickedVisibleLine = (mousePos.Y + textArea.VirtualTop.Y) / textArea.TextView.FontHeight;
            int lineNumber = textArea.Document.GetFirstLogicalLine(clickedVisibleLine);
            
            if ((mouseButtons & MouseButtons.Right) == MouseButtons.Right) {
                if (textArea.Caret.Line != lineNumber) {
                    textArea.Caret.Line = lineNumber;
                }
            }
            
            IList<TextFileEdit.Document.Bookmark> marks = textArea.Document.BookmarkManager.Marks;
            List<TextFileEdit.Document.Bookmark> marksInLine = new List<TextFileEdit.Document.Bookmark>();
            int oldCount = marks.Count;
            foreach (TextFileEdit.Document.Bookmark mark in marks) {
                if (mark.LineNumber == lineNumber) {
                    marksInLine.Add(mark);
                }
            }
            for (int i = marksInLine.Count - 1; i >= 0; i--) {
                TextFileEdit.Document.Bookmark mark = marksInLine[i];
                if (mark.Click(textArea, new MouseEventArgs(mouseButtons, 1, mousePos.X, mousePos.Y, 0))) {
                    if (oldCount != marks.Count) {
                        textArea.UpdateLine(lineNumber);
                    }
                    return;
                }
            }
            base.HandleMouseDown(mousePos, mouseButtons);
        }
        
#region Drawing functions
        public void DrawBreakpoint(Graphics g, int y, bool isEnabled, bool isHealthy)
        {
            int diameter = Math.Min(iconBarWidth - 2, textArea.TextView.FontHeight);
            Rectangle rect = new Rectangle(1,
                                           y + (textArea.TextView.FontHeight - diameter) / 2,
                                           diameter,
                                           diameter);
            
            
            using (GraphicsPath path = new GraphicsPath()) {
                path.AddEllipse(rect);
                using (PathGradientBrush pthGrBrush = new PathGradientBrush(path)) {
                    pthGrBrush.CenterPoint = new PointF(rect.Left + rect.Width / 3 , rect.Top + rect.Height / 3);
                    pthGrBrush.CenterColor = Color.MistyRose;
                    Color[] colors = {isHealthy ? Color.Firebrick : Color.Olive};
                    pthGrBrush.SurroundColors = colors;
                    
                    if (isEnabled) {
                        g.FillEllipse(pthGrBrush, rect);
                    } else {
                        g.FillEllipse(SystemBrushes.Control, rect);
                        using (Pen pen = new Pen(pthGrBrush)) {
                            g.DrawEllipse(pen, new Rectangle(rect.X + 1, rect.Y + 1, rect.Width - 2, rect.Height - 2));
                        }
                    }
                }
            }
        }
        
        public void DrawBookmark(Graphics g, int y, bool isEnabled)
        {
            int delta = textArea.TextView.FontHeight / 8;
            Rectangle rect = new Rectangle(1, y + delta, base.drawingPosition.Width - 4, textArea.TextView.FontHeight - delta * 2);
            
            if (isEnabled) {
                using (Brush brush = new LinearGradientBrush(new Point(rect.Left, rect.Top),
                                                             new Point(rect.Right, rect.Bottom),
                                                             Color.SkyBlue,
                                                             Color.White)) {
                    FillRoundRect(g, brush, rect);
                }
            } else {
                FillRoundRect(g, Brushes.White, rect);
            }
            using (Brush brush = new LinearGradientBrush(new Point(rect.Left, rect.Top),
                                                         new Point(rect.Right, rect.Bottom),
                                                         Color.SkyBlue,
                                                         Color.Blue)) {
                using (Pen pen = new Pen(brush)) {
                    DrawRoundRect(g, pen, rect);
                }
            }
        }

        public void DrawArrow(Graphics g, int y)
        {
            int delta = textArea.TextView.FontHeight / 8;
            Rectangle rect = new Rectangle(1, y + delta, base.drawingPosition.Width - 4, textArea.TextView.FontHeight - delta * 2);
            using (Brush brush = new LinearGradientBrush(new Point(rect.Left, rect.Top),
                                                         new Point(rect.Right, rect.Bottom),
                                                         Color.LightYellow,
                                                         Color.Yellow)) {
                FillArrow(g, brush, rect);
            }
            
            using (Brush brush = new LinearGradientBrush(new Point(rect.Left, rect.Top),
                                                         new Point(rect.Right, rect.Bottom),
                                                         Color.Yellow,
                                                         Color.Brown)) {
                using (Pen pen = new Pen(brush)) {
                    DrawArrow(g, pen, rect);
                }
            }
        }
        
        GraphicsPath CreateArrowGraphicsPath(Rectangle r)
        {
            GraphicsPath gp = new GraphicsPath();
            int halfX = r.Width / 2;
            int halfY = r.Height/ 2;
            gp.AddLine(r.X, r.Y + halfY/2, r.X + halfX, r.Y + halfY/2);
            gp.AddLine(r.X + halfX, r.Y + halfY/2, r.X + halfX, r.Y);
            gp.AddLine(r.X + halfX, r.Y, r.Right, r.Y + halfY);
            gp.AddLine(r.Right, r.Y + halfY, r.X + halfX, r.Bottom);
            gp.AddLine(r.X + halfX, r.Bottom, r.X + halfX, r.Bottom - halfY/2);
            gp.AddLine(r.X + halfX, r.Bottom - halfY/2, r.X, r.Bottom - halfY/2);
            gp.AddLine(r.X, r.Bottom - halfY/2, r.X, r.Y + halfY/2);
            gp.CloseFigure();
            return gp;
        }
        
        GraphicsPath CreateRoundRectGraphicsPath(Rectangle r)
        {
            GraphicsPath gp = new GraphicsPath();
            int radius = r.Width / 2;
            gp.AddLine(r.X + radius, r.Y, r.Right - radius, r.Y);
            gp.AddArc(r.Right - radius, r.Y, radius, radius, 270, 90);
            
            gp.AddLine(r.Right, r.Y + radius, r.Right, r.Bottom - radius);
            gp.AddArc(r.Right - radius, r.Bottom - radius, radius, radius, 0, 90);
            
            gp.AddLine(r.Right - radius, r.Bottom, r.X + radius, r.Bottom);
            gp.AddArc(r.X, r.Bottom - radius, radius, radius, 90, 90);
            
            gp.AddLine(r.X, r.Bottom - radius, r.X, r.Y + radius);
            gp.AddArc(r.X, r.Y, radius, radius, 180, 90);
            
            gp.CloseFigure();
            return gp;
        }
        
        void DrawRoundRect(Graphics g, Pen p , Rectangle r)
        {
            using (GraphicsPath gp = CreateRoundRectGraphicsPath(r)) {
                g.DrawPath(p, gp);
            }
        }
        
        void FillRoundRect(Graphics g, Brush b , Rectangle r)
        {
            using (GraphicsPath gp = CreateRoundRectGraphicsPath(r)) {
                g.FillPath(b, gp);
            }
        }

        void DrawArrow(Graphics g, Pen p , Rectangle r)
        {
            using (GraphicsPath gp = CreateArrowGraphicsPath(r)) {
                g.DrawPath(p, gp);
            }
        }
        
        void FillArrow(Graphics g, Brush b , Rectangle r)
        {
            using (GraphicsPath gp = CreateArrowGraphicsPath(r)) {
                g.FillPath(b, gp);
            }
        }

#endregion
        
        static bool IsLineInsideRegion(int top, int bottom, int regionTop, int regionBottom)
        {
            if (top >= regionTop && top <= regionBottom) {
                // Region overlaps the line's top edge.
                return true;
            } else if(regionTop > top && regionTop < bottom) {
                // Region's top edge inside line.
                return true;
            }
            return false;
        }
    }
}

#endif
// file ...\TextFileEdit\Gui\Ime.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Shinsaku Nakagawa" email="shinsaku@users.sourceforge.jp"/>
//     <version>$Revision: 4900 $</version>
// </file>


namespace TextFileEdit
{
    /// <summary>
    /// Used internally, not for own use.
    /// </summary>
    public class Ime
    {
        public Ime(IntPtr hWnd, Font font)
        {
            // For unknown reasons, the IME support is causing crashes when used in a WOW64 process
            // or when used in .NET 4.0. We'll disable IME support in those cases.
            string PROCESSOR_ARCHITEW6432 = Environment.GetEnvironmentVariable("PROCESSOR_ARCHITEW6432");
            if (PROCESSOR_ARCHITEW6432 == "IA64" || PROCESSOR_ARCHITEW6432 == "AMD64" || Environment.OSVersion.Platform == PlatformID.Unix || Environment.Version >= new Version(4,0)) {
                disableIME = true;
            } else {
                this.hIMEWnd = ImmGetDefaultIMEWnd(hWnd);
            }
            this.hWnd = hWnd;
            this.font = font;
            SetIMEWindowFont(font);
        }

        private Font font = null;
        public Font Font
        {
            get {
                return font;
            }
            set {
                if (!value.Equals(font)) {
                    font = value;
                    lf = null;
                    SetIMEWindowFont(value);
                }
            }
        }

        public IntPtr HWnd
        {
            set {
                if (this.hWnd != value) {
                    this.hWnd = value;
                    if (!disableIME)
                        this.hIMEWnd = ImmGetDefaultIMEWnd(value);
                    SetIMEWindowFont(font);
                }
            }
        }

        [ DllImport("imm32.dll") ]
        private static extern IntPtr ImmGetDefaultIMEWnd(IntPtr hWnd);

        [ DllImport("user32.dll") ]
        private static extern IntPtr SendMessage(IntPtr hWnd, int msg, IntPtr wParam, COMPOSITIONFORM lParam);
        [ DllImport("user32.dll") ]
        private static extern IntPtr SendMessage(IntPtr hWnd, int msg, IntPtr wParam, [In, MarshalAs(UnmanagedType.LPStruct)] LOGFONT lParam);

        [ StructLayout(LayoutKind.Sequential) ]
        private class COMPOSITIONFORM
        {
            public int dwStyle = 0;
            public POINT ptCurrentPos = null;
            public RECT rcArea = null;
        }

        [ StructLayout(LayoutKind.Sequential) ]
        private class POINT
        {
            public int x = 0;
            public int y = 0;
        }

        [ StructLayout(LayoutKind.Sequential) ]
        private class RECT
        {
            public int left = 0;
            public int top = 0;
            public int right = 0;
            public int bottom = 0;
        }

        private const int WM_IME_CONTROL = 0x0283;

        private const int IMC_SETCOMPOSITIONWINDOW = 0x000c;
        private IntPtr hIMEWnd;
        private IntPtr hWnd;
        private const int CFS_POINT = 0x0002;

        [ StructLayout(LayoutKind.Sequential) ]
        private class LOGFONT
        {
            public int lfHeight = 0;
            public int lfWidth = 0;
            public int lfEscapement = 0;
            public int lfOrientation = 0;
            public int lfWeight = 0;
            public byte lfItalic = 0;
            public byte lfUnderline = 0;
            public byte lfStrikeOut = 0;
            public byte lfCharSet = 0;
            public byte lfOutPrecision = 0;
            public byte lfClipPrecision = 0;
            public byte lfQuality = 0;
            public byte lfPitchAndFamily = 0;
            [ MarshalAs(UnmanagedType.ByValTStr, SizeConst=32) ] public string lfFaceName = null;
        }
        private const int IMC_SETCOMPOSITIONFONT = 0x000a;
        LOGFONT lf = null;
        static bool disableIME;
        
        private void SetIMEWindowFont(Font f)
        {
            if (disableIME || hIMEWnd == IntPtr.Zero) return;
            
            if (lf == null) {
                lf = new LOGFONT();
                f.ToLogFont(lf);
                lf.lfFaceName = f.Name;  // This is very important! "Font.ToLogFont" Method sets invalid value to LOGFONT.lfFaceName
            }

            try {
                SendMessage(
                    hIMEWnd,
                    WM_IME_CONTROL,
                    new IntPtr(IMC_SETCOMPOSITIONFONT),
                    lf
                );
            } catch (AccessViolationException ex) {
                Handle(ex);
            }
        }

        public void SetIMEWindowLocation(int x, int y)
        {
            if (disableIME || hIMEWnd == IntPtr.Zero) return;

            POINT p = new POINT();
            p.x = x;
            p.y = y;

            COMPOSITIONFORM lParam = new COMPOSITIONFORM();
            lParam.dwStyle = CFS_POINT;
            lParam.ptCurrentPos = p;
            lParam.rcArea = new RECT();

            try {
                SendMessage(
                    hIMEWnd,
                    WM_IME_CONTROL,
                    new IntPtr(IMC_SETCOMPOSITIONWINDOW),
                    lParam
                );
            } catch (AccessViolationException ex) {
                Handle(ex);
            }
        }
        
        void Handle(Exception ex)
        {
            Console.WriteLine(ex);
            if (!disableIME) {
                disableIME = true;
                MessageBox.Show("Error calling IME: " + ex.Message + "\nIME is disabled.", "IME error");
            }
        }
    }
}

#endif
// file ...\TextFileEdit\Gui\TextArea.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 4643 $</version>
// </file>


namespace TextFileEdit
{
    public delegate bool KeyEventHandler(char ch);
    public delegate bool DialogKeyProcessor(System.Windows.Forms.Keys keyData);
    
    /// <summary>
    /// This class paints the textarea.
    /// </summary>
    [ToolboxItem(false)]
    public class TextArea : System.Windows.Forms.Control
    {
        bool hiddenMouseCursor = false;
        /// <summary>
        /// The position where the mouse cursor was when it was hidden. Sometimes the text editor gets MouseMove
        /// events when typing text even if the mouse is not moved.
        /// </summary>
        Point mouseCursorHidePosition;
        
        Point virtualTop        = new Point(0, 0);
        TextAreaControl         motherTextAreaControl;
        TextEditorControl       motherTextEditorControl;
        
        List<BracketHighlightingSheme> bracketshemes  = new List<BracketHighlightingSheme>();
        TextAreaClipboardHandler  textAreaClipboardHandler;
        bool autoClearSelection = false;
        
        List<AbstractMargin> leftMargins = new List<AbstractMargin>();
        
        TextView      textView;
        GutterMargin  gutterMargin;
        FoldMargin    foldMargin;
        IconBarMargin iconBarMargin;
        
        TextFileEdit.Document.SelectionManager selectionManager;
        Caret            caret;

        internal Point mousepos = new Point(0, 0);
        //public Point selectionStartPos = new Point(0,0);

        bool disposed;
        
        [Browsable(false)]
        public IList<AbstractMargin> LeftMargins {
            get {
                return leftMargins.AsReadOnly();
            }
        }
        
        public void InsertLeftMargin(int index, AbstractMargin margin)
        {
            leftMargins.Insert(index, margin);
            Refresh();
        }
        
        public TextEditorControl MotherTextEditorControl {
            get {
                return motherTextEditorControl;
            }
        }
        
        public TextAreaControl MotherTextAreaControl {
            get {
                return motherTextAreaControl;
            }
        }
        
        public TextFileEdit.Document.SelectionManager SelectionManager {
            get {
                return selectionManager;
            }
        }
        
        public Caret Caret {
            get {
                return caret;
            }
        }
        
        public TextView TextView {
            get {
                return textView;
            }
        }
        
        public GutterMargin GutterMargin {
            get {
                return gutterMargin;
            }
        }
        
        public FoldMargin FoldMargin {
            get {
                return foldMargin;
            }
        }
        
        public IconBarMargin IconBarMargin {
            get {
                return iconBarMargin;
            }
        }
        
        public Encoding Encoding {
            get {
                return motherTextEditorControl.Encoding;
            }
        }
        public int MaxVScrollValue {
            get {
                return (Document.GetVisibleLine(Document.TotalNumberOfLines - 1) + 1 + TextView.VisibleLineCount * 2 / 3) * TextView.FontHeight;
            }
        }
        
        public Point VirtualTop {
            get {
                return virtualTop;
            }
            set {
                Point newVirtualTop = new Point(value.X, Math.Min(MaxVScrollValue, Math.Max(0, value.Y)));
                if (virtualTop != newVirtualTop) {
                    virtualTop = newVirtualTop;
                    motherTextAreaControl.VScrollBar.Value = virtualTop.Y;
                    Invalidate();
                }
                caret.UpdateCaretPosition();
            }
        }
        
        public bool AutoClearSelection {
            get {
                return autoClearSelection;
            }
            set {
                autoClearSelection = value;
            }
        }
        
        [Browsable(false)]
        public TextFileEdit.Document.IDocument Document
        {
            get {
                return motherTextEditorControl.Document;
            }
        }
        
        public TextAreaClipboardHandler ClipboardHandler {
            get {
                return textAreaClipboardHandler;
            }
        }


        public TextFileEdit.Document.ITextEditorProperties TextEditorProperties
        {
            get {
                return motherTextEditorControl.TextEditorProperties;
            }
        }
        
        public TextArea(TextEditorControl motherTextEditorControl, TextAreaControl motherTextAreaControl)
        {
            this.motherTextAreaControl      = motherTextAreaControl;
            this.motherTextEditorControl    = motherTextEditorControl;
            
            caret            = new Caret(this);
            selectionManager = new TextFileEdit.Document.SelectionManager(Document, this);
            
            this.textAreaClipboardHandler = new TextAreaClipboardHandler(this);
            
            ResizeRedraw = true;

            SetStyle(System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer, true);
//          SetStyle(System.Windows.Forms.ControlStyles.AllPaintingInWmPaint, true);
//          SetStyle(System.Windows.Forms.ControlStyles.UserPaint, true);
            SetStyle(System.Windows.Forms.ControlStyles.Opaque, false);
            SetStyle(System.Windows.Forms.ControlStyles.ResizeRedraw, true);
            SetStyle(System.Windows.Forms.ControlStyles.Selectable, true);
            
            textView = new TextView(this);
            
            gutterMargin = new GutterMargin(this);
            foldMargin   = new FoldMargin(this);
            iconBarMargin = new IconBarMargin(this);
            leftMargins.AddRange(new AbstractMargin[] { iconBarMargin, gutterMargin, foldMargin });
            OptionsChanged();
            
            
            new TextAreaMouseHandler(this).Attach();
            new TextAreaDragDropHandler().Attach(this);
            
            bracketshemes.Add(new BracketHighlightingSheme('{', '}'));
            bracketshemes.Add(new BracketHighlightingSheme('(', ')'));
            bracketshemes.Add(new BracketHighlightingSheme('[', ']'));
            
            caret.PositionChanged += new EventHandler(SearchMatchingBracket);
            Document.TextContentChanged += new EventHandler(TextContentChanged);
            Document.FoldingManager.FoldingsChanged += new EventHandler(DocumentFoldingsChanged);
        }
        
        public void UpdateMatchingBracket()
        {
            SearchMatchingBracket(null, null);
        }
        
        void TextContentChanged(object sender, EventArgs e)
        {
            Caret.Position = new TextLocation(0, 0);
            SelectionManager.SelectionCollection.Clear();
        }
        void SearchMatchingBracket(object sender, EventArgs e)
        {
            if (!TextEditorProperties.ShowMatchingBracket) {
                textView.Highlight = null;
                return;
            }
            int oldLine1 = -1, oldLine2 = -1;
            if (textView.Highlight != null && textView.Highlight.OpenBrace.Y >=0 && textView.Highlight.OpenBrace.Y < Document.TotalNumberOfLines) {
                oldLine1 = textView.Highlight.OpenBrace.Y;
            }
            if (textView.Highlight != null && textView.Highlight.CloseBrace.Y >=0 && textView.Highlight.CloseBrace.Y < Document.TotalNumberOfLines) {
                oldLine2 = textView.Highlight.CloseBrace.Y;
            }
            textView.Highlight = FindMatchingBracketHighlight();
            if (oldLine1 >= 0)
                UpdateLine(oldLine1);
            if (oldLine2 >= 0 && oldLine2 != oldLine1)
                UpdateLine(oldLine2);
            if (textView.Highlight != null) {
                int newLine1 = textView.Highlight.OpenBrace.Y;
                int newLine2 = textView.Highlight.CloseBrace.Y;
                if (newLine1 != oldLine1 && newLine1 != oldLine2)
                    UpdateLine(newLine1);
                if (newLine2 != oldLine1 && newLine2 != oldLine2 && newLine2 != newLine1)
                    UpdateLine(newLine2);
            }
        }
        
        public Highlight FindMatchingBracketHighlight()
        {
            if (Caret.Offset == 0)
                return null;
            foreach (BracketHighlightingSheme bracketsheme in bracketshemes) {
                Highlight highlight = bracketsheme.GetHighlight(Document, Caret.Offset - 1);
                if (highlight != null) {
                    return highlight;
                }
            }
            return null;
        }
        
        public void SetDesiredColumn()
        {
            Caret.DesiredColumn = TextView.GetDrawingXPos(Caret.Line, Caret.Column) + VirtualTop.X;
        }
        
        public void SetCaretToDesiredColumn()
        {
            TextFileEdit.Document.FoldMarker dummy;
            Caret.Position = textView.GetLogicalColumn(Caret.Line, Caret.DesiredColumn + VirtualTop.X, out dummy);
        }
        
        public void OptionsChanged()
        {
            UpdateMatchingBracket();
            textView.OptionsChanged();
            caret.RecreateCaret();
            caret.UpdateCaretPosition();
            Refresh();
        }
        
        AbstractMargin lastMouseInMargin;
        
        protected override void OnMouseLeave(System.EventArgs e)
        {
            base.OnMouseLeave(e);
            this.Cursor = System.Windows.Forms.Cursors.Default;
            if (lastMouseInMargin != null) {
                lastMouseInMargin.HandleMouseLeave(EventArgs.Empty);
                lastMouseInMargin = null;
            }
            CloseToolTip();
        }
        
        protected override void OnMouseDown(System.Windows.Forms.MouseEventArgs e)
        {
            // this corrects weird problems when text is selected,
            // then a menu item is selected, then the text is
            // clicked again - it correctly synchronises the
            // click position
            mousepos = new Point(e.X, e.Y);

            base.OnMouseDown(e);
            CloseToolTip();
            
            foreach (AbstractMargin margin in leftMargins) {
                if (margin.DrawingPosition.Contains(e.X, e.Y)) {
                    margin.HandleMouseDown(new Point(e.X, e.Y), e.Button);
                }
            }
        }
        
        /// <summary>
        /// Shows the mouse cursor if it has been hidden.
        /// </summary>
        /// <param name="forceShow"><c>true</c> to always show the cursor or <c>false</c> to show it only if it has been moved since it was hidden.</param>
        internal void ShowHiddenCursor(bool forceShow)
        {
            if (hiddenMouseCursor) {
                if (mouseCursorHidePosition != System.Windows.Forms.Cursor.Position || forceShow)
                {
                    System.Windows.Forms.Cursor.Show();
                    hiddenMouseCursor = false;
                }
            }
        }
        
        
        // static because the mouse can only be in one text area and we don't want to have
        // tooltips of text areas from inactive tabs floating around.
        static TextFileEdit.Gui.CompletionWindow.DeclarationViewWindow toolTip;
        static string oldToolTip;
        
        void SetToolTip(string text, int lineNumber)
        {
            if (toolTip == null || toolTip.IsDisposed)
                toolTip = new TextFileEdit.Gui.CompletionWindow.DeclarationViewWindow(this.FindForm());
            if (oldToolTip == text)
                return;
            if (text == null) {
                toolTip.Hide();
            } else {
                Point p = System.Windows.Forms.Control.MousePosition;
                Point cp = PointToClient(p);
                if (lineNumber >= 0) {
                    lineNumber = this.Document.GetVisibleLine(lineNumber);
                    p.Y = (p.Y - cp.Y) + (lineNumber * this.TextView.FontHeight) - this.virtualTop.Y;
                }
                p.Offset(3, 3);
                toolTip.Owner = this.FindForm();
                toolTip.Location = p;
                toolTip.Description = text;
                toolTip.HideOnClick = true;
                toolTip.Show();
            }
            oldToolTip = text;
        }
        
        public event ToolTipRequestEventHandler ToolTipRequest;
        
        protected virtual void OnToolTipRequest(ToolTipRequestEventArgs e)
        {
            if (ToolTipRequest != null) {
                ToolTipRequest(this, e);
            }
        }
        
        bool toolTipActive;
        /// <summary>
        /// Rectangle in text area that caused the current tool tip.
        /// Prevents tooltip from re-showing when it was closed because of a click or keyboard
        /// input and the mouse was not used.
        /// </summary>
        Rectangle toolTipRectangle;
        
        void CloseToolTip()
        {
            if (toolTipActive) {
                //Console.WriteLine("Closing tooltip");
                toolTipActive = false;
                SetToolTip(null, -1);
            }
            ResetMouseEventArgs();
        }
        
        protected override void OnMouseHover(EventArgs e)
        {
            base.OnMouseHover(e);
            //Console.WriteLine("Hover raised at " + PointToClient(Control.MousePosition));
            if (MouseButtons == System.Windows.Forms.MouseButtons.None)
            {
                RequestToolTip(PointToClient(System.Windows.Forms.Control.MousePosition));
            } else {
                CloseToolTip();
            }
        }
        
        protected void RequestToolTip(Point mousePos)
        {
            if (toolTipRectangle.Contains(mousePos)) {
                if (!toolTipActive)
                    ResetMouseEventArgs();
                return;
            }
            
            //Console.WriteLine("Request tooltip for " + mousePos);
            
            toolTipRectangle = new Rectangle(mousePos.X - 4, mousePos.Y - 4, 8, 8);
            
            TextLocation logicPos = textView.GetLogicalPosition(mousePos.X - textView.DrawingPosition.Left,
                                                                mousePos.Y - textView.DrawingPosition.Top);
            bool inDocument = textView.DrawingPosition.Contains(mousePos)
                && logicPos.Y >= 0 && logicPos.Y < Document.TotalNumberOfLines;
            ToolTipRequestEventArgs args = new ToolTipRequestEventArgs(mousePos, logicPos, inDocument);
            OnToolTipRequest(args);
            if (args.ToolTipShown) {
                //Console.WriteLine("Set tooltip to " + args.toolTipText);
                toolTipActive = true;
                SetToolTip(args.toolTipText, inDocument ? logicPos.Y + 1 : -1);
            } else {
                CloseToolTip();
            }
        }
        
        // external interface to the attached event
        internal void RaiseMouseMove(System.Windows.Forms.MouseEventArgs e)
        {
            OnMouseMove(e);
        }

        protected override void OnMouseMove(System.Windows.Forms.MouseEventArgs e)
        {
            base.OnMouseMove(e);
            if (!toolTipRectangle.Contains(e.Location)) {
                toolTipRectangle = Rectangle.Empty;
                if (toolTipActive)
                    RequestToolTip(e.Location);
            }
            foreach (AbstractMargin margin in leftMargins) {
                if (margin.DrawingPosition.Contains(e.X, e.Y)) {
                    this.Cursor = margin.Cursor;
                    margin.HandleMouseMove(new Point(e.X, e.Y), e.Button);
                    if (lastMouseInMargin != margin) {
                        if (lastMouseInMargin != null) {
                            lastMouseInMargin.HandleMouseLeave(EventArgs.Empty);
                        }
                        lastMouseInMargin = margin;
                    }
                    return;
                }
            }
            if (lastMouseInMargin != null) {
                lastMouseInMargin.HandleMouseLeave(EventArgs.Empty);
                lastMouseInMargin = null;
            }
            if (textView.DrawingPosition.Contains(e.X, e.Y)) {
                TextLocation realmousepos = TextView.GetLogicalPosition(e.X - TextView.DrawingPosition.X, e.Y - TextView.DrawingPosition.Y);
                if (SelectionManager.IsSelected(Document.PositionToOffset(realmousepos)) && MouseButtons == System.Windows.Forms.MouseButtons.None)
                {
                    // mouse is hovering over a selection, so show default mouse
                    this.Cursor = System.Windows.Forms.Cursors.Default;
                } else {
                    // mouse is hovering over text area, not a selection, so show the textView cursor
                    this.Cursor = textView.Cursor;
                }
                return;
            }
            this.Cursor = System.Windows.Forms.Cursors.Default;
        }
        AbstractMargin updateMargin = null;
        
        public void Refresh(AbstractMargin margin)
        {
            updateMargin = margin;
            Invalidate(updateMargin.DrawingPosition);
            Update();
            updateMargin = null;
        }
        
        protected override void OnPaintBackground(System.Windows.Forms.PaintEventArgs pevent)
        {
        }
        
        protected override void OnPaint(System.Windows.Forms.PaintEventArgs e)
        {
            int currentXPos = 0;
            int currentYPos = 0;
            bool adjustScrollBars = false;
            Graphics  g             = e.Graphics;
            Rectangle clipRectangle = e.ClipRectangle;
            
            bool isFullRepaint = clipRectangle.X == 0 && clipRectangle.Y == 0
                && clipRectangle.Width == this.Width && clipRectangle.Height == this.Height;
            
            g.TextRenderingHint = this.TextEditorProperties.TextRenderingHint;
            
            if (updateMargin != null) {
                updateMargin.Paint(g, updateMargin.DrawingPosition);
//              clipRectangle.Intersect(updateMargin.DrawingPosition);
            }
            
            if (clipRectangle.Width <= 0 || clipRectangle.Height <= 0) {
                return;
            }
            
            foreach (AbstractMargin margin in leftMargins) {
                if (margin.IsVisible) {
                    Rectangle marginRectangle = new Rectangle(currentXPos , currentYPos, margin.Size.Width, Height - currentYPos);
                    if (marginRectangle != margin.DrawingPosition) {
                        // margin changed size
                        if (!isFullRepaint && !clipRectangle.Contains(marginRectangle)) {
                            Invalidate(); // do a full repaint
                        }
                        adjustScrollBars = true;
                        margin.DrawingPosition = marginRectangle;
                    }
                    currentXPos += margin.DrawingPosition.Width;
                    if (clipRectangle.IntersectsWith(marginRectangle)) {
                        marginRectangle.Intersect(clipRectangle);
                        if (!marginRectangle.IsEmpty) {
                            margin.Paint(g, marginRectangle);
                        }
                    }
                }
            }
            
            Rectangle textViewArea = new Rectangle(currentXPos, currentYPos, Width - currentXPos, Height - currentYPos);
            if (textViewArea != textView.DrawingPosition) {
                adjustScrollBars = true;
                textView.DrawingPosition = textViewArea;
                // update caret position (but outside of WM_PAINT!)
                BeginInvoke((System.Windows.Forms.MethodInvoker)caret.UpdateCaretPosition);
            }
            if (clipRectangle.IntersectsWith(textViewArea)) {
                textViewArea.Intersect(clipRectangle);
                if (!textViewArea.IsEmpty) {
                    textView.Paint(g, textViewArea);
                }
            }
            
            if (adjustScrollBars) {
                this.motherTextAreaControl.AdjustScrollBars();
            }
            
            // we cannot update the caret position here, it's not allowed to call the caret API inside WM_PAINT
            //Caret.UpdateCaretPosition();
            
            base.OnPaint(e);
        }
        void DocumentFoldingsChanged(object sender, EventArgs e)
        {
            Caret.UpdateCaretPosition();
            Invalidate();
            this.motherTextAreaControl.AdjustScrollBars();
        }
        
#region keyboard handling methods
        
        /// <summary>
        /// This method is called on each Keypress
        /// </summary>
        /// <returns>
        /// True, if the key is handled by this method and should NOT be
        /// inserted in the textarea.
        /// </returns>
        protected internal virtual bool HandleKeyPress(char ch)
        {
            if (KeyEventHandler != null) {
                return KeyEventHandler(ch);
            }
            return false;
        }
        
        // Fixes SD2-747: Form containing the text editor and a button with a shortcut
        protected override bool IsInputChar(char charCode)
        {
            return true;
        }
        
        internal bool IsReadOnly(int offset)
        {
            if (Document.ReadOnly) {
                return true;
            }
            if (TextEditorProperties.SupportReadOnlySegments) {
                return Document.MarkerStrategy.GetMarkers(offset).Exists(m=>m.IsReadOnly);
            } else {
                return false;
            }
        }
        
        internal bool IsReadOnly(int offset, int length)
        {
            if (Document.ReadOnly) {
                return true;
            }
            if (TextEditorProperties.SupportReadOnlySegments) {
                return Document.MarkerStrategy.GetMarkers(offset, length).Exists(m=>m.IsReadOnly);
            } else {
                return false;
            }
        }
        
        public void SimulateKeyPress(char ch)
        {
            if (SelectionManager.HasSomethingSelected) {
                if (SelectionManager.SelectionIsReadonly)
                    return;
            } else if (IsReadOnly(Caret.Offset)) {
                return;
            }
            
            if (ch < ' ') {
                return;
            }
            
            if (!hiddenMouseCursor && TextEditorProperties.HideMouseCursor) {
                if (this.ClientRectangle.Contains(PointToClient(System.Windows.Forms.Cursor.Position)))
                {
                    mouseCursorHidePosition = System.Windows.Forms.Cursor.Position;
                    hiddenMouseCursor = true;
                    System.Windows.Forms.Cursor.Hide();
                }
            }
            CloseToolTip();
            
            BeginUpdate();
            Document.UndoStack.StartUndoGroup();
            try {
                // INSERT char
                if (!HandleKeyPress(ch)) {
                    switch (Caret.CaretMode) {
                        case CaretMode.InsertMode:
                            InsertChar(ch);
                            break;
                        case CaretMode.OverwriteMode:
                            ReplaceChar(ch);
                            break;
                        default:
                            Debug.Assert(false, "Unknown caret mode " + Caret.CaretMode);
                            break;
                    }
                }
                
                int currentLineNr = Caret.Line;
                Document.FormattingStrategy.FormatLine(this, currentLineNr, Document.PositionToOffset(Caret.Position), ch);
                
                EndUpdate();
            } finally {
                Document.UndoStack.EndUndoGroup();
            }
        }

        protected override void OnKeyPress(System.Windows.Forms.KeyPressEventArgs e)
        {
            base.OnKeyPress(e);
            SimulateKeyPress(e.KeyChar);
            e.Handled = true;
        }
        
        /// <summary>
        /// This method executes a dialog key
        /// </summary>
        public bool ExecuteDialogKey(System.Windows.Forms.Keys keyData)
        {
            // try, if a dialog key processor was set to use this
            if (DoProcessDialogKey != null && DoProcessDialogKey(keyData)) {
                return true;
            }
            
            // if not (or the process was 'silent', use the standard edit actions
            TextFileEdit.Actions.IEditAction action = motherTextEditorControl.GetEditAction(keyData);
            AutoClearSelection = true;
            if (action != null) {
                BeginUpdate();
                try {
                    lock (Document) {
                        action.Execute(this);
                        if (SelectionManager.HasSomethingSelected && AutoClearSelection /*&& caretchanged*/) {
                            if (Document.TextEditorProperties.DocumentSelectionMode == TextFileEdit.Document.DocumentSelectionMode.Normal)
                            {
                                SelectionManager.ClearSelection();
                            }
                        }
                    }
                } finally {
                    EndUpdate();
                    Caret.UpdateCaretPosition();
                }
                return true;
            }
            return false;
        }

        protected override bool ProcessDialogKey(System.Windows.Forms.Keys keyData)
        {
            return ExecuteDialogKey(keyData) || base.ProcessDialogKey(keyData);
        }
#endregion
        
        public void ScrollToCaret()
        {
            motherTextAreaControl.ScrollToCaret();
        }
        
        public void ScrollTo(int line)
        {
            motherTextAreaControl.ScrollTo(line);
        }
        
        public void BeginUpdate()
        {
            motherTextEditorControl.BeginUpdate();
        }
        
        public void EndUpdate()
        {
            motherTextEditorControl.EndUpdate();
        }
        
        public bool EnableCutOrPaste {
            get {
                if (motherTextAreaControl == null)
                    return false;
                if (SelectionManager.HasSomethingSelected)
                    return !SelectionManager.SelectionIsReadonly;
                else
                    return !IsReadOnly(Caret.Offset);
            }
        }
        
        string GenerateWhitespaceString(int length)
        {
            return new String(' ', length);
        }
        /// <remarks>
        /// Inserts a single character at the caret position
        /// </remarks>
        public void InsertChar(char ch)
        {
            bool updating = motherTextEditorControl.IsInUpdate;
            if (!updating) {
                BeginUpdate();
            }
            
            // filter out forgein whitespace chars and replace them with standard space (ASCII 32)
            if (Char.IsWhiteSpace(ch) && ch != '\t' && ch != '\n') {
                ch = ' ';
            }
            
            Document.UndoStack.StartUndoGroup();
            if (Document.TextEditorProperties.DocumentSelectionMode == TextFileEdit.Document.DocumentSelectionMode.Normal &&
                SelectionManager.SelectionCollection.Count > 0) {
                Caret.Position = SelectionManager.SelectionCollection[0].StartPosition;
                SelectionManager.RemoveSelectedText();
            }
            TextFileEdit.Document.LineSegment caretLine = Document.GetLineSegment(Caret.Line);
            int offset = Caret.Offset;
            // use desired column for generated whitespaces
            int dc = Caret.Column;
            if (caretLine.Length < dc && ch != '\n') {
                Document.Insert(offset, GenerateWhitespaceString(dc - caretLine.Length) + ch);
            } else {
                Document.Insert(offset, ch.ToString());
            }
            Document.UndoStack.EndUndoGroup();
            ++Caret.Column;
            
            if (!updating) {
                EndUpdate();
                UpdateLineToEnd(Caret.Line, Caret.Column);
            }
            
            // I prefer to set NOT the standard column, if you type something
//          ++Caret.DesiredColumn;
        }
        
        /// <remarks>
        /// Inserts a whole string at the caret position
        /// </remarks>
        public void InsertString(string str)
        {
            bool updating = motherTextEditorControl.IsInUpdate;
            if (!updating) {
                BeginUpdate();
            }
            try {
                Document.UndoStack.StartUndoGroup();
                if (Document.TextEditorProperties.DocumentSelectionMode == TextFileEdit.Document.DocumentSelectionMode.Normal &&
                    SelectionManager.SelectionCollection.Count > 0) {
                    Caret.Position = SelectionManager.SelectionCollection[0].StartPosition;
                    SelectionManager.RemoveSelectedText();
                }
                
                int oldOffset = Document.PositionToOffset(Caret.Position);
                int oldLine   = Caret.Line;
                TextFileEdit.Document.LineSegment caretLine = Document.GetLineSegment(Caret.Line);
                if (caretLine.Length < Caret.Column) {
                    int whiteSpaceLength = Caret.Column - caretLine.Length;
                    Document.Insert(oldOffset, GenerateWhitespaceString(whiteSpaceLength) + str);
                    Caret.Position = Document.OffsetToPosition(oldOffset + str.Length + whiteSpaceLength);
                } else {
                    Document.Insert(oldOffset, str);
                    Caret.Position = Document.OffsetToPosition(oldOffset + str.Length);
                }
                Document.UndoStack.EndUndoGroup();
                if (oldLine != Caret.Line) {
                    UpdateToEnd(oldLine);
                } else {
                    UpdateLineToEnd(Caret.Line, Caret.Column);
                }
            } finally {
                if (!updating) {
                    EndUpdate();
                }
            }
        }
        
        /// <remarks>
        /// Replaces a char at the caret position
        /// </remarks>
        public void ReplaceChar(char ch)
        {
            bool updating = motherTextEditorControl.IsInUpdate;
            if (!updating) {
                BeginUpdate();
            }
            if (Document.TextEditorProperties.DocumentSelectionMode == TextFileEdit.Document.DocumentSelectionMode.Normal && SelectionManager.SelectionCollection.Count > 0) {
                Caret.Position = SelectionManager.SelectionCollection[0].StartPosition;
                SelectionManager.RemoveSelectedText();
            }
            
            int lineNr   = Caret.Line;
            TextFileEdit.Document.LineSegment  line = Document.GetLineSegment(lineNr);
            int offset = Document.PositionToOffset(Caret.Position);
            if (offset < line.Offset + line.Length) {
                Document.Replace(offset, 1, ch.ToString());
            } else {
                Document.Insert(offset, ch.ToString());
            }
            if (!updating) {
                EndUpdate();
                UpdateLineToEnd(lineNr, Caret.Column);
            }
            ++Caret.Column;
//          ++Caret.DesiredColumn;
        }
        
        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (disposing) {
                if (!disposed) {
                    disposed = true;
                    if (caret != null) {
                        caret.PositionChanged -= new EventHandler(SearchMatchingBracket);
                        caret.Dispose();
                    }
                    if (selectionManager != null) {
                        selectionManager.Dispose();
                    }
                    Document.TextContentChanged -= new EventHandler(TextContentChanged);
                    Document.FoldingManager.FoldingsChanged -= new EventHandler(DocumentFoldingsChanged);
                    motherTextAreaControl = null;
                    motherTextEditorControl = null;
                    foreach (AbstractMargin margin in leftMargins) {
                        if (margin is IDisposable)
                            (margin as IDisposable).Dispose();
                    }
                    if (gutterMargin != null)
                        gutterMargin.Dispose();
                    textView.Dispose();
                }
            }
        }
        
#region UPDATE Commands
        internal void UpdateLine(int line)
        {
            UpdateLines(0, line, line);
        }
        
        internal void UpdateLines(int lineBegin, int lineEnd)
        {
            UpdateLines(0, lineBegin, lineEnd);
        }
        
        internal void UpdateToEnd(int lineBegin)
        {
//          if (lineBegin > FirstPhysicalLine + textView.VisibleLineCount) {
//              return;
//          }
            
            lineBegin = Document.GetVisibleLine(lineBegin);
            int y         = Math.Max(    0, (int)(lineBegin * textView.FontHeight));
            y = Math.Max(0, y - this.virtualTop.Y);
            Rectangle r = new Rectangle(0,
                                        y,
                                        Width,
                                        Height - y);
            Invalidate(r);
        }
        
        internal void UpdateLineToEnd(int lineNr, int xStart)
        {
            UpdateLines(xStart, lineNr, lineNr);
        }
        
        internal void UpdateLine(int line, int begin, int end)
        {
            UpdateLines(line, line);
        }
        int FirstPhysicalLine {
            get {
                return VirtualTop.Y / textView.FontHeight;
            }
        }
        internal void UpdateLines(int xPos, int lineBegin, int lineEnd)
        {
//          if (lineEnd < FirstPhysicalLine || lineBegin > FirstPhysicalLine + textView.VisibleLineCount) {
//              return;
//          }
            
            InvalidateLines((int)(xPos * this.TextView.WideSpaceWidth), lineBegin, lineEnd);
        }
        
        void InvalidateLines(int xPos, int lineBegin, int lineEnd)
        {
            lineBegin     = Math.Max(Document.GetVisibleLine(lineBegin), FirstPhysicalLine);
            lineEnd       = Math.Min(Document.GetVisibleLine(lineEnd),   FirstPhysicalLine + textView.VisibleLineCount);
            int y         = Math.Max(    0, (int)(lineBegin  * textView.FontHeight));
            int height    = Math.Min(textView.DrawingPosition.Height, (int)((1 + lineEnd - lineBegin) * (textView.FontHeight + 1)));
            
            Rectangle r = new Rectangle(0,
                                        y - 1 - this.virtualTop.Y,
                                        Width,
                                        height + 3);
            
            Invalidate(r);
        }
#endregion
        public event KeyEventHandler    KeyEventHandler;
        public event DialogKeyProcessor DoProcessDialogKey;
        
        //internal void
    }
}

#endif
// file ...\TextFileEdit\Gui\TextAreaClipboardHandler.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 4266 $</version>
// </file>


namespace TextFileEdit
{
	public class TextAreaClipboardHandler
	{
		TextArea textArea;
		
		public bool EnableCut {
			get {
				return textArea.EnableCutOrPaste; //textArea.SelectionManager.HasSomethingSelected;
			}
		}
		
		public bool EnableCopy {
			get {
				return true; //textArea.SelectionManager.HasSomethingSelected;
			}
		}
		
		public delegate bool ClipboardContainsTextDelegate();
		
		/// <summary>
		/// Is called when CachedClipboardContainsText should be updated.
		/// If this property is null (the default value), the text editor uses
		/// System.Windows.Forms.Clipboard.ContainsText.
		/// </summary>
		/// <remarks>
		/// This property is useful if you want to prevent the default Clipboard.ContainsText
		/// behaviour that waits for the clipboard to be available - the clipboard might
		/// never become available if it is owned by a process that is paused by the debugger.
		/// </remarks>
		public static ClipboardContainsTextDelegate GetClipboardContainsText;
		
		public bool EnablePaste {
			get {
				if (!textArea.EnableCutOrPaste)
					return false;
				ClipboardContainsTextDelegate d = GetClipboardContainsText;
				if (d != null) {
					return d();
				} else {
					try {
						return System.Windows.Forms.Clipboard.ContainsText();
					} catch (ExternalException) {
						return false;
					}
				}
			}
		}
		
		public bool EnableDelete {
			get {
				return textArea.SelectionManager.HasSomethingSelected && !textArea.SelectionManager.SelectionIsReadonly;
			}
		}
		
		public bool EnableSelectAll {
			get {
				return true;
			}
		}
		
		public TextAreaClipboardHandler(TextArea textArea)
		{
			this.textArea = textArea;
			textArea.SelectionManager.SelectionChanged += new EventHandler(DocumentSelectionChanged);
		}
		
		void DocumentSelectionChanged(object sender, EventArgs e)
		{
//			((DefaultWorkbench)WorkbenchSingleton.Workbench).UpdateToolbars();
		}

		const string LineSelectedType = "MSDEVLineSelect";  // This is the type VS 2003 and 2005 use for flagging a whole line copy
		
		bool CopyTextToClipboard(string stringToCopy, bool asLine)
		{
			if (stringToCopy.Length > 0) {
                System.Windows.Forms.DataObject dataObject = new System.Windows.Forms.DataObject();
                dataObject.SetData(System.Windows.Forms.DataFormats.UnicodeText, true, stringToCopy);
				if (asLine) {
					MemoryStream lineSelected = new MemoryStream(1);
					lineSelected.WriteByte(1);
					dataObject.SetData(LineSelectedType, false, lineSelected);
				}
				// Default has no highlighting, therefore we don't need RTF output
				if (textArea.Document.HighlightingStrategy.Name != "Default") {
                    dataObject.SetData(System.Windows.Forms.DataFormats.Rtf, TextFileEdit.Util.RtfWriter.GenerateRtf(textArea));
				}
				OnCopyText(new CopyTextEventArgs(stringToCopy));
				
				SafeSetClipboard(dataObject);
				return true;
			} else {
				return false;
			}
		}
		
		// Code duplication: TextAreaClipboardHandler.cs also has SafeSetClipboard
		[ThreadStatic] static int SafeSetClipboardDataVersion;
		
		static void SafeSetClipboard(object dataObject)
		{
			// Work around ExternalException bug. (SD2-426)
			// Best reproducable inside Virtual PC.
			int version = unchecked(++SafeSetClipboardDataVersion);
			try {
                System.Windows.Forms.Clipboard.SetDataObject(dataObject, true);
			} catch (ExternalException) {
                System.Windows.Forms.Timer timer = new System.Windows.Forms.Timer();
				timer.Interval = 100;
				timer.Tick += delegate {
					timer.Stop();
					timer.Dispose();
					if (SafeSetClipboardDataVersion == version) {
						try {
                            System.Windows.Forms.Clipboard.SetDataObject(dataObject, true, 10, 50);
						} catch (ExternalException) { }
					}
				};
				timer.Start();
			}
		}

		bool CopyTextToClipboard(string stringToCopy)
		{
			return CopyTextToClipboard(stringToCopy, false);
		}
		
		public void Cut(object sender, EventArgs e)
		{
			if (textArea.SelectionManager.HasSomethingSelected) {
				if (CopyTextToClipboard(textArea.SelectionManager.SelectedText)) {
					if (textArea.SelectionManager.SelectionIsReadonly)
						return;
					// Remove text
					textArea.BeginUpdate();
					textArea.Caret.Position = textArea.SelectionManager.SelectionCollection[0].StartPosition;
					textArea.SelectionManager.RemoveSelectedText();
					textArea.EndUpdate();
				}
			} else if (textArea.Document.TextEditorProperties.CutCopyWholeLine) {
				// No text was selected, select and cut the entire line
				int curLineNr = textArea.Document.GetLineNumberForOffset(textArea.Caret.Offset);
				TextFileEdit.Document.LineSegment lineWhereCaretIs = textArea.Document.GetLineSegment(curLineNr);
				string caretLineText = textArea.Document.GetText(lineWhereCaretIs.Offset, lineWhereCaretIs.TotalLength);
				textArea.SelectionManager.SetSelection(textArea.Document.OffsetToPosition(lineWhereCaretIs.Offset), textArea.Document.OffsetToPosition(lineWhereCaretIs.Offset + lineWhereCaretIs.TotalLength));
				if (CopyTextToClipboard(caretLineText, true)) {
					if (textArea.SelectionManager.SelectionIsReadonly)
						return;
					// remove line
					textArea.BeginUpdate();
					textArea.Caret.Position = textArea.Document.OffsetToPosition(lineWhereCaretIs.Offset);
					textArea.SelectionManager.RemoveSelectedText();
					textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.PositionToEnd, new TextLocation(0, curLineNr)));
					textArea.EndUpdate();
				}
			}
		}
		
		public void Copy(object sender, EventArgs e)
		{
			if (!CopyTextToClipboard(textArea.SelectionManager.SelectedText) && textArea.Document.TextEditorProperties.CutCopyWholeLine) {
				// No text was selected, select the entire line, copy it, and then deselect
				int curLineNr = textArea.Document.GetLineNumberForOffset(textArea.Caret.Offset);
				TextFileEdit.Document.LineSegment lineWhereCaretIs = textArea.Document.GetLineSegment(curLineNr);
				string caretLineText = textArea.Document.GetText(lineWhereCaretIs.Offset, lineWhereCaretIs.TotalLength);
				CopyTextToClipboard(caretLineText, true);
			}
		}
		
		public void Paste(object sender, EventArgs e)
		{
			if (!textArea.EnableCutOrPaste) {
				return;
			}
			// Clipboard.GetDataObject may throw an exception...
			for (int i = 0;; i++) {
				try {
                    System.Windows.Forms.IDataObject data = System.Windows.Forms.Clipboard.GetDataObject();
					if (data == null)
						return;
					bool fullLine = data.GetDataPresent(LineSelectedType);
                    if (data.GetDataPresent(System.Windows.Forms.DataFormats.UnicodeText))
                    {
                        string text = (string)data.GetData(System.Windows.Forms.DataFormats.UnicodeText);
						// we got NullReferenceExceptions here, apparently the clipboard can contain null strings
						if (!string.IsNullOrEmpty(text)) {
							textArea.Document.UndoStack.StartUndoGroup();
							try {
								if (textArea.SelectionManager.HasSomethingSelected) {
									textArea.Caret.Position = textArea.SelectionManager.SelectionCollection[0].StartPosition;
									textArea.SelectionManager.RemoveSelectedText();
								}
								if (fullLine) {
									int col = textArea.Caret.Column;
									textArea.Caret.Column = 0;
									if (!textArea.IsReadOnly(textArea.Caret.Offset))
										textArea.InsertString(text);
									textArea.Caret.Column = col;
								} else {
									// textArea.EnableCutOrPaste already checked readonly for this case
									textArea.InsertString(text);
								}
							} finally {
								textArea.Document.UndoStack.EndUndoGroup();
							}
						}
					}
					return;
				} catch (ExternalException) {
					// GetDataObject does not provide RetryTimes parameter
					if (i > 5) throw;
				}
			}
		}
		
		public void Delete(object sender, EventArgs e)
		{
			new TextFileEdit.Actions.Delete().Execute(textArea);
		}
		
		public void SelectAll(object sender, EventArgs e)
		{
			new TextFileEdit.Actions.SelectWholeDocument().Execute(textArea);
		}
		
		protected virtual void OnCopyText(CopyTextEventArgs e)
		{
			if (CopyText != null) {
				CopyText(this, e);
			}
		}
		
		public event CopyTextEventHandler CopyText;
	}
	
	public delegate void CopyTextEventHandler(object sender, CopyTextEventArgs e);
	public class CopyTextEventArgs : EventArgs
	{
		string text;
		
		public string Text {
			get {
				return text;
			}
		}
		
		public CopyTextEventArgs(string text)
		{
			this.text = text;
		}
	}
}

#endif
// file ...\TextFileEdit\Gui\TextAreaControl.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 4888 $</version>
// </file>


namespace TextFileEdit
{
    /// <summary>
    /// This class paints the textarea.
    /// </summary>
    [ToolboxItem(false)]
    public class TextAreaControl : Panel
    {
        TextEditorControl motherTextEditorControl;
        
        HRuler     hRuler     = null;
        
        VScrollBar vScrollBar = new VScrollBar();
        HScrollBar hScrollBar = new HScrollBar();
        TextArea   textArea;
        bool       doHandleMousewheel = true;
        bool       disposed;
        
        public TextArea TextArea {
            get {
                return textArea;
            }
        }
        
        public TextFileEdit.Document.SelectionManager SelectionManager {
            get {
                return textArea.SelectionManager;
            }
        }
        
        public Caret Caret {
            get {
                return textArea.Caret;
            }
        }
        
        [Browsable(false)]
        public TextFileEdit.Document.IDocument Document {
            get {
                if (motherTextEditorControl != null)
                    return motherTextEditorControl.Document;
                return null;
            }
        }

        public TextFileEdit.Document.ITextEditorProperties TextEditorProperties
        {
            get {
                if (motherTextEditorControl != null)
                    return motherTextEditorControl.TextEditorProperties;
                return null;
            }
        }
        
        public VScrollBar VScrollBar {
            get {
                return vScrollBar;
            }
        }
        
        public HScrollBar HScrollBar {
            get {
                return hScrollBar;
            }
        }
        
        public bool DoHandleMousewheel {
            get {
                return doHandleMousewheel;
            }
            set {
                doHandleMousewheel = value;
            }
        }
        
        public TextAreaControl(TextEditorControl motherTextEditorControl)
        {
            this.motherTextEditorControl = motherTextEditorControl;
            
            this.textArea                = new TextArea(motherTextEditorControl, this);
            Controls.Add(textArea);
            
            vScrollBar.ValueChanged += new EventHandler(VScrollBarValueChanged);
            Controls.Add(this.vScrollBar);
            
            hScrollBar.ValueChanged += new EventHandler(HScrollBarValueChanged);
            Controls.Add(this.hScrollBar);
            ResizeRedraw = true;
            
            Document.TextContentChanged += DocumentTextContentChanged;
            Document.DocumentChanged += AdjustScrollBarsOnDocumentChange;
            Document.UpdateCommited  += DocumentUpdateCommitted;
        }
        
        protected override void Dispose(bool disposing)
        {
            if (disposing) {
                if (!disposed) {
                    disposed = true;
                    Document.TextContentChanged -= DocumentTextContentChanged;
                    Document.DocumentChanged -= AdjustScrollBarsOnDocumentChange;
                    Document.UpdateCommited  -= DocumentUpdateCommitted;
                    motherTextEditorControl = null;
                    if (vScrollBar != null) {
                        vScrollBar.Dispose();
                        vScrollBar = null;
                    }
                    if (hScrollBar != null) {
                        hScrollBar.Dispose();
                        hScrollBar = null;
                    }
                    if (hRuler != null) {
                        hRuler.Dispose();
                        hRuler = null;
                    }
                }
            }
            base.Dispose(disposing);
        }
        
        void DocumentTextContentChanged(object sender, EventArgs e)
        {
            // after the text content is changed abruptly, we need to validate the
            // caret position - otherwise the caret position is invalid for a short amount
            // of time, which can break client code that expects that the caret position is always valid
            Caret.ValidateCaretPos();
        }
        
        protected override void OnResize(System.EventArgs e)
        {
            base.OnResize(e);
            ResizeTextArea();
        }
        
        public void ResizeTextArea()
        {
            int y = 0;
            int h = 0;
            if (hRuler != null) {
                hRuler.Bounds = new Rectangle(0,
                                              0,
                                              Width - SystemInformation.HorizontalScrollBarArrowWidth,
                                              textArea.TextView.FontHeight);
                
                y = hRuler.Bounds.Bottom;
                h = hRuler.Bounds.Height;
            }
            
            textArea.Bounds = new Rectangle(0, y,
                                            Width - SystemInformation.HorizontalScrollBarArrowWidth,
                                            Height - SystemInformation.VerticalScrollBarArrowHeight - h);
            SetScrollBarBounds();
        }
        
        public void SetScrollBarBounds()
        {
            vScrollBar.Bounds = new Rectangle(textArea.Bounds.Right, 0, SystemInformation.HorizontalScrollBarArrowWidth, Height - SystemInformation.VerticalScrollBarArrowHeight);
            hScrollBar.Bounds = new Rectangle(0,
                                              textArea.Bounds.Bottom,
                                              Width - SystemInformation.HorizontalScrollBarArrowWidth,
                                              SystemInformation.VerticalScrollBarArrowHeight);
        }
        
        bool adjustScrollBarsOnNextUpdate;
        Point scrollToPosOnNextUpdate;
        
        void AdjustScrollBarsOnDocumentChange(object sender, TextFileEdit.Document.DocumentEventArgs e)
        {
            if (motherTextEditorControl.IsInUpdate == false) {
                AdjustScrollBarsClearCache();
                AdjustScrollBars();
            } else {
                adjustScrollBarsOnNextUpdate = true;
            }
        }
        
        void DocumentUpdateCommitted(object sender, EventArgs e)
        {
            if (motherTextEditorControl.IsInUpdate == false) {
                Caret.ValidateCaretPos();
                
                // AdjustScrollBarsOnCommittedUpdate
                if (!scrollToPosOnNextUpdate.IsEmpty) {
                    ScrollTo(scrollToPosOnNextUpdate.Y, scrollToPosOnNextUpdate.X);
                }
                if (adjustScrollBarsOnNextUpdate) {
                    AdjustScrollBarsClearCache();
                    AdjustScrollBars();
                }
            }
        }
        
        int[] lineLengthCache;
        const int LineLengthCacheAdditionalSize = 100;
        
        void AdjustScrollBarsClearCache()
        {
            if (lineLengthCache != null) {
                if (lineLengthCache.Length < this.Document.TotalNumberOfLines + 2 * LineLengthCacheAdditionalSize) {
                    lineLengthCache = null;
                } else {
                    Array.Clear(lineLengthCache, 0, lineLengthCache.Length);
                }
            }
        }
        
        public void AdjustScrollBars()
        {
            adjustScrollBarsOnNextUpdate = false;
            vScrollBar.Minimum = 0;
            // number of visible lines in document (folding!)
            vScrollBar.Maximum = textArea.MaxVScrollValue;
            int max = 0;
            
            int firstLine = textArea.TextView.FirstVisibleLine;
            int lastLine = this.Document.GetFirstLogicalLine(textArea.TextView.FirstPhysicalLine + textArea.TextView.VisibleLineCount);
            if (lastLine >= this.Document.TotalNumberOfLines)
                lastLine = this.Document.TotalNumberOfLines - 1;
            
            if (lineLengthCache == null || lineLengthCache.Length <= lastLine) {
                lineLengthCache = new int[lastLine + LineLengthCacheAdditionalSize];
            }
            
            for (int lineNumber = firstLine; lineNumber <= lastLine; lineNumber++) {
                TextFileEdit.Document.LineSegment lineSegment = this.Document.GetLineSegment(lineNumber);
                if (Document.FoldingManager.IsLineVisible(lineNumber)) {
                    if (lineLengthCache[lineNumber] > 0) {
                        max = Math.Max(max, lineLengthCache[lineNumber]);
                    } else {
                        int visualLength = textArea.TextView.GetVisualColumnFast(lineSegment, lineSegment.Length);
                        lineLengthCache[lineNumber] = Math.Max(1, visualLength);
                        max = Math.Max(max, visualLength);
                    }
                }
            }
            hScrollBar.Minimum = 0;
            hScrollBar.Maximum = (Math.Max(max + 20, textArea.TextView.VisibleColumnCount - 1));
            
            vScrollBar.LargeChange = Math.Max(0, textArea.TextView.DrawingPosition.Height);
            vScrollBar.SmallChange = Math.Max(0, textArea.TextView.FontHeight);
            
            hScrollBar.LargeChange = Math.Max(0, textArea.TextView.VisibleColumnCount - 1);
            hScrollBar.SmallChange = Math.Max(0, (int)textArea.TextView.SpaceWidth);
        }
        
        public void OptionsChanged()
        {
            textArea.OptionsChanged();
            
            if (textArea.TextEditorProperties.ShowHorizontalRuler) {
                if (hRuler == null) {
                    hRuler = new HRuler(textArea);
                    Controls.Add(hRuler);
                    ResizeTextArea();
                } else {
                    hRuler.Invalidate();
                }
            } else {
                if (hRuler != null) {
                    Controls.Remove(hRuler);
                    hRuler.Dispose();
                    hRuler = null;
                    ResizeTextArea();
                }
            }
            
            AdjustScrollBars();
        }
        
        void VScrollBarValueChanged(object sender, EventArgs e)
        {
            textArea.VirtualTop = new Point(textArea.VirtualTop.X, vScrollBar.Value);
            textArea.Invalidate();
            AdjustScrollBars();
        }
        
        void HScrollBarValueChanged(object sender, EventArgs e)
        {
            textArea.VirtualTop = new Point(hScrollBar.Value * textArea.TextView.WideSpaceWidth, textArea.VirtualTop.Y);
            textArea.Invalidate();
        }
        
        Util.MouseWheelHandler mouseWheelHandler = new Util.MouseWheelHandler();
        
        public void HandleMouseWheel(MouseEventArgs e)
        {
            int scrollDistance = mouseWheelHandler.GetScrollAmount(e);
            if (scrollDistance == 0)
                return;
            if ((Control.ModifierKeys & Keys.Control) != 0 && TextEditorProperties.MouseWheelTextZoom) {
                if (scrollDistance > 0) {
                    motherTextEditorControl.Font = new Font(motherTextEditorControl.Font.Name,
                                                            motherTextEditorControl.Font.Size + 1);
                } else {
                    motherTextEditorControl.Font = new Font(motherTextEditorControl.Font.Name,
                                                            Math.Max(6, motherTextEditorControl.Font.Size - 1));
                }
            } else {
                if (TextEditorProperties.MouseWheelScrollDown)
                    scrollDistance = -scrollDistance;
                int newValue = vScrollBar.Value + vScrollBar.SmallChange * scrollDistance;
                vScrollBar.Value = Math.Max(vScrollBar.Minimum, Math.Min(vScrollBar.Maximum - vScrollBar.LargeChange + 1, newValue));
            }
        }
        
        protected override void OnMouseWheel(MouseEventArgs e)
        {
            base.OnMouseWheel(e);
            if (DoHandleMousewheel) {
                HandleMouseWheel(e);
            }
        }
        
        public void ScrollToCaret()
        {
            ScrollTo(textArea.Caret.Line, textArea.Caret.Column);
        }
        
        public void ScrollTo(int line, int column)
        {
            if (motherTextEditorControl.IsInUpdate) {
                scrollToPosOnNextUpdate = new Point(column, line);
                return;
            } else {
                scrollToPosOnNextUpdate = Point.Empty;
            }
            
            ScrollTo(line);
            
            int curCharMin  = (int)(this.hScrollBar.Value - this.hScrollBar.Minimum);
            int curCharMax  = curCharMin + textArea.TextView.VisibleColumnCount;
            
            int pos = textArea.TextView.GetVisualColumn(line, column);
            
            if (textArea.TextView.VisibleColumnCount < 0) {
                hScrollBar.Value = 0;
            } else {
                if (pos < curCharMin) {
                    hScrollBar.Value = (int)(Math.Max(0, pos - scrollMarginHeight));
                } else {
                    if (pos > curCharMax) {
                        hScrollBar.Value = (int)Math.Max(0, Math.Min(hScrollBar.Maximum, (pos - textArea.TextView.VisibleColumnCount + scrollMarginHeight)));
                    }
                }
            }
        }
        
        int scrollMarginHeight  = 3;
        
        /// <summary>
        /// Ensure that <paramref name="line"/> is visible.
        /// </summary>
        public void ScrollTo(int line)
        {
            line = Math.Max(0, Math.Min(Document.TotalNumberOfLines - 1, line));
            line = Document.GetVisibleLine(line);
            int curLineMin = textArea.TextView.FirstPhysicalLine;
            if (textArea.TextView.LineHeightRemainder > 0) {
                curLineMin ++;
            }
            
            if (line - scrollMarginHeight + 3 < curLineMin) {
                this.vScrollBar.Value =  Math.Max(0, Math.Min(this.vScrollBar.Maximum, (line - scrollMarginHeight + 3) * textArea.TextView.FontHeight)) ;
                VScrollBarValueChanged(this, EventArgs.Empty);
            } else {
                int curLineMax = curLineMin + this.textArea.TextView.VisibleLineCount;
                if (line + scrollMarginHeight - 1 > curLineMax) {
                    if (this.textArea.TextView.VisibleLineCount == 1) {
                        this.vScrollBar.Value =  Math.Max(0, Math.Min(this.vScrollBar.Maximum, (line - scrollMarginHeight - 1) * textArea.TextView.FontHeight)) ;
                    } else {
                        this.vScrollBar.Value = Math.Min(this.vScrollBar.Maximum,
                                                         (line - this.textArea.TextView.VisibleLineCount + scrollMarginHeight - 1)* textArea.TextView.FontHeight) ;
                    }
                    VScrollBarValueChanged(this, EventArgs.Empty);
                }
            }
        }
        
        /// <summary>
        /// Scroll so that the specified line is centered.
        /// </summary>
        /// <param name="line">Line to center view on</param>
        /// <param name="treshold">If this action would cause scrolling by less than or equal to
        /// <paramref name="treshold"/> lines in any direction, don't scroll.
        /// Use -1 to always center the view.</param>
        public void CenterViewOn(int line, int treshold)
        {
            line = Math.Max(0, Math.Min(Document.TotalNumberOfLines - 1, line));
            // convert line to visible line:
            line = Document.GetVisibleLine(line);
            // subtract half the visible line count
            line -= textArea.TextView.VisibleLineCount / 2;
            
            int curLineMin = textArea.TextView.FirstPhysicalLine;
            if (textArea.TextView.LineHeightRemainder > 0) {
                curLineMin ++;
            }
            if (Math.Abs(curLineMin - line) > treshold) {
                // scroll:
                this.vScrollBar.Value =  Math.Max(0, Math.Min(this.vScrollBar.Maximum, (line - scrollMarginHeight + 3) * textArea.TextView.FontHeight)) ;
                VScrollBarValueChanged(this, EventArgs.Empty);
            }
        }
        
        public void JumpTo(int line)
        {
            line = Math.Max(0, Math.Min(line, Document.TotalNumberOfLines - 1));
            string text = Document.GetText(Document.GetLineSegment(line));
            JumpTo(line, text.Length - text.TrimStart().Length);
        }
        
        public void JumpTo(int line, int column)
        {
            textArea.Focus();
            textArea.SelectionManager.ClearSelection();
            textArea.Caret.Position = new TextLocation(column, line);
            textArea.SetDesiredColumn();
            ScrollToCaret();
        }
        
        public event MouseEventHandler ShowContextMenu;
        
        protected override void WndProc(ref Message m)
        {
            if (m.Msg == 0x007B) { // handle WM_CONTEXTMENU
                if (ShowContextMenu != null) {
                    long lParam = m.LParam.ToInt64();
                    int x = unchecked((short)(lParam & 0xffff));
                    int y = unchecked((short)((lParam & 0xffff0000) >> 16));
                    if (x == -1 && y == -1) {
                        Point pos = Caret.ScreenPosition;
                        ShowContextMenu(this, new MouseEventArgs(MouseButtons.None, 0, pos.X, pos.Y + textArea.TextView.FontHeight, 0));
                    } else {
                        Point pos = PointToClient(new Point(x, y));
                        ShowContextMenu(this, new MouseEventArgs(MouseButtons.Right, 1, pos.X, pos.Y, 0));
                    }
                }
            }
            base.WndProc(ref m);
        }
        
        protected override void OnEnter(EventArgs e)
        {
            // SD2-1072 - Make sure the caret line is valid if anyone
            // has handlers for the Enter event.
            Caret.ValidateCaretPos();
            base.OnEnter(e);
        }
    }
}

#endif
// file ...\TextFileEdit\Gui\TextAreaDragDropHandler.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3205 $</version>
// </file>


namespace TextFileEdit
{
    public class TextAreaDragDropHandler
    {
        public static Action<Exception> OnDragDropException = ex => MessageBox.Show(ex.ToString());
        
        TextArea textArea;
        
        public void Attach(TextArea textArea)
        {
            this.textArea = textArea;
            textArea.AllowDrop = true;
            
            textArea.DragEnter += MakeDragEventHandler(OnDragEnter);
            textArea.DragDrop  += MakeDragEventHandler(OnDragDrop);
            textArea.DragOver  += MakeDragEventHandler(OnDragOver);
        }
        
        /// <summary>
        /// Create a drag'n'drop event handler.
        /// Windows Forms swallows unhandled exceptions during drag'n'drop, so we report them here.
        /// </summary>
        static DragEventHandler MakeDragEventHandler(DragEventHandler h)
        {
            return (sender, e) => {
                try {
                    h(sender, e);
                } catch (Exception ex) {
                    OnDragDropException(ex);
                }
            };
        }
        
        static DragDropEffects GetDragDropEffect(DragEventArgs e)
        {
            if ((e.AllowedEffect & DragDropEffects.Move) > 0 &&
                (e.AllowedEffect & DragDropEffects.Copy) > 0) {
                return (e.KeyState & 8) > 0 ? DragDropEffects.Copy : DragDropEffects.Move;
            } else if ((e.AllowedEffect & DragDropEffects.Move) > 0) {
                return DragDropEffects.Move;
            } else if ((e.AllowedEffect & DragDropEffects.Copy) > 0) {
                return DragDropEffects.Copy;
            }
            return DragDropEffects.None;
        }
        
        protected void OnDragEnter(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(typeof(string))) {
                e.Effect = GetDragDropEffect(e);
            }
        }
        
        
        void InsertString(int offset, string str)
        {
            textArea.Document.Insert(offset, str);
            
            textArea.SelectionManager.SetSelection(new TextFileEdit.Document.DefaultSelection(textArea.Document,
                                                                        textArea.Document.OffsetToPosition(offset),
                                                                        textArea.Document.OffsetToPosition(offset + str.Length)));
            textArea.Caret.Position = textArea.Document.OffsetToPosition(offset + str.Length);
            textArea.Refresh();
        }
        
        protected void OnDragDrop(object sender, DragEventArgs e)
        {
            Point p = textArea.PointToClient(new Point(e.X, e.Y));
            
            if (e.Data.GetDataPresent(typeof(string))) {
                textArea.BeginUpdate();
                textArea.Document.UndoStack.StartUndoGroup();
                try {
                    int offset = textArea.Caret.Offset;
                    if (textArea.IsReadOnly(offset)) {
                        // prevent dragging text into readonly section
                        return;
                    }
                    if (e.Data.GetDataPresent(typeof(TextFileEdit.Document.DefaultSelection))) {
                        TextFileEdit.Document.ISelection sel = (TextFileEdit.Document.ISelection)e.Data.GetData(typeof(TextFileEdit.Document.DefaultSelection));
                        if (sel.ContainsPosition(textArea.Caret.Position)) {
                            return;
                        }
                        if (GetDragDropEffect(e) == DragDropEffects.Move) {
                            if (TextFileEdit.Document.SelectionManager.SelectionIsReadOnly(textArea.Document, sel))
                            {
                                // prevent dragging text out of readonly section
                                return;
                            }
                            int len = sel.Length;
                            textArea.Document.Remove(sel.Offset, len);
                            if (sel.Offset < offset) {
                                offset -= len;
                            }
                        }
                    }
                    textArea.SelectionManager.ClearSelection();
                    InsertString(offset, (string)e.Data.GetData(typeof(string)));
                    textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.WholeTextArea));
                } finally {
                    textArea.Document.UndoStack.EndUndoGroup();
                    textArea.EndUpdate();
                }
            }
        }
        
        protected void OnDragOver(object sender, DragEventArgs e)
        {
            if (!textArea.Focused) {
                textArea.Focus();
            }
            
            Point p = textArea.PointToClient(new Point(e.X, e.Y));
            
            if (textArea.TextView.DrawingPosition.Contains(p.X, p.Y)) {
                TextLocation realmousepos= textArea.TextView.GetLogicalPosition(p.X - textArea.TextView.DrawingPosition.X,
                                                                                p.Y - textArea.TextView.DrawingPosition.Y);
                int lineNr = Math.Min(textArea.Document.TotalNumberOfLines - 1, Math.Max(0, realmousepos.Y));
                
                textArea.Caret.Position = new TextLocation(realmousepos.X, lineNr);
                textArea.SetDesiredColumn();
                if (e.Data.GetDataPresent(typeof(string)) && !textArea.IsReadOnly(textArea.Caret.Offset)) {
                    e.Effect = GetDragDropEffect(e);
                } else {
                    e.Effect = DragDropEffects.None;
                }
            } else {
                e.Effect = DragDropEffects.None;
            }
        }
    }
}

#endif
// file ...\TextFileEdit\Gui\TextAreaMouseHandler.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3786 $</version>
// </file>


namespace TextFileEdit
{
    /// <summary>
    /// This class handles all mouse stuff for a textArea.
    /// </summary>
    public class TextAreaMouseHandler
    {
        TextArea textArea;
        bool doubleclick = false;
        bool clickedOnSelectedText = false;

        System.Windows.Forms.MouseButtons button;

        static readonly Point nilPoint = new Point(-1, -1);
        Point mousedownpos = nilPoint;
        Point lastmousedownpos = nilPoint;

        bool gotmousedown = false;
        bool dodragdrop = false;

        public TextAreaMouseHandler(TextArea ttextArea)
        {
            textArea = ttextArea;
        }

        public void Attach()
        {
            textArea.Click += new EventHandler(TextAreaClick);
            textArea.MouseMove += new System.Windows.Forms.MouseEventHandler(TextAreaMouseMove);

            textArea.MouseDown += new System.Windows.Forms.MouseEventHandler(OnMouseDown);
            textArea.DoubleClick += new EventHandler(OnDoubleClick);
            textArea.MouseLeave += new EventHandler(OnMouseLeave);
            textArea.MouseUp += new System.Windows.Forms.MouseEventHandler(OnMouseUp);
            textArea.LostFocus += new EventHandler(TextAreaLostFocus);
            textArea.ToolTipRequest += new ToolTipRequestEventHandler(OnToolTipRequest);
        }

        void OnToolTipRequest(object sender, ToolTipRequestEventArgs e)
        {
            if (e.ToolTipShown)
                return;
            Point mousepos = e.MousePosition;
            TextFileEdit.Document.FoldMarker marker = textArea.TextView.GetFoldMarkerFromPosition(mousepos.X - textArea.TextView.DrawingPosition.X,
                                                                            mousepos.Y - textArea.TextView.DrawingPosition.Y);
            if (marker != null && marker.IsFolded)
            {
                StringBuilder sb = new StringBuilder(marker.InnerText);

                // max 10 lines
                int endLines = 0;
                for (int i = 0; i < sb.Length; ++i)
                {
                    if (sb[i] == '\n')
                    {
                        ++endLines;
                        if (endLines >= 10)
                        {
                            sb.Remove(i + 1, sb.Length - i - 1);
                            sb.Append(Environment.NewLine);
                            sb.Append("...");
                            break;

                        }
                    }
                }
                sb.Replace("\t", "    ");
                e.ShowToolTip(sb.ToString());
                return;
            }

            List<TextFileEdit.Document.TextMarker> markers = textArea.Document.MarkerStrategy.GetMarkers(e.LogicalPosition);
            foreach (TextFileEdit.Document.TextMarker tm in markers)
            {
                if (tm.ToolTip != null)
                {
                    e.ShowToolTip(tm.ToolTip.Replace("\t", "    "));
                    return;
                }
            }
        }

        void ShowHiddenCursorIfMovedOrLeft()
        {
            textArea.ShowHiddenCursor(!textArea.Focused ||
                                      !textArea.ClientRectangle.Contains(textArea.PointToClient(System.Windows.Forms.Cursor.Position)));
        }

        void TextAreaLostFocus(object sender, EventArgs e)
        {
            // The call to ShowHiddenCursorIfMovedOrLeft is delayed
            // until pending messages have been processed
            // so that it can properly detect whether the TextArea
            // has really lost focus.
            // For example, the CodeCompletionWindow gets focus when it is shown,
            // but immediately gives back focus to the TextArea.
            textArea.BeginInvoke(new System.Windows.Forms.MethodInvoker(ShowHiddenCursorIfMovedOrLeft));
        }

        void OnMouseLeave(object sender, EventArgs e)
        {
            ShowHiddenCursorIfMovedOrLeft();
            gotmousedown = false;
            mousedownpos = nilPoint;
        }

        void OnMouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            textArea.SelectionManager.selectFrom.where = TextFileEdit.Document.WhereFrom.None;
            gotmousedown = false;
            mousedownpos = nilPoint;
        }

        void TextAreaClick(object sender, EventArgs e)
        {
            Point mousepos;
            mousepos = textArea.mousepos;

            if (dodragdrop)
            {
                return;
            }

            if (clickedOnSelectedText && textArea.TextView.DrawingPosition.Contains(mousepos.X, mousepos.Y))
            {
                textArea.SelectionManager.ClearSelection();

                TextLocation clickPosition = textArea.TextView.GetLogicalPosition(
                    mousepos.X - textArea.TextView.DrawingPosition.X,
                    mousepos.Y - textArea.TextView.DrawingPosition.Y);
                textArea.Caret.Position = clickPosition;
                textArea.SetDesiredColumn();
            }
        }


        void TextAreaMouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            textArea.mousepos = e.Location;

            // honour the starting selection strategy
            switch (textArea.SelectionManager.selectFrom.where)
            {
                case TextFileEdit.Document.WhereFrom.Gutter:
                    ExtendSelectionToMouse();
                    return;

                case TextFileEdit.Document.WhereFrom.TArea:
                    break;

            }
            textArea.ShowHiddenCursor(false);
            if (dodragdrop)
            {
                dodragdrop = false;
                return;
            }

            doubleclick = false;
            textArea.mousepos = new Point(e.X, e.Y);

            if (clickedOnSelectedText)
            {
                if (Math.Abs(mousedownpos.X - e.X) >= System.Windows.Forms.SystemInformation.DragSize.Width / 2 ||
                    Math.Abs(mousedownpos.Y - e.Y) >= System.Windows.Forms.SystemInformation.DragSize.Height / 2)
                {
                    clickedOnSelectedText = false;
                    TextFileEdit.Document.ISelection selection = textArea.SelectionManager.GetSelectionAt(textArea.Caret.Offset);
                    if (selection != null)
                    {
                        string text = selection.SelectedText;
                        bool isReadOnly = TextFileEdit.Document.SelectionManager.SelectionIsReadOnly(textArea.Document, selection);
                        if (text != null && text.Length > 0)
                        {
                            System.Windows.Forms.DataObject dataObject = new System.Windows.Forms.DataObject();
                            dataObject.SetData(System.Windows.Forms.DataFormats.UnicodeText, true, text);
                            dataObject.SetData(selection);
                            dodragdrop = true;
                            textArea.DoDragDrop(dataObject, isReadOnly ? System.Windows.Forms.DragDropEffects.All & ~System.Windows.Forms.DragDropEffects.Move : System.Windows.Forms.DragDropEffects.All);
                        }
                    }
                }

                return;
            }

            if (e.Button == System.Windows.Forms.MouseButtons.Left)
            {
                if (gotmousedown && textArea.SelectionManager.selectFrom.where == TextFileEdit.Document.WhereFrom.TArea)
                {
                    ExtendSelectionToMouse();
                }
            }
        }

        void ExtendSelectionToMouse()
        {
            Point mousepos;
            mousepos = textArea.mousepos;
            TextLocation realmousepos = textArea.TextView.GetLogicalPosition(
                Math.Max(0, mousepos.X - textArea.TextView.DrawingPosition.X),
                mousepos.Y - textArea.TextView.DrawingPosition.Y);
            int y = realmousepos.Y;
            realmousepos = textArea.Caret.ValidatePosition(realmousepos);
            TextLocation oldPos = textArea.Caret.Position;
            if (oldPos == realmousepos && textArea.SelectionManager.selectFrom.where != TextFileEdit.Document.WhereFrom.Gutter)
            {
                return;
            }

            // the selection is from the gutter
            if (textArea.SelectionManager.selectFrom.where == TextFileEdit.Document.WhereFrom.Gutter)
            {
                if (realmousepos.Y < textArea.SelectionManager.SelectionStart.Y)
                {
                    // the selection has moved above the startpoint
                    textArea.Caret.Position = new TextLocation(0, realmousepos.Y);
                }
                else
                {
                    // the selection has moved below the startpoint
                    textArea.Caret.Position = textArea.SelectionManager.NextValidPosition(realmousepos.Y);
                }
            }
            else
            {
                textArea.Caret.Position = realmousepos;
            }

            // moves selection across whole words for double-click initiated selection
            if (!minSelection.IsEmpty && textArea.SelectionManager.SelectionCollection.Count > 0 && textArea.SelectionManager.selectFrom.where == TextFileEdit.Document.WhereFrom.TArea)
            {
                // Extend selection when selection was started with double-click
                TextFileEdit.Document.ISelection selection = textArea.SelectionManager.SelectionCollection[0];
                TextLocation min = textArea.SelectionManager.GreaterEqPos(minSelection, maxSelection) ? maxSelection : minSelection;
                TextLocation max = textArea.SelectionManager.GreaterEqPos(minSelection, maxSelection) ? minSelection : maxSelection;
                if (textArea.SelectionManager.GreaterEqPos(max, realmousepos) && textArea.SelectionManager.GreaterEqPos(realmousepos, min))
                {
                    textArea.SelectionManager.SetSelection(min, max);
                }
                else if (textArea.SelectionManager.GreaterEqPos(max, realmousepos))
                {
                    int moff = textArea.Document.PositionToOffset(realmousepos);
                    min = textArea.Document.OffsetToPosition(FindWordStart(textArea.Document, moff));
                    textArea.SelectionManager.SetSelection(min, max);
                }
                else
                {
                    int moff = textArea.Document.PositionToOffset(realmousepos);
                    max = textArea.Document.OffsetToPosition(FindWordEnd(textArea.Document, moff));
                    textArea.SelectionManager.SetSelection(min, max);
                }
            }
            else
            {
                textArea.SelectionManager.ExtendSelection(oldPos, textArea.Caret.Position);
            }
            textArea.SetDesiredColumn();
        }

        void DoubleClickSelectionExtend()
        {
            Point mousepos;
            mousepos = textArea.mousepos;

            textArea.SelectionManager.ClearSelection();
            if (textArea.TextView.DrawingPosition.Contains(mousepos.X, mousepos.Y))
            {
                TextFileEdit.Document.FoldMarker marker = textArea.TextView.GetFoldMarkerFromPosition(mousepos.X - textArea.TextView.DrawingPosition.X,
                                                                                mousepos.Y - textArea.TextView.DrawingPosition.Y);
                if (marker != null && marker.IsFolded)
                {
                    marker.IsFolded = false;
                    textArea.MotherTextAreaControl.AdjustScrollBars();
                }
                if (textArea.Caret.Offset < textArea.Document.TextLength)
                {
                    switch (textArea.Document.GetCharAt(textArea.Caret.Offset))
                    {
                        case '"':
                            if (textArea.Caret.Offset < textArea.Document.TextLength)
                            {
                                int next = FindNext(textArea.Document, textArea.Caret.Offset + 1, '"');
                                minSelection = textArea.Caret.Position;
                                if (next > textArea.Caret.Offset && next < textArea.Document.TextLength)
                                    next += 1;
                                maxSelection = textArea.Document.OffsetToPosition(next);
                            }
                            break;
                        default:
                            minSelection = textArea.Document.OffsetToPosition(FindWordStart(textArea.Document, textArea.Caret.Offset));
                            maxSelection = textArea.Document.OffsetToPosition(FindWordEnd(textArea.Document, textArea.Caret.Offset));
                            break;

                    }
                    textArea.Caret.Position = maxSelection;
                    textArea.SelectionManager.ExtendSelection(minSelection, maxSelection);
                }

                if (textArea.SelectionManager.selectionCollection.Count > 0)
                {
                    TextFileEdit.Document.ISelection selection = textArea.SelectionManager.selectionCollection[0];

                    selection.StartPosition = minSelection;
                    selection.EndPosition = maxSelection;
                    textArea.SelectionManager.SelectionStart = minSelection;
                }

                // after a double-click selection, the caret is placed correctly,
                // but it is not positioned internally.  The effect is when the cursor
                // is moved up or down a line, the caret will take on the column first
                // clicked on for the double-click
                textArea.SetDesiredColumn();

                // HA-CK WARNING !!!
                // must refresh here, because when a error tooltip is showed and the underlined
                // code is double clicked the textArea don't update corrctly, updateline doesn't
                // work ... but the refresh does.
                // Mike
                textArea.Refresh();
            }
        }

        void OnMouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            Point mousepos;
            textArea.mousepos = e.Location;
            mousepos = e.Location;

            if (dodragdrop)
            {
                return;
            }

            if (doubleclick)
            {
                doubleclick = false;
                return;
            }

            if (textArea.TextView.DrawingPosition.Contains(mousepos.X, mousepos.Y))
            {
                gotmousedown = true;
                textArea.SelectionManager.selectFrom.where = TextFileEdit.Document.WhereFrom.TArea;
                button = e.Button;

                // double-click
                if (button == System.Windows.Forms.MouseButtons.Left && e.Clicks == 2)
                {
                    int deltaX = Math.Abs(lastmousedownpos.X - e.X);
                    int deltaY = Math.Abs(lastmousedownpos.Y - e.Y);
                    if (deltaX <= System.Windows.Forms.SystemInformation.DoubleClickSize.Width &&
                        deltaY <= System.Windows.Forms.SystemInformation.DoubleClickSize.Height)
                    {
                        DoubleClickSelectionExtend();
                        lastmousedownpos = new Point(e.X, e.Y);

                        if (textArea.SelectionManager.selectFrom.where == TextFileEdit.Document.WhereFrom.Gutter)
                        {
                            if (!minSelection.IsEmpty && !maxSelection.IsEmpty && textArea.SelectionManager.SelectionCollection.Count > 0)
                            {
                                textArea.SelectionManager.SelectionCollection[0].StartPosition = minSelection;
                                textArea.SelectionManager.SelectionCollection[0].EndPosition = maxSelection;
                                textArea.SelectionManager.SelectionStart = minSelection;

                                minSelection = TextLocation.Empty;
                                maxSelection = TextLocation.Empty;
                            }
                        }
                        return;
                    }
                }
                minSelection = TextLocation.Empty;
                maxSelection = TextLocation.Empty;

                lastmousedownpos = mousedownpos = new Point(e.X, e.Y);

                if (button == System.Windows.Forms.MouseButtons.Left)
                {
                    TextFileEdit.Document.FoldMarker marker = textArea.TextView.GetFoldMarkerFromPosition(mousepos.X - textArea.TextView.DrawingPosition.X,
                                                                                    mousepos.Y - textArea.TextView.DrawingPosition.Y);
                    if (marker != null && marker.IsFolded)
                    {
                        if (textArea.SelectionManager.HasSomethingSelected)
                        {
                            clickedOnSelectedText = true;
                        }

                        TextLocation startLocation = new TextLocation(marker.StartColumn, marker.StartLine);
                        TextLocation endLocation = new TextLocation(marker.EndColumn, marker.EndLine);
                        textArea.SelectionManager.SetSelection(new TextFileEdit.Document.DefaultSelection(textArea.TextView.Document, startLocation, endLocation));
                        textArea.Caret.Position = startLocation;
                        textArea.SetDesiredColumn();
                        textArea.Focus();
                        return;
                    }

                    if ((System.Windows.Forms.Control.ModifierKeys & System.Windows.Forms.Keys.Shift) == System.Windows.Forms.Keys.Shift)
                    {
                        ExtendSelectionToMouse();
                    }
                    else
                    {
                        TextLocation realmousepos = textArea.TextView.GetLogicalPosition(mousepos.X - textArea.TextView.DrawingPosition.X, mousepos.Y - textArea.TextView.DrawingPosition.Y);
                        clickedOnSelectedText = false;

                        int offset = textArea.Document.PositionToOffset(realmousepos);

                        if (textArea.SelectionManager.HasSomethingSelected &&
                            textArea.SelectionManager.IsSelected(offset))
                        {
                            clickedOnSelectedText = true;
                        }
                        else
                        {
                            textArea.SelectionManager.ClearSelection();
                            if (mousepos.Y > 0 && mousepos.Y < textArea.TextView.DrawingPosition.Height)
                            {
                                TextLocation pos = new TextLocation();
                                pos.Y = Math.Min(textArea.Document.TotalNumberOfLines - 1, realmousepos.Y);
                                pos.X = realmousepos.X;
                                textArea.Caret.Position = pos;
                                textArea.SetDesiredColumn();
                            }
                        }
                    }
                }
                else if (button == System.Windows.Forms.MouseButtons.Right)
                {
                    // Rightclick sets the cursor to the click position unless
                    // the previous selection was clicked
                    TextLocation realmousepos = textArea.TextView.GetLogicalPosition(mousepos.X - textArea.TextView.DrawingPosition.X, mousepos.Y - textArea.TextView.DrawingPosition.Y);
                    int offset = textArea.Document.PositionToOffset(realmousepos);
                    if (!textArea.SelectionManager.HasSomethingSelected ||
                        !textArea.SelectionManager.IsSelected(offset))
                    {
                        textArea.SelectionManager.ClearSelection();
                        if (mousepos.Y > 0 && mousepos.Y < textArea.TextView.DrawingPosition.Height)
                        {
                            TextLocation pos = new TextLocation();
                            pos.Y = Math.Min(textArea.Document.TotalNumberOfLines - 1, realmousepos.Y);
                            pos.X = realmousepos.X;
                            textArea.Caret.Position = pos;
                            textArea.SetDesiredColumn();
                        }
                    }
                }
            }
            textArea.Focus();
        }

        int FindNext(TextFileEdit.Document.IDocument document, int offset, char ch)
        {
            TextFileEdit.Document.LineSegment line = document.GetLineSegmentForOffset(offset);
            int endPos = line.Offset + line.Length;

            while (offset < endPos && document.GetCharAt(offset) != ch)
            {
                ++offset;
            }
            return offset;
        }

        bool IsSelectableChar(char ch)
        {
            return Char.IsLetterOrDigit(ch) || ch == '_';
        }

        int FindWordStart(TextFileEdit.Document.IDocument document, int offset)
        {
            TextFileEdit.Document.LineSegment line = document.GetLineSegmentForOffset(offset);

            if (offset > 0 && Char.IsWhiteSpace(document.GetCharAt(offset - 1)) && Char.IsWhiteSpace(document.GetCharAt(offset)))
            {
                while (offset > line.Offset && Char.IsWhiteSpace(document.GetCharAt(offset - 1)))
                {
                    --offset;
                }
            }
            else if (IsSelectableChar(document.GetCharAt(offset)) || (offset > 0 && Char.IsWhiteSpace(document.GetCharAt(offset)) && IsSelectableChar(document.GetCharAt(offset - 1))))
            {
                while (offset > line.Offset && IsSelectableChar(document.GetCharAt(offset - 1)))
                {
                    --offset;
                }
            }
            else
            {
                if (offset > 0 && !Char.IsWhiteSpace(document.GetCharAt(offset - 1)) && !IsSelectableChar(document.GetCharAt(offset - 1)))
                {
                    return Math.Max(0, offset - 1);
                }
            }
            return offset;
        }

        int FindWordEnd(TextFileEdit.Document.IDocument document, int offset)
        {
            TextFileEdit.Document.LineSegment line = document.GetLineSegmentForOffset(offset);
            if (line.Length == 0)
                return offset;
            int endPos = line.Offset + line.Length;
            offset = Math.Min(offset, endPos - 1);

            if (IsSelectableChar(document.GetCharAt(offset)))
            {
                while (offset < endPos && IsSelectableChar(document.GetCharAt(offset)))
                {
                    ++offset;
                }
            }
            else if (Char.IsWhiteSpace(document.GetCharAt(offset)))
            {
                if (offset > 0 && Char.IsWhiteSpace(document.GetCharAt(offset - 1)))
                {
                    while (offset < endPos && Char.IsWhiteSpace(document.GetCharAt(offset)))
                    {
                        ++offset;
                    }
                }
            }
            else
            {
                return Math.Max(0, offset + 1);
            }

            return offset;
        }
        TextLocation minSelection = TextLocation.Empty;
        TextLocation maxSelection = TextLocation.Empty;

        void OnDoubleClick(object sender, System.EventArgs e)
        {
            if (dodragdrop)
            {
                return;
            }

            textArea.SelectionManager.selectFrom.where = TextFileEdit.Document.WhereFrom.TArea;
            doubleclick = true;

        }
    }
}

#endif
// file ...\TextFileEdit\Gui\TextAreaUpdate.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2659 $</version>
// </file>


namespace TextFileEdit
{
	/// <summary>
	/// This enum describes all implemented request types
	/// </summary>
	public enum TextAreaUpdateType {
		WholeTextArea,
		SingleLine,
		SinglePosition,
		PositionToLineEnd,
		PositionToEnd,
		LinesBetween
	}
	
	/// <summary>
	/// This class is used to request an update of the textarea
	/// </summary>
	public class TextAreaUpdate
	{
		TextLocation position;
		TextAreaUpdateType type;
		
		public TextAreaUpdateType TextAreaUpdateType {
			get {
				return type;
			}
		}
		
		public TextLocation Position {
			get {
				return position;
			}
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="TextAreaUpdate"/>
		/// </summary>
		public TextAreaUpdate(TextAreaUpdateType type)
		{
			this.type = type;
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="TextAreaUpdate"/>
		/// </summary>
		public TextAreaUpdate(TextAreaUpdateType type, TextLocation position)
		{
			this.type     = type;
			this.position = position;
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="TextAreaUpdate"/>
		/// </summary>
		public TextAreaUpdate(TextAreaUpdateType type, int startLine, int endLine)
		{
			this.type     = type;
			this.position = new TextLocation(startLine, endLine);
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="TextAreaUpdate"/>
		/// </summary>
		public TextAreaUpdate(TextAreaUpdateType type, int singleLine)
		{
			this.type     = type;
			this.position = new TextLocation(0, singleLine);
		}
		
		public override string ToString()
		{
			return String.Format("[TextAreaUpdate: Type={0}, Position={1}]", type, position);
		}
	}
}

#endif
// file ...\TextFileEdit\Gui\TextEditorControl.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 4081 $</version>
// </file>


namespace TextFileEdit
{
    /// <summary>
    /// This class is used for a basic text area control
    /// </summary>
    [ToolboxBitmap(typeof(TextEditorControl), "Resources.TextEditorControl.bmp")]
    [ToolboxItem(true)]
    public class TextEditorControl : TextEditorControlBase
    {
        protected Panel textAreaPanel     = new Panel();
        TextAreaControl primaryTextArea;
        Splitter        textAreaSplitter  = null;
        TextAreaControl secondaryTextArea = null;
        
        PrintDocument   printDocument = null;
        
        [Browsable(false)]
        public PrintDocument PrintDocument {
            get {
                if (printDocument == null) {
                    printDocument = new PrintDocument();
                    printDocument.BeginPrint += new PrintEventHandler(this.BeginPrint);
                    printDocument.PrintPage  += new PrintPageEventHandler(this.PrintPage);
                }
                return printDocument;
            }
        }
        
        TextAreaControl activeTextAreaControl;
        
        public override TextAreaControl ActiveTextAreaControl {
            get {
                return activeTextAreaControl;
            }
        }
        
        protected void SetActiveTextAreaControl(TextAreaControl value)
        {
            if (activeTextAreaControl != value) {
                activeTextAreaControl = value;
                
                if (ActiveTextAreaControlChanged != null) {
                    ActiveTextAreaControlChanged(this, EventArgs.Empty);
                }
            }
        }
        
        public event EventHandler ActiveTextAreaControlChanged;
        
        public TextEditorControl()
        {
            SetStyle(ControlStyles.ContainerControl, true);
            
            textAreaPanel.Dock = DockStyle.Fill;

            Document = (new TextFileEdit.Document.DocumentFactory()).CreateDocument();
            Document.HighlightingStrategy = TextFileEdit.Document.HighlightingStrategyFactory.CreateHighlightingStrategy();
            
            primaryTextArea  = new TextAreaControl(this);
            activeTextAreaControl = primaryTextArea;
            primaryTextArea.TextArea.GotFocus += delegate {
                SetActiveTextAreaControl(primaryTextArea);
            };
            primaryTextArea.Dock = DockStyle.Fill;
            textAreaPanel.Controls.Add(primaryTextArea);
            InitializeTextAreaControl(primaryTextArea);
            Controls.Add(textAreaPanel);
            ResizeRedraw = true;
            Document.UpdateCommited += new EventHandler(CommitUpdateRequested);
            OptionsChanged();
        }
        
        protected virtual void InitializeTextAreaControl(TextAreaControl newControl)
        {
        }
        
        public override void OptionsChanged()
        {
            primaryTextArea.OptionsChanged();
            if (secondaryTextArea != null) {
                secondaryTextArea.OptionsChanged();
            }
        }
        
        public void Split()
        {
            if (secondaryTextArea == null) {
                secondaryTextArea = new TextAreaControl(this);
                secondaryTextArea.Dock = DockStyle.Bottom;
                secondaryTextArea.Height = Height / 2;
                
                secondaryTextArea.TextArea.GotFocus += delegate {
                    SetActiveTextAreaControl(secondaryTextArea);
                };
                
                textAreaSplitter =  new Splitter();
                textAreaSplitter.BorderStyle = BorderStyle.FixedSingle ;
                textAreaSplitter.Height = 8;
                textAreaSplitter.Dock = DockStyle.Bottom;
                textAreaPanel.Controls.Add(textAreaSplitter);
                textAreaPanel.Controls.Add(secondaryTextArea);
                InitializeTextAreaControl(secondaryTextArea);
                secondaryTextArea.OptionsChanged();
            } else {
                SetActiveTextAreaControl(primaryTextArea);
                
                textAreaPanel.Controls.Remove(secondaryTextArea);
                textAreaPanel.Controls.Remove(textAreaSplitter);
                
                secondaryTextArea.Dispose();
                textAreaSplitter.Dispose();
                secondaryTextArea = null;
                textAreaSplitter  = null;
            }
        }
        
        [Browsable(false)]
        public bool EnableUndo {
            get {
                return Document.UndoStack.CanUndo;
            }
        }
        
        [Browsable(false)]
        public bool EnableRedo {
            get {
                return Document.UndoStack.CanRedo;
            }
        }

        public void Undo()
        {
            if (Document.ReadOnly)
            {
                return;
            }
            if (Document.UndoStack.CanUndo) {
                BeginUpdate();
                Document.UndoStack.Undo();
                
                Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.WholeTextArea));
                this.primaryTextArea.TextArea.UpdateMatchingBracket();
                if (secondaryTextArea != null) {
                    this.secondaryTextArea.TextArea.UpdateMatchingBracket();
                }
                EndUpdate();
            }
        }
        
        public void Redo()
        {
            if (Document.ReadOnly) {
                return;
            }
            if (Document.UndoStack.CanRedo) {
                BeginUpdate();
                Document.UndoStack.Redo();
                
                Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.WholeTextArea));
                this.primaryTextArea.TextArea.UpdateMatchingBracket();
                if (secondaryTextArea != null) {
                    this.secondaryTextArea.TextArea.UpdateMatchingBracket();
                }
                EndUpdate();
            }
        }
        
        public virtual void SetHighlighting(string name)
        {
            Document.HighlightingStrategy = TextFileEdit.Document.HighlightingStrategyFactory.CreateHighlightingStrategy(name);
        }
        
        protected override void Dispose(bool disposing)
        {
            if (disposing) {
                if (printDocument != null) {
                    printDocument.BeginPrint -= new PrintEventHandler(this.BeginPrint);
                    printDocument.PrintPage  -= new PrintPageEventHandler(this.PrintPage);
                    printDocument = null;
                }
                Document.UndoStack.ClearAll();
                Document.UpdateCommited -= new EventHandler(CommitUpdateRequested);
                if (textAreaPanel != null) {
                    if (secondaryTextArea != null) {
                        secondaryTextArea.Dispose();
                        textAreaSplitter.Dispose();
                        secondaryTextArea = null;
                        textAreaSplitter  = null;
                    }
                    if (primaryTextArea != null) {
                        primaryTextArea.Dispose();
                    }
                    textAreaPanel.Dispose();
                    textAreaPanel = null;
                }
            }
            base.Dispose(disposing);
        }
        
#region Update Methods
        public override void EndUpdate()
        {
            base.EndUpdate();
            Document.CommitUpdate();
            if (!IsInUpdate) {
                ActiveTextAreaControl.Caret.OnEndUpdate();
            }
        }
        
        void CommitUpdateRequested(object sender, EventArgs e)
        {
            if (IsInUpdate) {
                return;
            }
            foreach (TextAreaUpdate update in Document.UpdateQueue) {
                switch (update.TextAreaUpdateType) {
                    case TextAreaUpdateType.PositionToEnd:
                        this.primaryTextArea.TextArea.UpdateToEnd(update.Position.Y);
                        if (this.secondaryTextArea != null) {
                            this.secondaryTextArea.TextArea.UpdateToEnd(update.Position.Y);
                        }
                        break;
                    case TextAreaUpdateType.PositionToLineEnd:
                    case TextAreaUpdateType.SingleLine:
                        this.primaryTextArea.TextArea.UpdateLine(update.Position.Y);
                        if (this.secondaryTextArea != null) {
                            this.secondaryTextArea.TextArea.UpdateLine(update.Position.Y);
                        }
                        break;
                    case TextAreaUpdateType.SinglePosition:
                        this.primaryTextArea.TextArea.UpdateLine(update.Position.Y, update.Position.X, update.Position.X);
                        if (this.secondaryTextArea != null) {
                            this.secondaryTextArea.TextArea.UpdateLine(update.Position.Y, update.Position.X, update.Position.X);
                        }
                        break;
                    case TextAreaUpdateType.LinesBetween:
                        this.primaryTextArea.TextArea.UpdateLines(update.Position.X, update.Position.Y);
                        if (this.secondaryTextArea != null) {
                            this.secondaryTextArea.TextArea.UpdateLines(update.Position.X, update.Position.Y);
                        }
                        break;
                    case TextAreaUpdateType.WholeTextArea:
                        this.primaryTextArea.TextArea.Invalidate();
                        if (this.secondaryTextArea != null) {
                            this.secondaryTextArea.TextArea.Invalidate();
                        }
                        break;
                }
            }
            Document.UpdateQueue.Clear();
//          this.primaryTextArea.TextArea.Update();
//          if (this.secondaryTextArea != null) {
//              this.secondaryTextArea.TextArea.Update();
//          }
        }
#endregion
        
#region Printing routines
        int          curLineNr = 0;
        float        curTabIndent = 0;
        StringFormat printingStringFormat;
        
        void BeginPrint(object sender, PrintEventArgs ev)
        {
            curLineNr = 0;
            printingStringFormat = (StringFormat)System.Drawing.StringFormat.GenericTypographic.Clone();
            
            // 100 should be enough for everyone ...err ?
            float[] tabStops = new float[100];
            for (int i = 0; i < tabStops.Length; ++i) {
                tabStops[i] = TabIndent * primaryTextArea.TextArea.TextView.WideSpaceWidth;
            }
            
            printingStringFormat.SetTabStops(0, tabStops);
        }
        
        void Advance(ref float x, ref float y, float maxWidth, float size, float fontHeight)
        {
            if (x + size < maxWidth) {
                x += size;
            } else {
                x  = curTabIndent;
                y += fontHeight;
            }
        }
        
        // btw. I hate source code duplication ... but this time I don't care !!!!
        float MeasurePrintingHeight(Graphics g, TextFileEdit.Document.LineSegment line, float maxWidth)
        {
            float xPos = 0;
            float yPos = 0;
            float fontHeight = Font.GetHeight(g);
//          bool  gotNonWhitespace = false;
            curTabIndent = 0;
            TextFileEdit.Document.FontContainer fontContainer = TextEditorProperties.FontContainer;
            foreach (TextFileEdit.Document.TextWord word in line.Words) {
                switch (word.Type) {
                    case TextFileEdit.Document.TextWordType.Space:
                        Advance(ref xPos, ref yPos, maxWidth, primaryTextArea.TextArea.TextView.SpaceWidth, fontHeight);
//                      if (!gotNonWhitespace) {
//                          curTabIndent = xPos;
//                      }
                        break;
                    case TextFileEdit.Document.TextWordType.Tab:
                        Advance(ref xPos, ref yPos, maxWidth, TabIndent * primaryTextArea.TextArea.TextView.WideSpaceWidth, fontHeight);
//                      if (!gotNonWhitespace) {
//                          curTabIndent = xPos;
//                      }
                        break;
                    case TextFileEdit.Document.TextWordType.Null:
                        Advance(ref xPos, ref yPos, maxWidth, primaryTextArea.TextArea.TextView.SpaceWidth * 3, fontHeight);
//                      if (!gotNonWhitespace) {
//                          curTabIndent = xPos;
//                      }
                        break;
                    case TextFileEdit.Document.TextWordType.Word:
//                      if (!gotNonWhitespace) {
//                          gotNonWhitespace = true;
//                          curTabIndent    += TabIndent * primaryTextArea.TextArea.TextView.GetWidth(' ');
//                      }
                        SizeF drawingSize = g.MeasureString(word.Word, word.GetFont(fontContainer), new SizeF(maxWidth, fontHeight * 100), printingStringFormat);
                        Advance(ref xPos, ref yPos, maxWidth, drawingSize.Width, fontHeight);
                        break;
                }
            }
            return yPos + fontHeight;
        }
        
        void DrawLine(Graphics g, TextFileEdit.Document.LineSegment line, float yPos, RectangleF margin)
        {
            float xPos = 0;
            float fontHeight = Font.GetHeight(g);
//          bool  gotNonWhitespace = false;
            curTabIndent = 0 ;

            TextFileEdit.Document.FontContainer fontContainer = TextEditorProperties.FontContainer;
            foreach (TextFileEdit.Document.TextWord word in line.Words) {
                switch (word.Type) {
                    case TextFileEdit.Document.TextWordType.Space:
                        Advance(ref xPos, ref yPos, margin.Width, primaryTextArea.TextArea.TextView.SpaceWidth, fontHeight);
//                      if (!gotNonWhitespace) {
//                          curTabIndent = xPos;
//                      }
                        break;
                    case TextFileEdit.Document.TextWordType.Tab:
                        Advance(ref xPos, ref yPos, margin.Width, TabIndent * primaryTextArea.TextArea.TextView.WideSpaceWidth, fontHeight);
//                      if (!gotNonWhitespace) {
//                          curTabIndent = xPos;
//                      }
                        break;
                    case TextFileEdit.Document.TextWordType.Null:
                        Advance(ref xPos, ref yPos, margin.Width, primaryTextArea.TextArea.TextView.SpaceWidth * 3, fontHeight);
                        //                      if (!gotNonWhitespace) {
                        //                          curTabIndent = xPos;
                        //                      }
                        break;
                    case TextFileEdit.Document.TextWordType.Word:
//                      if (!gotNonWhitespace) {
//                          gotNonWhitespace = true;
//                          curTabIndent    += TabIndent * primaryTextArea.TextArea.TextView.GetWidth(' ');
//                      }
                        g.DrawString(word.Word, word.GetFont(fontContainer), BrushRegistry.GetBrush(word.Color), xPos + margin.X, yPos);
                        SizeF drawingSize = g.MeasureString(word.Word, word.GetFont(fontContainer), new SizeF(margin.Width, fontHeight * 100), printingStringFormat);
                        Advance(ref xPos, ref yPos, margin.Width, drawingSize.Width, fontHeight);
                        break;
                }
            }
        }
        
        void PrintPage(object sender, PrintPageEventArgs ev)
        {
            Graphics g = ev.Graphics;
            float yPos = ev.MarginBounds.Top;
            
            while (curLineNr < Document.TotalNumberOfLines) {
                TextFileEdit.Document.LineSegment curLine  = Document.GetLineSegment(curLineNr);
                if (curLine.Words != null) {
                    float drawingHeight = MeasurePrintingHeight(g, curLine, ev.MarginBounds.Width);
                    if (drawingHeight + yPos > ev.MarginBounds.Bottom) {
                        break;
                    }
                    
                    DrawLine(g, curLine, yPos, ev.MarginBounds);
                    yPos += drawingHeight;
                }
                ++curLineNr;
            }
            
            // If more lines exist, print another page.
            ev.HasMorePages = curLineNr < Document.TotalNumberOfLines;
        }
#endregion
    }
}

#endif
// file ...\TextFileEdit\Gui\TextEditorControlBase.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3723 $</version>
// </file>


namespace TextFileEdit
{
    /// <summary>
    /// This class is used for a basic text area control
    /// </summary>
    [ToolboxItem(false)]
    public abstract class TextEditorControlBase : UserControl
    {
        string    currentFileName = null;
        int       updateLevel     = 0;
        TextFileEdit.Document.IDocument document;
        
        /// <summary>
        /// This hashtable contains all editor keys, where
        /// the key is the key combination and the value the
        /// action.
        /// </summary>
        protected Dictionary<Keys, TextFileEdit.Actions.IEditAction> editactions = new Dictionary<Keys, TextFileEdit.Actions.IEditAction>();
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public TextFileEdit.Document.ITextEditorProperties TextEditorProperties {
            get {
                return document.TextEditorProperties;
            }
            set {
                document.TextEditorProperties = value;
                OptionsChanged();
            }
        }
        
        Encoding encoding;
        
        /// <value>
        /// Current file's character encoding
        /// </value>
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public Encoding Encoding {
            get {
                if (encoding == null)
                    return TextEditorProperties.Encoding;
                return encoding;
            }
            set {
                encoding = value;
            }
        }
        
        /// <value>
        /// The current file name
        /// </value>
        [Browsable(false)]
        [ReadOnly(true)]
        public string FileName {
            get {
                return currentFileName;
            }
            set {
                if (currentFileName != value) {
                    currentFileName = value;
                    OnFileNameChanged(EventArgs.Empty);
                }
            }
        }
        
        /// <value>
        /// The current document
        /// </value>
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public TextFileEdit.Document.IDocument Document {
            get {
                return document;
            }
            set {
                if (value == null)
                    throw new ArgumentNullException("value");
                if (document != null) {
                    document.DocumentChanged -= OnDocumentChanged;
                }
                document = value;
                document.UndoStack.TextEditorControl = this;
                document.DocumentChanged += OnDocumentChanged;
            }
        }
        
        void OnDocumentChanged(object sender, EventArgs e)
        {
            OnTextChanged(e);
        }
        
        [EditorBrowsable(EditorBrowsableState.Always), Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        [Editor("System.ComponentModel.Design.MultilineStringEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))]
        public override string Text {
            get {
                return Document.TextContent;
            }
            set {
                Document.TextContent = value;
                Refresh();
            }
        }
        
        [EditorBrowsable(EditorBrowsableState.Always), Browsable(true)]
        public new event EventHandler TextChanged
        {
            add { base.TextChanged += value; }
            remove { base.TextChanged -= value; }
        }
        
        static Font ParseFont(string font)
        {
            string[] descr = font.Split(new char[]{',', '='});
            return new Font(descr[1], Single.Parse(descr[3]));
        }
        
        /// <value>
        /// If set to true the contents can't be altered.
        /// </value>
        [Browsable(false)]
        public bool IsReadOnly {
            get {
                return Document.ReadOnly;
            }
            set {
                Document.ReadOnly = value;
            }
        }
        
        /// <value>
        /// true, if the textarea is updating it's status, while
        /// it updates it status no redraw operation occurs.
        /// </value>
        [Browsable(false)]
        public bool IsInUpdate {
            get {
                return updateLevel > 0;
            }
        }
        
        /// <value>
        /// supposedly this is the way to do it according to .NET docs,
        /// as opposed to setting the size in the constructor
        /// </value>
        protected override Size DefaultSize {
            get {
                return new Size(100, 100);
            }
        }
        
#region Document Properties
        /// <value>
        /// If true spaces are shown in the textarea
        /// </value>
        [Category("Appearance")]
        [DefaultValue(false)]
        [Description("If true spaces are shown in the textarea")]
        public bool ShowSpaces {
            get {
                return document.TextEditorProperties.ShowSpaces;
            }
            set {
                document.TextEditorProperties.ShowSpaces = value;
                OptionsChanged();
            }
        }
        
        /// <value>
        /// Specifies the quality of text rendering (whether to use hinting and/or anti-aliasing).
        /// </value>
        [Category("Appearance")]
        [DefaultValue(TextRenderingHint.SystemDefault)]
        [Description("Specifies the quality of text rendering (whether to use hinting and/or anti-aliasing).")]
        public TextRenderingHint TextRenderingHint {
            get {
                return document.TextEditorProperties.TextRenderingHint;
            }
            set {
                document.TextEditorProperties.TextRenderingHint = value;
                OptionsChanged();
            }
        }
        
        /// <value>
        /// If true tabs are shown in the textarea
        /// </value>
        [Category("Appearance")]
        [DefaultValue(false)]
        [Description("If true tabs are shown in the textarea")]
        public bool ShowTabs {
            get {
                return document.TextEditorProperties.ShowTabs;
            }
            set {
                document.TextEditorProperties.ShowTabs = value;
                OptionsChanged();
            }
        }
        
        /// <value>
        /// If true EOL markers are shown in the textarea
        /// </value>
        [Category("Appearance")]
        [DefaultValue(false)]
        [Description("If true EOL markers are shown in the textarea")]
        public bool ShowEOLMarkers {
            get {
                return document.TextEditorProperties.ShowEOLMarker;
            }
            set {
                document.TextEditorProperties.ShowEOLMarker = value;
                OptionsChanged();
            }
        }
        
        /// <value>
        /// If true the horizontal ruler is shown in the textarea
        /// </value>
        [Category("Appearance")]
        [DefaultValue(false)]
        [Description("If true the horizontal ruler is shown in the textarea")]
        public bool ShowHRuler {
            get {
                return document.TextEditorProperties.ShowHorizontalRuler;
            }
            set {
                document.TextEditorProperties.ShowHorizontalRuler = value;
                OptionsChanged();
            }
        }
        
        /// <value>
        /// If true the vertical ruler is shown in the textarea
        /// </value>
        [Category("Appearance")]
        [DefaultValue(true)]
        [Description("If true the vertical ruler is shown in the textarea")]
        public bool ShowVRuler {
            get {
                return document.TextEditorProperties.ShowVerticalRuler;
            }
            set {
                document.TextEditorProperties.ShowVerticalRuler = value;
                OptionsChanged();
            }
        }
        
        /// <value>
        /// The row in which the vertical ruler is displayed
        /// </value>
        [Category("Appearance")]
        [DefaultValue(80)]
        [Description("The row in which the vertical ruler is displayed")]
        public int VRulerRow {
            get {
                return document.TextEditorProperties.VerticalRulerRow;
            }
            set {
                document.TextEditorProperties.VerticalRulerRow = value;
                OptionsChanged();
            }
        }
        
        /// <value>
        /// If true line numbers are shown in the textarea
        /// </value>
        [Category("Appearance")]
        [DefaultValue(true)]
        [Description("If true line numbers are shown in the textarea")]
        public bool ShowLineNumbers {
            get {
                return document.TextEditorProperties.ShowLineNumbers;
            }
            set {
                document.TextEditorProperties.ShowLineNumbers = value;
                OptionsChanged();
            }
        }
        
        /// <value>
        /// If true invalid lines are marked in the textarea
        /// </value>
        [Category("Appearance")]
        [DefaultValue(false)]
        [Description("If true invalid lines are marked in the textarea")]
        public bool ShowInvalidLines {
            get {
                return document.TextEditorProperties.ShowInvalidLines;
            }
            set {
                document.TextEditorProperties.ShowInvalidLines = value;
                OptionsChanged();
            }
        }
        
        /// <value>
        /// If true folding is enabled in the textarea
        /// </value>
        [Category("Appearance")]
        [DefaultValue(true)]
        [Description("If true folding is enabled in the textarea")]
        public bool EnableFolding {
            get {
                return document.TextEditorProperties.EnableFolding;
            }
            set {
                document.TextEditorProperties.EnableFolding = value;
                OptionsChanged();
            }
        }
        
        [Category("Appearance")]
        [DefaultValue(true)]
        [Description("If true matching brackets are highlighted")]
        public bool ShowMatchingBracket {
            get {
                return document.TextEditorProperties.ShowMatchingBracket;
            }
            set {
                document.TextEditorProperties.ShowMatchingBracket = value;
                OptionsChanged();
            }
        }
        
        [Category("Appearance")]
        [DefaultValue(false)]
        [Description("If true the icon bar is displayed")]
        public bool IsIconBarVisible {
            get {
                return document.TextEditorProperties.IsIconBarVisible;
            }
            set {
                document.TextEditorProperties.IsIconBarVisible = value;
                OptionsChanged();
            }
        }
        
        /// <value>
        /// The width in spaces of a tab character
        /// </value>
        [Category("Appearance")]
        [DefaultValue(4)]
        [Description("The width in spaces of a tab character")]
        public int TabIndent {
            get {
                return document.TextEditorProperties.TabIndent;
            }
            set {
                document.TextEditorProperties.TabIndent = value;
                OptionsChanged();
            }
        }
        
        /// <value>
        /// The line viewer style
        /// </value>
        [Category("Appearance")]
        [DefaultValue(TextFileEdit.Document.LineViewerStyle.None)]
        [Description("The line viewer style")]
        public TextFileEdit.Document.LineViewerStyle LineViewerStyle {
            get {
                return document.TextEditorProperties.LineViewerStyle;
            }
            set {
                document.TextEditorProperties.LineViewerStyle = value;
                OptionsChanged();
            }
        }

        /// <value>
        /// The indent style
        /// </value>
        [Category("Behavior")]
        [DefaultValue(TextFileEdit.Document.IndentStyle.Smart)]
        [Description("The indent style")]
        public TextFileEdit.Document.IndentStyle IndentStyle {
            get {
                return document.TextEditorProperties.IndentStyle;
            }
            set {
                document.TextEditorProperties.IndentStyle = value;
                OptionsChanged();
            }
        }
        
        /// <value>
        /// if true spaces are converted to tabs
        /// </value>
        [Category("Behavior")]
        [DefaultValue(false)]
        [Description("Converts tabs to spaces while typing")]
        public bool ConvertTabsToSpaces {
            get {
                return document.TextEditorProperties.ConvertTabsToSpaces;
            }
            set {
                document.TextEditorProperties.ConvertTabsToSpaces = value;
                OptionsChanged();
            }
        }
        
        /// <value>
        /// if true spaces are converted to tabs
        /// </value>
        [Category("Behavior")]
        [DefaultValue(false)]
        [Description("Hide the mouse cursor while typing")]
        public bool HideMouseCursor {
            get {
                return document.TextEditorProperties.HideMouseCursor;
            }
            set {
                document.TextEditorProperties.HideMouseCursor = value;
                OptionsChanged();
            }
        }
        
        /// <value>
        /// if true spaces are converted to tabs
        /// </value>
        [Category("Behavior")]
        [DefaultValue(false)]
        [Description("Allows the caret to be placed beyond the end of line")]
        public bool AllowCaretBeyondEOL {
            get {
                return document.TextEditorProperties.AllowCaretBeyondEOL;
            }
            set {
                document.TextEditorProperties.AllowCaretBeyondEOL = value;
                OptionsChanged();
            }
        }
        /// <value>
        /// if true spaces are converted to tabs
        /// </value>
        [Category("Behavior")]
        [DefaultValue(TextFileEdit.Document.BracketMatchingStyle.After)]
        [Description("Specifies if the bracket matching should match the bracket before or after the caret.")]
        public TextFileEdit.Document.BracketMatchingStyle BracketMatchingStyle {
            get {
                return document.TextEditorProperties.BracketMatchingStyle;
            }
            set {
                document.TextEditorProperties.BracketMatchingStyle = value;
                OptionsChanged();
            }
        }
        
        /// <value>
        /// The base font of the text area. No bold or italic fonts
        /// can be used because bold/italic is reserved for highlighting
        /// purposes.
        /// </value>
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
        [Description("The base font of the text area. No bold or italic fonts can be used because bold/italic is reserved for highlighting purposes.")]
        public override Font Font {
            get {
                return document.TextEditorProperties.Font;
            }
            set {
                document.TextEditorProperties.Font = value;
                OptionsChanged();
            }
        }
        
#endregion
        public abstract TextAreaControl ActiveTextAreaControl {
            get;
        }
        
        protected TextEditorControlBase()
        {
            GenerateDefaultActions();
            TextFileEdit.Document.HighlightingManager.Manager.ReloadSyntaxHighlighting += new EventHandler(OnReloadHighlighting);
        }
        
        protected virtual void OnReloadHighlighting(object sender, EventArgs e)
        {
            if (Document.HighlightingStrategy != null) {
                try {
                    Document.HighlightingStrategy = TextFileEdit.Document.HighlightingStrategyFactory.CreateHighlightingStrategy(Document.HighlightingStrategy.Name);
                } catch (TextFileEdit.Document.HighlightingDefinitionInvalidException ex) {
                    MessageBox.Show(ex.ToString(), "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
                OptionsChanged();
            }
        }
        
        public bool IsEditAction(Keys keyData)
        {
            return editactions.ContainsKey(keyData);
        }

        internal TextFileEdit.Actions.IEditAction GetEditAction(Keys keyData)
        {
            if (!IsEditAction(keyData)) {
                return null;
            }
            return (TextFileEdit.Actions.IEditAction)editactions[keyData];
        }

        void GenerateDefaultActions()
        {
            editactions[Keys.Left] = new TextFileEdit.Actions.CaretLeft();
            editactions[Keys.Left | Keys.Shift] = new TextFileEdit.Actions.ShiftCaretLeft();
            editactions[Keys.Left | Keys.Control] = new TextFileEdit.Actions.WordLeft();
            editactions[Keys.Left | Keys.Control | Keys.Shift] = new TextFileEdit.Actions.ShiftWordLeft();
            editactions[Keys.Right] = new TextFileEdit.Actions.CaretRight();
            editactions[Keys.Right | Keys.Shift] = new TextFileEdit.Actions.ShiftCaretRight();
            editactions[Keys.Right | Keys.Control] = new TextFileEdit.Actions.WordRight();
            editactions[Keys.Right | Keys.Control | Keys.Shift] = new TextFileEdit.Actions.ShiftWordRight();
            editactions[Keys.Up] = new TextFileEdit.Actions.CaretUp();
            editactions[Keys.Up | Keys.Shift] = new TextFileEdit.Actions.ShiftCaretUp();
            editactions[Keys.Up | Keys.Control] = new TextFileEdit.Actions.ScrollLineUp();
            editactions[Keys.Down] = new TextFileEdit.Actions.CaretDown();
            editactions[Keys.Down | Keys.Shift] = new TextFileEdit.Actions.ShiftCaretDown();
            editactions[Keys.Down | Keys.Control] = new TextFileEdit.Actions.ScrollLineDown();
            
            editactions[Keys.Insert] = new TextFileEdit.Actions.ToggleEditMode();
            editactions[Keys.Insert | Keys.Control] = new TextFileEdit.Actions.Copy();
            editactions[Keys.Insert | Keys.Shift] = new TextFileEdit.Actions.Paste();
            editactions[Keys.Delete] = new TextFileEdit.Actions.Delete();
            editactions[Keys.Delete | Keys.Shift] = new TextFileEdit.Actions.Cut();
            editactions[Keys.Home] = new TextFileEdit.Actions.Home();
            editactions[Keys.Home | Keys.Shift] = new TextFileEdit.Actions.ShiftHome();
            editactions[Keys.Home | Keys.Control] = new TextFileEdit.Actions.MoveToStart();
            editactions[Keys.Home | Keys.Control | Keys.Shift] = new TextFileEdit.Actions.ShiftMoveToStart();
            editactions[Keys.End] = new TextFileEdit.Actions.End();
            editactions[Keys.End | Keys.Shift] = new TextFileEdit.Actions.ShiftEnd();
            editactions[Keys.End | Keys.Control] = new TextFileEdit.Actions.MoveToEnd();
            editactions[Keys.End | Keys.Control | Keys.Shift] = new TextFileEdit.Actions.ShiftMoveToEnd();
            editactions[Keys.PageUp] = new TextFileEdit.Actions.MovePageUp();
            editactions[Keys.PageUp | Keys.Shift] = new TextFileEdit.Actions.ShiftMovePageUp();
            editactions[Keys.PageDown] = new TextFileEdit.Actions.MovePageDown();
            editactions[Keys.PageDown | Keys.Shift] = new TextFileEdit.Actions.ShiftMovePageDown();
            
            editactions[Keys.Return] = new TextFileEdit.Actions.Return();
            editactions[Keys.Tab] = new TextFileEdit.Actions.Tab();
            editactions[Keys.Tab | Keys.Shift] = new TextFileEdit.Actions.ShiftTab();
            editactions[Keys.Back] = new TextFileEdit.Actions.Backspace();
            editactions[Keys.Back | Keys.Shift] = new TextFileEdit.Actions.Backspace();
            
            editactions[Keys.X | Keys.Control] = new TextFileEdit.Actions.Cut();
            editactions[Keys.C | Keys.Control] = new TextFileEdit.Actions.Copy();
            editactions[Keys.V | Keys.Control] = new TextFileEdit.Actions.Paste();
            
            editactions[Keys.A | Keys.Control] = new TextFileEdit.Actions.SelectWholeDocument();
            editactions[Keys.Escape] = new TextFileEdit.Actions.ClearAllSelections();
            
            editactions[Keys.Divide | Keys.Control] = new TextFileEdit.Actions.ToggleComment();
            editactions[Keys.OemQuestion | Keys.Control] = new TextFileEdit.Actions.ToggleComment();
            
            editactions[Keys.Back | Keys.Alt]  = new Actions.Undo();
            editactions[Keys.Z | Keys.Control] = new Actions.Undo();
            editactions[Keys.Y | Keys.Control] = new TextFileEdit.Actions.Redo();
            
            editactions[Keys.Delete | Keys.Control] = new TextFileEdit.Actions.DeleteWord();
            editactions[Keys.Back | Keys.Control]   = new TextFileEdit.Actions.WordBackspace();
            editactions[Keys.D | Keys.Control]      = new TextFileEdit.Actions.DeleteLine();
            editactions[Keys.D | Keys.Shift | Keys.Control]      = new TextFileEdit.Actions.DeleteToLineEnd();
            
            editactions[Keys.B | Keys.Control]      = new TextFileEdit.Actions.GotoMatchingBrace();
        }
        
        /// <remarks>
        /// Call this method before a long update operation this
        /// 'locks' the text area so that no screen update occurs.
        /// </remarks>
        public virtual void BeginUpdate()
        {
            ++updateLevel;
        }
        
        /// <remarks>
        /// Call this method to 'unlock' the text area. After this call
        /// screen update can occur. But no automatical refresh occurs you
        /// have to commit the updates in the queue.
        /// </remarks>
        public virtual void EndUpdate()
        {
            Debug.Assert(updateLevel > 0);
            updateLevel = Math.Max(0, updateLevel - 1);
        }
        
        public void LoadFile(string fileName)
        {
            LoadFile(fileName, true, true);
        }
        
        /// <remarks>
        /// Loads a file given by fileName
        /// </remarks>
        /// <param name="fileName">The name of the file to open</param>
        /// <param name="autoLoadHighlighting">Automatically load the highlighting for the file</param>
        /// <param name="autodetectEncoding">Automatically detect file encoding and set Encoding property to the detected encoding.</param>
        public void LoadFile(string fileName, bool autoLoadHighlighting, bool autodetectEncoding)
        {
            using (FileStream fs = new FileStream(fileName, FileMode.Open, FileAccess.Read)) {
                LoadFile(fileName, fs, autoLoadHighlighting, autodetectEncoding);
            }
        }
        
        /// <remarks>
        /// Loads a file from the specified stream.
        /// </remarks>
        /// <param name="fileName">The name of the file to open. Used to find the correct highlighting strategy
        /// if autoLoadHighlighting is active, and sets the filename property to this value.</param>
        /// <param name="stream">The stream to actually load the file content from.</param>
        /// <param name="autoLoadHighlighting">Automatically load the highlighting for the file</param>
        /// <param name="autodetectEncoding">Automatically detect file encoding and set Encoding property to the detected encoding.</param>
        public void LoadFile(string fileName, Stream stream, bool autoLoadHighlighting, bool autodetectEncoding)
        {
            if (stream == null)
                throw new ArgumentNullException("stream");
            
            BeginUpdate();
            document.TextContent = String.Empty;
            document.UndoStack.ClearAll();
            document.BookmarkManager.Clear();
            if (autoLoadHighlighting) {
                try {
                    document.HighlightingStrategy = TextFileEdit.Document.HighlightingStrategyFactory.CreateHighlightingStrategyForFile(fileName);
                } catch (TextFileEdit.Document.HighlightingDefinitionInvalidException ex) {
                    MessageBox.Show(ex.ToString(), "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
            
            if (autodetectEncoding) {
                Encoding encoding = this.Encoding;
                Document.TextContent = Util.FileReader.ReadFileContent(stream, ref encoding);
                this.Encoding = encoding;
            } else {
                using (StreamReader reader = new StreamReader(fileName, this.Encoding)) {
                    Document.TextContent = reader.ReadToEnd();
                }
            }
            
            this.FileName = fileName;
            Document.UpdateQueue.Clear();
            EndUpdate();
            
            OptionsChanged();
            Refresh();
        }
        
        /// <summary>
        /// Gets if the document can be saved with the current encoding without losing data.
        /// </summary>
        public bool CanSaveWithCurrentEncoding()
        {
            if (encoding == null || Util.FileReader.IsUnicode(encoding))
                return true;
            // not a unicode codepage
            string text = document.TextContent;
            return encoding.GetString(encoding.GetBytes(text)) == text;
        }
        
        /// <remarks>
        /// Saves the text editor content into the file.
        /// </remarks>
        public void SaveFile(string fileName)
        {
            using (FileStream fs = new FileStream(fileName, FileMode.Create, FileAccess.Write)) {
                SaveFile(fs);
            }
            this.FileName = fileName;
        }
        
        /// <remarks>
        /// Saves the text editor content into the specified stream.
        /// Does not close the stream.
        /// </remarks>
        public void SaveFile(Stream stream)
        {
            StreamWriter streamWriter = new StreamWriter(stream, this.Encoding ?? Encoding.UTF8);
            
            // save line per line to apply the LineTerminator to all lines
            // (otherwise we might save files with mixed-up line endings)
            foreach (TextFileEdit.Document.LineSegment line in Document.LineSegmentCollection) {
                streamWriter.Write(Document.GetText(line.Offset, line.Length));
                if (line.DelimiterLength > 0) {
                    char charAfterLine = Document.GetCharAt(line.Offset + line.Length);
                    if (charAfterLine != '\n' && charAfterLine != '\r')
                        throw new InvalidOperationException("The document cannot be saved because it is corrupted.");
                    // only save line terminator if the line has one
                    streamWriter.Write(document.TextEditorProperties.LineTerminator);
                }
            }
            streamWriter.Flush();
        }
        
        public abstract void OptionsChanged();
        
        // Localization ISSUES
        
        // used in insight window
        public virtual string GetRangeDescription(int selectedItem, int itemCount)
        {
            StringBuilder sb=new StringBuilder(selectedItem.ToString());
            sb.Append(" from ");
            sb.Append(itemCount.ToString());
            return sb.ToString();
        }
        
        /// <remarks>
        /// Overwritten refresh method that does nothing if the control is in
        /// an update cycle.
        /// </remarks>
        public override void Refresh()
        {
            if (IsInUpdate) {
                return;
            }
            base.Refresh();
        }
        
        protected override void Dispose(bool disposing)
        {
            if (disposing) {
                TextFileEdit.Document.HighlightingManager.Manager.ReloadSyntaxHighlighting -= new EventHandler(OnReloadHighlighting);
                document.HighlightingStrategy = null;
                document.UndoStack.TextEditorControl = null;
            }
            base.Dispose(disposing);
        }
        
        protected virtual void OnFileNameChanged(EventArgs e)
        {
            if (FileNameChanged != null) {
                FileNameChanged(this, e);
            }
        }
        
        public event EventHandler FileNameChanged;
    }
}

#endif
// file ...\TextFileEdit\Gui\TextView.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Daniel Grunwald" email="daniel@danielgrunwald.de"/>
//     <version>$Revision: 3756 $</version>
// </file>


namespace TextFileEdit
{
    /// <summary>
    /// This class paints the textarea.
    /// </summary>
    public class TextView : AbstractMargin, IDisposable
    {
        int fontHeight;
        //Hashtable    charWitdh           = new Hashtable();
        //StringFormat measureStringFormat = (StringFormat)StringFormat.GenericTypographic.Clone();
        Highlight highlight;
        int physicalColumn = 0; // used for calculating physical column during paint

        public void Dispose()
        {
            measureCache.Clear();
            //measureStringFormat.Dispose();
        }

        public Highlight Highlight
        {
            get
            {
                return highlight;
            }
            set
            {
                highlight = value;
            }
        }

        public int FirstPhysicalLine
        {
            get
            {
                return textArea.VirtualTop.Y / fontHeight;
            }
        }
        public int LineHeightRemainder
        {
            get
            {
                return textArea.VirtualTop.Y % fontHeight;
            }
        }
        /// <summary>Gets the first visible <b>logical</b> line.</summary>
        public int FirstVisibleLine
        {
            get
            {
                return textArea.Document.GetFirstLogicalLine(textArea.VirtualTop.Y / fontHeight);
            }
            set
            {
                if (FirstVisibleLine != value)
                {
                    textArea.VirtualTop = new Point(textArea.VirtualTop.X, textArea.Document.GetVisibleLine(value) * fontHeight);

                }
            }
        }

        public int VisibleLineDrawingRemainder
        {
            get
            {
                return textArea.VirtualTop.Y % fontHeight;
            }
        }

        public int FontHeight
        {
            get
            {
                return fontHeight;
            }
        }

        public int VisibleLineCount
        {
            get
            {
                return 1 + DrawingPosition.Height / fontHeight;
            }
        }

        public int VisibleColumnCount
        {
            get
            {
                return (int)(DrawingPosition.Width / WideSpaceWidth) - 1;
            }
        }

        public TextView(TextArea textArea) : base(textArea)
        {
            base.Cursor = Cursors.IBeam;
            OptionsChanged();
        }

        static int GetFontHeight(Font font)
        {
            int height1 = TextRenderer.MeasureText("_", font).Height;
            int height2 = (int)Math.Ceiling(font.GetHeight());
            return Math.Max(height1, height2) + 1;
        }

        int spaceWidth;

        /// <summary>
        /// Gets the width of a space character.
        /// This value can be quite small in some fonts - consider using WideSpaceWidth instead.
        /// </summary>
        public int SpaceWidth
        {
            get
            {
                return spaceWidth;
            }
        }

        int wideSpaceWidth;

        /// <summary>
        /// Gets the width of a 'wide space' (=one quarter of a tab, if tab is set to 4 spaces).
        /// On monospaced fonts, this is the same value as spaceWidth.
        /// </summary>
        public int WideSpaceWidth
        {
            get
            {
                return wideSpaceWidth;
            }
        }

        Font lastFont;

        public void OptionsChanged()
        {
            this.lastFont = TextEditorProperties.FontContainer.RegularFont;
            this.fontHeight = GetFontHeight(lastFont);
            // use minimum width - in some fonts, space has no width but kerning is used instead
            // -> DivideByZeroException
            this.spaceWidth = Math.Max(GetWidth(' ', lastFont), 1);
            // tab should have the width of 4*'x'
            this.wideSpaceWidth = Math.Max(spaceWidth, GetWidth('x', lastFont));
        }

#region Paint functions
        public override void Paint(Graphics g, Rectangle rect)
        {
            if (rect.Width <= 0 || rect.Height <= 0)
            {
                return;
            }

            // Just to ensure that fontHeight and char widths are always correct...
            if (lastFont != TextEditorProperties.FontContainer.RegularFont)
            {
                OptionsChanged();
                textArea.Invalidate();
            }

            int horizontalDelta = textArea.VirtualTop.X;
            if (horizontalDelta > 0)
            {
                g.SetClip(this.DrawingPosition);
            }

            for (int y = 0; y < (DrawingPosition.Height + VisibleLineDrawingRemainder) / fontHeight + 1; ++y)
            {
                Rectangle lineRectangle = new Rectangle(DrawingPosition.X - horizontalDelta,
                                                        DrawingPosition.Top + y * fontHeight - VisibleLineDrawingRemainder,
                                                        DrawingPosition.Width + horizontalDelta,
                                                        fontHeight);

                if (rect.IntersectsWith(lineRectangle))
                {
                    int fvl = textArea.Document.GetVisibleLine(FirstVisibleLine);
                    int currentLine = textArea.Document.GetFirstLogicalLine(textArea.Document.GetVisibleLine(FirstVisibleLine) + y);
                    PaintDocumentLine(g, currentLine, lineRectangle);
                }
            }

            DrawMarkerDraw(g);

            if (horizontalDelta > 0)
            {
                g.ResetClip();
            }
            textArea.Caret.PaintCaret(g);
        }

        void PaintDocumentLine(Graphics g, int lineNumber, Rectangle lineRectangle)
        {
            Debug.Assert(lineNumber >= 0);
            Brush bgColorBrush = GetBgColorBrush(lineNumber);
            Brush backgroundBrush = textArea.Enabled ? bgColorBrush : SystemBrushes.InactiveBorder;

            if (lineNumber >= textArea.Document.TotalNumberOfLines)
            {
                g.FillRectangle(backgroundBrush, lineRectangle);
                if (TextEditorProperties.ShowInvalidLines)
                {
                    DrawInvalidLineMarker(g, lineRectangle.Left, lineRectangle.Top);
                }
                if (TextEditorProperties.ShowVerticalRuler)
                {
                    DrawVerticalRuler(g, lineRectangle);
                }
                //              bgColorBrush.Dispose();
                return;
            }

            int physicalXPos = lineRectangle.X;
            // there can't be a folding wich starts in an above line and ends here, because the line is a new one,
            // there must be a return before this line.
            int column = 0;
            physicalColumn = 0;
            if (TextEditorProperties.EnableFolding)
            {
                while (true)
                {
                    List<TextFileEdit.Document.FoldMarker> starts = textArea.Document.FoldingManager.GetFoldedFoldingsWithStartAfterColumn(lineNumber, column - 1);
                    if (starts == null || starts.Count <= 0)
                    {
                        if (lineNumber < textArea.Document.TotalNumberOfLines)
                        {
                            physicalXPos = PaintLinePart(g, lineNumber, column, textArea.Document.GetLineSegment(lineNumber).Length, lineRectangle, physicalXPos);
                        }
                        break;
                    }
                    // search the first starting folding
                    TextFileEdit.Document.FoldMarker firstFolding = (TextFileEdit.Document.FoldMarker)starts[0];
                    foreach (TextFileEdit.Document.FoldMarker fm in starts)
                    {
                        if (fm.StartColumn < firstFolding.StartColumn)
                        {
                            firstFolding = fm;
                        }
                    }
                    starts.Clear();

                    physicalXPos = PaintLinePart(g, lineNumber, column, firstFolding.StartColumn, lineRectangle, physicalXPos);
                    column = firstFolding.EndColumn;
                    lineNumber = firstFolding.EndLine;
                    if (lineNumber >= textArea.Document.TotalNumberOfLines)
                    {
                        Debug.Assert(false, "Folding ends after document end");
                        break;
                    }

                    TextFileEdit.Document.ColumnRange selectionRange2 = textArea.SelectionManager.GetSelectionAtLine(lineNumber);
                    bool drawSelected = TextFileEdit.Document.ColumnRange.WholeColumn.Equals(selectionRange2) || firstFolding.StartColumn >= selectionRange2.StartColumn && firstFolding.EndColumn <= selectionRange2.EndColumn;

                    physicalXPos = PaintFoldingText(g, lineNumber, physicalXPos, lineRectangle, firstFolding.FoldText, drawSelected);
                }
            }
            else
            {
                physicalXPos = PaintLinePart(g, lineNumber, 0, textArea.Document.GetLineSegment(lineNumber).Length, lineRectangle, physicalXPos);
            }

            if (lineNumber < textArea.Document.TotalNumberOfLines)
            {
                // Paint things after end of line
                TextFileEdit.Document.ColumnRange selectionRange = textArea.SelectionManager.GetSelectionAtLine(lineNumber);
                TextFileEdit.Document.LineSegment currentLine = textArea.Document.GetLineSegment(lineNumber);
                TextFileEdit.Document.HighlightColor selectionColor = textArea.Document.HighlightingStrategy.GetColorFor("Selection");

                bool selectionBeyondEOL = selectionRange.EndColumn > currentLine.Length || TextFileEdit.Document.ColumnRange.WholeColumn.Equals(selectionRange);

                if (TextEditorProperties.ShowEOLMarker)
                {
                    TextFileEdit.Document.HighlightColor eolMarkerColor = textArea.Document.HighlightingStrategy.GetColorFor("EOLMarkers");
                    physicalXPos += DrawEOLMarker(g, eolMarkerColor.Color, selectionBeyondEOL ? bgColorBrush : backgroundBrush, physicalXPos, lineRectangle.Y);
                }
                else
                {
                    if (selectionBeyondEOL)
                    {
                        g.FillRectangle(BrushRegistry.GetBrush(selectionColor.BackgroundColor), new RectangleF(physicalXPos, lineRectangle.Y, WideSpaceWidth, lineRectangle.Height));
                        physicalXPos += WideSpaceWidth;
                    }
                }

                Brush fillBrush = selectionBeyondEOL && TextEditorProperties.AllowCaretBeyondEOL ? bgColorBrush : backgroundBrush;
                g.FillRectangle(fillBrush,
                                new RectangleF(physicalXPos, lineRectangle.Y, lineRectangle.Width - physicalXPos + lineRectangle.X, lineRectangle.Height));
            }
            if (TextEditorProperties.ShowVerticalRuler)
            {
                DrawVerticalRuler(g, lineRectangle);
            }
            //          bgColorBrush.Dispose();
        }

        bool DrawLineMarkerAtLine(int lineNumber)
        {
            return lineNumber == base.textArea.Caret.Line && textArea.MotherTextAreaControl.TextEditorProperties.LineViewerStyle == TextFileEdit.Document.LineViewerStyle.FullRow;
        }

        Brush GetBgColorBrush(int lineNumber)
        {
            if (DrawLineMarkerAtLine(lineNumber))
            {
                TextFileEdit.Document.HighlightColor caretLine = textArea.Document.HighlightingStrategy.GetColorFor("CaretMarker");
                return BrushRegistry.GetBrush(caretLine.Color);
            }
            TextFileEdit.Document.HighlightColor background = textArea.Document.HighlightingStrategy.GetColorFor("Default");
            Color bgColor = background.BackgroundColor;
            return BrushRegistry.GetBrush(bgColor);
        }

        const int additionalFoldTextSize = 1;

        int PaintFoldingText(Graphics g, int lineNumber, int physicalXPos, Rectangle lineRectangle, string text, bool drawSelected)
        {
            //OneCodeTODO: get font and color from the highlighting file
            TextFileEdit.Document.HighlightColor selectionColor = textArea.Document.HighlightingStrategy.GetColorFor("Selection");
            Brush bgColorBrush = drawSelected ? BrushRegistry.GetBrush(selectionColor.BackgroundColor) : GetBgColorBrush(lineNumber);
            Brush backgroundBrush = textArea.Enabled ? bgColorBrush : SystemBrushes.InactiveBorder;

            Font font = textArea.TextEditorProperties.FontContainer.RegularFont;

            int wordWidth = MeasureStringWidth(g, text, font) + additionalFoldTextSize;
            Rectangle rect = new Rectangle(physicalXPos, lineRectangle.Y, wordWidth, lineRectangle.Height - 1);

            g.FillRectangle(backgroundBrush, rect);

            physicalColumn += text.Length;
            DrawString(g,
                       text,
                       font,
                       drawSelected ? selectionColor.Color : Color.Gray,
                       rect.X + 1, rect.Y);
            g.DrawRectangle(BrushRegistry.GetPen(drawSelected ? Color.DarkGray : Color.Gray), rect.X, rect.Y, rect.Width, rect.Height);

            return physicalXPos + wordWidth + 1;
        }

        struct MarkerToDraw
        {
            internal TextFileEdit.Document.TextMarker marker;
            internal RectangleF drawingRect;

            public MarkerToDraw(TextFileEdit.Document.TextMarker marker, RectangleF drawingRect)
            {
                this.marker = marker;
                this.drawingRect = drawingRect;
            }
        }

        List<MarkerToDraw> markersToDraw = new List<MarkerToDraw>();

        void DrawMarker(Graphics g, TextFileEdit.Document.TextMarker marker, RectangleF drawingRect)
        {
            // draw markers later so they can overdraw the following text
            markersToDraw.Add(new MarkerToDraw(marker, drawingRect));
        }

        void DrawMarkerDraw(Graphics g)
        {
            foreach (MarkerToDraw m in markersToDraw)
            {
                TextFileEdit.Document.TextMarker marker = m.marker;
                RectangleF drawingRect = m.drawingRect;
                float drawYPos = drawingRect.Bottom - 1;
                switch (marker.TextMarkerType)
                {
                    case TextFileEdit.Document.TextMarkerType.Underlined:
                        g.DrawLine(BrushRegistry.GetPen(marker.Color), drawingRect.X, drawYPos, drawingRect.Right, drawYPos);
                        break;
                    case TextFileEdit.Document.TextMarkerType.WaveLine:
                        int reminder = ((int)drawingRect.X) % 6;
                        for (float i = (int)drawingRect.X - reminder; i < drawingRect.Right; i += 6)
                        {
                            g.DrawLine(BrushRegistry.GetPen(marker.Color), i, drawYPos + 3 - 4, i + 3, drawYPos + 1 - 4);
                            if (i + 3 < drawingRect.Right)
                            {
                                g.DrawLine(BrushRegistry.GetPen(marker.Color), i + 3, drawYPos + 1 - 4, i + 6, drawYPos + 3 - 4);
                            }
                        }
                        break;
                    case TextFileEdit.Document.TextMarkerType.SolidBlock:
                        g.FillRectangle(BrushRegistry.GetBrush(marker.Color), drawingRect);
                        break;
                }
            }
            markersToDraw.Clear();
        }

        /// <summary>
        /// Get the marker brush (for solid block markers) at a given position.
        /// </summary>
        /// <param name="offset">The offset.</param>
        /// <param name="length">The length.</param>
        /// <param name="markers">All markers that have been found.</param>
        /// <returns>The Brush or null when no marker was found.</returns>
        Brush GetMarkerBrushAt(int offset, int length, ref Color foreColor, out IList<TextFileEdit.Document.TextMarker> markers)
        {
            markers = Document.MarkerStrategy.GetMarkers(offset, length);
            foreach (TextFileEdit.Document.TextMarker marker in markers)
            {
                if (marker.TextMarkerType == TextFileEdit.Document.TextMarkerType.SolidBlock)
                {
                    if (marker.OverrideForeColor)
                    {
                        foreColor = marker.ForeColor;
                    }
                    return BrushRegistry.GetBrush(marker.Color);
                }
            }
            return null;
        }

        int PaintLinePart(Graphics g, int lineNumber, int startColumn, int endColumn, Rectangle lineRectangle, int physicalXPos)
        {
            bool drawLineMarker = DrawLineMarkerAtLine(lineNumber);
            Brush backgroundBrush = textArea.Enabled ? GetBgColorBrush(lineNumber) : SystemBrushes.InactiveBorder;

            TextFileEdit.Document.HighlightColor selectionColor = textArea.Document.HighlightingStrategy.GetColorFor("Selection");
            TextFileEdit.Document.ColumnRange selectionRange = textArea.SelectionManager.GetSelectionAtLine(lineNumber);
            TextFileEdit.Document.HighlightColor tabMarkerColor = textArea.Document.HighlightingStrategy.GetColorFor("TabMarkers");
            TextFileEdit.Document.HighlightColor spaceMarkerColor = textArea.Document.HighlightingStrategy.GetColorFor("SpaceMarkers");

            TextFileEdit.Document.LineSegment currentLine = textArea.Document.GetLineSegment(lineNumber);

            Brush selectionBackgroundBrush = BrushRegistry.GetBrush(selectionColor.BackgroundColor);

            if (currentLine.Words == null)
            {
                return physicalXPos;
            }

            int currentWordOffset = 0; // we cannot use currentWord.Offset because it is not set on space words

            TextFileEdit.Document.TextWord currentWord;
            TextFileEdit.Document.TextWord nextCurrentWord = null;
            TextFileEdit.Document.FontContainer fontContainer = TextEditorProperties.FontContainer;
            for (int wordIdx = 0; wordIdx < currentLine.Words.Count; wordIdx++)
            {
                currentWord = currentLine.Words[wordIdx];
                if (currentWordOffset < startColumn)
                {
                    // TO-DO: maybe we need to split at startColumn when we support fold markers
                    // inside words
                    currentWordOffset += currentWord.Length;
                    continue;
                }
            repeatDrawCurrentWord:
                //physicalXPos += 10; // leave room between drawn words - useful for debugging the drawing code
                if (currentWordOffset >= endColumn || physicalXPos >= lineRectangle.Right)
                {
                    break;
                }
                int currentWordEndOffset = currentWordOffset + currentWord.Length - 1;
                TextFileEdit.Document.TextWordType currentWordType = currentWord.Type;

                IList<TextFileEdit.Document.TextMarker> markers;
                Color wordForeColor;
                if (currentWordType == TextFileEdit.Document.TextWordType.Space)
                    wordForeColor = spaceMarkerColor.Color;
                else if (currentWordType == TextFileEdit.Document.TextWordType.Tab)
                    wordForeColor = tabMarkerColor.Color;
                else if (currentWordType == TextFileEdit.Document.TextWordType.Null)
                    wordForeColor = tabMarkerColor.Color;
                else
                    wordForeColor = currentWord.Color;
                Brush wordBackBrush = GetMarkerBrushAt(currentLine.Offset + currentWordOffset, currentWord.Length, ref wordForeColor, out markers);

                // It is possible that we have to split the current word because a marker/the selection begins/ends inside it
                if (currentWord.Length > 1)
                {
                    int splitPos = int.MaxValue;
                    if (highlight != null)
                    {
                        // split both before and after highlight
                        if (highlight.OpenBrace.Y == lineNumber)
                        {
                            if (highlight.OpenBrace.X >= currentWordOffset && highlight.OpenBrace.X <= currentWordEndOffset)
                            {
                                splitPos = Math.Min(splitPos, highlight.OpenBrace.X - currentWordOffset);
                            }
                        }
                        if (highlight.CloseBrace.Y == lineNumber)
                        {
                            if (highlight.CloseBrace.X >= currentWordOffset && highlight.CloseBrace.X <= currentWordEndOffset)
                            {
                                splitPos = Math.Min(splitPos, highlight.CloseBrace.X - currentWordOffset);
                            }
                        }
                        if (splitPos == 0)
                        {
                            splitPos = 1; // split after highlight
                        }
                    }
                    if (endColumn < currentWordEndOffset)
                    { // split when endColumn is reached
                        splitPos = Math.Min(splitPos, endColumn - currentWordOffset);
                    }
                    if (selectionRange.StartColumn > currentWordOffset && selectionRange.StartColumn <= currentWordEndOffset)
                    {
                        splitPos = Math.Min(splitPos, selectionRange.StartColumn - currentWordOffset);
                    }
                    else if (selectionRange.EndColumn > currentWordOffset && selectionRange.EndColumn <= currentWordEndOffset)
                    {
                        splitPos = Math.Min(splitPos, selectionRange.EndColumn - currentWordOffset);
                    }
                    foreach (TextFileEdit.Document.TextMarker marker in markers)
                    {
                        int markerColumn = marker.Offset - currentLine.Offset;
                        int markerEndColumn = marker.EndOffset - currentLine.Offset + 1; // make end offset exclusive
                        if (markerColumn > currentWordOffset && markerColumn <= currentWordEndOffset)
                        {
                            splitPos = Math.Min(splitPos, markerColumn - currentWordOffset);
                        }
                        else if (markerEndColumn > currentWordOffset && markerEndColumn <= currentWordEndOffset)
                        {
                            splitPos = Math.Min(splitPos, markerEndColumn - currentWordOffset);
                        }
                    }
                    if (splitPos != int.MaxValue)
                    {
                        if (nextCurrentWord != null)
                            throw new ApplicationException("split part invalid: first part cannot be splitted further");
                        nextCurrentWord = TextFileEdit.Document.TextWord.Split(ref currentWord, splitPos);
                        goto repeatDrawCurrentWord; // get markers for first word part
                    }
                }

                // get colors from selection status:
                if (TextFileEdit.Document.ColumnRange.WholeColumn.Equals(selectionRange) || (selectionRange.StartColumn <= currentWordOffset
                                                                       && selectionRange.EndColumn > currentWordEndOffset))
                {
                    // word is completely selected
                    wordBackBrush = selectionBackgroundBrush;
                    if (selectionColor.HasForeground)
                    {
                        wordForeColor = selectionColor.Color;
                    }
                }
                else if (drawLineMarker)
                {
                    wordBackBrush = backgroundBrush;
                }

                if (wordBackBrush == null)
                { // use default background if no other background is set
                    if (currentWord.SyntaxColor != null && currentWord.SyntaxColor.HasBackground)
                        wordBackBrush = BrushRegistry.GetBrush(currentWord.SyntaxColor.BackgroundColor);
                    else
                        wordBackBrush = backgroundBrush;
                }

                RectangleF wordRectangle;

                if (currentWord.Type == TextFileEdit.Document.TextWordType.Space)
                {
                    ++physicalColumn;

                    wordRectangle = new RectangleF(physicalXPos, lineRectangle.Y, SpaceWidth, lineRectangle.Height);
                    g.FillRectangle(wordBackBrush, wordRectangle);

                    if (TextEditorProperties.ShowSpaces)
                    {
                        DrawSpaceMarker(g, wordForeColor, physicalXPos, lineRectangle.Y);
                    }
                    physicalXPos += SpaceWidth;
                }
                else if (currentWord.Type == TextFileEdit.Document.TextWordType.Tab)
                {

                    physicalColumn += TextEditorProperties.TabIndent;
                    physicalColumn = (physicalColumn / TextEditorProperties.TabIndent) * TextEditorProperties.TabIndent;
                    // go to next tabstop
                    int physicalTabEnd = ((physicalXPos + MinTabWidth - lineRectangle.X)
                                          / WideSpaceWidth / TextEditorProperties.TabIndent)
                        * WideSpaceWidth * TextEditorProperties.TabIndent + lineRectangle.X;
                    physicalTabEnd += WideSpaceWidth * TextEditorProperties.TabIndent;

                    wordRectangle = new RectangleF(physicalXPos, lineRectangle.Y, physicalTabEnd - physicalXPos, lineRectangle.Height);
                    g.FillRectangle(wordBackBrush, wordRectangle);

                    if (TextEditorProperties.ShowTabs)
                    {
                        DrawTabMarker(g, wordForeColor, physicalXPos, lineRectangle.Y);
                    }
                    physicalXPos = physicalTabEnd;
                }
                else if (currentWord.Type == TextFileEdit.Document.TextWordType.Null)
                {
                    ++physicalColumn;

                    int w = SpaceWidth * 3;
                    wordRectangle = new RectangleF(physicalXPos, lineRectangle.Y, w, lineRectangle.Height);
                    g.FillRectangle(wordBackBrush, wordRectangle);
                    wordRectangle.Inflate(-1, -3);
                    wordRectangle.Width += 1;
                    wordRectangle.Height -= 2;

                    g.FillRectangle(Brushes.Black, wordRectangle);
                    //g.DrawRectangle(Pens.Black, (int)wordRectangle.X, (int)wordRectangle.Y, (int)wordRectangle.Width, (int)wordRectangle.Height);

                    if (TextEditorProperties.ShowSpaces)
                    {
                        DrawNullMarker(g, currentWord.Word, Color.White, physicalXPos, lineRectangle.Y);
                    }
                    physicalXPos += w;
                }
                else
                {
                    int wordWidth = DrawDocumentWord(g,
                                                     currentWord.Word,
                                                     new Point(physicalXPos, lineRectangle.Y),
                                                     currentWord.GetFont(fontContainer),
                                                     wordForeColor,
                                                     wordBackBrush);
                    wordRectangle = new RectangleF(physicalXPos, lineRectangle.Y, wordWidth, lineRectangle.Height);
                    physicalXPos += wordWidth;
                }
                foreach (TextFileEdit.Document.TextMarker marker in markers)
                {
                    if (marker.TextMarkerType != TextFileEdit.Document.TextMarkerType.SolidBlock)
                    {
                        DrawMarker(g, marker, wordRectangle);
                    }
                }

                // draw bracket highlight
                if (highlight != null)
                {
                    if (highlight.OpenBrace.Y == lineNumber && highlight.OpenBrace.X == currentWordOffset ||
                        highlight.CloseBrace.Y == lineNumber && highlight.CloseBrace.X == currentWordOffset)
                    {
                        DrawBracketHighlight(g, new Rectangle((int)wordRectangle.X, lineRectangle.Y, (int)wordRectangle.Width - 1, lineRectangle.Height - 1));
                    }
                }

                currentWordOffset += currentWord.Length;
                if (nextCurrentWord != null)
                {
                    currentWord = nextCurrentWord;
                    nextCurrentWord = null;
                    goto repeatDrawCurrentWord;
                }
            }
            if (physicalXPos < lineRectangle.Right && endColumn >= currentLine.Length)
            {
                // draw markers at line end
                IList<TextFileEdit.Document.TextMarker> markers = Document.MarkerStrategy.GetMarkers(currentLine.Offset + currentLine.Length);
                foreach (TextFileEdit.Document.TextMarker marker in markers)
                {
                    if (marker.TextMarkerType != TextFileEdit.Document.TextMarkerType.SolidBlock)
                    {
                        DrawMarker(g, marker, new RectangleF(physicalXPos, lineRectangle.Y, WideSpaceWidth, lineRectangle.Height));
                    }
                }
            }
            return physicalXPos;
        }

        int DrawDocumentWord(Graphics g, string word, Point position, Font font, Color foreColor, Brush backBrush)
        {
            if (word == null || word.Length == 0)
            {
                return 0;
            }

            if (word.Length > MaximumWordLength)
            {
                int width = 0;
                for (int i = 0; i < word.Length; i += MaximumWordLength)
                {
                    Point pos = position;
                    pos.X += width;
                    if (i + MaximumWordLength < word.Length)
                        width += DrawDocumentWord(g, word.Substring(i, MaximumWordLength), pos, font, foreColor, backBrush);
                    else
                        width += DrawDocumentWord(g, word.Substring(i, word.Length - i), pos, font, foreColor, backBrush);
                }
                return width;
            }

            int wordWidth = MeasureStringWidth(g, word, font);

            //num = ++num % 3;
            g.FillRectangle(backBrush, //num == 0 ? Brushes.LightBlue : num == 1 ? Brushes.LightGreen : Brushes.Yellow,
                            new RectangleF(position.X, position.Y, wordWidth + 1, FontHeight));

            DrawString(g,
                       word,
                       font,
                       foreColor,
                       position.X,
                       position.Y);
            return wordWidth;
        }

        struct WordFontPair
        {
            string word;
            Font font;
            public WordFontPair(string word, Font font)
            {
                this.word = word;
                this.font = font;
            }
            public override bool Equals(object obj)
            {
                WordFontPair myWordFontPair = (WordFontPair)obj;
                if (!word.Equals(myWordFontPair.word)) return false;
                return font.Equals(myWordFontPair.font);
            }

            public override int GetHashCode()
            {
                return word.GetHashCode() ^ font.GetHashCode();
            }
        }

        Dictionary<WordFontPair, int> measureCache = new Dictionary<WordFontPair, int>();

        // split words after 1000 characters. Fixes GDI+ crash on very longs words, for example
        // a 100 KB Base64-file without any line breaks.
        const int MaximumWordLength = 1000;
        const int MaximumCacheSize = 2000;

        int MeasureStringWidth(Graphics g, string word, Font font)
        {
            int width;

            if (word == null || word.Length == 0)
                return 0;
            if (word.Length > MaximumWordLength)
            {
                width = 0;
                for (int i = 0; i < word.Length; i += MaximumWordLength)
                {
                    if (i + MaximumWordLength < word.Length)
                        width += MeasureStringWidth(g, word.Substring(i, MaximumWordLength), font);
                    else
                        width += MeasureStringWidth(g, word.Substring(i, word.Length - i), font);
                }
                return width;
            }
            if (measureCache.TryGetValue(new WordFontPair(word, font), out width))
            {
                return width;
            }
            if (measureCache.Count > MaximumCacheSize)
            {
                measureCache.Clear();
            }

            // This code here provides better results than MeasureString!
            // Example line that is measured wrong:
            // txt.GetPositionFromCharIndex(txt.SelectionStart)
            // (Verdana 10, highlighting makes GetP... bold) -> note the space between 'x' and '('
            // this also fixes "jumping" characters when selecting in non-monospace fonts
            // [...]
            // Replaced GDI+ measurement with GDI measurement: faster and even more exact
            width = TextRenderer.MeasureText(g, word, font, new Size(short.MaxValue, short.MaxValue), textFormatFlags).Width;
            measureCache.Add(new WordFontPair(word, font), width);
            return width;
        }

        // Important: Some flags combinations work on WinXP, but not on Win2000.
        // Make sure to test changes here on all operating systems.
        const TextFormatFlags textFormatFlags =
            TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix | TextFormatFlags.PreserveGraphicsClipping;
#endregion

#region Conversion Functions
        Dictionary<Font, Dictionary<char, int>> fontBoundCharWidth = new Dictionary<Font, Dictionary<char, int>>();

        public int GetWidth(char ch, Font font)
        {
            if (!fontBoundCharWidth.ContainsKey(font))
            {
                fontBoundCharWidth.Add(font, new Dictionary<char, int>());
            }
            if (!fontBoundCharWidth[font].ContainsKey(ch))
            {
                using (Graphics g = textArea.CreateGraphics())
                {
                    return GetWidth(g, ch, font);
                }
            }
            return fontBoundCharWidth[font][ch];
        }

        public int GetWidth(Graphics g, char ch, Font font)
        {
            if (!fontBoundCharWidth.ContainsKey(font))
            {
                fontBoundCharWidth.Add(font, new Dictionary<char, int>());
            }
            if (!fontBoundCharWidth[font].ContainsKey(ch))
            {
                //Console.WriteLine("Calculate character width: " + ch);
                fontBoundCharWidth[font].Add(ch, MeasureStringWidth(g, ch.ToString(), font));
            }
            return fontBoundCharWidth[font][ch];
        }

        public int GetVisualColumn(int logicalLine, int logicalColumn)
        {
            int column = 0;
            using (Graphics g = textArea.CreateGraphics())
            {
                CountColumns(ref column, 0, logicalColumn, logicalLine, g);
            }
            return column;
        }

        public int GetVisualColumnFast(TextFileEdit.Document.LineSegment line, int logicalColumn)
        {
            int lineOffset = line.Offset;
            int tabIndent = Document.TextEditorProperties.TabIndent;
            int guessedColumn = 0;
            for (int i = 0; i < logicalColumn; ++i)
            {
                char ch;
                if (i >= line.Length)
                {
                    ch = ' ';
                }
                else
                {
                    ch = Document.GetCharAt(lineOffset + i);
                }
                switch (ch)
                {
                    case '\t':
                        guessedColumn += tabIndent;
                        guessedColumn = (guessedColumn / tabIndent) * tabIndent;
                        break;
                    default:
                        ++guessedColumn;
                        break;
                }
            }
            return guessedColumn;
        }

        /// <summary>
        /// returns line/column for a visual point position
        /// </summary>
        public TextLocation GetLogicalPosition(Point mousePosition)
        {
            TextFileEdit.Document.FoldMarker dummy;
            return GetLogicalColumn(GetLogicalLine(mousePosition.Y), mousePosition.X, out dummy);
        }

        /// <summary>
        /// returns line/column for a visual point position
        /// </summary>
        public TextLocation GetLogicalPosition(int visualPosX, int visualPosY)
        {
            TextFileEdit.Document.FoldMarker dummy;
            return GetLogicalColumn(GetLogicalLine(visualPosY), visualPosX, out dummy);
        }

        /// <summary>
        /// returns line/column for a visual point position
        /// </summary>
        public TextFileEdit.Document.FoldMarker GetFoldMarkerFromPosition(int visualPosX, int visualPosY)
        {
            TextFileEdit.Document.FoldMarker foldMarker;
            GetLogicalColumn(GetLogicalLine(visualPosY), visualPosX, out foldMarker);
            return foldMarker;
        }

        /// <summary>
        /// returns logical line number for a visual point
        /// </summary>
        public int GetLogicalLine(int visualPosY)
        {
            int clickedVisualLine = Math.Max(0, (visualPosY + this.textArea.VirtualTop.Y) / fontHeight);
            return Document.GetFirstLogicalLine(clickedVisualLine);
        }

        internal TextLocation GetLogicalColumn(int lineNumber, int visualPosX, out TextFileEdit.Document.FoldMarker inFoldMarker)
        {
            visualPosX += textArea.VirtualTop.X;

            inFoldMarker = null;
            if (lineNumber >= Document.TotalNumberOfLines)
            {
                return new TextLocation((int)(visualPosX / WideSpaceWidth), lineNumber);
            }
            if (visualPosX <= 0)
            {
                return new TextLocation(0, lineNumber);
            }

            int start = 0; // column
            int posX = 0; // visual position

            int result;
            using (Graphics g = textArea.CreateGraphics())
            {
                // call GetLogicalColumnInternal to skip over text,
                // then skip over fold markers
                // and repeat as necessary.
                // The loop terminates once the correct logical column is reached in
                // GetLogicalColumnInternal or inside a fold marker.
                while (true)
                {

                    TextFileEdit.Document.LineSegment line = Document.GetLineSegment(lineNumber);
                    TextFileEdit.Document.FoldMarker nextFolding = FindNextFoldedFoldingOnLineAfterColumn(lineNumber, start - 1);
                    int end = nextFolding != null ? nextFolding.StartColumn : int.MaxValue;
                    result = GetLogicalColumnInternal(g, line, start, end, ref posX, visualPosX);

                    // break when GetLogicalColumnInternal found the result column
                    if (result < end)
                        break;

                    // reached fold marker
                    lineNumber = nextFolding.EndLine;
                    start = nextFolding.EndColumn;
                    int newPosX = posX + 1 + MeasureStringWidth(g, nextFolding.FoldText, TextEditorProperties.FontContainer.RegularFont);
                    if (newPosX >= visualPosX)
                    {
                        inFoldMarker = nextFolding;
                        if (IsNearerToAThanB(visualPosX, posX, newPosX))
                            return new TextLocation(nextFolding.StartColumn, nextFolding.StartLine);
                        else
                            return new TextLocation(nextFolding.EndColumn, nextFolding.EndLine);
                    }
                    posX = newPosX;
                }
            }
            return new TextLocation(result, lineNumber);
        }

        int GetLogicalColumnInternal(Graphics g, TextFileEdit.Document.LineSegment line, int start, int end, ref int drawingPos, int targetVisualPosX)
        {
            if (start == end)
                return end;
            Debug.Assert(start < end);
            Debug.Assert(drawingPos < targetVisualPosX);

            int tabIndent = Document.TextEditorProperties.TabIndent;

            /*float spaceWidth = SpaceWidth;
            float drawingPos = 0;
            LineSegment currentLine = Document.GetLineSegment(logicalLine);
            List<TextWord> words = currentLine.Words;
            if (words == null) return 0;
            int wordCount = words.Count;
            int wordOffset = 0;
            FontContainer fontContainer = TextEditorProperties.FontContainer;
             */
            TextFileEdit.Document.FontContainer fontContainer = TextEditorProperties.FontContainer;

            List<TextFileEdit.Document.TextWord> words = line.Words;
            if (words == null) return 0;
            int wordOffset = 0;
            for (int i = 0; i < words.Count; i++)
            {
                TextFileEdit.Document.TextWord word = words[i];
                if (wordOffset >= end)
                {
                    return wordOffset;
                }
                if (wordOffset + word.Length >= start)
                {
                    int newDrawingPos;
                    switch (word.Type)
                    {
                        case TextFileEdit.Document.TextWordType.Space:
                            newDrawingPos = drawingPos + spaceWidth;
                            if (newDrawingPos >= targetVisualPosX)
                                return IsNearerToAThanB(targetVisualPosX, drawingPos, newDrawingPos) ? wordOffset : wordOffset + 1;
                            break;
                        case TextFileEdit.Document.TextWordType.Tab:
                            // go to next tab position
                            drawingPos = (int)((drawingPos + MinTabWidth) / tabIndent / WideSpaceWidth) * tabIndent * WideSpaceWidth;
                            newDrawingPos = drawingPos + tabIndent * WideSpaceWidth;
                            if (newDrawingPos >= targetVisualPosX)
                                return IsNearerToAThanB(targetVisualPosX, drawingPos, newDrawingPos) ? wordOffset : wordOffset + 1;
                            break;
                        case TextFileEdit.Document.TextWordType.Null:
                            newDrawingPos = drawingPos + spaceWidth * 3;
                            if (newDrawingPos >= targetVisualPosX)
                                return IsNearerToAThanB(targetVisualPosX, drawingPos, newDrawingPos) ? wordOffset : wordOffset + 1;
                            break;
                        case TextFileEdit.Document.TextWordType.Word:
                            int wordStart = Math.Max(wordOffset, start);
                            int wordLength = Math.Min(wordOffset + word.Length, end) - wordStart;
                            string text = Document.GetText(line.Offset + wordStart, wordLength);
                            Font font = word.GetFont(fontContainer) ?? fontContainer.RegularFont;
                            newDrawingPos = drawingPos + MeasureStringWidth(g, text, font);
                            if (newDrawingPos >= targetVisualPosX)
                            {
                                for (int j = 0; j < text.Length; j++)
                                {
                                    newDrawingPos = drawingPos + MeasureStringWidth(g, text[j].ToString(), font);
                                    if (newDrawingPos >= targetVisualPosX)
                                    {
                                        if (IsNearerToAThanB(targetVisualPosX, drawingPos, newDrawingPos))
                                            return wordStart + j;
                                        else
                                            return wordStart + j + 1;
                                    }
                                    drawingPos = newDrawingPos;
                                }
                                return wordStart + text.Length;
                            }
                            break;
                        default:
                            throw new NotSupportedException();
                    }
                    drawingPos = newDrawingPos;
                }
                wordOffset += word.Length;
            }
            return wordOffset;
        }

        static bool IsNearerToAThanB(int num, int a, int b)
        {
            return Math.Abs(a - num) < Math.Abs(b - num);
        }

        TextFileEdit.Document.FoldMarker FindNextFoldedFoldingOnLineAfterColumn(int lineNumber, int column)
        {
            List<TextFileEdit.Document.FoldMarker> list = Document.FoldingManager.GetFoldedFoldingsWithStartAfterColumn(lineNumber, column);
            if (list.Count != 0)
                return list[0];
            else
                return null;
        }

        const int MinTabWidth = 4;

        float CountColumns(ref int column, int start, int end, int logicalLine, Graphics g)
        {
            if (start > end) throw new ArgumentException("start > end");
            if (start == end) return 0;
            float spaceWidth = SpaceWidth;
            float drawingPos = 0;
            int tabIndent = Document.TextEditorProperties.TabIndent;
            TextFileEdit.Document.LineSegment currentLine = Document.GetLineSegment(logicalLine);
            List<TextFileEdit.Document.TextWord> words = currentLine.Words;
            if (words == null) return 0;
            int wordCount = words.Count;
            int wordOffset = 0;
            TextFileEdit.Document.FontContainer fontContainer = TextEditorProperties.FontContainer;
            for (int i = 0; i < wordCount; i++)
            {
                TextFileEdit.Document.TextWord word = words[i];
                if (wordOffset >= end)
                    break;
                if (wordOffset + word.Length >= start)
                {
                    switch (word.Type)
                    {
                        case TextFileEdit.Document.TextWordType.Space:
                            drawingPos += spaceWidth;
                            break;
                        case TextFileEdit.Document.TextWordType.Tab:
                            // go to next tab position
                            drawingPos = (int)((drawingPos + MinTabWidth) / tabIndent / WideSpaceWidth) * tabIndent * WideSpaceWidth;
                            drawingPos += tabIndent * WideSpaceWidth;
                            break;
                        case TextFileEdit.Document.TextWordType.Null:
                            drawingPos += spaceWidth * 3;
                            break;
                        case TextFileEdit.Document.TextWordType.Word:
                            int wordStart = Math.Max(wordOffset, start);
                            int wordLength = Math.Min(wordOffset + word.Length, end) - wordStart;
                            string text = Document.GetText(currentLine.Offset + wordStart, wordLength);
                            drawingPos += MeasureStringWidth(g, text, word.GetFont(fontContainer) ?? fontContainer.RegularFont);
                            break;
                    }
                }
                wordOffset += word.Length;
            }
            for (int j = currentLine.Length; j < end; j++)
            {
                drawingPos += WideSpaceWidth;
            }
            // add one pixel in column calculation to account for floating point calculation errors
            column += (int)((drawingPos + 1) / WideSpaceWidth);

            /* OLD Code (does not work for fonts like Verdana)
            for (int j = start; j < end; ++j) {
                char ch;
                if (j >= line.Length) {
                    ch = ' ';
                } else {
                    ch = Document.GetCharAt(line.Offset + j);
                }
                
                switch (ch) {
                    case '\t':
                        int oldColumn = column;
                        column += tabIndent;
                        column = (column / tabIndent) * tabIndent;
                        drawingPos += (column - oldColumn) * spaceWidth;
                        break;
                    default:
                        ++column;
                        TextWord word = line.GetWord(j);
                        if (word == null || word.Font == null) {
                            drawingPos += GetWidth(ch, TextEditorProperties.Font);
                        } else {
                            drawingPos += GetWidth(ch, word.Font);
                        }
                        break;
                }
            }
            //*/
            return drawingPos;
        }

        public int GetDrawingXPos(int logicalLine, int logicalColumn)
        {
            List<TextFileEdit.Document.FoldMarker> foldings = Document.FoldingManager.GetTopLevelFoldedFoldings();
            int i;
            TextFileEdit.Document.FoldMarker f = null;
            // search the last folding that's interresting
            for (i = foldings.Count - 1; i >= 0; --i)
            {
                f = foldings[i];
                if (f.StartLine < logicalLine || f.StartLine == logicalLine && f.StartColumn < logicalColumn)
                {
                    break;
                }
                TextFileEdit.Document.FoldMarker f2 = foldings[i / 2];
                if (f2.StartLine > logicalLine || f2.StartLine == logicalLine && f2.StartColumn >= logicalColumn)
                {
                    i /= 2;
                }
            }
            int lastFolding = 0;
            int firstFolding = 0;
            int column = 0;
            int tabIndent = Document.TextEditorProperties.TabIndent;
            float drawingPos;
            Graphics g = textArea.CreateGraphics();
            // if no folding is interresting
            if (f == null || !(f.StartLine < logicalLine || f.StartLine == logicalLine && f.StartColumn < logicalColumn))
            {
                drawingPos = CountColumns(ref column, 0, logicalColumn, logicalLine, g);
                return (int)(drawingPos - textArea.VirtualTop.X);
            }

            // if logicalLine/logicalColumn is in folding
            if (f.EndLine > logicalLine || f.EndLine == logicalLine && f.EndColumn > logicalColumn)
            {
                logicalColumn = f.StartColumn;
                logicalLine = f.StartLine;
                --i;
            }
            lastFolding = i;

            // search backwards until a new visible line is reched
            for (; i >= 0; --i)
            {
                f = (TextFileEdit.Document.FoldMarker)foldings[i];
                if (f.EndLine < logicalLine)
                { // reached the begin of a new visible line
                    break;
                }
            }
            firstFolding = i + 1;

            if (lastFolding < firstFolding)
            {
                drawingPos = CountColumns(ref column, 0, logicalColumn, logicalLine, g);
                return (int)(drawingPos - textArea.VirtualTop.X);
            }

            int foldEnd = 0;
            drawingPos = 0;
            for (i = firstFolding; i <= lastFolding; ++i)
            {
                f = foldings[i];
                drawingPos += CountColumns(ref column, foldEnd, f.StartColumn, f.StartLine, g);
                foldEnd = f.EndColumn;
                column += f.FoldText.Length;
                drawingPos += additionalFoldTextSize;
                drawingPos += MeasureStringWidth(g, f.FoldText, TextEditorProperties.FontContainer.RegularFont);
            }
            drawingPos += CountColumns(ref column, foldEnd, logicalColumn, logicalLine, g);
            g.Dispose();
            return (int)(drawingPos - textArea.VirtualTop.X);
        }
#endregion

#region DrawHelper functions
        void DrawBracketHighlight(Graphics g, Rectangle rect)
        {
            g.FillRectangle(BrushRegistry.GetBrush(Color.FromArgb(50, 0, 0, 255)), rect);
            g.DrawRectangle(Pens.Blue, rect);
        }

        void DrawString(Graphics g, string text, Font font, Color color, int x, int y)
        {
            TextRenderer.DrawText(g, text, font, new Point(x, y), color, textFormatFlags);
        }

        void DrawInvalidLineMarker(Graphics g, int x, int y)
        {
            TextFileEdit.Document.HighlightColor invalidLinesColor = textArea.Document.HighlightingStrategy.GetColorFor("InvalidLines");
            DrawString(g, "------------------------", invalidLinesColor.GetFont(TextEditorProperties.FontContainer), Color.LightGray, x, y);
        }

        void DrawSpaceMarker(Graphics g, Color color, int x, int y)
        {
            TextFileEdit.Document.HighlightColor spaceMarkerColor = textArea.Document.HighlightingStrategy.GetColorFor("SpaceMarkers");
            DrawString(g, "\u00B7", spaceMarkerColor.GetFont(TextEditorProperties.FontContainer), color, x, y);
        }

        void DrawTabMarker(Graphics g, Color color, int x, int y)
        {
            TextFileEdit.Document.HighlightColor tabMarkerColor = textArea.Document.HighlightingStrategy.GetColorFor("TabMarkers");
            DrawString(g, "\u00BB", tabMarkerColor.GetFont(TextEditorProperties.FontContainer), color, x, y);
        }

        void DrawNullMarker(Graphics g, string text, Color color, int x, int y)
        {
            TextFileEdit.Document.HighlightColor nullMarkerColor = textArea.Document.HighlightingStrategy.GetColorFor("NullMarkers");
            Font f = nullMarkerColor.GetFont(TextEditorProperties.FontContainer);
            f = new Font(f.FontFamily, f.Size - 2);

            if (text.Length > 0)
            {
                switch (text[0])
                {
                    case '\x0000': text = "NUL"; break; //(Null character)
                    case '\x0001': text = "SOH"; break; //(Start of Header)
                    case '\x0002': text = "STX"; break; //(Start of Text)
                    case '\x0003': text = "ETX"; break; //(End of Text)
                    case '\x0004': text = "EOT"; break; //(End of Trans.)
                    case '\x0005': text = "ENQ"; break; //(Enquiry)
                    case '\x0006': text = "ACK"; break; //(Acknowledgement)
                    case '\x0007': text = "BEL"; break; //(Bell)
                    case '\x0008': text = "BS"; break; //(Backspace)
                    //case '\x0009': text = "HT"; break; //(Horizontal Tab)
                    //case '\x000A': text = "LF"; break; //(Line feed)
                    case '\x000B': text = "VT"; break; //(Vertical Tab)
                    case '\x000C': text = "FF"; break; //(Form feed)
                    //case '\x000D': text = "CR"; break; //(Carriage return)
                    case '\x000E': text = "SO"; break; //(Shift Out)
                    case '\x000F': text = "SI"; break; //(Shift In)
                    case '\x0010': text = "DLE"; break; //(Data link escape)
                    case '\x0011': text = "DC1"; break; //(Device control 1)
                    case '\x0012': text = "DC2"; break; //(Device control 2)
                    case '\x0013': text = "DC3"; break; //(Device control 3)
                    case '\x0014': text = "DC4"; break; //(Device control 4)
                    case '\x0015': text = "NAK"; break; //(Negative acknowl.)
                    case '\x0016': text = "SYN"; break; //(Synchronous idle)
                    case '\x0017': text = "ETB"; break; //(End of trans. block)
                    case '\x0018': text = "CAN"; break; //(Cancel)
                    case '\x0019': text = "EM"; break; //(End of medium)
                    case '\x001A': text = "SUB"; break; //(Substitute)
                    case '\x001B': text = "ESC"; break; //(Escape)
                    case '\x001C': text = "FS"; break; //(File separator)
                    case '\x001D': text = "GS"; break; //(Group separator)
                    case '\x001E': text = "RS"; break; //(Record separator)
                    case '\x001F': text = "US"; break; //(Unit separator)
                    case '\x007F': text = "DEL"; break; //(Delete)            
                }
            }
            if (text.Length != 3) text = "???";

            DrawString(g, text, f, color, x + 2, y);
        }

        int DrawEOLMarker(Graphics g, Color color, Brush backBrush, int x, int y)
        {
            TextFileEdit.Document.HighlightColor eolMarkerColor = textArea.Document.HighlightingStrategy.GetColorFor("EOLMarkers");

            int width = GetWidth('\u00B6', eolMarkerColor.GetFont(TextEditorProperties.FontContainer));
            g.FillRectangle(backBrush,
                            new RectangleF(x, y, width, fontHeight));

            DrawString(g, "\u00B6", eolMarkerColor.GetFont(TextEditorProperties.FontContainer), color, x, y);
            return width;
        }

        void DrawVerticalRuler(Graphics g, Rectangle lineRectangle)
        {
            int xpos = WideSpaceWidth * TextEditorProperties.VerticalRulerRow - textArea.VirtualTop.X;
            if (xpos <= 0)
            {
                return;
            }
            TextFileEdit.Document.HighlightColor vRulerColor = textArea.Document.HighlightingStrategy.GetColorFor("VRuler");

            g.DrawLine(BrushRegistry.GetPen(vRulerColor.Color),
                       drawingPosition.Left + xpos,
                       lineRectangle.Top,
                       drawingPosition.Left + xpos,
                       lineRectangle.Bottom);
        }
#endregion
    }
}

#endif
// file ...\TextFileEdit\Gui\ToolTipRequestEventArgs.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Daniel Grunwald" email="daniel@danielgrunwald.de"/>
//     <version>$Revision: 2659 $</version>
// </file>


namespace TextFileEdit
{
	public delegate void ToolTipRequestEventHandler(object sender, ToolTipRequestEventArgs e);
	
	public class ToolTipRequestEventArgs
	{
		Point mousePosition;
		TextLocation logicalPosition;
		bool inDocument;
		
		public Point MousePosition {
			get {
				return mousePosition;
			}
		}
		
		public TextLocation LogicalPosition {
			get {
				return logicalPosition;
			}
		}
		
		public bool InDocument {
			get {
				return inDocument;
			}
		}
		
		/// <summary>
		/// Gets if some client handling the event has already shown a tool tip.
		/// </summary>
		public bool ToolTipShown {
			get {
				return toolTipText != null;
			}
		}
		
		internal string toolTipText;
		
		public void ShowToolTip(string text)
		{
			toolTipText = text;
		}
		
		public ToolTipRequestEventArgs(Point mousePosition, TextLocation logicalPosition, bool inDocument)
		{
			this.mousePosition = mousePosition;
			this.logicalPosition = logicalPosition;
			this.inDocument = inDocument;
		}
	}
}

#endif
// file ...\TextFileEdit\Gui\CompletionWindow\AbstractCompletionWindow.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2681 $</version>
// </file>


namespace TextFileEdit.Gui.CompletionWindow
{
    /// <summary>
    /// Description of AbstractCompletionWindow.
    /// </summary>
    public abstract class AbstractCompletionWindow : System.Windows.Forms.Form
    {
        protected TextEditorControl control;
        protected Size              drawingSize;
        Rectangle workingScreen;
        Form parentForm;
        
        protected AbstractCompletionWindow(Form parentForm, TextEditorControl control)
        {
            workingScreen = Screen.GetWorkingArea(parentForm);
//          SetStyle(ControlStyles.Selectable, false);
            this.parentForm = parentForm;
            this.control  = control;
            
            SetLocation();
            StartPosition   = FormStartPosition.Manual;
            FormBorderStyle = FormBorderStyle.None;
            ShowInTaskbar   = false;
            MinimumSize     = new Size(1, 1);
            Size            = new Size(1, 1);
        }
        
        protected virtual void SetLocation()
        {
            TextArea textArea = control.ActiveTextAreaControl.TextArea;
            TextLocation caretPos  = textArea.Caret.Position;
            
            int xpos = textArea.TextView.GetDrawingXPos(caretPos.Y, caretPos.X);
            int rulerHeight = textArea.TextEditorProperties.ShowHorizontalRuler ? textArea.TextView.FontHeight : 0;
            Point pos = new Point(textArea.TextView.DrawingPosition.X + xpos,
                                  textArea.TextView.DrawingPosition.Y + (textArea.Document.GetVisibleLine(caretPos.Y)) * textArea.TextView.FontHeight 
                                  - textArea.TextView.TextArea.VirtualTop.Y + textArea.TextView.FontHeight + rulerHeight);
            
            Point location = control.ActiveTextAreaControl.PointToScreen(pos);
            
            // set bounds
            Rectangle bounds = new Rectangle(location, drawingSize);
            
            if (!workingScreen.Contains(bounds)) {
                if (bounds.Right > workingScreen.Right) {
                    bounds.X = workingScreen.Right - bounds.Width;
                }
                if (bounds.Left < workingScreen.Left) {
                    bounds.X = workingScreen.Left;
                }
                if (bounds.Top < workingScreen.Top) {
                    bounds.Y = workingScreen.Top;
                }
                if (bounds.Bottom > workingScreen.Bottom) {
                    bounds.Y = bounds.Y - bounds.Height - control.ActiveTextAreaControl.TextArea.TextView.FontHeight;
                    if (bounds.Bottom > workingScreen.Bottom) {
                        bounds.Y = workingScreen.Bottom - bounds.Height;
                    }
                }
            }
            Bounds = bounds;
        }
        
        protected override CreateParams CreateParams {
            get {
                CreateParams p = base.CreateParams;
                AddShadowToWindow(p);
                return p;
            }
        }
        
        static int shadowStatus;
        
        /// <summary>
        /// Adds a shadow to the create params if it is supported by the operating system.
        /// </summary>
        public static void AddShadowToWindow(CreateParams createParams)
        {
            if (shadowStatus == 0) {
                // Test OS version
                shadowStatus = -1; // shadow not supported
                if (Environment.OSVersion.Platform == PlatformID.Win32NT) {
                    Version ver = Environment.OSVersion.Version;
                    if (ver.Major > 5 || ver.Major == 5 && ver.Minor >= 1) {
                        shadowStatus = 1;
                    }
                }
            }
            if (shadowStatus == 1) {
                createParams.ClassStyle |= 0x00020000; // set CS_DROPSHADOW
            }
        }
        
        protected override bool ShowWithoutActivation {
            get {
                return true;
            }
        }
        
        protected void ShowCompletionWindow()
        {
            Owner = parentForm;
            Enabled = true;
            this.Show();
            
            control.Focus();
            
            if (parentForm != null) {
                parentForm.LocationChanged += new EventHandler(this.ParentFormLocationChanged);
            }
            
            control.ActiveTextAreaControl.VScrollBar.ValueChanged     += new EventHandler(ParentFormLocationChanged);
            control.ActiveTextAreaControl.HScrollBar.ValueChanged     += new EventHandler(ParentFormLocationChanged);
            control.ActiveTextAreaControl.TextArea.DoProcessDialogKey += new DialogKeyProcessor(ProcessTextAreaKey);
            control.ActiveTextAreaControl.Caret.PositionChanged       += new EventHandler(CaretOffsetChanged);
            control.ActiveTextAreaControl.TextArea.LostFocus          += new EventHandler(this.TextFileEditLostFocus);
            control.Resize += new EventHandler(ParentFormLocationChanged);
            
            foreach (Control c in Controls) {
                c.MouseMove += ControlMouseMove;
            }
        }
        
        void ParentFormLocationChanged(object sender, EventArgs e)
        {
            SetLocation();
        }
        
        public virtual bool ProcessKeyEvent(char ch)
        {
            return false;
        }
        
        protected virtual bool ProcessTextAreaKey(Keys keyData)
        {
            if (!Visible) {
                return false;
            }
            switch (keyData) {
                case Keys.Escape:
                    Close();
                    return true;
            }
            return false;
        }
        
        protected virtual void CaretOffsetChanged(object sender, EventArgs e)
        {
        }
        
        protected void TextFileEditLostFocus(object sender, EventArgs e)
        {
            if (!control.ActiveTextAreaControl.TextArea.Focused && !this.ContainsFocus) {
                Close();
            }
        }
        
        protected override void OnClosed(EventArgs e)
        {
            base.OnClosed(e);
            
            // take out the inserted methods
            parentForm.LocationChanged -= new EventHandler(ParentFormLocationChanged);
            
            foreach (Control c in Controls) {
                c.MouseMove -= ControlMouseMove;
            }
            
            if (control.ActiveTextAreaControl.VScrollBar != null) {
                control.ActiveTextAreaControl.VScrollBar.ValueChanged -= new EventHandler(ParentFormLocationChanged);
            }
            if (control.ActiveTextAreaControl.HScrollBar != null) {
                control.ActiveTextAreaControl.HScrollBar.ValueChanged -= new EventHandler(ParentFormLocationChanged);
            }
            
            control.ActiveTextAreaControl.TextArea.LostFocus          -= new EventHandler(this.TextFileEditLostFocus);
            control.ActiveTextAreaControl.Caret.PositionChanged       -= new EventHandler(CaretOffsetChanged);
            control.ActiveTextAreaControl.TextArea.DoProcessDialogKey -= new DialogKeyProcessor(ProcessTextAreaKey);
            control.Resize -= new EventHandler(ParentFormLocationChanged);
            Dispose();
        }
        
        protected override void OnMouseMove(MouseEventArgs e)
        {
            base.OnMouseMove(e);
            ControlMouseMove(this, e);
        }
        
        /// <summary>
        /// Invoked when the mouse moves over this form or any child control.
        /// Shows the mouse cursor on the text area if it has been hidden.
        /// </summary>
        /// <remarks>
        /// Derived classes should attach this handler to the MouseMove event
        /// of all created controls which are not added to the Controls
        /// collection.
        /// </remarks>
        protected void ControlMouseMove(object sender, MouseEventArgs e)
        {
            control.ActiveTextAreaControl.TextArea.ShowHiddenCursor(false);
        }
    }
}

#endif
// file ...\TextFileEdit\Gui\CompletionWindow\CodeCompletionListView.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2932 $</version>
// </file>


namespace TextFileEdit.Gui.CompletionWindow
{
	/// <summary>
	/// Description of CodeCompletionListView.
	/// </summary>
	public class CodeCompletionListView : System.Windows.Forms.UserControl
	{
		ICompletionData[] completionData;
		int               firstItem    = 0;
		int               selectedItem = -1;
		ImageList         imageList;
		
		public ImageList ImageList {
			get {
				return imageList;
			}
			set {
				imageList = value;
			}
		}
		
		public int FirstItem {
			get {
				return firstItem;
			}
			set {
				if (firstItem != value) {
					firstItem = value;
					OnFirstItemChanged(EventArgs.Empty);
				}
			}
		}
		
		public ICompletionData SelectedCompletionData {
			get {
				if (selectedItem < 0) {
					return null;
				}
				return completionData[selectedItem];
			}
		}
		
		public int ItemHeight {
			get {
				return Math.Max(imageList.ImageSize.Height, (int)(Font.Height * 1.25));
			}
		}
		
		public int MaxVisibleItem {
			get {
				return Height / ItemHeight;
			}
		}
		
		public CodeCompletionListView(ICompletionData[] completionData)
		{
			Array.Sort(completionData, DefaultCompletionData.Compare);
			this.completionData = completionData;
			
//			this.KeyDown += new System.Windows.Forms.KeyEventHandler(OnKey);
//			SetStyle(ControlStyles.Selectable, false);
//			SetStyle(ControlStyles.UserPaint, true);
//			SetStyle(ControlStyles.DoubleBuffer, false);
		}
		
		public void Close()
		{
			if (completionData != null) {
				Array.Clear(completionData, 0, completionData.Length);
			}
			base.Dispose();
		}
		
		public void SelectIndex(int index)
		{
			int oldSelectedItem = selectedItem;
			int oldFirstItem    = firstItem;
			
			index = Math.Max(0, index);
			selectedItem = Math.Max(0, Math.Min(completionData.Length - 1, index));
			if (selectedItem < firstItem) {
				FirstItem = selectedItem;
			}
			if (firstItem + MaxVisibleItem <= selectedItem) {
				FirstItem = selectedItem - MaxVisibleItem + 1;
			}
			if (oldSelectedItem != selectedItem) {
				if (firstItem != oldFirstItem) {
					Invalidate();
				} else {
					int min = Math.Min(selectedItem, oldSelectedItem) - firstItem;
					int max = Math.Max(selectedItem, oldSelectedItem) - firstItem;
					Invalidate(new Rectangle(0, 1 + min * ItemHeight, Width, (max - min + 1) * ItemHeight));
				}
				OnSelectedItemChanged(EventArgs.Empty);
			}
		}
		
		public void CenterViewOn(int index)
		{
			int oldFirstItem = this.FirstItem;
			int firstItem = index - MaxVisibleItem / 2;
			if (firstItem < 0)
				this.FirstItem = 0;
			else if (firstItem >= completionData.Length - MaxVisibleItem)
				this.FirstItem = completionData.Length - MaxVisibleItem;
			else
				this.FirstItem = firstItem;
			if (this.FirstItem != oldFirstItem) {
				Invalidate();
			}
		}
		
		public void ClearSelection()
		{
			if (selectedItem < 0)
				return;
			int itemNum = selectedItem - firstItem;
			selectedItem = -1;
			Invalidate(new Rectangle(0, itemNum * ItemHeight, Width, (itemNum + 1) * ItemHeight + 1));
			Update();
			OnSelectedItemChanged(EventArgs.Empty);
		}
		
		public void PageDown()
		{
			SelectIndex(selectedItem + MaxVisibleItem);
		}
		
		public void PageUp()
		{
			SelectIndex(selectedItem - MaxVisibleItem);
		}
		
		public void SelectNextItem()
		{
			SelectIndex(selectedItem + 1);
		}
		
		public void SelectPrevItem()
		{
			SelectIndex(selectedItem - 1);
		}
		
		public void SelectItemWithStart(string startText)
		{
			if (startText == null || startText.Length == 0) return;
			string originalStartText = startText;
			startText = startText.ToLower();
			int bestIndex = -1;
			int bestQuality = -1;
			// Qualities: 0 = match start
			//            1 = match start case sensitive
			//            2 = full match
			//            3 = full match case sensitive
			double bestPriority = 0;
			for (int i = 0; i < completionData.Length; ++i) {
				string itemText = completionData[i].Text;
				string lowerText = itemText.ToLower();
				if (lowerText.StartsWith(startText)) {
					double priority = completionData[i].Priority;
					int quality;
					if (lowerText == startText) {
						if (itemText == originalStartText)
							quality = 3;
						else
							quality = 2;
					} else if (itemText.StartsWith(originalStartText)) {
						quality = 1;
					} else {
						quality = 0;
					}
					bool useThisItem;
					if (bestQuality < quality) {
						useThisItem = true;
					} else {
						if (bestIndex == selectedItem) {
							useThisItem = false;
						} else if (i == selectedItem) {
							useThisItem = bestQuality == quality;
						} else {
							useThisItem = bestQuality == quality && bestPriority < priority;
						}
					}
					if (useThisItem) {
						bestIndex = i;
						bestPriority = priority;
						bestQuality = quality;
					}
				}
			}
			if (bestIndex < 0) {
				ClearSelection();
			} else {
				if (bestIndex < firstItem || firstItem + MaxVisibleItem <= bestIndex) {
					SelectIndex(bestIndex);
					CenterViewOn(bestIndex);
				} else {
					SelectIndex(bestIndex);
				}
			}
		}
		
		protected override void OnPaint(PaintEventArgs pe)
		{
			float yPos       = 1;
			float itemHeight = ItemHeight;
			// Maintain aspect ratio
			int imageWidth = (int)(itemHeight * imageList.ImageSize.Width / imageList.ImageSize.Height);
			
			int curItem = firstItem;
			Graphics g  = pe.Graphics;
			while (curItem < completionData.Length && yPos < Height) {
				RectangleF drawingBackground = new RectangleF(1, yPos, Width - 2, itemHeight);
				if (drawingBackground.IntersectsWith(pe.ClipRectangle)) {
					// draw Background
					if (curItem == selectedItem) {
						g.FillRectangle(SystemBrushes.Highlight, drawingBackground);
					} else {
						g.FillRectangle(SystemBrushes.Window, drawingBackground);
					}
					
					// draw Icon
					int   xPos   = 0;
					if (imageList != null && completionData[curItem].ImageIndex < imageList.Images.Count) {
						g.DrawImage(imageList.Images[completionData[curItem].ImageIndex], new RectangleF(1, yPos, imageWidth, itemHeight));
						xPos = imageWidth;
					}
					
					// draw text
					if (curItem == selectedItem) {
						g.DrawString(completionData[curItem].Text, Font, SystemBrushes.HighlightText, xPos, yPos);
					} else {
						g.DrawString(completionData[curItem].Text, Font, SystemBrushes.WindowText, xPos, yPos);
					}
				}
				
				yPos += itemHeight;
				++curItem;
			}
			g.DrawRectangle(SystemPens.Control, new Rectangle(0, 0, Width - 1, Height - 1));
		}
		
		protected override void OnMouseDown(System.Windows.Forms.MouseEventArgs e)
		{
			float yPos       = 1;
			int curItem = firstItem;
			float itemHeight = ItemHeight;
			
			while (curItem < completionData.Length && yPos < Height) {
				RectangleF drawingBackground = new RectangleF(1, yPos, Width - 2, itemHeight);
				if (drawingBackground.Contains(e.X, e.Y)) {
					SelectIndex(curItem);
					break;
				}
				yPos += itemHeight;
				++curItem;
			}
		}
		
		protected override void OnPaintBackground(PaintEventArgs pe)
		{
		}
		
		protected virtual void OnSelectedItemChanged(EventArgs e)
		{
			if (SelectedItemChanged != null) {
				SelectedItemChanged(this, e);
			}
		}
		
		protected virtual void OnFirstItemChanged(EventArgs e)
		{
			if (FirstItemChanged != null) {
				FirstItemChanged(this, e);
			}
		}
		
		public event EventHandler SelectedItemChanged;
		public event EventHandler FirstItemChanged;
	}
}

#endif
// file ...\TextFileEdit\Gui\CompletionWindow\CodeCompletionWindow.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3515 $</version>
// </file>


namespace TextFileEdit.Gui.CompletionWindow
{
    public class CodeCompletionWindow : AbstractCompletionWindow
    {
        ICompletionData[] completionData;
        CodeCompletionListView codeCompletionListView;
        VScrollBar vScrollBar = new VScrollBar();
        ICompletionDataProvider dataProvider;
        TextFileEdit.Document.IDocument document;
        bool showDeclarationWindow = true;
        bool fixedListViewWidth = true;
        const int ScrollbarWidth = 16;
        const int MaxListLength = 10;

        int startOffset;
        int endOffset;
        DeclarationViewWindow declarationViewWindow = null;
        Rectangle workingScreen;
        
        public static CodeCompletionWindow ShowCompletionWindow(Form parent, TextEditorControl control, string fileName, ICompletionDataProvider completionDataProvider, char firstChar)
        {
            return ShowCompletionWindow(parent, control, fileName, completionDataProvider, firstChar, true, true);
        }
        
        public static CodeCompletionWindow ShowCompletionWindow(Form parent, TextEditorControl control, string fileName, ICompletionDataProvider completionDataProvider, char firstChar, bool showDeclarationWindow, bool fixedListViewWidth)
        {
            ICompletionData[] completionData = completionDataProvider.GenerateCompletionData(fileName, control.ActiveTextAreaControl.TextArea, firstChar);
            if (completionData == null || completionData.Length == 0) {
                return null;
            }
            CodeCompletionWindow codeCompletionWindow = new CodeCompletionWindow(completionDataProvider, completionData, parent, control, showDeclarationWindow, fixedListViewWidth);
            codeCompletionWindow.CloseWhenCaretAtBeginning = firstChar == '\0';
            codeCompletionWindow.ShowCompletionWindow();
            return codeCompletionWindow;
        }
        
        CodeCompletionWindow(ICompletionDataProvider completionDataProvider, ICompletionData[] completionData, Form parentForm, TextEditorControl control, bool showDeclarationWindow, bool fixedListViewWidth) : base(parentForm, control)
        {
            this.dataProvider = completionDataProvider;
            this.completionData = completionData;
            this.document = control.Document;
            this.showDeclarationWindow = showDeclarationWindow;
            this.fixedListViewWidth = fixedListViewWidth;

            workingScreen = Screen.GetWorkingArea(Location);
            startOffset = control.ActiveTextAreaControl.Caret.Offset + 1;
            endOffset   = startOffset;
            if (completionDataProvider.PreSelection != null) {
                startOffset -= completionDataProvider.PreSelection.Length + 1;
                endOffset--;
            }
            
            codeCompletionListView = new CodeCompletionListView(completionData);
            codeCompletionListView.ImageList = completionDataProvider.ImageList;
            codeCompletionListView.Dock = DockStyle.Fill;
            codeCompletionListView.SelectedItemChanged += new EventHandler(CodeCompletionListViewSelectedItemChanged);
            codeCompletionListView.DoubleClick += new EventHandler(CodeCompletionListViewDoubleClick);
            codeCompletionListView.Click  += new EventHandler(CodeCompletionListViewClick);
            Controls.Add(codeCompletionListView);
            
            if (completionData.Length > MaxListLength) {
                vScrollBar.Dock = DockStyle.Right;
                vScrollBar.Minimum = 0;
                vScrollBar.Maximum = completionData.Length - 1;
                vScrollBar.SmallChange = 1;
                vScrollBar.LargeChange = MaxListLength;
                codeCompletionListView.FirstItemChanged += new EventHandler(CodeCompletionListViewFirstItemChanged);
                Controls.Add(vScrollBar);
            }
            
            this.drawingSize = GetListViewSize();
            SetLocation();
            
            if (declarationViewWindow == null) {
                declarationViewWindow = new DeclarationViewWindow(parentForm);
            }
            SetDeclarationViewLocation();
            declarationViewWindow.ShowDeclarationViewWindow();
            declarationViewWindow.MouseMove += ControlMouseMove;
            control.Focus();
            CodeCompletionListViewSelectedItemChanged(this, EventArgs.Empty);
            
            if (completionDataProvider.DefaultIndex >= 0) {
                codeCompletionListView.SelectIndex(completionDataProvider.DefaultIndex);
            }
            
            if (completionDataProvider.PreSelection != null) {
                CaretOffsetChanged(this, EventArgs.Empty);
            }
            
            vScrollBar.ValueChanged += VScrollBarValueChanged;
            document.DocumentAboutToBeChanged += DocumentAboutToBeChanged;
        }
        
        bool inScrollUpdate;
        
        void CodeCompletionListViewFirstItemChanged(object sender, EventArgs e)
        {
            if (inScrollUpdate) return;
            inScrollUpdate = true;
            vScrollBar.Value = Math.Min(vScrollBar.Maximum, codeCompletionListView.FirstItem);
            inScrollUpdate = false;
        }
        
        void VScrollBarValueChanged(object sender, EventArgs e)
        {
            if (inScrollUpdate) return;
            inScrollUpdate = true;
            codeCompletionListView.FirstItem = vScrollBar.Value;
            codeCompletionListView.Refresh();
            control.ActiveTextAreaControl.TextArea.Focus();
            inScrollUpdate = false;
        }
        
        void SetDeclarationViewLocation()
        {
            //  This method uses the side with more free space
            int leftSpace = Bounds.Left - workingScreen.Left;
            int rightSpace = workingScreen.Right - Bounds.Right;
            Point pos;
            // The declaration view window has better line break when used on
            // the right side, so prefer the right side to the left.
            if (rightSpace * 2 > leftSpace) {
                declarationViewWindow.FixedWidth = false;
                pos = new Point(Bounds.Right, Bounds.Top);
                if (declarationViewWindow.Location != pos) {
                    declarationViewWindow.Location = pos;
                }
            } else {
                declarationViewWindow.Width = declarationViewWindow.GetRequiredLeftHandSideWidth(new Point(Bounds.Left, Bounds.Top));
                declarationViewWindow.FixedWidth = true;
                if (Bounds.Left < declarationViewWindow.Width) {
                    pos = new Point(0, Bounds.Top);
                } else {
                    pos = new Point(Bounds.Left - declarationViewWindow.Width, Bounds.Top);
                }
                if (declarationViewWindow.Location != pos) {
                    declarationViewWindow.Location = pos;
                }
                declarationViewWindow.Refresh();
            }
        }
        
        protected override void SetLocation()
        {
            base.SetLocation();
            if (declarationViewWindow != null) {
                SetDeclarationViewLocation();
            }
        }
        
        Util.MouseWheelHandler mouseWheelHandler = new Util.MouseWheelHandler();
        
        public void HandleMouseWheel(MouseEventArgs e)
        {
            int scrollDistance = mouseWheelHandler.GetScrollAmount(e);
            if (scrollDistance == 0)
                return;
            if (control.TextEditorProperties.MouseWheelScrollDown)
                scrollDistance = -scrollDistance;
            int newValue = vScrollBar.Value + vScrollBar.SmallChange * scrollDistance;
            vScrollBar.Value = Math.Max(vScrollBar.Minimum, Math.Min(vScrollBar.Maximum - vScrollBar.LargeChange + 1, newValue));
        }

        void CodeCompletionListViewSelectedItemChanged(object sender, EventArgs e)
        {
            ICompletionData data = codeCompletionListView.SelectedCompletionData;
            if (showDeclarationWindow && data != null && data.Description != null && data.Description.Length > 0) {
                declarationViewWindow.Description = data.Description;
                SetDeclarationViewLocation();
            } else {
                declarationViewWindow.Description = null;
            }
        }
        
        public override bool ProcessKeyEvent(char ch)
        {
            switch (dataProvider.ProcessKey(ch)) {
                case CompletionDataProviderKeyResult.BeforeStartKey:
                    // increment start+end, then process as normal char
                    ++startOffset;
                    ++endOffset;
                    return base.ProcessKeyEvent(ch);
                case CompletionDataProviderKeyResult.NormalKey:
                    // just process normally
                    return base.ProcessKeyEvent(ch);
                case CompletionDataProviderKeyResult.InsertionKey:
                    return InsertSelectedItem(ch);
                default:
                    throw new InvalidOperationException("Invalid return value of dataProvider.ProcessKey");
            }
        }
        
        void DocumentAboutToBeChanged(object sender, TextFileEdit.Document.DocumentEventArgs e)
        {
            // => startOffset test required so that this startOffset/endOffset are not incremented again
            //    for BeforeStartKey characters
            if (e.Offset >= startOffset && e.Offset <= endOffset) {
                if (e.Length > 0) { // length of removed region
                    endOffset -= e.Length;
                }
                if (!string.IsNullOrEmpty(e.Text)) {
                    endOffset += e.Text.Length;
                }
            }
        }
        
        /// <summary>
        /// When this flag is set, code completion closes if the caret moves to the
        /// beginning of the allowed range. This is useful in Ctrl+Space and "complete when typing",
        /// but not in dot-completion.
        /// </summary>
        public bool CloseWhenCaretAtBeginning { get; set; }
        
        protected override void CaretOffsetChanged(object sender, EventArgs e)
        {
            int offset = control.ActiveTextAreaControl.Caret.Offset;
            if (offset == startOffset) {
                if (CloseWhenCaretAtBeginning)
                    Close();
                return;
            }
            if (offset < startOffset || offset > endOffset) {
                Close();
            } else {
                codeCompletionListView.SelectItemWithStart(control.Document.GetText(startOffset, offset - startOffset));
            }
        }
        
        protected override bool ProcessTextAreaKey(Keys keyData)
        {
            if (!Visible) {
                return false;
            }
            
            switch (keyData) {
                case Keys.Home:
                    codeCompletionListView.SelectIndex(0);
                    return true;
                case Keys.End:
                    codeCompletionListView.SelectIndex(completionData.Length-1);
                    return true;
                case Keys.PageDown:
                    codeCompletionListView.PageDown();
                    return true;
                case Keys.PageUp:
                    codeCompletionListView.PageUp();
                    return true;
                case Keys.Down:
                    codeCompletionListView.SelectNextItem();
                    return true;
                case Keys.Up:
                    codeCompletionListView.SelectPrevItem();
                    return true;
                case Keys.Tab:
                    InsertSelectedItem('\t');
                    return true;
                case Keys.Return:
                    InsertSelectedItem('\n');
                    return true;
            }
            return base.ProcessTextAreaKey(keyData);
        }
        
        void CodeCompletionListViewDoubleClick(object sender, EventArgs e)
        {
            InsertSelectedItem('\0');
        }
        
        void CodeCompletionListViewClick(object sender, EventArgs e)
        {
            control.ActiveTextAreaControl.TextArea.Focus();
        }
        
        protected override void Dispose(bool disposing)
        {
            if (disposing) {
                document.DocumentAboutToBeChanged -= DocumentAboutToBeChanged;
                if (codeCompletionListView != null) {
                    codeCompletionListView.Dispose();
                    codeCompletionListView = null;
                }
                if (declarationViewWindow != null) {
                    declarationViewWindow.Dispose();
                    declarationViewWindow = null;
                }
            }
            base.Dispose(disposing);
        }
        
        bool InsertSelectedItem(char ch)
        {
            document.DocumentAboutToBeChanged -= DocumentAboutToBeChanged;
            ICompletionData data = codeCompletionListView.SelectedCompletionData;
            bool result = false;
            if (data != null) {
                control.BeginUpdate();
                
                try {
                    if (endOffset - startOffset > 0) {
                        control.Document.Remove(startOffset, endOffset - startOffset);
                    }
                    Debug.Assert(startOffset <= document.TextLength);
                    result = dataProvider.InsertAction(data, control.ActiveTextAreaControl.TextArea, startOffset, ch);
                } finally {
                    control.EndUpdate();
                }
            }
            Close();
            return result;
        }
        
        Size GetListViewSize()
        {
            int height = codeCompletionListView.ItemHeight * Math.Min(MaxListLength, completionData.Length);
            int width = codeCompletionListView.ItemHeight * 10;
            if (!fixedListViewWidth) {
                width = GetListViewWidth(width, height);
            }
            return new Size(width, height);
        }
        
        /// <summary>
        /// Gets the list view width large enough to handle the longest completion data
        /// text string.
        /// </summary>
        /// <param name="defaultWidth">The default width of the list view.</param>
        /// <param name="height">The height of the list view.  This is
        /// used to determine if the scrollbar is visible.</param>
        /// <returns>The list view width to accommodate the longest completion
        /// data text string; otherwise the default width.</returns>
        int GetListViewWidth(int defaultWidth, int height)
        {
            float width = defaultWidth;
            using (Graphics graphics = codeCompletionListView.CreateGraphics()) {
                for (int i = 0; i < completionData.Length; ++i) {
                    float itemWidth = graphics.MeasureString(completionData[i].Text.ToString(), codeCompletionListView.Font).Width;
                    if(itemWidth > width) {
                        width = itemWidth;
                    }
                }
            }
            
            float totalItemsHeight = codeCompletionListView.ItemHeight * completionData.Length;
            if (totalItemsHeight > height) {
                width += ScrollbarWidth; // Compensate for scroll bar.
            }
            return (int)width;
        }
    }
}

#endif
// file ...\TextFileEdit\Gui\CompletionWindow\DeclarationViewWindow.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3515 $</version>
// </file>


namespace TextFileEdit.Gui.CompletionWindow
{
    public interface IDeclarationViewWindow
    {
        string Description {
            get;
            set;
        }
        void ShowDeclarationViewWindow();
        void CloseDeclarationViewWindow();
    }
    
    public class DeclarationViewWindow : Form, IDeclarationViewWindow
    {
        string description = String.Empty;
        bool fixedWidth;
        
        public string Description {
            get {
                return description;
            }
            set {
                description = value;
                if (value == null && Visible) {
                    Visible = false;
                } else if (value != null) {
                    if (!Visible) ShowDeclarationViewWindow();
                    Refresh();
                }
            }
        }
        
        public bool FixedWidth {
            get {
                return fixedWidth;
            }
            set {
                fixedWidth = value;
            }
        }
        
        public int GetRequiredLeftHandSideWidth(Point p) {
            if (description != null && description.Length > 0) {
                using (Graphics g = CreateGraphics()) {
                    Size s = TextFileEdit.Util.TipPainterTools.GetLeftHandSideDrawingSizeHelpTipFromCombinedDescription(this, g, Font, null, description, p);
                    return s.Width;
                }
            }
            return 0;
        }
        
        public bool HideOnClick;
        
        public DeclarationViewWindow(Form parent)
        {
            SetStyle(ControlStyles.Selectable, false);
            StartPosition   = FormStartPosition.Manual;
            FormBorderStyle = FormBorderStyle.None;
            Owner           = parent;
            ShowInTaskbar   = false;
            Size            = new Size(0, 0);
            base.CreateHandle();
        }
        
        protected override CreateParams CreateParams {
            get {
                CreateParams p = base.CreateParams;
                AbstractCompletionWindow.AddShadowToWindow(p);
                return p;
            }
        }
        
        protected override bool ShowWithoutActivation {
            get {
                return true;
            }
        }
        
        protected override void OnClick(EventArgs e)
        {
            base.OnClick(e);
            if (HideOnClick) Hide();
        }
        
        public void ShowDeclarationViewWindow()
        {
            Show();
        }
        
        public void CloseDeclarationViewWindow()
        {
            Close();
            Dispose();
        }
        
        protected override void OnPaint(PaintEventArgs pe)
        {
            if (description != null && description.Length > 0) {
                if (fixedWidth) {
                    TextFileEdit.Util.TipPainterTools.DrawFixedWidthHelpTipFromCombinedDescription(this, pe.Graphics, Font, null, description);
                } else {
                    TextFileEdit.Util.TipPainterTools.DrawHelpTipFromCombinedDescription(this, pe.Graphics, Font, null, description);
                }
            }
        }
        
        protected override void OnPaintBackground(PaintEventArgs pe)
        {
            pe.Graphics.FillRectangle(SystemBrushes.Info, pe.ClipRectangle);
        }
    }
}

#endif
// file ...\TextFileEdit\Gui\CompletionWindow\ICompletionData.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3794 $</version>
// </file>


namespace TextFileEdit.Gui.CompletionWindow
{
	public interface ICompletionData
	{
		int ImageIndex {
			get;
		}
		
		string Text {
			get;
			set;
		}
		
		string Description {
			get;
		}
		
		/// <summary>
		/// Gets a priority value for the completion data item.
		/// When selecting items by their start characters, the item with the highest
		/// priority is selected first.
		/// </summary>
		double Priority {
			get;
		}
		
		/// <summary>
		/// Insert the element represented by the completion data into the text
		/// editor.
		/// </summary>
		/// <param name="textArea">TextArea to insert the completion data in.</param>
		/// <param name="ch">Character that should be inserted after the completion data.
		/// \0 when no character should be inserted.</param>
		/// <returns>Returns true when the insert action has processed the character
		/// <paramref name="ch"/>; false when the character was not processed.</returns>
		bool InsertAction(TextArea textArea, char ch);
	}
	
	public class DefaultCompletionData : ICompletionData
	{
		string text;
		string description;
		int imageIndex;
		
		public int ImageIndex {
			get {
				return imageIndex;
			}
		}
		
		public string Text {
			get {
				return text;
			}
			set {
				text = value;
			}
		}
		
		public virtual string Description {
			get {
				return description;
			}
		}
		
		double priority;
		
		public double Priority {
			get {
				return priority;
			}
			set {
				priority = value;
			}
		}
		
		public virtual bool InsertAction(TextArea textArea, char ch)
		{
			textArea.InsertString(text);
			return false;
		}
		
		public DefaultCompletionData(string text, int imageIndex)
		{
			this.text        = text;
			this.imageIndex  = imageIndex;
		}
		
		public DefaultCompletionData(string text, string description, int imageIndex)
		{
			this.text        = text;
			this.description = description;
			this.imageIndex  = imageIndex;
		}
		
		public static int Compare(ICompletionData a, ICompletionData b)
		{
			if (a == null)
				throw new ArgumentNullException("a");
			if (b == null)
				throw new ArgumentNullException("b");
			return string.Compare(a.Text, b.Text, StringComparison.InvariantCultureIgnoreCase);
		}
	}
}

#endif
// file ...\TextFileEdit\Gui\CompletionWindow\ICompletionDataProvider.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2074 $</version>
// </file>


namespace TextFileEdit.Gui.CompletionWindow
{
    public interface ICompletionDataProvider
    {
        ImageList ImageList {
            get;
        }
        string PreSelection {
            get;
        }
        /// <summary>
        /// Gets the index of the element in the list that is chosen by default.
        /// </summary>
        int DefaultIndex {
            get;
        }
        
        /// <summary>
        /// Processes a keypress. Returns the action to be run with the key.
        /// </summary>
        CompletionDataProviderKeyResult ProcessKey(char key);
        
        /// <summary>
        /// Executes the insertion. The provider should set the caret position and then
        /// call data.InsertAction.
        /// </summary>
        bool InsertAction(ICompletionData data, TextArea textArea, int insertionOffset, char key);
        
        /// <summary>
        /// Generates the completion data. This method is called by the text editor control.
        /// </summary>
        ICompletionData[] GenerateCompletionData(string fileName, TextArea textArea, char charTyped);
    }
    
    public enum CompletionDataProviderKeyResult
    {
        /// <summary>
        /// Normal key, used to choose an entry from the completion list
        /// </summary>
        NormalKey,
        /// <summary>
        /// This key triggers insertion of the completed expression
        /// </summary>
        InsertionKey,
        /// <summary>
        /// Increment both start and end offset of completion region when inserting this
        /// key. Can be used to insert whitespace (or other characters) in front of the expression
        /// while the completion window is open.
        /// </summary>
        BeforeStartKey
    }
}

#endif
// file ...\TextFileEdit\Gui\InsightWindow\IInsightDataProvider.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2318 $</version>
// </file>


namespace TextFileEdit.Gui.InsightWindow
{
	public interface IInsightDataProvider
	{
		/// <summary>
		/// Tells the insight provider to prepare its data.
		/// </summary>
		/// <param name="fileName">The name of the edited file</param>
		/// <param name="textArea">The text area in which the file is being edited</param>
		void SetupDataProvider(string fileName, TextArea textArea);
		
		/// <summary>
		/// Notifies the insight provider that the caret offset has changed.
		/// </summary>
		/// <returns>Return true to close the insight window (e.g. when the
		/// caret was moved outside the region where insight is displayed for).
		/// Return false to keep the window open.</returns>
		bool CaretOffsetChanged();
		
		/// <summary>
		/// Gets the text to display in the insight window.
		/// </summary>
		/// <param name="number">The number of the active insight entry.
		/// Multiple insight entries might be multiple overloads of the same method.</param>
		/// <returns>The text to display, e.g. a multi-line string where
		/// the first line is the method definition, followed by a description.</returns>
		string GetInsightData(int number);
		
		/// <summary>
		/// Gets the number of available insight entries, e.g. the number of available
		/// overloads to call.
		/// </summary>
		int InsightDataCount {
			get;
		}
		
		/// <summary>
		/// Gets the index of the entry to initially select.
		/// </summary>
		int DefaultIndex {
			get;
		}
	}
}

#endif
// file ...\TextFileEdit\Gui\InsightWindow\InsightWindow.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3064 $</version>
// </file>


namespace TextFileEdit.Gui.InsightWindow
{
    public class InsightWindow : TextFileEdit.Gui.CompletionWindow.AbstractCompletionWindow
    {
        public InsightWindow(Form parentForm, TextEditorControl control) : base(parentForm, control)
        {
            SetStyle(ControlStyles.UserPaint, true);
            SetStyle(ControlStyles.OptimizedDoubleBuffer, true);
        }
        
        public void ShowInsightWindow()
        {
            if (!Visible) {
                if (insightDataProviderStack.Count > 0) {
                    ShowCompletionWindow();
                }
            } else {
                Refresh();
            }
        }
        
#region Event handling routines
        protected override bool ProcessTextAreaKey(Keys keyData)
        {
            if (!Visible) {
                return false;
            }
            switch (keyData) {
                case Keys.Down:
                    if (DataProvider != null && DataProvider.InsightDataCount > 0) {
                        CurrentData = (CurrentData + 1) % DataProvider.InsightDataCount;
                        Refresh();
                    }
                    return true;
                case Keys.Up:
                    if (DataProvider != null && DataProvider.InsightDataCount > 0) {
                        CurrentData = (CurrentData + DataProvider.InsightDataCount - 1) % DataProvider.InsightDataCount;
                        Refresh();
                    }
                    return true;
            }
            return base.ProcessTextAreaKey(keyData);
        }
        
        protected override void CaretOffsetChanged(object sender, EventArgs e)
        {
            // move the window under the caret (don't change the x position)
            TextLocation caretPos  = control.ActiveTextAreaControl.Caret.Position;
            int y = (int)((1 + caretPos.Y) * control.ActiveTextAreaControl.TextArea.TextView.FontHeight)
                - control.ActiveTextAreaControl.TextArea.VirtualTop.Y - 1
                + control.ActiveTextAreaControl.TextArea.TextView.DrawingPosition.Y;
            
            int xpos = control.ActiveTextAreaControl.TextArea.TextView.GetDrawingXPos(caretPos.Y, caretPos.X);
            int ypos = (control.ActiveTextAreaControl.Document.GetVisibleLine(caretPos.Y) + 1) * control.ActiveTextAreaControl.TextArea.TextView.FontHeight
                - control.ActiveTextAreaControl.TextArea.VirtualTop.Y;
            int rulerHeight = control.TextEditorProperties.ShowHorizontalRuler ? control.ActiveTextAreaControl.TextArea.TextView.FontHeight : 0;
            
            Point p = control.ActiveTextAreaControl.PointToScreen(new Point(xpos, ypos + rulerHeight));
            if (p.Y != Location.Y) {
                Location = p;
            }
            
            while (DataProvider != null && DataProvider.CaretOffsetChanged()) {
                CloseCurrentDataProvider();
            }
        }
        
        protected override void OnMouseDown(MouseEventArgs e)
        {
            base.OnMouseDown(e);
            control.ActiveTextAreaControl.TextArea.Focus();
            if (TextFileEdit.Util.TipPainterTools.DrawingRectangle1.Contains(e.X, e.Y)) {
                CurrentData = (CurrentData + DataProvider.InsightDataCount - 1) % DataProvider.InsightDataCount;
                Refresh();
            }
            if (TextFileEdit.Util.TipPainterTools.DrawingRectangle2.Contains(e.X, e.Y))
            {
                CurrentData = (CurrentData + 1) % DataProvider.InsightDataCount;
                Refresh();
            }
        }
        
#endregion
        
        TextFileEdit.Util.MouseWheelHandler mouseWheelHandler = new TextFileEdit.Util.MouseWheelHandler();
        
        public void HandleMouseWheel(MouseEventArgs e)
        {
            if (DataProvider != null && DataProvider.InsightDataCount > 0) {
                int distance = mouseWheelHandler.GetScrollAmount(e);
                if (control.TextEditorProperties.MouseWheelScrollDown)
                    distance = -distance;
                if (distance > 0) {
                    CurrentData = (CurrentData + 1) % DataProvider.InsightDataCount;
                } else if (distance < 0) {
                    CurrentData = (CurrentData + DataProvider.InsightDataCount - 1) % DataProvider.InsightDataCount;
                }
                Refresh();
            }
        }
        
#region Insight Window Drawing routines
        protected override void OnPaint(PaintEventArgs pe)
        {
            string methodCountMessage = null, description;
            if (DataProvider == null || DataProvider.InsightDataCount < 1) {
                description = "Unknown Method";
            } else {
                if (DataProvider.InsightDataCount > 1) {
                    methodCountMessage = control.GetRangeDescription(CurrentData + 1, DataProvider.InsightDataCount);
                }
                description = DataProvider.GetInsightData(CurrentData);
            }
            
            drawingSize = TextFileEdit.Util.TipPainterTools.GetDrawingSizeHelpTipFromCombinedDescription(this,
                                                                                       pe.Graphics,
                                                                                       Font,
                                                                                       methodCountMessage,
                                                                                       description);
            if (drawingSize != Size) {
                SetLocation();
            } else {
                TextFileEdit.Util.TipPainterTools.DrawHelpTipFromCombinedDescription(this, pe.Graphics, Font, methodCountMessage, description);
            }
        }
        
        protected override void OnPaintBackground(PaintEventArgs pe)
        {
            pe.Graphics.FillRectangle(SystemBrushes.Info, pe.ClipRectangle);
        }
#endregion
        
#region InsightDataProvider handling
        Stack<InsightDataProviderStackElement> insightDataProviderStack = new Stack<InsightDataProviderStackElement>();
        
        int CurrentData {
            get {
                return insightDataProviderStack.Peek().currentData;
            }
            set {
                insightDataProviderStack.Peek().currentData = value;
            }
        }
        
        IInsightDataProvider DataProvider {
            get {
                if (insightDataProviderStack.Count == 0) {
                    return null;
                }
                return insightDataProviderStack.Peek().dataProvider;
            }
        }
        
        public void AddInsightDataProvider(IInsightDataProvider provider, string fileName)
        {
            provider.SetupDataProvider(fileName, control.ActiveTextAreaControl.TextArea);
            if (provider.InsightDataCount > 0) {
                insightDataProviderStack.Push(new InsightDataProviderStackElement(provider));
            }
        }
        
        void CloseCurrentDataProvider()
        {
            insightDataProviderStack.Pop();
            if (insightDataProviderStack.Count == 0) {
                Close();
            } else {
                Refresh();
            }
        }
        
        class InsightDataProviderStackElement
        {
            public int                  currentData;
            public IInsightDataProvider dataProvider;
            
            public InsightDataProviderStackElement(IInsightDataProvider dataProvider)
            {
                this.currentData  = Math.Max(dataProvider.DefaultIndex, 0);
                this.dataProvider = dataProvider;
            }
        }
#endregion
    }
}

#endif
// file ...\TextFileEdit\Undo\IUndoableOperation.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 915 $</version>
// </file>

namespace TextFileEdit.Undo
{
	/// <summary>
	/// This Interface describes a the basic Undo/Redo operation
	/// all Undo Operations must implement this interface.
	/// </summary>
	public interface IUndoableOperation
	{
		/// <summary>
		/// Undo the last operation
		/// </summary>
		void Undo();
		
		/// <summary>
		/// Redo the last operation
		/// </summary>
		void Redo();
	}
}

#endif
// file ...\TextFileEdit\Undo\UndoableDelete.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1965 $</version>
// </file>


namespace TextFileEdit.Undo
{
	/// <summary>
	/// This class is for the undo of Document insert operations
	/// </summary>
	public class UndoableDelete : IUndoableOperation
	{
		TextFileEdit.Document.IDocument document;
//		int      oldCaretPos;
		int      offset;
		string   text;
		
		/// <summary>
		/// Creates a new instance of <see cref="UndoableDelete"/>
		/// </summary>	
		public UndoableDelete(TextFileEdit.Document.IDocument document, int offset, string text)
		{
			if (document == null) {
				throw new ArgumentNullException("document");
			}
			if (offset < 0 || offset > document.TextLength) {
				throw new ArgumentOutOfRangeException("offset");
			}
			
			Debug.Assert(text != null, "text can't be null");
//			oldCaretPos   = document.Caret.Offset;
			this.document = document;
			this.offset   = offset;
			this.text     = text;
		}
		
		/// <remarks>
		/// Undo last operation
		/// </remarks>
		public void Undo()
		{
			// we clear all selection direct, because the redraw
			// is done per refresh at the end of the action
//			textArea.SelectionManager.SelectionCollection.Clear();
			document.UndoStack.AcceptChanges = false;
			document.Insert(offset, text);
//			document.Caret.Offset = Math.Min(document.TextLength, Math.Max(0, oldCaretPos));
			document.UndoStack.AcceptChanges = true;
		}
		
		/// <remarks>
		/// Redo last undone operation
		/// </remarks>
		public void Redo()
		{
			// we clear all selection direct, because the redraw
			// is done per refresh at the end of the action
//			textArea.SelectionManager.SelectionCollection.Clear();

			document.UndoStack.AcceptChanges = false;
			document.Remove(offset, text.Length);
//			document.Caret.Offset = Math.Min(document.TextLength, Math.Max(0, document.Caret.Offset));
			document.UndoStack.AcceptChanges = true;
		}
	}
}

#endif
// file ...\TextFileEdit\Undo\UndoableInsert.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1965 $</version>
// </file>


namespace TextFileEdit.Undo
{
	/// <summary>
	/// This class is for the undo of Document insert operations
	/// </summary>
	public class UndoableInsert : IUndoableOperation
	{
		TextFileEdit.Document.IDocument document;
//		int      oldCaretPos;
		int      offset;
		string   text;
		
		/// <summary>
		/// Creates a new instance of <see cref="UndoableInsert"/>
		/// </summary>	
		public UndoableInsert(TextFileEdit.Document.IDocument document, int offset, string text)
		{
			if (document == null) {
				throw new ArgumentNullException("document");
			}
			if (offset < 0 || offset > document.TextLength) {
				throw new ArgumentOutOfRangeException("offset");
			}
			
			Debug.Assert(text != null, "text can't be null");
//			oldCaretPos   = document.Caret.Offset;
			this.document = document;
			this.offset   = offset;
			this.text     = text;
		}
		
		/// <remarks>
		/// Undo last operation
		/// </remarks>
		public void Undo()
		{
			// we clear all selection direct, because the redraw
			// is done per refresh at the end of the action
//			document.SelectionCollection.Clear();

			document.UndoStack.AcceptChanges = false;
			document.Remove(offset, text.Length);
//			document.Caret.Offset = Math.Min(document.TextLength, Math.Max(0, oldCaretPos));
			document.UndoStack.AcceptChanges = true;
		}
		
		/// <remarks>
		/// Redo last undone operation
		/// </remarks>
		public void Redo()
		{
			// we clear all selection direct, because the redraw
			// is done per refresh at the end of the action
//			document.SelectionCollection.Clear();

			document.UndoStack.AcceptChanges = false;
			document.Insert(offset, text);
//			document.Caret.Offset = Math.Min(document.TextLength, Math.Max(0, document.Caret.Offset));
			document.UndoStack.AcceptChanges = true;
		}
	}
}

#endif
// file ...\TextFileEdit\Undo\UndoableReplace.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 1965 $</version>
// </file>


namespace TextFileEdit.Undo
{
	/// <summary>
	/// This class is for the undo of Document insert operations
	/// </summary>
	public class UndoableReplace : IUndoableOperation
	{
		TextFileEdit.Document.IDocument document;
//		int       oldCaretPos;
		int       offset;
		string    text;
		string    origText;
		
		/// <summary>
		/// Creates a new instance of <see cref="UndoableReplace"/>
		/// </summary>	
		public UndoableReplace(TextFileEdit.Document.IDocument document, int offset, string origText, string text)
		{
			if (document == null) {
				throw new ArgumentNullException("document");
			}
			if (offset < 0 || offset > document.TextLength) {
				throw new ArgumentOutOfRangeException("offset");
			}
			
			Debug.Assert(text != null, "text can't be null");
//			oldCaretPos   = document.Caret.Offset;
			this.document = document;
			this.offset   = offset;
			this.text     = text;
			this.origText = origText;
		}
		
		/// <remarks>
		/// Undo last operation
		/// </remarks>
		public void Undo()
		{
			// we clear all selection direct, because the redraw
			// is done per refresh at the end of the action
//			document.SelectionCollection.Clear();

			document.UndoStack.AcceptChanges = false;
			document.Replace(offset, text.Length, origText);
//			document.Caret.Offset = Math.Min(document.TextLength, Math.Max(0, oldCaretPos));
			document.UndoStack.AcceptChanges = true;
		}
		
		/// <remarks>
		/// Redo last undone operation
		/// </remarks>
		public void Redo()
		{
			// we clear all selection direct, because the redraw
			// is done per refresh at the end of the action
//			document.SelectionCollection.Clear();

			document.UndoStack.AcceptChanges = false;
			document.Replace(offset, origText.Length, text);
//			document.Caret.Offset = Math.Min(document.TextLength, Math.Max(0, document.Caret.Offset));
			document.UndoStack.AcceptChanges = true;
		}
	}
}

#endif
// file ...\TextFileEdit\Undo\UndoQueue.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 2161 $</version>
// </file>


namespace TextFileEdit.Undo
{
	/// <summary>
	/// This class stacks the last x operations from the undostack and makes
	/// one undo/redo operation from it.
	/// </summary>
	public sealed class UndoQueue : IUndoableOperation
	{
		List<IUndoableOperation> undolist = new List<IUndoableOperation>();
		
		/// <summary>
		/// </summary>
		public UndoQueue(Stack<IUndoableOperation> stack, int numops)
		{
			if (stack == null)  {
				throw new ArgumentNullException("stack");
			}
			
			Debug.Assert(numops > 0 , "TextFileEdit.Undo.UndoQueue : numops should be > 0");
			if (numops > stack.Count) {
				numops = stack.Count;
			}
			
			for (int i = 0; i < numops; ++i) {
				undolist.Add(stack.Pop());
			}
		}
		public void Undo()
		{
			for (int i = 0; i < undolist.Count; ++i) {
				undolist[i].Undo();
			}
		}
		
		public void Redo()
		{
			for (int i = undolist.Count - 1 ; i >= 0 ; --i) {
				undolist[i].Redo();
			}
		}
	}
}

#endif
// file ...\TextFileEdit\Undo\UndoStack.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3664 $</version>
// </file>


namespace TextFileEdit.Undo
{
    /// <summary>
    /// This class implements an undo stack
    /// </summary>
    public class UndoStack
    {
        Stack<IUndoableOperation> undostack = new Stack<IUndoableOperation>();
        Stack<IUndoableOperation> redostack = new Stack<IUndoableOperation>();
        
        public TextEditorControlBase TextEditorControl = null;
        
        /// <summary>
        /// </summary>
        public event EventHandler ActionUndone;
        /// <summary>
        /// </summary>
        public event EventHandler ActionRedone;
        
        public event OperationEventHandler OperationPushed;
        
        /// <summary>
        /// Gets/Sets if changes to the document are protocolled by the undo stack.
        /// Used internally to disable the undo stack temporarily while undoing an action.
        /// </summary>
        internal bool AcceptChanges = true;
        
        /// <summary>
        /// Gets if there are actions on the undo stack.
        /// </summary>
        public bool CanUndo {
            get {
                return undostack.Count > 0;
            }
        }
        
        /// <summary>
        /// Gets if there are actions on the redo stack.
        /// </summary>
        public bool CanRedo {
            get {
                return redostack.Count > 0;
            }
        }
        
        /// <summary>
        /// Gets the number of actions on the undo stack.
        /// </summary>
        public int UndoItemCount {
            get {
                return undostack.Count;
            }
        }
        
        /// <summary>
        /// Gets the number of actions on the redo stack.
        /// </summary>
        public int RedoItemCount {
            get {
                return redostack.Count;
            }
        }
        
        int undoGroupDepth;
        int actionCountInUndoGroup;
        
        public void StartUndoGroup()
        {
            if (undoGroupDepth == 0) {
                actionCountInUndoGroup = 0;
            }
            undoGroupDepth++;
            //Util.LoggingService.Debug("Open undo group (new depth=" + undoGroupDepth + ")");
        }
        
        public void EndUndoGroup()
        {
            if (undoGroupDepth == 0)
                throw new InvalidOperationException("There are no open undo groups");
            undoGroupDepth--;
            //Util.LoggingService.Debug("Close undo group (new depth=" + undoGroupDepth + ")");
            if (undoGroupDepth == 0 && actionCountInUndoGroup > 1) {
                UndoQueue op = new UndoQueue(undostack, actionCountInUndoGroup);
                undostack.Push(op);
                if (OperationPushed != null) {
                    OperationPushed(this, new OperationEventArgs(op));
                }
            }
        }
        
        public void AssertNoUndoGroupOpen()
        {
            if (undoGroupDepth != 0) {
                undoGroupDepth = 0;
                throw new InvalidOperationException("No undo group should be open at this point");
            }
        }
        
        /// <summary>
        /// Call this method to undo the last operation on the stack
        /// </summary>
        public void Undo()
        {
            AssertNoUndoGroupOpen();
            if (undostack.Count > 0) {
                IUndoableOperation uedit = (IUndoableOperation)undostack.Pop();
                redostack.Push(uedit);
                uedit.Undo();
                OnActionUndone();
            }
        }
        
        /// <summary>
        /// Call this method to redo the last undone operation
        /// </summary>
        public void Redo()
        {
            AssertNoUndoGroupOpen();
            if (redostack.Count > 0) {
                IUndoableOperation uedit = (IUndoableOperation)redostack.Pop();
                undostack.Push(uedit);
                uedit.Redo();
                OnActionRedone();
            }
        }
        
        /// <summary>
        /// Call this method to push an UndoableOperation on the undostack, the redostack
        /// will be cleared, if you use this method.
        /// </summary>
        public void Push(IUndoableOperation operation)
        {
            if (operation == null) {
                throw new ArgumentNullException("operation");
            }
            
            if (AcceptChanges) {
                StartUndoGroup();
                undostack.Push(operation);
                actionCountInUndoGroup++;
                if (TextEditorControl != null) {
                    undostack.Push(new UndoableSetCaretPosition(this, TextEditorControl.ActiveTextAreaControl.Caret.Position));
                    actionCountInUndoGroup++;
                }
                EndUndoGroup();
                ClearRedoStack();
            }
        }
        
        /// <summary>
        /// Call this method, if you want to clear the redo stack
        /// </summary>
        public void ClearRedoStack()
        {
            redostack.Clear();
        }
        
        /// <summary>
        /// Clears both the undo and redo stack.
        /// </summary>
        public void ClearAll()
        {
            AssertNoUndoGroupOpen();
            undostack.Clear();
            redostack.Clear();
            actionCountInUndoGroup = 0;
        }
        
        /// <summary>
        /// </summary>
        protected void OnActionUndone()
        {
            if (ActionUndone != null) {
                ActionUndone(null, null);
            }
        }
        
        /// <summary>
        /// </summary>
        protected void OnActionRedone()
        {
            if (ActionRedone != null) {
                ActionRedone(null, null);
            }
        }
        
        class UndoableSetCaretPosition : IUndoableOperation
        {
            UndoStack stack;
            TextLocation pos;
            TextLocation redoPos;
            
            public UndoableSetCaretPosition(UndoStack stack, TextLocation pos)
            {
                this.stack = stack;
                this.pos = pos;
            }
            
            public void Undo()
            {
                redoPos = stack.TextEditorControl.ActiveTextAreaControl.Caret.Position;
                stack.TextEditorControl.ActiveTextAreaControl.Caret.Position = pos;
                stack.TextEditorControl.ActiveTextAreaControl.SelectionManager.ClearSelection();
            }
            
            public void Redo()
            {
                stack.TextEditorControl.ActiveTextAreaControl.Caret.Position = redoPos;
                stack.TextEditorControl.ActiveTextAreaControl.SelectionManager.ClearSelection();
            }
        }
    }
        
    public class OperationEventArgs : EventArgs
    {
        public OperationEventArgs(IUndoableOperation op)
        {
            this.op = op;
        }
        
        IUndoableOperation op;
        
        public IUndoableOperation Operation {
            get {
                return op;
            }
        }
    }
    
    public delegate void OperationEventHandler(object sender, OperationEventArgs e);
}

#endif
// file ...\TextFileEdit\Util\AugmentableRedBlackTree.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Daniel Grunwald" email="daniel@danielgrunwald.de"/>
//     <version>$Revision: 2497 $</version>
// </file>


namespace TextFileEdit.Util
{
	public sealed class RedBlackTreeNode<T>
	{
		internal RedBlackTreeNode<T> left, right, parent;
		internal T val;
		internal bool color;
		
		internal RedBlackTreeNode(T val)
		{
			this.val = val;
		}
		
		internal RedBlackTreeNode<T> LeftMost {
			get {
				RedBlackTreeNode<T> node = this;
				while (node.left != null)
					node = node.left;
				return node;
			}
		}
		
		internal RedBlackTreeNode<T> RightMost {
			get {
				RedBlackTreeNode<T> node = this;
				while (node.right != null)
					node = node.right;
				return node;
			}
		}
	}
	
	public interface IRedBlackTreeHost<T> : IComparer<T>
	{
		bool Equals(T a, T b);
		
		void UpdateAfterChildrenChange(RedBlackTreeNode<T> node);
		void UpdateAfterRotateLeft(RedBlackTreeNode<T> node);
		void UpdateAfterRotateRight(RedBlackTreeNode<T> node);
	}
	
	/// <summary>
	/// Description of RedBlackTree.
	/// </summary>
	public sealed class AugmentableRedBlackTree<T, Host> : ICollection<T> where Host : IRedBlackTreeHost<T>
	{
		readonly Host host;
		int count;
		internal RedBlackTreeNode<T> root;
		
		public AugmentableRedBlackTree(Host host)
		{
			if (host == null) throw new ArgumentNullException("host");
			this.host = host;
		}
		
		public int Count {
			get { return count; }
		}
		
		public void Clear()
		{
			root = null;
			count = 0;
		}
		
		#region Debugging code
		#if DEBUG
		/// <summary>
		/// Check tree for consistency and being balanced.
		/// </summary>
		[Conditional("DATACONSISTENCYTEST")]
		void CheckProperties()
		{
			int blackCount = -1;
			CheckNodeProperties(root, null, RED, 0, ref blackCount);
			
			int nodeCount = 0;
			foreach (T val in this) {
				nodeCount++;
			}
			Debug.Assert(count == nodeCount);
		}
		
		/*
		1. A node is either red or black.
		2. The root is black.
		3. All leaves are black. (The leaves are the NIL children.)
		4. Both children of every red node are black. (So every red node must have a black parent.)
		5. Every simple path from a node to a descendant leaf contains the same number of black nodes. (Not counting the leaf node.)
		 */
		void CheckNodeProperties(RedBlackTreeNode<T> node, RedBlackTreeNode<T> parentNode, bool parentColor, int blackCount, ref int expectedBlackCount)
		{
			if (node == null) return;
			
			Debug.Assert(node.parent == parentNode);
			
			if (parentColor == RED) {
				Debug.Assert(node.color == BLACK);
			}
			if (node.color == BLACK) {
				blackCount++;
			}
			if (node.left == null && node.right == null) {
				// node is a leaf node:
				if (expectedBlackCount == -1)
					expectedBlackCount = blackCount;
				else
					Debug.Assert(expectedBlackCount == blackCount);
			}
			CheckNodeProperties(node.left, node, node.color, blackCount, ref expectedBlackCount);
			CheckNodeProperties(node.right, node, node.color, blackCount, ref expectedBlackCount);
		}
		
		public string GetTreeAsString()
		{
			StringBuilder b = new StringBuilder();
			AppendTreeToString(root, b, 0);
			return b.ToString();
		}
		
		static void AppendTreeToString(RedBlackTreeNode<T> node, StringBuilder b, int indent)
		{
			if (node.color == RED)
				b.Append("RED   ");
			else
				b.Append("BLACK ");
			b.AppendLine(node.val.ToString());
			indent += 2;
			if (node.left != null) {
				b.Append(' ', indent);
				b.Append("L: ");
				AppendTreeToString(node.left, b, indent);
			}
			if (node.right != null) {
				b.Append(' ', indent);
				b.Append("R: ");
				AppendTreeToString(node.right, b, indent);
			}
		}
		#endif
		#endregion
		
		#region Add
		public void Add(T item)
		{
			AddInternal(new RedBlackTreeNode<T>(item));
			#if DEBUG
			CheckProperties();
			#endif
		}
		
		void AddInternal(RedBlackTreeNode<T> newNode)
		{
			Debug.Assert(newNode.color == BLACK);
			if (root == null) {
				count = 1;
				root = newNode;
				return;
			}
			// Insert into the tree
			RedBlackTreeNode<T> parentNode = root;
			while (true) {
				if (host.Compare(newNode.val, parentNode.val) <= 0) {
					if (parentNode.left == null) {
						InsertAsLeft(parentNode, newNode);
						return;
					}
					parentNode = parentNode.left;
				} else {
					if (parentNode.right == null) {
						InsertAsRight(parentNode, newNode);
						return;
					}
					parentNode = parentNode.right;
				}
			}
		}
		
		internal void InsertAsLeft(RedBlackTreeNode<T> parentNode, RedBlackTreeNode<T> newNode)
		{
			Debug.Assert(parentNode.left == null);
			parentNode.left = newNode;
			newNode.parent = parentNode;
			newNode.color = RED;
			host.UpdateAfterChildrenChange(parentNode);
			FixTreeOnInsert(newNode);
			count++;
		}
		
		internal void InsertAsRight(RedBlackTreeNode<T> parentNode, RedBlackTreeNode<T> newNode)
		{
			Debug.Assert(parentNode.right == null);
			parentNode.right = newNode;
			newNode.parent = parentNode;
			newNode.color = RED;
			host.UpdateAfterChildrenChange(parentNode);
			FixTreeOnInsert(newNode);
			count++;
		}
		
		void FixTreeOnInsert(RedBlackTreeNode<T> node)
		{
			Debug.Assert(node != null);
			Debug.Assert(node.color == RED);
			Debug.Assert(node.left == null || node.left.color == BLACK);
			Debug.Assert(node.right == null || node.right.color == BLACK);
			
			RedBlackTreeNode<T> parentNode = node.parent;
			if (parentNode == null) {
				// we inserted in the root -> the node must be black
				// since this is a root node, making the node black increments the number of black nodes
				// on all paths by one, so it is still the same for all paths.
				node.color = BLACK;
				return;
			}
			if (parentNode.color == BLACK) {
				// if the parent node where we inserted was black, our red node is placed correctly.
				// since we inserted a red node, the number of black nodes on each path is unchanged
				// -> the tree is still balanced
				return;
			}
			// parentNode is red, so there is a conflict here!
			
			// because the root is black, parentNode is not the root -> there is a grandparent node
			RedBlackTreeNode<T> grandparentNode = parentNode.parent;
			RedBlackTreeNode<T> uncleNode = Sibling(parentNode);
			if (uncleNode != null && uncleNode.color == RED) {
				parentNode.color = BLACK;
				uncleNode.color = BLACK;
				grandparentNode.color = RED;
				FixTreeOnInsert(grandparentNode);
				return;
			}
			// now we know: parent is red but uncle is black
			// First rotation:
			if (node == parentNode.right && parentNode == grandparentNode.left) {
				RotateLeft(parentNode);
				node = node.left;
			} else if (node == parentNode.left && parentNode == grandparentNode.right) {
				RotateRight(parentNode);
				node = node.right;
			}
			// because node might have changed, reassign variables:
			parentNode = node.parent;
			grandparentNode = parentNode.parent;
			
			// Now recolor a bit:
			parentNode.color = BLACK;
			grandparentNode.color = RED;
			// Second rotation:
			if (node == parentNode.left && parentNode == grandparentNode.left) {
				RotateRight(grandparentNode);
			} else {
				// because of the first rotation, this is guaranteed:
				Debug.Assert(node == parentNode.right && parentNode == grandparentNode.right);
				RotateLeft(grandparentNode);
			}
		}
		
		void ReplaceNode(RedBlackTreeNode<T> replacedNode, RedBlackTreeNode<T> newNode)
		{
			if (replacedNode.parent == null) {
				Debug.Assert(replacedNode == root);
				root = newNode;
			} else {
				if (replacedNode.parent.left == replacedNode)
					replacedNode.parent.left = newNode;
				else
					replacedNode.parent.right = newNode;
			}
			if (newNode != null) {
				newNode.parent = replacedNode.parent;
			}
			replacedNode.parent = null;
		}
		
		void RotateLeft(RedBlackTreeNode<T> p)
		{
			// let q be p's right child
			RedBlackTreeNode<T> q = p.right;
			Debug.Assert(q != null);
			Debug.Assert(q.parent == p);
			// set q to be the new root
			ReplaceNode(p, q);
			
			// set p's right child to be q's left child
			p.right = q.left;
			if (p.right != null) p.right.parent = p;
			// set q's left child to be p
			q.left = p;
			p.parent = q;
			host.UpdateAfterRotateLeft(p);
		}
		
		void RotateRight(RedBlackTreeNode<T> p)
		{
			// let q be p's left child
			RedBlackTreeNode<T> q = p.left;
			Debug.Assert(q != null);
			Debug.Assert(q.parent == p);
			// set q to be the new root
			ReplaceNode(p, q);
			
			// set p's left child to be q's right child
			p.left = q.right;
			if (p.left != null) p.left.parent = p;
			// set q's right child to be p
			q.right = p;
			p.parent = q;
			host.UpdateAfterRotateRight(p);
		}
		
		RedBlackTreeNode<T> Sibling(RedBlackTreeNode<T> node)
		{
			if (node == node.parent.left)
				return node.parent.right;
			else
				return node.parent.left;
		}
		#endregion
		
		#region Remove
		public void RemoveAt(RedBlackTreeIterator<T> iterator)
		{
			RedBlackTreeNode<T> node = iterator.node;
			if (node == null)
				throw new ArgumentException("Invalid iterator");
			while (node.parent != null)
				node = node.parent;
			if (node != root)
				throw new ArgumentException("Iterator does not belong to this tree");
			RemoveNode(iterator.node);
			#if DEBUG
			CheckProperties();
			#endif
		}
		
		internal void RemoveNode(RedBlackTreeNode<T> removedNode)
		{
			if (removedNode.left != null && removedNode.right != null) {
				// replace removedNode with it's in-order successor
				
				RedBlackTreeNode<T> leftMost = removedNode.right.LeftMost;
				RemoveNode(leftMost); // remove leftMost from its current location
				
				// and overwrite the removedNode with it
				ReplaceNode(removedNode, leftMost);
				leftMost.left = removedNode.left;
				if (leftMost.left != null) leftMost.left.parent = leftMost;
				leftMost.right = removedNode.right;
				if (leftMost.right != null) leftMost.right.parent = leftMost;
				leftMost.color = removedNode.color;
				
				host.UpdateAfterChildrenChange(leftMost);
				if (leftMost.parent != null) host.UpdateAfterChildrenChange(leftMost.parent);
				return;
			}
			
			count--;
			
			// now either removedNode.left or removedNode.right is null
			// get the remaining child
			RedBlackTreeNode<T> parentNode = removedNode.parent;
			RedBlackTreeNode<T> childNode = removedNode.left ?? removedNode.right;
			ReplaceNode(removedNode, childNode);
			if (parentNode != null) host.UpdateAfterChildrenChange(parentNode);
			if (removedNode.color == BLACK) {
				if (childNode != null && childNode.color == RED) {
					childNode.color = BLACK;
				} else {
					FixTreeOnDelete(childNode, parentNode);
				}
			}
		}
		
		static RedBlackTreeNode<T> Sibling(RedBlackTreeNode<T> node, RedBlackTreeNode<T> parentNode)
		{
			Debug.Assert(node == null || node.parent == parentNode);
			if (node == parentNode.left)
				return parentNode.right;
			else
				return parentNode.left;
		}
		
		const bool RED = true;
		const bool BLACK = false;
		
		static bool GetColor(RedBlackTreeNode<T> node)
		{
			return node != null ? node.color : BLACK;
		}
		
		void FixTreeOnDelete(RedBlackTreeNode<T> node, RedBlackTreeNode<T> parentNode)
		{
			Debug.Assert(node == null || node.parent == parentNode);
			if (parentNode == null)
				return;
			
			// warning: node may be null
			RedBlackTreeNode<T> sibling = Sibling(node, parentNode);
			if (sibling.color == RED) {
				parentNode.color = RED;
				sibling.color = BLACK;
				if (node == parentNode.left) {
					RotateLeft(parentNode);
				} else {
					RotateRight(parentNode);
				}
				
				sibling = Sibling(node, parentNode); // update value of sibling after rotation
			}
			
			if (parentNode.color == BLACK
			    && sibling.color == BLACK
			    && GetColor(sibling.left) == BLACK
			    && GetColor(sibling.right) == BLACK)
			{
				sibling.color = RED;
				FixTreeOnDelete(parentNode, parentNode.parent);
				return;
			}
			
			if (parentNode.color == RED
			    && sibling.color == BLACK
			    && GetColor(sibling.left) == BLACK
			    && GetColor(sibling.right) == BLACK)
			{
				sibling.color = RED;
				parentNode.color = BLACK;
				return;
			}
			
			if (node == parentNode.left &&
			    sibling.color == BLACK &&
			    GetColor(sibling.left) == RED &&
			    GetColor(sibling.right) == BLACK)
			{
				sibling.color = RED;
				sibling.left.color = BLACK;
				RotateRight(sibling);
			}
			else if (node == parentNode.right &&
			         sibling.color == BLACK &&
			         GetColor(sibling.right) == RED &&
			         GetColor(sibling.left) == BLACK)
			{
				sibling.color = RED;
				sibling.right.color = BLACK;
				RotateLeft(sibling);
			}
			sibling = Sibling(node, parentNode); // update value of sibling after rotation
			
			sibling.color = parentNode.color;
			parentNode.color = BLACK;
			if (node == parentNode.left) {
				if (sibling.right != null) {
					Debug.Assert(sibling.right.color == RED);
					sibling.right.color = BLACK;
				}
				RotateLeft(parentNode);
			} else {
				if (sibling.left != null) {
					Debug.Assert(sibling.left.color == RED);
					sibling.left.color = BLACK;
				}
				RotateRight(parentNode);
			}
		}
		#endregion
		
		#region Find/LowerBound/UpperBound/GetEnumerator
		/// <summary>
		/// Returns the iterator pointing to the specified item, or an iterator in End state if the item is not found.
		/// </summary>
		public RedBlackTreeIterator<T> Find(T item)
		{
			RedBlackTreeIterator<T> it = LowerBound(item);
			while (it.IsValid && host.Compare(it.Current, item) == 0) {
				if (host.Equals(it.Current, item))
					return it;
				it.MoveNext();
			}
			return default(RedBlackTreeIterator<T>);
		}
		
		/// <summary>
		/// Returns the iterator pointing to the first item greater or equal to <paramref name="item"/>.
		/// </summary>
		public RedBlackTreeIterator<T> LowerBound(T item)
		{
			RedBlackTreeNode<T> node = root;
			RedBlackTreeNode<T> resultNode = null;
			while (node != null) {
				if (host.Compare(node.val, item) < 0) {
					node = node.right;
				} else {
					resultNode = node;
					node = node.left;
				}
			}
			return new RedBlackTreeIterator<T>(resultNode);
		}
		
		/// <summary>
		/// Returns the iterator pointing to the first item greater than <paramref name="item"/>.
		/// </summary>
		public RedBlackTreeIterator<T> UpperBound(T item)
		{
			RedBlackTreeIterator<T> it = LowerBound(item);
			while (it.IsValid && host.Compare(it.Current, item) == 0) {
				it.MoveNext();
			}
			return it;
		}
		
		/// <summary>
		/// Gets a tree iterator that starts on the first node.
		/// </summary>
		public RedBlackTreeIterator<T> Begin()
		{
			if (root == null) return default(RedBlackTreeIterator<T>);
			return new RedBlackTreeIterator<T>(root.LeftMost);
		}
		
		/// <summary>
		/// Gets a tree iterator that starts one node before the first node.
		/// </summary>
		public RedBlackTreeIterator<T> GetEnumerator()
		{
			if (root == null) return default(RedBlackTreeIterator<T>);
			RedBlackTreeNode<T> dummyNode = new RedBlackTreeNode<T>(default(T));
			dummyNode.right = root;
			return new RedBlackTreeIterator<T>(dummyNode);
		}
		#endregion
		
		#region ICollection members
		public bool Contains(T item)
		{
			return Find(item).IsValid;
		}
		
		public bool Remove(T item)
		{
			RedBlackTreeIterator<T> it = Find(item);
			if (!it.IsValid) {
				return false;
			} else {
				RemoveAt(it);
				return true;
			}
		}
		
		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			return GetEnumerator();
		}
		
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
		
		bool ICollection<T>.IsReadOnly {
			get { return false; }
		}
		
		public void CopyTo(T[] array, int arrayIndex)
		{
			if (array == null) throw new ArgumentNullException("array");
			foreach (T val in this) {
				array[arrayIndex++] = val;
			}
		}
		#endregion
	}
}

#endif
// file ...\TextFileEdit\Util\CheckedList.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <author name="Daniel Grunwald"/>
//     <version>$Revision: 3090 $</version>
// </file>


namespace TextFileEdit.Util
{
	/// <summary>
	/// A IList{T} that checks that it is only accessed on the thread that created it, and that
	/// it is not modified while an enumerator is running.
	/// </summary>
	sealed class CheckedList<T> : IList<T>
	{
		readonly int threadID;
		readonly IList<T> baseList;
		int enumeratorCount;
		
		public CheckedList() : this(new List<T>()) {}
		
		public CheckedList(IList<T> baseList)
		{
			if (baseList == null)
				throw new ArgumentNullException("baseList");
			this.baseList = baseList;
			this.threadID = Thread.CurrentThread.ManagedThreadId;
		}
		
		void CheckRead()
		{
			if (Thread.CurrentThread.ManagedThreadId != threadID)
				throw new InvalidOperationException("CheckList cannot be accessed from this thread!");
		}
		
		void CheckWrite()
		{
			if (Thread.CurrentThread.ManagedThreadId != threadID)
				throw new InvalidOperationException("CheckList cannot be accessed from this thread!");
			if (enumeratorCount != 0)
				throw new InvalidOperationException("CheckList cannot be written to while enumerators are active!");
		}
		
		public T this[int index] {
			get {
				CheckRead();
				return baseList[index];
			}
			set {
				CheckWrite();
				baseList[index] = value;
			}
		}
		
		public int Count {
			get {
				CheckRead();
				return baseList.Count;
			}
		}
		
		public bool IsReadOnly {
			get {
				CheckRead();
				return baseList.IsReadOnly;
			}
		}
		
		public int IndexOf(T item)
		{
			CheckRead();
			return baseList.IndexOf(item);
		}
		
		public void Insert(int index, T item)
		{
			CheckWrite();
			baseList.Insert(index, item);
		}
		
		public void RemoveAt(int index)
		{
			CheckWrite();
			baseList.RemoveAt(index);
		}
		
		public void Add(T item)
		{
			CheckWrite();
			baseList.Add(item);
		}
		
		public void Clear()
		{
			CheckWrite();
			baseList.Clear();
		}
		
		public bool Contains(T item)
		{
			CheckRead();
			return baseList.Contains(item);
		}
		
		public void CopyTo(T[] array, int arrayIndex)
		{
			CheckRead();
			baseList.CopyTo(array, arrayIndex);
		}
		
		public bool Remove(T item)
		{
			CheckWrite();
			return baseList.Remove(item);
		}
		
		public IEnumerator<T> GetEnumerator()
		{
			CheckRead();
			return Enumerate();
		}
		
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
		{
			CheckRead();
			return Enumerate();
		}
		
		IEnumerator<T> Enumerate()
		{
			CheckRead();
			try {
				enumeratorCount++;
				foreach (T val in baseList) {
					yield return val;
					CheckRead();
				}
			} finally {
				enumeratorCount--;
				CheckRead();
			}
		}
	}
}

#endif
// file ...\TextFileEdit\Util\FileReader.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Daniel Grunwald" email="daniel@danielgrunwald.de"/>
//     <version>$Revision: 2682 $</version>
// </file>


namespace TextFileEdit.Util
{
	/// <summary>
	/// Class that can open text files with auto-detection of the encoding.
	/// </summary>
	public static class FileReader
	{
		public static bool IsUnicode(Encoding encoding)
		{
			int codepage = encoding.CodePage;
			// return true if codepage is any UTF codepage
			return codepage == 65001 || codepage == 65000 || codepage == 1200 || codepage == 1201;
		}
		
		public static string ReadFileContent(Stream fs, ref Encoding encoding)
		{
			using (StreamReader reader = OpenStream(fs, encoding)) {
				reader.Peek();
				encoding = reader.CurrentEncoding;
				return reader.ReadToEnd();
			}
		}
		
		public static string ReadFileContent(string fileName, Encoding encoding)
		{
			using (FileStream fs = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)) {
				return ReadFileContent(fs, ref encoding);
			}
		}
		
		public static StreamReader OpenStream(Stream fs, Encoding defaultEncoding)
		{
			if (fs == null)
				throw new ArgumentNullException("fs");
			
			if (fs.Length >= 2) {
				// the autodetection of StreamReader is not capable of detecting the difference
				// between ISO-8859-1 and UTF-8 without BOM.
				int firstByte = fs.ReadByte();
				int secondByte = fs.ReadByte();
				switch ((firstByte << 8) | secondByte) {
					case 0x0000: // either UTF-32 Big Endian or a binary file; use StreamReader
					case 0xfffe: // Unicode BOM (UTF-16 LE or UTF-32 LE)
					case 0xfeff: // UTF-16 BE BOM
					case 0xefbb: // start of UTF-8 BOM
						// StreamReader autodetection works
						fs.Position = 0;
						return new StreamReader(fs);
					default:
						return AutoDetect(fs, (byte)firstByte, (byte)secondByte, defaultEncoding);
				}
			} else {
				if (defaultEncoding != null) {
					return new StreamReader(fs, defaultEncoding);
				} else {
					return new StreamReader(fs);
				}
			}
		}
		
		static StreamReader AutoDetect(Stream fs, byte firstByte, byte secondByte, Encoding defaultEncoding)
		{
			int max = (int)Math.Min(fs.Length, 500000); // look at max. 500 KB
			const int ASCII = 0;
			const int Error = 1;
			const int UTF8  = 2;
			const int UTF8Sequence = 3;
			int state = ASCII;
			int sequenceLength = 0;
			byte b;
			for (int i = 0; i < max; i++) {
				if (i == 0) {
					b = firstByte;
				} else if (i == 1) {
					b = secondByte;
				} else {
					b = (byte)fs.ReadByte();
				}
				if (b < 0x80) {
					// normal ASCII character
					if (state == UTF8Sequence) {
						state = Error;
						break;
					}
				} else if (b < 0xc0) {
					// 10xxxxxx : continues UTF8 byte sequence
					if (state == UTF8Sequence) {
						--sequenceLength;
						if (sequenceLength < 0) {
							state = Error;
							break;
						} else if (sequenceLength == 0) {
							state = UTF8;
						}
					} else {
						state = Error;
						break;
					}
				} else if (b >= 0xc2 && b < 0xf5) {
					// beginning of byte sequence
					if (state == UTF8 || state == ASCII) {
						state = UTF8Sequence;
						if (b < 0xe0) {
							sequenceLength = 1; // one more byte following
						} else if (b < 0xf0) {
							sequenceLength = 2; // two more bytes following
						} else {
							sequenceLength = 3; // three more bytes following
						}
					} else {
						state = Error;
						break;
					}
				} else {
					// 0xc0, 0xc1, 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)
					state = Error;
					break;
				}
			}
			fs.Position = 0;
			switch (state) {
				case ASCII:
				case Error:
					// when the file seems to be ASCII or non-UTF8,
					// we read it using the user-specified encoding so it is saved again
					// using that encoding.
					if (IsUnicode(defaultEncoding)) {
						// the file is not Unicode, so don't read it using Unicode even if the
						// user has choosen Unicode as the default encoding.
						
						// If we don't do this, SD will end up always adding a Byte Order Mark
						// to ASCII files.
						defaultEncoding = Encoding.Default; // use system encoding instead
					}
					return new StreamReader(fs, defaultEncoding);
				default:
					return new StreamReader(fs);
			}
		}
	}
}

#endif
// file ...\TextFileEdit\Util\LoggingService.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <author name="Daniel Grunwald"/>
//     <version>$Revision: 2719 $</version>
// </file>


namespace TextFileEdit.Util
{
	/// <summary>
	/// Central location for logging calls in the text editor.
	/// </summary>
	static class LoggingService
	{
		public static void Debug(string text)
		{
			#if DEBUG
			Console.WriteLine(text);
			#endif
		}
	}
}

#endif
// file ...\TextFileEdit\Util\LookupTable.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 3672 $</version>
// </file>


namespace TextFileEdit.Util
{
	/// <summary>
	/// This class implements a keyword map. It implements a digital search trees (tries) to find
	/// a word.
	/// </summary>
	public class LookupTable
	{
		Node root = new Node(null, null);
		bool casesensitive;
		int  length;
		
		/// <value>
		/// The number of elements in the table
		/// </value>
		public int Count {
			get {
				return length;
			}
		}
		
		/// <summary>
		/// Get the object, which was inserted under the keyword (line, at offset, with length length),
		/// returns null, if no such keyword was inserted.
		/// </summary>
		public object this[TextFileEdit.Document.IDocument document, TextFileEdit.Document.LineSegment line, int offset, int length] {
			get {
				if(length == 0) {
					return null;
				}
				Node next = root;
				
				int wordOffset = line.Offset + offset;
				if (casesensitive) {
					for (int i = 0; i < length; ++i) {
						int index = ((int)document.GetCharAt(wordOffset + i)) % 256;
						next = next[index];
						
						if (next == null) {
							return null;
						}
						
						if (next.color != null && TextUtility.RegionMatches(document, wordOffset, length, next.word)) {
							return next.color;
						}
					}
				} else {
					for (int i = 0; i < length; ++i) {
						int index = ((int)Char.ToUpper(document.GetCharAt(wordOffset + i))) % 256;
						
						next = next[index];
						
						if (next == null) {
							return null;
						}
						
						if (next.color != null && TextUtility.RegionMatches(document, casesensitive, wordOffset, length, next.word)) {
							return next.color;
						}
					}
				}
				return null;
			}
		}
		
		/// <summary>
		/// Inserts an object in the tree, under keyword
		/// </summary>
		public object this[string keyword] {
			set {
				Node node = root;
				Node next = root;
				if (!casesensitive) {
					keyword = keyword.ToUpper();
				}
				++length;
				
				// insert word into the tree
				for (int i = 0; i < keyword.Length; ++i) {
					int index = ((int)keyword[i]) % 256; // index of curchar
					bool d = keyword[i] == '\\';
					
					next = next[index];             // get node to this index
					
					if (next == null) { // no node created -> insert word here
						node[index] = new Node(value, keyword);
						break;
					}
					
					if (next.word != null && next.word.Length != i) { // node there, take node content and insert them again
						string tmpword  = next.word;                  // this word will be inserted 1 level deeper (better, don't need too much
						object tmpcolor = next.color;                 // string comparisons for finding.)
						next.color = next.word = null;
						this[tmpword] = tmpcolor;
					}
					
					if (i == keyword.Length - 1) { // end of keyword reached, insert node there, if a node was here it was
						next.word = keyword;       // reinserted, if it has the same length (keyword EQUALS this word) it will be overwritten
						next.color = value;
						break;
					}
					
					node = next;
				}
			}
		}
		
		/// <summary>
		/// Creates a new instance of <see cref="LookupTable"/>
		/// </summary>
		public LookupTable(bool casesensitive)
		{
			this.casesensitive = casesensitive;
		}
		
		class Node
		{
			public Node(object color, string word)
			{
				this.word  = word;
				this.color = color;
			}
			
			public string word;
			public object color;
			
			// Lazily initialize children array. Saves 200 KB of memory for the C# highlighting
			// because we don't have to store the array for leaf nodes.
			public Node this[int index] {
				get { 
					if (children != null)
						return children[index];
					else
						return null;
				}
				set {
					if (children == null)
						children = new Node[256];
					children[index] = value;
				}
			}
			
			private Node[] children;
		}
	}
}

#endif
// file ...\TextFileEdit\Util\MouseWheelHandler.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <author name="Daniel Grunwald"/>
//     <version>$Revision: 3064 $</version>
// </file>


namespace TextFileEdit.Util
{
	/// <summary>
	/// Accumulates mouse wheel deltas and reports the actual number of lines to scroll.
	/// </summary>
	class MouseWheelHandler
	{
		// CODE DUPLICATION: See ICSharpCode.SharpDevelop.Widgets.MouseWheelHandler
		
		const int WHEEL_DELTA = 120;
		
		int mouseWheelDelta;
		
		public int GetScrollAmount(MouseEventArgs e)
		{
			// accumulate the delta to support high-resolution mice
			mouseWheelDelta += e.Delta;
			
			int linesPerClick = Math.Max(SystemInformation.MouseWheelScrollLines, 1);
			
			int scrollDistance = mouseWheelDelta * linesPerClick / WHEEL_DELTA;
			mouseWheelDelta %= Math.Max(1, WHEEL_DELTA / linesPerClick);
			return scrollDistance;
		}
	}
}

#endif
// file ...\TextFileEdit\Util\RedBlackTreeIterator.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Daniel Grunwald" email="daniel@danielgrunwald.de"/>
//     <version>$Revision: 2497 $</version>
// </file>


namespace TextFileEdit.Util
{
	public struct RedBlackTreeIterator<T> : IEnumerator<T>
	{
		internal RedBlackTreeNode<T> node;
		
		internal RedBlackTreeIterator(RedBlackTreeNode<T> node)
		{
			this.node = node;
		}
		
		public bool IsValid {
			get { return node != null; }
		}
		
		public T Current {
			get {
				if (node != null)
					return node.val;
				else
					throw new InvalidOperationException();
			}
		}
		
		object System.Collections.IEnumerator.Current {
			get {
				return this.Current;
			}
		}
		
		void IDisposable.Dispose()
		{
		}
		
		void System.Collections.IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}
		
		public bool MoveNext()
		{
			if (node == null)
				return false;
			if (node.right != null) {
				node = node.right.LeftMost;
			} else {
				RedBlackTreeNode<T> oldNode;
				do {
					oldNode = node;
					node = node.parent;
					// we are on the way up from the right part, don't output node again
				} while (node != null && node.right == oldNode);
			}
			return node != null;
		}
		
		public bool MoveBack()
		{
			if (node == null)
				return false;
			if (node.left != null) {
				node = node.left.RightMost;
			} else {
				RedBlackTreeNode<T> oldNode;
				do {
					oldNode = node;
					node = node.parent;
					// we are on the way up from the left part, don't output node again
				} while (node != null && node.left == oldNode);
			}
			return node != null;
		}
	}
}

#endif
// file ...\TextFileEdit\Util\RtfWriter.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 4453 $</version>
// </file>


namespace TextFileEdit.Util
{
	public class RtfWriter
	{
		static Dictionary<string, int> colors;
		static int           colorNum;
		static StringBuilder colorString;
		
		public static string GenerateRtf(TextArea textArea)
		{
			colors = new Dictionary<string, int>();
			colorNum = 0;
			colorString = new StringBuilder();
			
			
			StringBuilder rtf = new StringBuilder();
			
			rtf.Append(@"{\rtf1\ansi\ansicpg1252\deff0\deflang1031");
			BuildFontTable(textArea.Document, rtf);
			rtf.Append('\n');
			
			string fileContent = BuildFileContent(textArea);
			BuildColorTable(textArea.Document, rtf);
			rtf.Append('\n');
			rtf.Append(@"\viewkind4\uc1\pard");
			rtf.Append(fileContent);
			rtf.Append("}");
			return rtf.ToString();
		}
		
		static void BuildColorTable(TextFileEdit.Document.IDocument doc, StringBuilder rtf)
		{
			rtf.Append(@"{\colortbl ;");
			rtf.Append(colorString.ToString());
			rtf.Append("}");
		}
		
		static void BuildFontTable(TextFileEdit.Document.IDocument doc, StringBuilder rtf)
		{
			rtf.Append(@"{\fonttbl");
			rtf.Append(@"{\f0\fmodern\fprq1\fcharset0 " + doc.TextEditorProperties.Font.Name + ";}");
			rtf.Append("}");
		}
		
		static string BuildFileContent(TextArea textArea)
		{
			StringBuilder rtf = new StringBuilder();
			bool firstLine = true;
			Color curColor = Color.Black;
			bool  oldItalic = false;
			bool  oldBold   = false;
			bool  escapeSequence = false;
			
			foreach (TextFileEdit.Document.ISelection selection in textArea.SelectionManager.SelectionCollection) {
				int selectionOffset    = textArea.Document.PositionToOffset(selection.StartPosition);
				int selectionEndOffset = textArea.Document.PositionToOffset(selection.EndPosition);
				for (int i = selection.StartPosition.Y; i <= selection.EndPosition.Y; ++i) {
					TextFileEdit.Document.LineSegment line = textArea.Document.GetLineSegment(i);
					int offset = line.Offset;
					if (line.Words == null) {
						continue;
					}
					
					foreach (TextFileEdit.Document.TextWord word in line.Words) {
						switch (word.Type) {
							case TextFileEdit.Document.TextWordType.Space:
								if (selection.ContainsOffset(offset)) {
									rtf.Append(' ');
								}
								++offset;
								break;
							
							case TextFileEdit.Document.TextWordType.Tab:
								if (selection.ContainsOffset(offset)) {
									rtf.Append(@"\tab");
								}
								++offset;
								escapeSequence = true;
								break;

                            case TextFileEdit.Document.TextWordType.Null:
                                if (selection.ContainsOffset(offset))
                                {
                                    rtf.Append(' ');
                                }
                                ++offset;
                                break;
							
							case TextFileEdit.Document.TextWordType.Word:
								Color c = word.Color;
								
								if (offset + word.Word.Length > selectionOffset && offset < selectionEndOffset) {
									string colorstr = c.R + ", " + c.G + ", " + c.B;
									
									if (!colors.ContainsKey(colorstr)) {
										colors[colorstr] = ++colorNum;
										colorString.Append(@"\red" + c.R + @"\green" + c.G + @"\blue" + c.B + ";");
									}
									if (c != curColor || firstLine) {
										rtf.Append(@"\cf" + colors[colorstr].ToString());
										curColor = c;
										escapeSequence = true;
									}
									
									if (oldItalic != word.Italic) {
										if (word.Italic) {
											rtf.Append(@"\i");
										} else {
											rtf.Append(@"\i0");
										}
										oldItalic = word.Italic;
										escapeSequence = true;
									}
									
									if (oldBold != word.Bold) {
										if (word.Bold) {
											rtf.Append(@"\b");
										} else {
											rtf.Append(@"\b0");
										}
										oldBold = word.Bold;
										escapeSequence = true;
									}
									
									if (firstLine) {
										rtf.Append(@"\f0\fs" + (textArea.TextEditorProperties.Font.Size * 2));
										firstLine = false;
									}
									if (escapeSequence) {
										rtf.Append(' ');
										escapeSequence = false;
									}
									string printWord;
									if (offset < selectionOffset) {
										printWord = word.Word.Substring(selectionOffset - offset);
									} else if (offset + word.Word.Length > selectionEndOffset) {
										printWord = word.Word.Substring(0, (offset + word.Word.Length) - selectionEndOffset);
									} else {
										printWord = word.Word;
									}
									
									AppendText(rtf, printWord);
								}
								offset += word.Length;
								break;
						}
					}
					if (offset < selectionEndOffset) {
						rtf.Append(@"\par");
					}
					rtf.Append('\n');
				}
			}
			
			return rtf.ToString();
		}
		
		static void AppendText(StringBuilder rtfOutput, string text)
		{
			//rtf.Append(printWord.Replace(@"\", @"\\").Replace("{", "\\{").Replace("}", "\\}"));
			foreach (char c in text) {
				switch (c) {
					case '\\':
						rtfOutput.Append(@"\\");
						break;
					case '{':
						rtfOutput.Append("\\{");
						break;
					case '}':
						rtfOutput.Append("\\}");
						break;
					default:
						if (c < 256) {
							rtfOutput.Append(c);
						} else {
							// yes, RTF really expects signed 16-bit integers!
							rtfOutput.Append("\\u" + unchecked((short)c).ToString() + "?");
						}
						break;
				}
			}
		}
	}
}

#endif
// file ...\TextFileEdit\Util\TextUtility.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Mike Krüger" email="mike@icsharpcode.net"/>
//     <version>$Revision: 915 $</version>
// </file>


namespace TextFileEdit.Util
{
	public class TextUtility
	{
		
		public static bool RegionMatches(TextFileEdit.Document.IDocument document, int offset, int length, string word)
		{
			if (length != word.Length || document.TextLength < offset + length) {
				return false;
			}
			
			for (int i = 0; i < length; ++i) {
				if (document.GetCharAt(offset + i) != word[i]) {
					return false;
				}
			}
			return true;
		}
		
		public static bool RegionMatches(TextFileEdit.Document.IDocument document, bool casesensitive, int offset, int length, string word)
		{
			if (casesensitive) {
				return RegionMatches(document, offset, length, word);
			}
			
			if (length != word.Length || document.TextLength < offset + length) {
				return false;
			}
			
			for (int i = 0; i < length; ++i) {
				if (Char.ToUpper(document.GetCharAt(offset + i)) != Char.ToUpper(word[i])) {
					return false;
				}
			}
			return true;
		}
		
		public static bool RegionMatches(TextFileEdit.Document.IDocument document, int offset, int length, char[] word)
		{
			if (length != word.Length || document.TextLength < offset + length) {
				return false;
			}
			
			for (int i = 0; i < length; ++i) {
				if (document.GetCharAt(offset + i) != word[i]) {
					return false;
				}
			}
			return true;
		}
		
		public static bool RegionMatches(TextFileEdit.Document.IDocument document, bool casesensitive, int offset, int length, char[] word)
		{
			if (casesensitive) {
				return RegionMatches(document, offset, length, word);
			}
			
			if (length != word.Length || document.TextLength < offset + length) {
				return false;
			}
			
			for (int i = 0; i < length; ++i) {
				if (Char.ToUpper(document.GetCharAt(offset + i)) != Char.ToUpper(word[i])) {
					return false;
				}
			}
			return true;
		}
	}
}

#endif
// file ...\TextFileEdit\Util\TipPainter.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="none" email=""/>
//     <version>$Revision: 3733 $</version>
// </file>


namespace TextFileEdit.Util
{
    static class TipPainter
    {
        const float HorizontalBorder = 2;
        const float VerticalBorder   = 1;
        
        //static StringFormat centerTipFormat = CreateTipStringFormat();
        
        public static Size GetTipSize(Control control, Graphics graphics, Font font, string description)
        {
            return GetTipSize(control, graphics, new TipText (graphics, font, description));
        }
        
        static Rectangle GetWorkingArea(Control control)
        {
            Form ownerForm = control.FindForm();
            if (ownerForm.Owner != null) {
                ownerForm = ownerForm.Owner;
            }
            
            return Screen.GetWorkingArea(ownerForm);
        }
        
        public static Size GetTipSize(Control control, Graphics graphics, TipSection tipData)
        {
            Size tipSize = Size.Empty;
            SizeF tipSizeF = SizeF.Empty;
            
            RectangleF workingArea = GetWorkingArea(control);
            
            PointF screenLocation = control.PointToScreen(Point.Empty);
            
            SizeF maxLayoutSize = new SizeF(workingArea.Right - screenLocation.X - HorizontalBorder * 2,
                                            workingArea.Bottom - screenLocation.Y - VerticalBorder * 2);
            
            if (maxLayoutSize.Width > 0 && maxLayoutSize.Height > 0) {
                graphics.TextRenderingHint =
                    TextRenderingHint.AntiAliasGridFit;
                
                tipData.SetMaximumSize(maxLayoutSize);
                tipSizeF = tipData.GetRequiredSize();
                tipData.SetAllocatedSize(tipSizeF);
                
                tipSizeF += new SizeF(HorizontalBorder * 2,
                                      VerticalBorder   * 2);
                tipSize = Size.Ceiling(tipSizeF);
            }
            
            if (control.ClientSize != tipSize) {
                control.ClientSize = tipSize;
            }
            
            return tipSize;
        }
        
        public static Size GetLeftHandSideTipSize(Control control, Graphics graphics, TipSection tipData, Point p)
        {
            Size tipSize = Size.Empty;
            SizeF tipSizeF = SizeF.Empty;
            
            RectangleF workingArea = GetWorkingArea(control);
            
            PointF screenLocation = p;
            
            SizeF maxLayoutSize = new SizeF(screenLocation.X - HorizontalBorder * 2,
                                            workingArea.Bottom - screenLocation.Y - VerticalBorder * 2);
            
            if (maxLayoutSize.Width > 0 && maxLayoutSize.Height > 0) {
                graphics.TextRenderingHint =
                    TextRenderingHint.AntiAliasGridFit;
                
                tipData.SetMaximumSize(maxLayoutSize);
                tipSizeF = tipData.GetRequiredSize();
                tipData.SetAllocatedSize(tipSizeF);
                
                tipSizeF += new SizeF(HorizontalBorder * 2,
                                      VerticalBorder   * 2);
                tipSize = Size.Ceiling(tipSizeF);
            }
            
            return tipSize;
        }
        
        public static Size DrawTip(Control control, Graphics graphics, Font font, string description)
        {
            return DrawTip(control, graphics, new TipText (graphics, font, description));
        }
        
        public static Size DrawTip(Control control, Graphics graphics, TipSection tipData)
        {
            Size tipSize = Size.Empty;
            SizeF tipSizeF = SizeF.Empty;
            
            PointF screenLocation = control.PointToScreen(Point.Empty);
            
            RectangleF workingArea = GetWorkingArea(control);
            
            SizeF maxLayoutSize = new SizeF(workingArea.Right - screenLocation.X - HorizontalBorder * 2,
                                            workingArea.Bottom - screenLocation.Y - VerticalBorder * 2);
            
            if (maxLayoutSize.Width > 0 && maxLayoutSize.Height > 0) {
                graphics.TextRenderingHint =
                    TextRenderingHint.AntiAliasGridFit;
                
                tipData.SetMaximumSize(maxLayoutSize);
                tipSizeF = tipData.GetRequiredSize();
                tipData.SetAllocatedSize(tipSizeF);
                
                tipSizeF += new SizeF(HorizontalBorder * 2,
                                      VerticalBorder   * 2);
                tipSize = Size.Ceiling(tipSizeF);
            }
            
            if (control.ClientSize != tipSize) {
                control.ClientSize = tipSize;
            }
            
            if (tipSize != Size.Empty) {
                Rectangle borderRectangle = new Rectangle
                    (Point.Empty, tipSize - new Size(1, 1));
                
                RectangleF displayRectangle = new RectangleF
                    (HorizontalBorder, VerticalBorder,
                     tipSizeF.Width - HorizontalBorder * 2,
                     tipSizeF.Height - VerticalBorder * 2);
                
                // DrawRectangle draws from Left to Left + Width. A bug? :-/
                graphics.DrawRectangle(SystemPens.WindowFrame,
                                       borderRectangle);
                tipData.Draw(new PointF(HorizontalBorder, VerticalBorder));
            }
            return tipSize;
        }
        
        public static Size DrawFixedWidthTip(Control control, Graphics graphics, TipSection tipData)
        {
            Size tipSize = Size.Empty;
            SizeF tipSizeF = SizeF.Empty;
            
            PointF screenLocation = control.PointToScreen(new Point(control.Width, 0));
            
            RectangleF workingArea = GetWorkingArea(control);
            
            SizeF maxLayoutSize = new SizeF(screenLocation.X - HorizontalBorder * 2,
                                            workingArea.Bottom - screenLocation.Y - VerticalBorder * 2);
            
            if (maxLayoutSize.Width > 0 && maxLayoutSize.Height > 0) {
                graphics.TextRenderingHint =
                    TextRenderingHint.AntiAliasGridFit;
                
                tipData.SetMaximumSize(maxLayoutSize);
                tipSizeF = tipData.GetRequiredSize();
                tipData.SetAllocatedSize(tipSizeF);
                
                tipSizeF += new SizeF(HorizontalBorder * 2,
                                      VerticalBorder   * 2);
                tipSize = Size.Ceiling(tipSizeF);
            }
            
            if (control.Height != tipSize.Height) {
                control.Height = tipSize.Height;
            }
            
            if (tipSize != Size.Empty) {
                Rectangle borderRectangle = new Rectangle
                    (Point.Empty, control.Size - new Size(1, 1));
                
                RectangleF displayRectangle = new RectangleF
                    (HorizontalBorder, VerticalBorder,
                     tipSizeF.Width - HorizontalBorder * 2,
                     tipSizeF.Height - VerticalBorder * 2);
                
                // DrawRectangle draws from Left to Left + Width. A bug? :-/
                graphics.DrawRectangle(SystemPens.WindowFrame,
                                       borderRectangle);
                tipData.Draw(new PointF(HorizontalBorder, VerticalBorder));
            }
            return tipSize;
        }
    }
}

#endif
// file ...\TextFileEdit\Util\TipPainterTools.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="none" email=""/>
//     <version>$Revision: 3515 $</version>
// </file>


namespace TextFileEdit.Util
{
    static class TipPainterTools
    {
        const int SpacerSize = 4;
        
        public static Size GetLeftHandSideDrawingSizeHelpTipFromCombinedDescription(Control control,
                                                                                    Graphics graphics,
                                                                                    Font font,
                                                                                    string countMessage,
                                                                                    string description,
                                                                                    Point p)
        {
            string basicDescription = null;
            string documentation = null;

            if (IsVisibleText(description)) {
                string[] splitDescription = description.Split(new char[] { '\n' }, 2);
                
                if (splitDescription.Length > 0) {
                    basicDescription = splitDescription[0];
                    
                    if (splitDescription.Length > 1) {
                        documentation = splitDescription[1].Trim();
                    }
                }
            }
            
            return GetLeftHandSideDrawingSizeDrawHelpTip(control, graphics, font, countMessage, basicDescription, documentation, p);
        }
        
        public static Size GetDrawingSizeHelpTipFromCombinedDescription(Control control,
                                                                        Graphics graphics,
                                                                        Font font,
                                                                        string countMessage,
                                                                        string description)
        {
            string basicDescription = null;
            string documentation = null;

            if (IsVisibleText(description)) {
                string[] splitDescription = description.Split(new char[] { '\n' }, 2);
                
                if (splitDescription.Length > 0) {
                    basicDescription = splitDescription[0];
                    
                    if (splitDescription.Length > 1) {
                        documentation = splitDescription[1].Trim();
                    }
                }
            }
            
            return GetDrawingSizeDrawHelpTip(control, graphics, font, countMessage, basicDescription, documentation);
        }
        
        public static Size DrawHelpTipFromCombinedDescription(Control control,
                                                              Graphics graphics,
                                                              Font font,
                                                              string countMessage,
                                                              string description)
        {
            string basicDescription = null;
            string documentation = null;

            if (IsVisibleText(description)) {
                string[] splitDescription = description.Split
                    (new char[] { '\n' }, 2);
                
                if (splitDescription.Length > 0) {
                    basicDescription = splitDescription[0];
                    
                    if (splitDescription.Length > 1) {
                        documentation = splitDescription[1].Trim();
                    }
                }
            }
            
            return DrawHelpTip(control, graphics, font, countMessage,
                               basicDescription, documentation);
        }
        
        public static Size DrawFixedWidthHelpTipFromCombinedDescription(Control control,
                                                                        Graphics graphics,
                                                                        Font font,
                                                                        string countMessage,
                                                                        string description)
        {
            string basicDescription = null;
            string documentation = null;

            if (IsVisibleText(description)) {
                string[] splitDescription = description.Split
                    (new char[] { '\n' }, 2);
                
                if (splitDescription.Length > 0) {
                    basicDescription = splitDescription[0];
                    
                    if (splitDescription.Length > 1) {
                        documentation = splitDescription[1].Trim();
                    }
                }
            }
            
            return DrawFixedWidthHelpTip(control, graphics, font, countMessage,
                                         basicDescription, documentation);
        }
        
        // btw. I know it's ugly.
        public static Rectangle DrawingRectangle1;
        public static Rectangle DrawingRectangle2;
        
        public static Size GetDrawingSizeDrawHelpTip(Control control,
                                                     Graphics graphics, Font font,
                                                     string countMessage,
                                                     string basicDescription,
                                                     string documentation)
        {
            if (IsVisibleText(countMessage)     ||
                IsVisibleText(basicDescription) ||
                IsVisibleText(documentation)) {
                // Create all the TipSection objects.
                CountTipText countMessageTip = new CountTipText(graphics, font, countMessage);
                
                TipSpacer countSpacer = new TipSpacer(graphics, new SizeF(IsVisibleText(countMessage) ? 4 : 0, 0));
                
                TipText descriptionTip = new TipText(graphics, font, basicDescription);
                
                TipSpacer docSpacer = new TipSpacer(graphics, new SizeF(0, IsVisibleText(documentation) ? 4 : 0));
                
                TipText docTip = new TipText(graphics, font, documentation);
                
                // Now put them together.
                TipSplitter descSplitter = new TipSplitter(graphics, false,
                                                           descriptionTip,
                                                           docSpacer
                                                          );
                
                TipSplitter mainSplitter = new TipSplitter(graphics, true,
                                                           countMessageTip,
                                                           countSpacer,
                                                           descSplitter);
                
                TipSplitter mainSplitter2 = new TipSplitter(graphics, false,
                                                            mainSplitter,
                                                            docTip);
                
                // Show it.
                Size size = TipPainter.GetTipSize(control, graphics, mainSplitter2);
                DrawingRectangle1 = countMessageTip.DrawingRectangle1;
                DrawingRectangle2 = countMessageTip.DrawingRectangle2;
                return size;
            }
            return Size.Empty;
        }
        public static Size GetLeftHandSideDrawingSizeDrawHelpTip(Control control,
                                                                 Graphics graphics, Font font,
                                                                 string countMessage,
                                                                 string basicDescription,
                                                                 string documentation,
                                                                 Point p)
        {
            if (IsVisibleText(countMessage)     ||
                IsVisibleText(basicDescription) ||
                IsVisibleText(documentation)) {
                // Create all the TipSection objects.
                CountTipText countMessageTip = new CountTipText(graphics, font, countMessage);
                
                TipSpacer countSpacer = new TipSpacer(graphics, new SizeF(IsVisibleText(countMessage) ? 4 : 0, 0));
                
                TipText descriptionTip = new TipText(graphics, font, basicDescription);
                
                TipSpacer docSpacer = new TipSpacer(graphics, new SizeF(0, IsVisibleText(documentation) ? 4 : 0));
                
                TipText docTip = new TipText(graphics, font, documentation);
                
                // Now put them together.
                TipSplitter descSplitter = new TipSplitter(graphics, false,
                                                           descriptionTip,
                                                           docSpacer
                                                          );
                
                TipSplitter mainSplitter = new TipSplitter(graphics, true,
                                                           countMessageTip,
                                                           countSpacer,
                                                           descSplitter);
                
                TipSplitter mainSplitter2 = new TipSplitter(graphics, false,
                                                            mainSplitter,
                                                            docTip);
                
                // Show it.
                Size size = TipPainter.GetLeftHandSideTipSize(control, graphics, mainSplitter2, p);
                return size;
            }
            return Size.Empty;
        }
        public static Size DrawHelpTip(Control control,
                                       Graphics graphics, Font font,
                                       string countMessage,
                                       string basicDescription,
                                       string documentation)
        {
            if (IsVisibleText(countMessage)     ||
                IsVisibleText(basicDescription) ||
                IsVisibleText(documentation)) {
                // Create all the TipSection objects.
                CountTipText countMessageTip = new CountTipText(graphics, font, countMessage);
                
                TipSpacer countSpacer = new TipSpacer(graphics, new SizeF(IsVisibleText(countMessage) ? 4 : 0, 0));
                
                TipText descriptionTip = new TipText(graphics, font, basicDescription);
                
                TipSpacer docSpacer = new TipSpacer(graphics, new SizeF(0, IsVisibleText(documentation) ? 4 : 0));
                
                TipText docTip = new TipText(graphics, font, documentation);
                
                // Now put them together.
                TipSplitter descSplitter = new TipSplitter(graphics, false,
                                                           descriptionTip,
                                                           docSpacer
                                                          );
                
                TipSplitter mainSplitter = new TipSplitter(graphics, true,
                                                           countMessageTip,
                                                           countSpacer,
                                                           descSplitter);
                
                TipSplitter mainSplitter2 = new TipSplitter(graphics, false,
                                                            mainSplitter,
                                                            docTip);
                
                // Show it.
                Size size = TipPainter.DrawTip(control, graphics, mainSplitter2);
                DrawingRectangle1 = countMessageTip.DrawingRectangle1;
                DrawingRectangle2 = countMessageTip.DrawingRectangle2;
                return size;
            }
            return Size.Empty;
        }
        
        public static Size DrawFixedWidthHelpTip(Control control,
                                                 Graphics graphics, Font font,
                                                 string countMessage,
                                                 string basicDescription,
                                                 string documentation)
        {
            if (IsVisibleText(countMessage)     ||
                IsVisibleText(basicDescription) ||
                IsVisibleText(documentation)) {
                // Create all the TipSection objects.
                CountTipText countMessageTip = new CountTipText(graphics, font, countMessage);
                
                TipSpacer countSpacer = new TipSpacer(graphics, new SizeF(IsVisibleText(countMessage) ? 4 : 0, 0));
                
                TipText descriptionTip = new TipText(graphics, font, basicDescription);
                
                TipSpacer docSpacer = new TipSpacer(graphics, new SizeF(0, IsVisibleText(documentation) ? 4 : 0));
                
                TipText docTip = new TipText(graphics, font, documentation);
                
                // Now put them together.
                TipSplitter descSplitter = new TipSplitter(graphics, false,
                                                           descriptionTip,
                                                           docSpacer
                                                          );
                
                TipSplitter mainSplitter = new TipSplitter(graphics, true,
                                                           countMessageTip,
                                                           countSpacer,
                                                           descSplitter);
                
                TipSplitter mainSplitter2 = new TipSplitter(graphics, false,
                                                            mainSplitter,
                                                            docTip);
                
                // Show it.
                Size size = TipPainter.DrawFixedWidthTip(control, graphics, mainSplitter2);
                DrawingRectangle1 = countMessageTip.DrawingRectangle1;
                DrawingRectangle2 = countMessageTip.DrawingRectangle2;
                return size;
            }
            return Size.Empty;
        }
        
        static bool IsVisibleText(string text)
        {
            return text != null && text.Length > 0;
        }
    }
}

#endif
// file ...\TextFileEdit\Util\TipSection.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="none" email=""/>
//     <version>$Revision: 915 $</version>
// </file>


namespace TextFileEdit.Util
{
	abstract class TipSection
	{
		SizeF    tipAllocatedSize;
		Graphics tipGraphics;
		SizeF    tipMaxSize;
		SizeF    tipRequiredSize;
		
		protected TipSection(Graphics graphics)
		{
			tipGraphics = graphics;
		}
		
		public abstract void Draw(PointF location);
		
		public SizeF GetRequiredSize()
		{
			return tipRequiredSize;
		}
		
		public void SetAllocatedSize(SizeF allocatedSize)
		{
			Debug.Assert(allocatedSize.Width >= tipRequiredSize.Width &&
			             allocatedSize.Height >= tipRequiredSize.Height);
			
			tipAllocatedSize = allocatedSize; OnAllocatedSizeChanged();
		}
		
		public void SetMaximumSize(SizeF maximumSize)
		{
			tipMaxSize = maximumSize; OnMaximumSizeChanged();
		}
		
		protected virtual void OnAllocatedSizeChanged()
		{
			
		}
		
		protected virtual void OnMaximumSizeChanged()
		{
			
		}
		
		protected void SetRequiredSize(SizeF requiredSize)
		{
			requiredSize.Width  = Math.Max(0, requiredSize.Width);
			requiredSize.Height = Math.Max(0, requiredSize.Height);
			requiredSize.Width  = Math.Min(tipMaxSize.Width, requiredSize.Width);
			requiredSize.Height = Math.Min(tipMaxSize.Height, requiredSize.Height);
			
			tipRequiredSize = requiredSize;
		}
		
		protected Graphics Graphics	{
			get {
				return tipGraphics;
			}
		}
		
		protected SizeF AllocatedSize {
			get {
				return tipAllocatedSize;
			}
		}
		
		protected SizeF MaximumSize {
			get {
				return tipMaxSize;
			}
		}
	}
}

#endif
// file ...\TextFileEdit\Util\TipSpacer.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="none" email=""/>
//     <version>$Revision: 915 $</version>
// </file>


namespace TextFileEdit.Util
{
	class TipSpacer: TipSection
	{
		SizeF spacerSize;
		
		public TipSpacer(Graphics graphics, SizeF size): base(graphics)
		{
			spacerSize = size;
		}
		
		public override void Draw(PointF location)
		{
			
		}
		
		protected override void OnMaximumSizeChanged()
		{
			base.OnMaximumSizeChanged();
			
			SetRequiredSize(new SizeF
			                (Math.Min(MaximumSize.Width, spacerSize.Width),
			                Math.Min(MaximumSize.Height, spacerSize.Height)));
		}
	}
}

#endif
// file ...\TextFileEdit\Util\TipSplitter.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="none" email=""/>
//     <version>$Revision: 915 $</version>
// </file>


namespace TextFileEdit.Util
{
	class TipSplitter: TipSection
	{
		bool         isHorizontal;
		float     [] offsets;
		TipSection[] tipSections;
		
		public TipSplitter(Graphics graphics, bool horizontal, params TipSection[] sections): base(graphics)
		{
			Debug.Assert(sections != null);
			
			isHorizontal = horizontal;
			offsets = new float[sections.Length];
			tipSections = (TipSection[])sections.Clone();	
		}
		
		public override void Draw(PointF location)
		{
			if (isHorizontal) {
				for (int i = 0; i < tipSections.Length; i ++) {
					tipSections[i].Draw
						(new PointF(location.X + offsets[i], location.Y));
				}
			} else {
				for (int i = 0; i < tipSections.Length; i ++) {
					tipSections[i].Draw
						(new PointF(location.X, location.Y + offsets[i]));
				}
			}
		}
		
		protected override void OnMaximumSizeChanged()
		{
			base.OnMaximumSizeChanged();
			
			float currentDim = 0;
			float otherDim = 0;
			SizeF availableArea = MaximumSize;
			
			for (int i = 0; i < tipSections.Length; i ++) {
				TipSection section = (TipSection)tipSections[i];
			
				section.SetMaximumSize(availableArea);
				
				SizeF requiredArea = section.GetRequiredSize();
				offsets[i] = currentDim;

				// It's best to start on pixel borders, so this will
				// round up to the nearest pixel. Otherwise there are
				// weird cutoff artifacts.
				float pixelsUsed;
				
				if (isHorizontal) {
					pixelsUsed  = (float)Math.Ceiling(requiredArea.Width);
					currentDim += pixelsUsed;
					
					availableArea.Width = Math.Max
						(0, availableArea.Width - pixelsUsed);
					
					otherDim = Math.Max(otherDim, requiredArea.Height);
				} else {
					pixelsUsed  = (float)Math.Ceiling(requiredArea.Height);
					currentDim += pixelsUsed;
					
					availableArea.Height = Math.Max
						(0, availableArea.Height - pixelsUsed);
					
					otherDim = Math.Max(otherDim, requiredArea.Width);
				}
			}
			
			foreach (TipSection section in tipSections) {
				if (isHorizontal) {
					section.SetAllocatedSize(new SizeF(section.GetRequiredSize().Width, otherDim));
				} else {
					section.SetAllocatedSize(new SizeF(otherDim, section.GetRequiredSize().Height));
				}
			}

			if (isHorizontal) {
				SetRequiredSize(new SizeF(currentDim, otherDim));
			} else {
				SetRequiredSize(new SizeF(otherDim, currentDim));
			}
		}
	}
}

#endif
// file ...\TextFileEdit\Util\TipText.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="none" email=""/>
//     <version>$Revision: 2561 $</version>
// </file>


namespace TextFileEdit.Util
{
	class CountTipText: TipText
	{
		float triHeight = 10;
		float triWidth  = 10;
		
		public CountTipText(Graphics graphics, Font font, string text) : base(graphics, font, text)
		{
		}
		
		void DrawTriangle(float x, float y, bool flipped)
		{
			Brush brush = BrushRegistry.GetBrush(Color.FromArgb(192, 192, 192));
			base.Graphics.FillRectangle(brush, new RectangleF(x, y, triHeight, triHeight));
			float triHeight2 = triHeight / 2;
			float triHeight4 = triHeight / 4;
			brush = Brushes.Black;
			if (flipped) {
				base.Graphics.FillPolygon(brush, new PointF[] {
				                          	new PointF(x,                y + triHeight2 - triHeight4),
				                          	new PointF(x + triWidth / 2, y + triHeight2 + triHeight4),
				                          	new PointF(x + triWidth,     y + triHeight2 - triHeight4),
				                          });
				
			} else {
				base.Graphics.FillPolygon(brush, new PointF[] {
				                          	new PointF(x,                y +  triHeight2 + triHeight4),
				                          	new PointF(x + triWidth / 2, y +  triHeight2 - triHeight4),
				                          	new PointF(x + triWidth,     y +  triHeight2 + triHeight4),
				                          });
			}
		}
		
		public Rectangle DrawingRectangle1;
		public Rectangle DrawingRectangle2;
		
		public override void Draw(PointF location)
		{
			if (tipText != null && tipText.Length > 0) {
				base.Draw(new PointF(location.X + triWidth + 4, location.Y));
				DrawingRectangle1 = new Rectangle((int)location.X + 2,
				                                  (int)location.Y + 2,
				                                  (int)(triWidth),
				                                  (int)(triHeight));
				DrawingRectangle2 = new Rectangle((int)(location.X + base.AllocatedSize.Width - triWidth  - 2),
				                                  (int)location.Y + 2,
				                                  (int)(triWidth),
				                                  (int)(triHeight));
				DrawTriangle(location.X + 2, location.Y + 2, false);
				DrawTriangle(location.X + base.AllocatedSize.Width - triWidth  - 2, location.Y + 2, true);
			}
		}
		
		protected override void OnMaximumSizeChanged()
		{
			if (IsTextVisible()) {
				SizeF tipSize = Graphics.MeasureString
					(tipText, tipFont, MaximumSize,
					 GetInternalStringFormat());
				tipSize.Width += triWidth * 2 + 8;
				SetRequiredSize(tipSize);
			} else {
				SetRequiredSize(SizeF.Empty);
			}
		}
		
	}
	
	class TipText: TipSection
	{
		protected StringAlignment horzAlign;
		protected StringAlignment vertAlign;
		protected Color           tipColor;
		protected Font            tipFont;
		protected StringFormat    tipFormat;
		protected string          tipText;
		
		public TipText(Graphics graphics, Font font, string text):
			base(graphics)
		{
			tipFont = font; tipText = text;
			if (text != null && text.Length > short.MaxValue)
				throw new ArgumentException("TipText: text too long (max. is " + short.MaxValue + " characters)", "text");
			
			Color               = SystemColors.InfoText;
			HorizontalAlignment = StringAlignment.Near;
			VerticalAlignment   = StringAlignment.Near;
		}
		
		public override void Draw(PointF location)
		{
			if (IsTextVisible()) {
				RectangleF drawRectangle = new RectangleF(location, AllocatedSize);
				
				Graphics.DrawString(tipText, tipFont,
				                    BrushRegistry.GetBrush(Color),
				                    drawRectangle,
				                    GetInternalStringFormat());
			}
		}
		
		protected StringFormat GetInternalStringFormat()
		{
			if (tipFormat == null) {
				tipFormat = CreateTipStringFormat(horzAlign, vertAlign);
			}
			
			return tipFormat;
		}
		
		protected override void OnMaximumSizeChanged()
		{
			base.OnMaximumSizeChanged();
			
			if (IsTextVisible()) {
				SizeF tipSize = Graphics.MeasureString
					(tipText, tipFont, MaximumSize,
					 GetInternalStringFormat());
				
				SetRequiredSize(tipSize);
			} else {
				SetRequiredSize(SizeF.Empty);
			}
		}
		
		static StringFormat CreateTipStringFormat(StringAlignment horizontalAlignment, StringAlignment verticalAlignment)
		{
			StringFormat format = (StringFormat)StringFormat.GenericTypographic.Clone();
			format.FormatFlags = StringFormatFlags.FitBlackBox | StringFormatFlags.MeasureTrailingSpaces;
			// note: Align Near, Line Center seemed to do something before
			
			format.Alignment     = horizontalAlignment;
			format.LineAlignment = verticalAlignment;
			
			return format;
		}
		
		protected bool IsTextVisible()
		{
			return tipText != null && tipText.Length > 0;
		}
		
		public Color Color {
			get {
				return tipColor;
			}
			set {
				tipColor = value;
			}
		}
		
		public StringAlignment HorizontalAlignment {
			get {
				return horzAlign;
			}
			set {
				horzAlign = value;
				tipFormat = null;
			}
		}
		
		public StringAlignment VerticalAlignment {
			get {
				return vertAlign;
			}
			set {
				vertAlign = value;
				tipFormat = null;
			}
		}
	}
}

#endif
// file ...\TextFileEdit\Util\WeakCollection.cs
#if !MOBILE && !CORE
// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Daniel Grunwald" email="daniel@danielgrunwald.de"/>
//     <version>$Revision: 2683 $</version>
// </file>


namespace TextFileEdit.Util
{
	/// <summary>
	/// A collection that does not allows its elements to be garbage-collected (unless there are other
	/// references to the elements). Elements will disappear from the collection when they are
	/// garbage-collected.
	/// 
	/// The WeakCollection is not thread-safe, not even for read-only access!
	/// No methods may be called on the WeakCollection while it is enumerated, not even a Contains or
	/// creating a second enumerator.
	/// The WeakCollection does not preserve any order among its contents; the ordering may be different each
	/// time the collection is enumerated.
	/// 
	/// Since items may disappear at any time when they are garbage collected, this class
	/// cannot provide a useful implementation for Count and thus cannot implement the ICollection interface.
	/// </summary>
	public class WeakCollection<T> : IEnumerable<T> where T : class
	{
		readonly List<WeakReference> innerList = new List<WeakReference>();
		
		/// <summary>
		/// Adds an element to the collection. Runtime: O(n).
		/// </summary>
		public void Add(T item)
		{
			if (item == null)
				throw new ArgumentNullException("item");
			CheckNoEnumerator();
			if (innerList.Count == innerList.Capacity || (innerList.Count % 32) == 31)
				innerList.RemoveAll(delegate(WeakReference r) { return !r.IsAlive; });
			innerList.Add(new WeakReference(item));
		}
		
		/// <summary>
		/// Removes all elements from the collection. Runtime: O(n).
		/// </summary>
		public void Clear()
		{
			innerList.Clear();
			CheckNoEnumerator();
		}
		
		/// <summary>
		/// Checks if the collection contains an item. Runtime: O(n).
		/// </summary>
		public bool Contains(T item)
		{
			if (item == null)
				throw new ArgumentNullException("item");
			CheckNoEnumerator();
			foreach (T element in this) {
				if (item.Equals(element))
					return true;
			}
			return false;
		}
		
		/// <summary>
		/// Removes an element from the collection. Returns true if the item is found and removed,
		/// false when the item is not found.
		/// Runtime: O(n).
		/// </summary>
		public bool Remove(T item)
		{
			if (item == null)
				throw new ArgumentNullException("item");
			CheckNoEnumerator();
			for (int i = 0; i < innerList.Count;) {
				T element = (T)innerList[i].Target;
				if (element == null) {
					RemoveAt(i);
				} else if (element == item) {
					RemoveAt(i);
					return true;
				} else {
					i++;
				}
			}
			return false;
		}
		
		void RemoveAt(int i)
		{
			int lastIndex = innerList.Count - 1;
			innerList[i] = innerList[lastIndex];
			innerList.RemoveAt(lastIndex);
		}
		
		bool hasEnumerator;
		
		void CheckNoEnumerator()
		{
			if (hasEnumerator)
				throw new InvalidOperationException("The WeakCollection is already being enumerated, it cannot be modified at the same time. Ensure you dispose the first enumerator before modifying the WeakCollection.");
		}
		
		/// <summary>
		/// Enumerates the collection.
		/// Each MoveNext() call on the enumerator is O(1), thus the enumeration is O(n).
		/// </summary>
		public IEnumerator<T> GetEnumerator()
		{
			if (hasEnumerator)
				throw new InvalidOperationException("The WeakCollection is already being enumerated, it cannot be enumerated twice at the same time. Ensure you dispose the first enumerator before using another enumerator.");
			try {
				hasEnumerator = true;
				for (int i = 0; i < innerList.Count;) {
					T element = (T)innerList[i].Target;
					if (element == null) {
						RemoveAt(i);
					} else {
						yield return element;
						i++;
					}
				}
			} finally {
				hasEnumerator = false;
			}
		}
		
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
}

#endif
// file ...\Threading\ProcessMutex.cs
#if !MOBILE

namespace Zero5.Threading
{
    public class ProcessMutex
    {
        private string mName = "";
        private Mutex mtx;

        public ProcessMutex(string name)
        {
            mName = name;
        }

        public void Create()
        {
            mtx = new Mutex(false, "Global" + System.IO.Path.DirectorySeparatorChar + "" + mName); 
        }

        public bool Open()
        {
            try
            {
                mtx = Mutex.OpenExisting("Global" + System.IO.Path.DirectorySeparatorChar + "" + mName);
                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }

        public bool Exist()
        {
            try
            {
                Mutex mtx_tmp = Mutex.OpenExisting("Global" + System.IO.Path.DirectorySeparatorChar + "" + mName);
                mtx_tmp.Close();
                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }

        public bool Lock(int timeout)
        {
            return mtx.WaitOne(timeout, false);
        }

        public void Unlock()
        {
            try
            {
                mtx.ReleaseMutex();
            }
            catch (Exception)
            {
            }
        }

        public bool LockAndUnLock(int timeout)
        {
            if (mtx.WaitOne(timeout, false))
            {
                Thread.Sleep(timeout);
                mtx.ReleaseMutex();
                Thread.Sleep(timeout);
                return true;
            }
            return false;
        }

        public void Close()
        {
            mtx.Close();
        }
    }
}
#endif
// file ...\Threading\SequentialItemProcessor.cs
#if !MOBILE

namespace Zero5.Threading
{
    /// <summary>
    /// This class is used to process items sequentially in a multithreaded manner.
    /// </summary>
    /// <typeparam name="TItem">Type of item to process</typeparam>
    public class SequentialItemProcessor<TItem>
    {
        #region Private fields

        /// <summary>
        /// The method delegate that is called to actually process items.
        /// </summary>
        private readonly Action<TItem> _processMethod;

        /// <summary>
        /// Item queue. Used to process items sequentially.
        /// </summary>
        private readonly Queue<TItem> _queue;

        /// <summary>
        /// A reference to the current Task that is processing an item in
        /// ProcessItem method.
        /// </summary>
        private Task _currentProcessTask;

        /// <summary>
        /// Indicates state of the item processing.
        /// </summary>
        private bool _isProcessing;

        /// <summary>
        /// A boolean value to control running of SequentialItemProcessor.
        /// </summary>
        private bool _isRunning;

        /// <summary>
        /// An object to synchronize threads.
        /// </summary>
        private readonly object _syncObj = new object();

        #endregion

        #region Constructor

        /// <summary>
        /// Creates a new SequentialItemProcessor object.
        /// </summary>
        /// <param name="processMethod">The method delegate that is called to actually process items</param>
        public SequentialItemProcessor(Action<TItem> processMethod)
        {
            _processMethod = processMethod;
            _queue = new Queue<TItem>();
        }

        #endregion

        #region Public methods

        /// <summary>
        /// Adds an item to queue to process the item.
        /// </summary>
        /// <param name="item">Item to add to the queue</param>
        public void EnqueueMessage(TItem item)
        {
            //Add the item to the queue and start a new Task if needed
            lock (_syncObj)
            {
                if (!_isRunning)
                {
                    return;
                }

                _queue.Enqueue(item);

                if (!_isProcessing)
                {
                    _currentProcessTask = Task.Factory.StartNew(ProcessItem);
                }
            }
        }

        /// <summary>
        /// Starts processing of items.
        /// </summary>
        public void Start()
        {
            _isRunning = true;
        }

        /// <summary>
        /// Stops processing of items and waits stopping of current item.
        /// </summary>
        public void Stop()
        {
            _isRunning = false;

            //Clear all incoming messages
            lock (_syncObj)
            {
                _queue.Clear();
            }

            //Check if is there a message that is being processed now
            if (!_isProcessing)
            {
                return;
            }

            //Wait current processing task to finish
            try
            {
                _currentProcessTask.Wait();
            }
            catch
            {

            }
        }

        #endregion

        #region Private methods

        /// <summary>
        /// This method runs on a new seperated Task (thread) to process
        /// items on the queue.
        /// </summary>
        private void ProcessItem()
        {
            //Try to get an item from queue to process it.
            TItem itemToProcess;
            lock (_syncObj)
            {
                if (!_isRunning || _isProcessing)
                {
                    return;
                }

                if (_queue.Count <= 0)
                {
                    return;
                }

                _isProcessing = true;
                itemToProcess = _queue.Dequeue();
            }

            //Process the item (by calling the _processMethod delegate)
            _processMethod(itemToProcess);

            //Process next item if available
            lock (_syncObj)
            {
                _isProcessing = false;
                if (!_isRunning || _queue.Count <= 0)
                {
                    return;
                }

                //Start a new task
                _currentProcessTask = Task.Factory.StartNew(ProcessItem);
            }
        }

        #endregion
    }
}
#endif
// file ...\Threading\SingleInstance.cs
#if !MOBILE


namespace Zero5.Threading
{
    public class SingleInstance
    {
        private static Dictionary<string, System.Threading.Mutex> mtx;

#if !CORE
        public static bool ImAloneWithinUser()
        {
            return ImAlone(
                "Global" + System.IO.Path.DirectorySeparatorChar +
                System.Diagnostics.Process.GetCurrentProcess().ProcessName + "-" +
                System.Security.Principal.WindowsIdentity.GetCurrent().Name.Replace(System.IO.Path.DirectorySeparatorChar.ToString(), "_"));
        }
#endif

        public static bool ImAloneWithinSystem()
        {
            return ImAloneWithinSystem("");
        }

        public static bool ImAloneWithinSystem(string postfix)
        {
            return ImAlone(
                "Global" + System.IO.Path.DirectorySeparatorChar +
                System.Diagnostics.Process.GetCurrentProcess().ProcessName + postfix);
        }

        private static bool ImAlone(string mutexName)
        {
            try
            {
                if (mtx == null) mtx = new Dictionary<string, System.Threading.Mutex>();

                if (!mtx.ContainsKey(mutexName))
                {
                    try
                    {

                        System.Threading.Mutex mtx_tmp = System.Threading.Mutex.OpenExisting(mutexName);
                        mtx_tmp.Close();
                        //...double istance
                        return false;
                    }
                    catch (Exception)
                    {
                    }

                    if (!mtx.ContainsKey(mutexName))
                        mtx.Add(mutexName, new System.Threading.Mutex(false, mutexName));
                    else
                        mtx[mutexName] = new System.Threading.Mutex(false, mutexName);
                }

            }
            catch (Exception ex)
            {
                Zero5.Util.Log.WriteLog(ex.ToString());
            }

            return true;
        }

    }
}
#endif
// file ...\Threading\TimerElapsed.cs
#if !MOBILE

namespace Zero5.Threading
{
    /// <summary>
    /// This class is a timer that performs some tasks periodically.
    /// </summary>
    public class TimerElapsed
    {
        #region Public events

        /// <summary>
        /// This event is raised periodically according to Period of Timer.
        /// </summary>
        public event EventHandler Elapsed;

        #endregion

        #region Public fields

        /// <summary>
        /// Task period of timer (as milliseconds).
        /// </summary>
        public int Period { get; set; }

        /// <summary>
        /// Indicates whether timer raises Elapsed event on Start method of Timer for once.
        /// Default: False.
        /// </summary>
        public bool RunOnStart { get; set; }

        #endregion

        #region Private fields

        /// <summary>
        /// This timer is used to perfom the task at spesified intervals.
        /// </summary>
        private readonly System.Threading.Timer _taskTimer;

        /// <summary>
        /// Indicates that whether timer is running or stopped.
        /// </summary>
        private volatile bool _running;

        /// <summary>
        /// Indicates that whether performing the task or _taskTimer is in sleep mode.
        /// This field is used to wait executing tasks when stopping Timer.
        /// </summary>
        private volatile bool _performingTasks;

        #endregion

        #region Constructors

        /// <summary>
        /// Creates a new Timer.
        /// </summary>
        /// <param name="period">Task period of timer (as milliseconds)</param>
        public TimerElapsed(int period)
            : this(period, false)
        {

        }

        /// <summary>
        /// Creates a new Timer.
        /// </summary>
        /// <param name="period">Task period of timer (as milliseconds)</param>
        /// <param name="runOnStart">Indicates whether timer raises Elapsed event on Start method of Timer for once</param>
        public TimerElapsed(int period, bool runOnStart)
        {
            Period = period;
            RunOnStart = runOnStart;
            _taskTimer = new System.Threading.Timer(TimerCallBack, null, Timeout.Infinite, Timeout.Infinite);
        }

        #endregion

        #region Public methods

        /// <summary>
        /// Starts the timer.
        /// </summary>
        public void Start()
        {
            _running = true;
            _taskTimer.Change(RunOnStart ? 0 : Period, Timeout.Infinite);
        }

        /// <summary>
        /// Stops the timer.
        /// </summary>
        public void Stop()
        {
            lock (_taskTimer)
            {
                _running = false;
                _taskTimer.Change(Timeout.Infinite, Timeout.Infinite);
            }
        }

        /// <summary>
        /// Waits the service to stop.
        /// </summary>
        public void WaitToStop()
        {
            lock (_taskTimer)
            {
                while (_performingTasks)
                {
                    Monitor.Wait(_taskTimer);
                }
            }
        }

        #endregion

        #region Private methods

        /// <summary>
        /// This method is called by _taskTimer.
        /// </summary>
        /// <param name="state">Not used argument</param>
        private void TimerCallBack(object state)
        {
            lock (_taskTimer)
            {
                if (!_running || _performingTasks)
                {
                    return;
                }

                _taskTimer.Change(Timeout.Infinite, Timeout.Infinite);
                _performingTasks = true;
            }

            try
            {
                if (Elapsed != null)
                {
                    Elapsed(this, new EventArgs());
                }
            }
            catch
            {

            }
            finally
            {
                lock (_taskTimer)
                {
                    _performingTasks = false;
                    if (_running)
                    {
                        _taskTimer.Change(Period, Timeout.Infinite);
                    }

                    Monitor.Pulse(_taskTimer);
                }
            }
        }

        #endregion
    }
}
#endif
// file ...\Util\BinaryConverters.cs

namespace Zero5.Util
{
    public class BinaryConverters
    {
        public static byte[] DataSetToBytes(System.Data.DataSet ds)
        {
            //Default preCode to test byte array content
            return DataSetToBytes(ds, 48); // '0'
        }

        public static byte[] DataSetToBytes(System.Data.DataSet ds, byte preCode)
        {
            //using (new Zero5.Performance.StopWatch("DS to Bytes " + ds.Tables[0].TableName + " rows " + ds.Tables[0].Rows.Count.ToString(), 50))
            {
                //preCode is to test byte array content

                System.IO.MemoryStream ms;
                Zero5.IO.RawSerializer.RawSerializer rs;
                ms = new System.IO.MemoryStream();
                rs = new Zero5.IO.RawSerializer.RawSerializer(ms);

                ms.WriteByte(preCode); // first write precode

                rs.Serialize(ds.Tables[0].TableName);       // serialize tablename
                rs.Serialize(ds.Tables[0].Columns.Count);   // serialize columns count
                rs.Serialize(ds.Tables[0].Rows.Count);      // serialize rows count

                // serialize columns info
                foreach (System.Data.DataColumn dc in ds.Tables[0].Columns)
                {
                    rs.Serialize(dc.ColumnName);
                    rs.Serialize(dc.AllowDBNull);
                    rs.Serialize(dc.DataType.AssemblyQualifiedName);
                }

                // serialize data
                foreach (System.Data.DataRow dr in ds.Tables[0].Rows)
                {
                    foreach (System.Data.DataColumn dc in ds.Tables[0].Columns)
                    {
                        //serialize field
                        if (dc.AllowDBNull)
                        {
                            if (dr.RowState == System.Data.DataRowState.Deleted)
                                rs.SerializeNullable(dr[dc, System.Data.DataRowVersion.Original]);
                            else
                                rs.SerializeNullable(dr[dc]);
                        }
                        else
                        {
                            if (dr.RowState == System.Data.DataRowState.Deleted)
                                rs.Serialize(dr[dc, System.Data.DataRowVersion.Original]);
                            else
                                rs.Serialize(dr[dc]);
                        }
                    }

                    //serialize row state
                    switch (dr.RowState)
                    {
                        case System.Data.DataRowState.Unchanged:
                            rs.Serialize((byte)0);
                            break;
                        case System.Data.DataRowState.Added:
                            rs.Serialize((byte)1);
                            break;
                        case System.Data.DataRowState.Modified:
                            rs.Serialize((byte)2);
                            break;
                        case System.Data.DataRowState.Deleted:
                            rs.Serialize((byte)3);
                            break;
                        default:
                            rs.Serialize((byte)0);
                            break;
                    }
                }

                rs.Flush();
                ms.Position = 0;
                return ms.ToArray();
            }
        }

        public static System.Data.DataSet BytesToDataSet(byte[] data)
        {
            //dummy
            if (data.Length == 0) return null;

            //using (Zero5.Performance.StopWatch stw = new Zero5.Performance.StopWatch("Bytes To DS", 50))
            {
                System.IO.MemoryStream ms;
                Zero5.IO.RawSerializer.RawDeserializer rd;

                ms = new System.IO.MemoryStream(data);
                rd = new Zero5.IO.RawSerializer.RawDeserializer(ms);

                //ignore precode on first byte
                ms.Position = 1;

                int rowState = 0;

                string tableName = rd.DeserializeString();  // deserialize table name
                int columns = rd.DeserializeInt();          // deserialize columns count
                int rows = rd.DeserializeInt();             // deserialize rows count

                System.Data.DataSet dsIn = new System.Data.DataSet();
                dsIn.Tables.Add(tableName);

                // deserialize columns with columns attribs
                for (int x = 0; x < columns; x++)
                {
                    string columnName = rd.DeserializeString();
                    bool allowNulls = rd.DeserializeBool();
                    string sType = rd.DeserializeString();
                    Type type = Type.GetType(sType);

                    if (type == null)
                    {
                        if (sType.Contains(","))
                        {
                            sType = sType.Substring(0, sType.IndexOf(","));
                            type = Type.GetType(sType);
                        }
                    }

                    System.Data.DataColumn dc = new System.Data.DataColumn(columnName, type);
                    dc.AllowDBNull = allowNulls;
                    dsIn.Tables[0].Columns.Add(dc);
                }

                // deserialize data
                for (int y = 0; y < rows; y++)
                {
                    System.Data.DataRow dr = dsIn.Tables[0].NewRow();

                    // deserialize fields
                    for (int x = 0; x < columns; x++)
                    {
                        System.Data.DataColumn dc = dsIn.Tables[0].Columns[x];
                        object obj;

                        if (dc.AllowDBNull)
                        {
                            obj = rd.DeserializeNullable(dc.DataType);
                        }
                        else
                        {
                            obj = rd.Deserialize(dc.DataType);
                        }

                        dr[dc] = obj;
                    }

                    //add new row, now this row is in Added state
                    dsIn.Tables[0].Rows.Add(dr);

                    // force real row state
                    rowState = rd.DeserializeByte();
                    switch (rowState)
                    {
                        case 0:
                            dsIn.Tables[0].Rows[y].AcceptChanges();
                            break;
                        case 1:
                            //dsIn.Tables[0].Rows[y].SetAdded();
                            break;
                        case 2:
                            dsIn.Tables[0].Rows[y].AcceptChanges();
                            dsIn.Tables[0].Rows[y].SetModified();
                            break;
                        case 3:
                            dsIn.Tables[0].Rows[y].AcceptChanges();
                            dsIn.Tables[0].Rows[y].Delete();
                            break;
                    }

                }
                //stw.Name = "Bytes To DS " + dsIn.Tables[0].TableName + " rows " + dsIn.Tables[0].Rows.Count.ToString();
                return dsIn;
            }
        }

        public static byte[] IntListToBytes(List<int> list)
        {
            //preCode is to test byte array content
            System.IO.MemoryStream ms;
            Zero5.IO.RawSerializer.RawSerializer rs;
            ms = new System.IO.MemoryStream();
            rs = new Zero5.IO.RawSerializer.RawSerializer(ms);

            // serialize columns info
            foreach (int i in list)
            {
                rs.Serialize(i);
            }
            rs.Serialize((int)0);

            rs.Flush();
            ms.Position = 0;
            return ms.ToArray();
        }

        public static List<int> BytesToIntList(byte[] data)
        {
            //dummy
            if (data.Length == 0) return null;

            System.IO.MemoryStream ms;
            Zero5.IO.RawSerializer.RawDeserializer rd;

            ms = new System.IO.MemoryStream(data);
            rd = new Zero5.IO.RawSerializer.RawDeserializer(ms);

            ms.Position = 0;

            int i = rd.DeserializeInt();             // deserialize rows count
            List<int> list = new List<int>();

            while (i > 0)
            {
                list.Add(i);
                i = rd.DeserializeInt();
            }

            return list;
        }

        public static byte[] ImageToBytes(System.Drawing.Image imageIn)
        {
            System.IO.MemoryStream ms = new System.IO.MemoryStream();
            System.Drawing.Bitmap image = new System.Drawing.Bitmap(imageIn);
            image.Save(ms, System.Drawing.Imaging.ImageFormat.Png);
            return ms.ToArray();
        }

        public static System.Drawing.Image BytesToImage(byte[] byteArray)
        {
            System.IO.MemoryStream ms = new System.IO.MemoryStream(byteArray);
#if MOBILE
            return new System.Drawing.Bitmap(ms);
#else
            return System.Drawing.Image.FromStream(ms);
#endif
        }

        public static string ImageToBase64(System.Drawing.Image value)
        {
            if (value == null)
            {
                return "";
            }

            //map the image as png format
            System.IO.MemoryStream memoryStream = new System.IO.MemoryStream();
            value.Save(memoryStream, System.Drawing.Imaging.ImageFormat.Png);

            //convert the image map to base 64 string
            string base64 = Convert.ToBase64String(memoryStream.ToArray());
            memoryStream.Close();

            return base64;
        }

        public static System.Drawing.Image Base64ToImage(string base64String)
        {
            // Convert Base64 String to byte[]
            byte[] imageBytes = Convert.FromBase64String(base64String);
            System.IO.MemoryStream ms = new System.IO.MemoryStream(imageBytes, 0,
              imageBytes.Length);

            // Convert byte[] to Image
            ms.Write(imageBytes, 0, imageBytes.Length);
#if MOBILE
            return new System.Drawing.Bitmap(ms);
#else
            return System.Drawing.Image.FromStream(ms, true);
#endif
        }
    }
}
// file ...\Util\Common.cs

namespace Zero5.Util
{
    public class Common
    {
        public static Dictionary<int, string> Dictionary_Clone(Dictionary<int, string> sorgente)
        {
            Dictionary<int, string> dic = new Dictionary<int, string>();
            foreach (KeyValuePair<int, string> item in sorgente)
            {
                dic.Add(item.Key, item.Value);
            }
            return dic;
        }

        public static List<int> List_FromDSForColum(System.Data.DataTable dt, string columName)
        {
            List<int> list = new List<int>();
            for (int i = 0; i < dt.Rows.Count; i++)
            {
                if (!list.Contains((int)dt.Rows[i][columName])) list.Add((int)dt.Rows[i][columName]);
            }
            return list;
        }
        
        public static List<List<T>> SplitList<T>(List<T> source,int size) {
            List<List<T>> result = new List<List<T>>();
            if (source.Count > 0)
                result.Add(new List<T>());
            foreach (T elem in source) {
                if (result.Last().Count >= size)
                    result.Add(new List<T>());
                result.Last().Add(elem);
            }
            return result;
        }

        public static List<T> MergeList<T>(List<List<T>> sources) {
            List<T> result = new List<T>();
            foreach (List<T> elem in sources)
                result.AddRange(elem);
            return result;
        }
    }
}
// file ...\Util\Date.cs

namespace Zero5.Util
{
    class Date
    {
        private static System.Globalization.CultureInfo _locCulture = null;
        private static System.Globalization.CultureInfo LocalCulture
        {
            get
            {
                if (_locCulture == null)
                    _locCulture = new System.Globalization.CultureInfo("it-IT");
                return _locCulture;
            }
        }

        private static System.Globalization.Calendar _locCalendar = null;
        private static System.Globalization.Calendar LocalCalendar
        {
            get
            {
                if (_locCalendar == null)
                    _locCalendar = LocalCulture.Calendar;
                return _locCalendar;
            }
        }

        public static int GetWeekNumberFromDate(DateTime dtTarget)
        {
            return LocalCalendar.GetWeekOfYear(dtTarget, LocalCulture.DateTimeFormat.CalendarWeekRule, LocalCulture.DateTimeFormat.FirstDayOfWeek);
        }

        public static DateTime FirstDateOfWeek(int year, int weekOfYear)
        {
            DateTime dtref = new DateTime(year, 1, 1);
            dtref.AddDays(7 * weekOfYear);

            int weekCheck = GetWeekNumberFromDate(dtref);
            if (weekCheck > weekOfYear)
                dtref.AddDays(-7);
            else if (weekCheck < weekOfYear)
                dtref.AddDays(7);

            return FirstDateOfWeek(dtref);
        }

        public static DateTime FirstDateOfWeek(DateTime dtref)
        {
            return dtref.Date.AddDays(-(((int)dtref.DayOfWeek - (int)LocalCulture.DateTimeFormat.FirstDayOfWeek) % 7));
        }

        public static DateTime DataOraAttuale()
        { return DateTime.Now; }

        public static DateTime RoundMinute(DateTime dt, int minutes)
        {
            return new DateTime(dt.Ticks - (dt.Ticks % ((long)600000000 * minutes))); //ai n minuti
        }

        public static DateTime Parse_yyyyMMddHHmmssfff(string date)
        {
            try
            {
                return new DateTime(
                    int.Parse(date.Substring(0, 4)),
                    int.Parse(date.Substring(4, 2)),
                    int.Parse(date.Substring(6, 2)),
                    int.Parse(date.Substring(8, 2)),
                    int.Parse(date.Substring(10, 2)),
                    int.Parse(date.Substring(12, 2)),
                    int.Parse(date.Substring(14, 3)));

            }
            catch
            { }

            return DateTime.MinValue;
        }

        public static DateTime Parse_ddMMyyyyHHmmssfff(string date)
        {
            try
            {
                return new DateTime(
                    int.Parse(date.Substring(4, 4)),
                    int.Parse(date.Substring(2, 2)),
                    int.Parse(date.Substring(0, 2)),
                    int.Parse(date.Substring(8, 2)),
                    int.Parse(date.Substring(10, 2)),
                    int.Parse(date.Substring(12, 2)),
                    int.Parse(date.Substring(14, 3)));

            }
            catch
            { }

            return DateTime.MinValue;
        }
    }
}
// file ...\Util\FileParametri.cs

namespace Zero5.Util
{
    public class FileParametri
    {
        private static StringBuilder lockObj = new StringBuilder();

        private string configfilename = "";
        private string configEncryptionString = "";
                
        public FileParametri(string filename)
            : this(filename, "")
        { }

        public FileParametri(string filename, string encryptionString)
        {
            configfilename = filename;
            if (encryptionString != "") configEncryptionString = (Zero5.Util.StringTools.WithOutSpecialCharacters(encryptionString) + "diufhasdilfhlasadfsdfwlpidsufhiasudhf").Substring(0, 24);

            lock (Zero5.Util.FileParametri.lockObj)
            {
                if (!System.IO.File.Exists(configfilename)) return;
#if MOBILE
                List<string> list = new List<string>();
                using (System.IO.StreamReader streamReader = new System.IO.StreamReader(filename))
                {
                    string item;
                    while ((item = streamReader.ReadLine()) != null)
                    {
                        list.Add(item);
                    }
                }
                string[] data = list.ToArray(); 
#else
                string[] data;

                if (configEncryptionString == "")
                    data = System.IO.File.ReadAllLines(configfilename);
                else
                {
                    string encData = System.IO.File.ReadAllText(configfilename);
                    try
                    {
                        encData = Zero5.Encryption.Simple.Decrypt(encData, configEncryptionString);
                    }
                    catch 
                    {
                        data = System.IO.File.ReadAllLines(configfilename);
                    }
                    data = encData.Replace("\r\n", "\n").Split('\n');
                }
#endif

                for (int i = 0; i < data.Length; i++)
                {
                    string key = data[i].Split('=')[0].ToUpper().Trim();
                    if (key != "")
                        if (!Parametri.ContainsKey(key))
                        {
                            Parametri.Add(key, data[i].Substring(key.Length + 1));
                        }
                }
            }
        }
        private Dictionary<string, string> Parametri = new Dictionary<string, string>();

        protected string GetParametro(string nomeParametro, string defaultValue)
        {
            lock (Zero5.Util.FileParametri.lockObj)
            {
                string value = GetParametro(nomeParametro);
                if (value == "")
                {
                    SetParametro(nomeParametro, defaultValue);
                    return defaultValue;
                }
                else
                {
                    return value;
                }
            }
        }

        protected int GetParametroAsInt(string nomeParametro, int defaultValue)
        {
            return int.Parse(GetParametro(nomeParametro, defaultValue.ToString()), System.Globalization.CultureInfo.InvariantCulture);
        }

#if !MOBILE
        protected long GetParametroAsLong(string nomeParametro, long defaultValue)
        {
            return long.Parse(GetParametro(nomeParametro, defaultValue.ToString()), System.Globalization.CultureInfo.InvariantCulture);
        }
#endif

        protected double GetParametroAsDouble(string nomeParametro, double defaultValue)
        {
            return double.Parse(GetParametro(nomeParametro, defaultValue.ToString(System.Globalization.CultureInfo.InvariantCulture)), System.Globalization.CultureInfo.InvariantCulture);
        }

        protected string GetParametro(string nomeParametro)
        {
            lock (Zero5.Util.FileParametri.lockObj)
            {

                nomeParametro = nomeParametro.ToUpper().Trim();
                if (Parametri.ContainsKey(nomeParametro))
                {
                    return Parametri[nomeParametro];
                }
                return "";
            }
        }

        protected void SetParametro(string nomeParametro, string valoreParametro)
        {
            lock (Zero5.Util.FileParametri.lockObj)
            {
                nomeParametro = nomeParametro.ToUpper().Trim();
                if (Parametri.ContainsKey(nomeParametro))
                {
                    if (Parametri[nomeParametro] == valoreParametro) return;

                    Parametri[nomeParametro] = valoreParametro;
                }
                else
                {
                    Parametri.Add(nomeParametro, valoreParametro);
                }
                Save();
            }
        }

        protected void SetParametro(string nomeParametro, int valoreParametro)
        {
            SetParametro(nomeParametro, valoreParametro.ToString());
        }

        protected void SetParametro(string nomeParametro, long valoreParametro)
        {
            SetParametro(nomeParametro, valoreParametro.ToString());
        }

        protected void SetParametro(string nomeParametro, double valoreParametro)
        {
            SetParametro(nomeParametro, valoreParametro.ToString(System.Globalization.CultureInfo.InvariantCulture));
        }

        private void Save()
        {
            lock (Zero5.Util.FileParametri.lockObj)
            {
                StringBuilder sb = new StringBuilder();
                foreach (KeyValuePair<string, string> par in Parametri)
                {
                    sb.Append(par.Key + "=" + par.Value + "\r\n");
                }

#if !MOBILE
                if (configEncryptionString == "")
                {
                    System.IO.File.WriteAllText(configfilename, sb.ToString(), System.Text.Encoding.UTF8);
                }
                else
                {
                    try
                    {
                        System.IO.File.WriteAllText(configfilename, Zero5.Encryption.Simple.Encrypt(sb.ToString(), configEncryptionString), System.Text.Encoding.UTF8);
                    }
                    catch
                    {
                        System.IO.File.WriteAllText(configfilename, sb.ToString(), System.Text.Encoding.UTF8);
                    }

                }
#else
                using (System.IO.StreamWriter streamWriter = new System.IO.StreamWriter(configfilename, false))
                {
                    streamWriter.Write(sb.ToString());
                }
#endif

            }
        }

    }
}
// file ...\Util\KeyConverter.cs

namespace Zero5.Util
{
    class KeyConverter
    {
        public static int DayToIntKey(DateTime date)
        {
            return date.Year * 1000 + date.DayOfYear;
        }

        public static DateTime IntKeyToDay(int key)
        {
            return new DateTime(key / 1000, 0, 0).AddDays(key % 1000);
        }

    }
}
// file ...\Util\Log.cs

namespace Zero5.Util
{
    public class Log
    {
#if MOBILE || CORE
        public static string ProductName = "log";
        private static string m_sProgramName = ProductName;
#else
        private static string m_sProgramName = System.Windows.Forms.Application.ProductName;
#endif
        public static string ProgramName
        {
            get { return Log.m_sProgramName; }
            set { Log.m_sProgramName = value; }
        }

        static DateTime mdt_UltimaPulizia = new DateTime();
        static DirectoryInfo folder = new DirectoryInfo(Zero5.IO.Util.LocalPathFile("Log", ""));
        private static void VerificaEseguiPulizia(string progName)
        {
            System.TimeSpan TS = new System.TimeSpan(DateTime.Now.Ticks - mdt_UltimaPulizia.Ticks);
            if (TS.TotalMinutes < 1440) return;

            if (!folder.Exists) folder.Create();

            FileInfo[] filesLog = folder.GetFiles("*.log");
            if (filesLog.Length == 0)
                return;

            FileInfo[] filesCompressi = folder.GetFiles("*.gz");

            List<FileInfo> lstFileInfo = new List<FileInfo>();
            lstFileInfo.AddRange(filesLog);

            if (filesCompressi.Length > 1)
            {
                lstFileInfo.AddRange(filesCompressi);
            }

            foreach (FileInfo file in lstFileInfo)
            {
                TS = new System.TimeSpan(DateTime.Now.Ticks - file.CreationTime.Ticks);
                if (TS.TotalDays >= 15)
                {
                    file.Delete();
                }
            }

            mdt_UltimaPulizia = DateTime.Now;
        }

        private static void ComprimiFile(object filePath)
        {
            try
            {
                string path = filePath.ToString();

                if (System.IO.File.Exists(path))
                {
                    //System.IO.Compression.ZipStorer storer = System.IO.Compression.ZipStorer.Create(path, "");
                    //storer.AddFile(System.IO.Compression.ZipStorer.Compression.Deflate, tempFlussoPath, $"{nomeCliente}_FOD_{flussoPartenza.NomeFlusso}_flow.dat", "");
                    //storer.Close();

                    FileStream sourceFileStream = File.OpenRead(path);
                    FileStream destFileStream = File.Create(path + ".gz");

                    System.IO.Compression.GZipStream compressingStream = new System.IO.Compression.GZipStream(destFileStream, System.IO.Compression.CompressionMode.Compress);

                    byte[] bytes = new byte[2 * 1024];
                    int bytesRead = 0;
                    while ((bytesRead = sourceFileStream.Read(bytes, 0, bytes.Length)) != 0)
                    {
                        compressingStream.Write(bytes, 0, bytesRead);
                    }

                    sourceFileStream.Close();
                    compressingStream.Close();
                    destFileStream.Close();

                    sourceFileStream = null;
                    destFileStream = null;
                    compressingStream = null;

                    System.IO.File.Delete(path);
                }
            }
            catch (Exception) { }
        }

        public static void WriteLog(string sMessage)
        {
            try
            {
                WriteLog(ProgramName, sMessage);
            }
            catch { }
        }

        private static int PID = 0;

        private static Object thisLock = new Object();
        public static void WriteLog(string progName, string sMessage)
        {
            try
            {
                PID = System.Diagnostics.Process.GetCurrentProcess().Id;
            }
            catch (Exception)
            {
            }

            try
            {
                sMessage = DateTime.Now.ToString("HH:mm:ss.fff") +
                            (" [P" + PID + "-T" + System.Threading.Thread.CurrentThread.GetHashCode().ToString() + "-" +
                            System.Threading.Thread.CurrentThread.Name + "]").PadRight(7) +
                            " " + sMessage;

                WriteAndClear(progName, sMessage);
            }
            catch
            {
            }
        }

        public static void WriteLog(string progName, string sMessage, string formatDataOra)
        {
            try
            {
                if (formatDataOra == "")
                    formatDataOra = "HH:mm:ss.fff";

                sMessage = " [" + System.Threading.Thread.CurrentThread.GetHashCode().ToString() + "-" +
                            System.Threading.Thread.CurrentThread.Name + "]" +
                            " " + sMessage;
                sMessage = DateTime.Now.ToString(formatDataOra) + " " + sMessage;
                WriteAndClear(progName, sMessage);
            }
            catch { }
        }

#if MOBILE

        private static void WriteAndClear(string progName, string sMessage)
        {
            try
            {
                lock (thisLock)
                {
                    m_LastRowsBuffer = sMessage + "\r\n" + m_LastRowsBuffer;
                    if (m_LastRowsBuffer.Length > 100000) m_LastRowsBuffer = m_LastRowsBuffer.Substring(0, 6000);

                    if (!folder.Exists) folder.Create();

                    String sFileName = IO.Util.LocalPath() + "\\Log\\" + progName + DateTime.Now.ToString("yyyyMMdd") + ".log";

                    StreamWriter sw;
                    if (File.Exists(sFileName))
                        sw = File.AppendText(sFileName);
                    else
                        sw = new System.IO.StreamWriter(sFileName);

                    sw.WriteLine(sMessage);
                    sw.Flush();
                    sw.Close();
                }
                VerificaEseguiPulizia(progName);
            }
            catch { }
        }
#else
        private static void WriteAndClear(string progName, string sMessage)
        {
            try
            {
                string nomeFileDaComprimere = "";

                lock (thisLock)
                {
                    if (!folder.Exists) folder.Create();

#if MONO
                    string sFileName = LPS.Util.AppPath() + "/Log/" + progName + DateTime.Now.ToString("yyyyMMdd") + ".log";
#else
                    string sFileName = Zero5.IO.Util.LocalPathFile("Log", progName + DateTime.Now.ToString("yyyyMMdd") + ".log");
#endif

                    try
                    {
                        if (System.IO.File.Exists(sFileName))
                        {
                            FileInfo fileInfo = new FileInfo(sFileName);

                            double dimensioneMB = fileInfo.Length / 1024 / 1024;

                            if (dimensioneMB >= 200)
                            {
                                int i = 1;
                                string nuovoNomeFile = sFileName.Replace(".log", "") + "." + i.ToString("000") + ".log";
                                while (System.IO.File.Exists(nuovoNomeFile) || System.IO.File.Exists(nuovoNomeFile + ".gz"))
                                {
                                    i++;
                                    nuovoNomeFile = nuovoNomeFile = sFileName.Replace(".log", "") + "." + i.ToString("000") + ".log";
                                }

                                System.IO.File.Move(sFileName, nuovoNomeFile);
                                sFileName = nuovoNomeFile;
                                nomeFileDaComprimere = sFileName;
                            }

                            fileInfo = null;
                        }
                    }
                    catch (Exception ex) { }

                    try
                    {
                        System.IO.File.AppendAllText(sFileName, sMessage + "\r\n");
                    }
                    catch
                    {
                        try
                        {
                            System.IO.File.AppendAllText(sFileName, sMessage + "\r\n");
                        }
                        catch
                        {
                            try
                            {
                                System.IO.File.AppendAllText(sFileName, sMessage + "\r\n");
                            }
                            catch (Exception ex)
                            {
#if MONO
                                System.IO.File.AppendAllText(LPS.Util.AppPath() + "/Log/LogError.log", sMessage + "\r\n" + ex.Message + "\r\n");
#else
                                System.IO.File.AppendAllText(Zero5.IO.Util.LocalPathFile("Log", "LogError.log"), sMessage + "\r\n" + ex.Message + "\r\n");
#endif
                            }
                        }
                    }

                    //StreamWriter sw;
                    //if (File.Exists(sFileName))
                    //    sw = File.AppendText(sFileName);
                    //else
                    //    sw = new System.IO.StreamWriter(sFileName);

                    //sw.WriteLine(sMessage);
                    //sw.Flush();
                    //sw.Close();
                }

                if (nomeFileDaComprimere != "")
                {
                    System.Threading.Thread threadCompressioneFile = new System.Threading.Thread(new System.Threading.ParameterizedThreadStart(ComprimiFile));
                    threadCompressioneFile.Start(nomeFileDaComprimere);
                }

                VerificaEseguiPulizia(progName);
            }
            catch (Exception ex)
            {
                try
                {
#if MONO
                    System.IO.File.AppendAllText(LPS.Util.AppPath() + "/Log/LogError.log", sMessage + "\r\n" + ex.Message + "\r\n");
#else
                    System.IO.File.AppendAllText(Zero5.IO.Util.LocalPathFile("Log", "LogError.log"), sMessage + "\r\n" + ex.Message + "\r\n");
#endif
                }
                catch { }
            }
        }
#endif
    }
}
// file ...\Util\PDFConverter.cs

namespace Zero5.Util
{
#if GHOSTSCRIPT
    class PDFConverter
    {
        public static Dictionary<int, byte[]> ConvertToPNG(string sFileName, bool autorotate)
        {
            using (System.IO.FileStream file = System.IO.File.OpenRead(sFileName)) // in file
            {
                byte[] bytes = new byte[file.Length];
                file.Read(bytes, 0, bytes.Length);

                return ConvertToPNG(bytes, autorotate);
            }
        }

        private static StringBuilder lockObj = new StringBuilder();

        public int GetPageCount(byte[] pdfData)
        {
            Ghostscript.NET.GhostscriptVersionInfo _lastInstalledVersion = null;
            Ghostscript.NET.Rasterizer.GhostscriptRasterizer _rasterizer = null;

            _lastInstalledVersion =
                Ghostscript.NET.GhostscriptVersionInfo.GetLastInstalledVersion(
                        Ghostscript.NET.GhostscriptLicense.GPL | Ghostscript.NET.GhostscriptLicense.AFPL,
                        Ghostscript.NET.GhostscriptLicense.GPL);

            _rasterizer = new Ghostscript.NET.Rasterizer.GhostscriptRasterizer();

            System.IO.MemoryStream ioPdf = new System.IO.MemoryStream(pdfData);
            _rasterizer.Open(ioPdf, _lastInstalledVersion, false);
            return _rasterizer.PageCount;

        }

        public static Dictionary<int, byte[]> ConvertToPNG(byte[] pdfData, bool autorotate)
        {
            return ConvertToPNG(pdfData, autorotate, 0, 0);
        }
        public static Dictionary<int, byte[]> ConvertToPNG(byte[] pdfData, bool autorotate, int pageStart, int pageTo)
        {
            Dictionary<int, byte[]> immagini = new Dictionary<int, byte[]>();

            lock (lockObj)
            {
                Ghostscript.NET.GhostscriptVersionInfo _lastInstalledVersion = null;
                Ghostscript.NET.Rasterizer.GhostscriptRasterizer _rasterizer = null;

                GC.Collect();

                int desired_x_dpi = 300;
                int desired_y_dpi = 300;

                _lastInstalledVersion =
                    Ghostscript.NET.GhostscriptVersionInfo.GetLastInstalledVersion(
                            Ghostscript.NET.GhostscriptLicense.GPL | Ghostscript.NET.GhostscriptLicense.AFPL,
                            Ghostscript.NET.GhostscriptLicense.GPL);

                _rasterizer = new Ghostscript.NET.Rasterizer.GhostscriptRasterizer();

                System.IO.MemoryStream ioPdf = new System.IO.MemoryStream(pdfData);
                _rasterizer.Open(ioPdf, _lastInstalledVersion, false);

                ioPdf.Position = 0;
                //iTextSharp.text.pdf.PdfReader reader = null;
                //if(autorotate)
                //    reader = new iTextSharp.text.pdf.PdfReader(ioPdf);

                int start = 1;
                if (pageStart != 0)
                    start = pageStart;
                int end = _rasterizer.PageCount;
                if (pageTo > 0 && pageTo < _rasterizer.PageCount)
                    end = pageTo;

                for (int pageNumber = 1; pageNumber < (end + 1); pageNumber++)
                {
                    System.Threading.Thread.Sleep(10);
                    System.Drawing.Image img = _rasterizer.GetPage(desired_x_dpi, desired_y_dpi, pageNumber);
                    img = img.Clone() as System.Drawing.Image;

                    if (autorotate)
                        if (img.Height < img.Width)
                            img.RotateFlip(RotateFlipType.Rotate90FlipNone);

                    System.IO.MemoryStream ms = new System.IO.MemoryStream();
                    img.Save(ms, System.Drawing.Imaging.ImageFormat.Png);
                    img.Dispose();
                    if (ms.Length > 15000000)
                    {
                        desired_x_dpi = (int)(0.8 * desired_x_dpi);
                        desired_y_dpi = (int)(0.8 * desired_y_dpi);
                        Zero5.Util.Log.WriteLog("degrade dpi to " + desired_x_dpi);
                    }
                    immagini.Add(pageNumber, ms.ToArray());
                }
                _rasterizer.Close();
                ioPdf.Close();
                ioPdf.Dispose();
            }
            return immagini;
        }

    }
#endif
}
// file ...\Util\Printer.cs
#if !MONO && !MOBILE && !CORE

namespace Zero5.Util
{
    public class Printer
    {
        // Structure and API declarions:
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public class DOCINFOA
        {
            [MarshalAs(UnmanagedType.LPStr)]
            public string pDocName;
            [MarshalAs(UnmanagedType.LPStr)]
            public string pOutputFile;
            [MarshalAs(UnmanagedType.LPStr)]
            public string pDataType;
        }
        [DllImport("winspool.Drv", EntryPoint = "OpenPrinterA", SetLastError = true, CharSet = CharSet.Ansi, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)]
        public static extern bool OpenPrinter([MarshalAs(UnmanagedType.LPStr)] string szPrinter, out IntPtr hPrinter, IntPtr pd);

        [DllImport("winspool.Drv", EntryPoint = "ClosePrinter", SetLastError = true, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)]
        public static extern bool ClosePrinter(IntPtr hPrinter);

        [DllImport("winspool.Drv", EntryPoint = "StartDocPrinterA", SetLastError = true, CharSet = CharSet.Ansi, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)]
        public static extern bool StartDocPrinter(IntPtr hPrinter, Int32 level, [In, MarshalAs(UnmanagedType.LPStruct)] DOCINFOA di);

        [DllImport("winspool.Drv", EntryPoint = "EndDocPrinter", SetLastError = true, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)]
        public static extern bool EndDocPrinter(IntPtr hPrinter);

        [DllImport("winspool.Drv", EntryPoint = "StartPagePrinter", SetLastError = true, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)]
        public static extern bool StartPagePrinter(IntPtr hPrinter);

        [DllImport("winspool.Drv", EntryPoint = "EndPagePrinter", SetLastError = true, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)]
        public static extern bool EndPagePrinter(IntPtr hPrinter);

        [DllImport("winspool.Drv", EntryPoint = "WritePrinter", SetLastError = true, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)]
        public static extern bool WritePrinter(IntPtr hPrinter, byte[] pBytes, Int32 dwCount, out Int32 dwWritten);

        // SendBytesToPrinter()
        // When the function is given a printer name and an unmanaged array
        // of bytes, the function sends those bytes to the print queue.
        // Returns true on success, false on failure.
        public static bool SendBytesToPrinter(string docName, string szPrinterName, byte[] pBytes, Int32 dwCount)
        {
            Int32 dwError = 0, dwWritten = 0;
            IntPtr hPrinter = new IntPtr(0);
            DOCINFOA di = new DOCINFOA();
            bool bSuccess = false; // Assume failure unless you specifically succeed.

            di.pDocName = docName;
            di.pDataType = "RAW";

            // Open the printer.
            if (OpenPrinter(szPrinterName.Normalize(), out hPrinter, IntPtr.Zero))
            {
                // Start a document.
                if (StartDocPrinter(hPrinter, 1, di))
                {
                    // Start a page.
                    if (StartPagePrinter(hPrinter))
                    {
                        // Write your bytes.
                        bSuccess = WritePrinter(hPrinter, pBytes, dwCount, out dwWritten);
                        EndPagePrinter(hPrinter);
                    }
                    EndDocPrinter(hPrinter);
                }
                ClosePrinter(hPrinter);
            }
            // If you did not succeed, GetLastError may give more information
            // about why not.
            if (bSuccess == false)
            {
                dwError = Marshal.GetLastWin32Error();
            }
            return bSuccess;
        }

    }
}
#endif
// file ...\Util\Report.cs

namespace Zero5.Util
{
    public class Report
    {
        public enum eParametriDS
        {
            NomeModelloReportStandard = 0,
            IDModelloReportPersonalizzato = 2,
        }

        public static byte[] PrintDataToByteArray(DataSet dataset, int idModelloReportPersonalizzato)
        {
            return PrintDataToByteArray(new List<DataSet> { dataset },"", idModelloReportPersonalizzato);
        }

        public static byte[] PrintDataToByteArray(DataSet[] lDataset, int idModelloReportPersonalizzato)
        {
            return PrintDataToByteArray(new List<DataSet>(lDataset),  "", idModelloReportPersonalizzato);
        }

        public static byte[] PrintDataToByteArray(List<DataSet> lDataset,  int idModelloReportPersonalizzato)
        {
            return PrintDataToByteArray(lDataset, "", idModelloReportPersonalizzato);
        }

        public static byte[] PrintDataToByteArray(DataSet dataset, string NomeModelloReportStandard)
        {
            return PrintDataToByteArray(new List<DataSet> { dataset },NomeModelloReportStandard, 0);
        }

        public static byte[] PrintDataToByteArray(DataSet[] lDataset,string NomeModelloReportStandard)
        {
            return PrintDataToByteArray(new List<DataSet>(lDataset), NomeModelloReportStandard, 0);
        }

        public static byte[] PrintDataToByteArray(List<DataSet> lDataset, string NomeModelloReportStandard)
        {
            return PrintDataToByteArray(lDataset,  NomeModelloReportStandard, 0);
        }

        private static byte[] PrintDataToByteArray(List<DataSet> lDataset, string NomeModelloReportStandard, int idModelloReportPersonalizzato)
        {
            DataSet resultDataset = new DataSet();

            //Table 0: eParametriDS, value
            //Table 1: dataset_name, dataset_byte[]

            DataTable dt = new DataTable();
            dt.Columns.Add("parameter", typeof(string));
            dt.Columns.Add("string_value",typeof(string));
            dt.Columns.Add("byte_value", typeof(byte[]));

            DataRow row = dt.NewRow();
            row[0] = eParametriDS.IDModelloReportPersonalizzato.ToString();
            row[1] = idModelloReportPersonalizzato.ToString();
            dt.Rows.Add(row);

            row = dt.NewRow();
            row[0] = eParametriDS.NomeModelloReportStandard.ToString();
            row[1] = NomeModelloReportStandard;
            dt.Rows.Add(row);

            resultDataset.Tables.Add(dt);

            Dictionary<string, int> dicNames = new Dictionary<string, int>();
            foreach (DataSet ds in lDataset)
            {
                row = dt.NewRow();
                if (dicNames.ContainsKey(ds.Tables[0].TableName))
                {
                    row[0] = "_DS_" + ds.Tables[0].TableName + (dicNames[ds.Tables[0].TableName] + 1);
                    dicNames[ds.Tables[0].TableName]++;
                }
                else
                {
                    row[0] = "_DS_" + ds.Tables[0].TableName;
                    dicNames.Add(ds.Tables[0].TableName, 1);
                }
                row[2] = Zero5.Util.BinaryConverters.DataSetToBytes(ds);
                dt.Rows.Add(row);
            }

            return Zero5.Util.BinaryConverters.DataSetToBytes(resultDataset);
        }
    }
}
// file ...\Util\StringConverters.cs

namespace Zero5.Util
{
    public class StringConverters
    {
        public static string IntListToString(List<int> list)
        {
            return IntListToString(list, ";");
        }

        public static string IntListToString(List<int> list, string separator)
        {
#if !MOBILE
            return String.Join(separator, list);
#else
            string[] strings = new string[list.Count];
            int iPos = 0;
            foreach (int val in list)
            {
                strings[iPos++] = val.ToString();
            }
            return String.Join(separator, strings);
#endif
        }

        public static List<int> StringToIntList(string source)
        {
            return StringToIntList(source, ';');
        }

        public static List<int> StringToIntList(string source, char separator)
        {
            List<int> result = new List<int>();
            string[] tokenized = source.Split(new char[] { separator });

            int parsed = 0;
            foreach (string token in tokenized)
                if (token.Trim().Length > 0)
                    if (intTryParse.TryParse(token, out parsed))
                        result.Add(parsed);

            return result;
        }


        public static string EncodeIndirizzoTag(int dbNumber, int indirizzo, int bit, int offset, int lunghezza)
        {
            return EncodeIndirizzoTag(dbNumber, indirizzo.ToString(), bit, offset, lunghezza);
        }

        public static string EncodeIndirizzoTag(int dbNumber, string indirizzo, int bit, int offset, int lunghezza)
        {
            //[DBNumber-]indirizzo[.bit][:offset]:lunghezza

            string indirizzoTag = "";
            if (dbNumber >= 0)
            {
                indirizzoTag += dbNumber + "-";
            }

            if (indirizzo != "")
            {
                indirizzoTag += indirizzo;
            }
            else
            {
                throw new Exception("Valorizzare Indirizzo");
            }

            if (bit >= 0)
            {
                indirizzoTag += "." + bit;
            }

            if (offset >= 0)
            {
                indirizzoTag += ":" + offset;
            }

            if (lunghezza >= 0)
            {
                indirizzoTag += ":" + lunghezza;
            }

            return indirizzoTag;
        }

        public static void DecodeIndirizzoTag(string indirizzoTag, out int dBNumber, out int indirizzo, out int bit, out int offset, out int lunghezza)
        {
            string tag = "";
            DecodeIndirizzoTag(indirizzoTag, out dBNumber, out tag, out bit, out offset, out lunghezza);
            int.TryParse(tag, out indirizzo);
        }

        public static void DecodeIndirizzoTag(string indirizzoTag, out int dBNumber, out string tag, out int bit, out int offset, out int lunghezza)
        {
            //[DBNumber-]indirizzo[.bit][:offset]:lunghezza

            dBNumber = 0;
            tag = "";
            bit = 0;
            offset = 0;
            lunghezza = 0;

            bool DBNumberPresente = indirizzoTag.Contains('-');
            bool BitPresente = indirizzoTag.Contains('.');
            bool OffsetPresente = false;

            if (indirizzoTag.Contains(':'))
            {
                OffsetPresente = indirizzoTag.IndexOf(':') != indirizzoTag.LastIndexOf(':');
            }

            if (!DBNumberPresente && !BitPresente)
            {
                if (indirizzoTag.Contains(':'))
                {
                    tag = indirizzoTag.Split(':')[0];
                }
            }

            if (DBNumberPresente)
            {
                int.TryParse(indirizzoTag.Split('-')[0], out dBNumber);

                if (!BitPresente)
                {
                    string indirizzoTemp = indirizzoTag.Split('-')[1];
                    if (indirizzoTag.Contains(':'))
                    {
                        tag = indirizzoTemp.Split(':')[0];
                    }
                }
            }

            if (DBNumberPresente && BitPresente)
            {
                string indirizzoTemp = indirizzoTag.Split('-')[1];
                tag = indirizzoTemp.Split('.')[0];
            }

            if (BitPresente)
            {
                if (!DBNumberPresente)
                {
                    tag = indirizzoTag.Split('.')[0];
                }
                string bitTemp = indirizzoTag.Split('.')[1];

                if (bitTemp.Contains(':'))
                {
                    int.TryParse(bitTemp.Split(':')[0], out bit);
                }
            }

            if (indirizzoTag.Contains(':'))
            {
                if (OffsetPresente)
                {
                    int.TryParse(indirizzoTag.Split(':')[1], out offset);
                    int.TryParse(indirizzoTag.Split(':')[2], out lunghezza);
                }
                else
                {
                    int.TryParse(indirizzoTag.Split(':')[1], out lunghezza);
                }
            }
        }
        public static string EncodeIndirizzoTag_21_Heidenhain(int modalitaAccesso, string percorso)
        {
            return modalitaAccesso.ToString() + "|" + percorso;
        }

        public static void DecodeIndirizzoTag_21_Heidenhain(string indirizzoTag, out int modalitaAccesso, out string percorso)
        {
            modalitaAccesso = 0;
            percorso = "";

            if (indirizzoTag.Contains("|"))
            {
                string[] valori = indirizzoTag.Split('|');
                modalitaAccesso = int.Parse(valori[0]);
                percorso = valori[1];
            }
        }

#if !MOBILE
        public static Dictionary<int, string> CreateAZDictionary(int size, bool zeroBased)
        {
            Dictionary<int, string> result = new Dictionary<int, string>();
            if (size > 26 * 26)
                size = 26 * 26;

            for (int i = 0; i < size; i++)
            {
                string composed = "";
                if (i > 25)
                    composed += (char)(Math.Truncate((decimal)(i / 26)) + 65 - 1);
                composed += (char)((i % 26) + 65);

                if (zeroBased)
                    result.Add(i, composed);
                else
                    result.Add(i + 1, composed);
            }
            return result;
        }
#endif

        public static UInt16[] StringTo_UInt16Array_LE(string data, int arraySize)
        {
            if (arraySize == 0)
                arraySize = (int)Math.Ceiling(((double)data.Length) / 2);

            string sData = data.PadRight(arraySize * 2, ' ');

            UInt16[] result = new UInt16[arraySize];

            for (int i = 0; i < arraySize; i++)
            {

                string token = sData.Substring(i * 2, 2);
                byte[] bytes = System.Text.Encoding.ASCII.GetBytes(token);
                UInt16 uintEquivalent = System.BitConverter.ToUInt16(bytes, 0);
                result[i] = uintEquivalent;
            }

            return result;
        }

        public static string UInt16ArraytoString_LE(UInt16[] data)
        {

            System.Text.StringBuilder sb = new System.Text.StringBuilder();

            for (int i = 0; i < data.Length; i++)
            {
                UInt16 arrayCell = data[i];
                byte[] bytes = System.BitConverter.GetBytes(arrayCell);
                string token = System.Text.Encoding.ASCII.GetString(bytes);

                sb.Append(token);
            }

            return sb.ToString();
        }
    }
}
// file ...\Util\StringTools.cs

namespace Zero5.Util
{
    public class StringTools
    {

        public static StringBuilder SplitTextOnCharCount(string t, int w)
        {
            StringBuilder rows = new StringBuilder();
            string[] words;
            string temp;
            int s;

            words = t.Split(' ');
            temp = "";

            for (int i = 0; i < words.Length; i++)
            {
                s = (temp + " " + words[i]).Trim().Length;
                if (s > w)
                {
                    if (temp.Trim().Length > 0)
                    {
                        rows.Append(temp.Trim());
                        rows.Append('\n');
                    }
                    temp = words[i];
                }
                else
                {
                    temp += " " + words[i];
                }
            }
            if (temp.Trim().Length > 0)
            {
                rows.Append(temp.Trim());
            }
            return rows;
        }

        public static string FormatMinute(double minute)
        {
            return FormatMinute(minute, false);
        }

        public static string FormatMinute(double minute, bool showMilliseconds)
        {
            TimeSpan ts = new TimeSpan();

            if (showMilliseconds)
                ts = new TimeSpan(0, 0, 0, 0, (int)(minute * 60 * 1000));
            else
                ts = new TimeSpan(0, 0, (int)(minute * 60));

            string result = "";

            if (minute >= 0)
            {
                result = Math.Truncate(ts.TotalHours).ToString() + ":" + ts.Minutes.ToString("00") + ":" + ts.Seconds.ToString("00");
                if (showMilliseconds) result += "." + ts.Milliseconds.ToString("000");
            }
            else
            {
                result = "- " + Math.Truncate(-ts.TotalHours).ToString() + ":" + (-ts.Minutes).ToString("00") + ":" + (-ts.Seconds).ToString("00");
                if (showMilliseconds) result += "." + (-ts.Milliseconds).ToString("000");
            }

            return result;
        }

        public static string FormatHoursMinuteRound(double minute, int minuteRound)
        {
            TimeSpan ts = new TimeSpan(0, 0, (int)(minute * 60));
            if (minuteRound > 0)
            {
                int totalMinutes = (int)ts.TotalMinutes;
                totalMinutes = totalMinutes + (minuteRound - (totalMinutes % minuteRound));
                ts = new TimeSpan(0, 0, (int)(totalMinutes * 60));
            }
            return ((int)(ts.TotalHours)).ToString() + ":" + ts.Minutes.ToString("00");
        }

        public static string WithOutSpecialCharacters(string text)
        {
            string result = "";
            for (int i = 0; i < text.Length; i++)
            {
                if (char.IsLetterOrDigit(text[i])) result += text[i].ToString();
            }
            return result;
        }

        public static string GetCognomeOperatore(string nome)
        {
            string[] componentiNome = nome.Split(' ');

            if (componentiNome.Length > 2)
            {
                if (componentiNome[0].Length < 4)
                {
                    return componentiNome[0] + " " + componentiNome[1];
                }
                else
                    return componentiNome[0];

            }
            else
                return componentiNome[0];
        }
    }
}
// file ...\Util\TolleranzaISO.cs

namespace Zero5.Util
{
    class TolleranzaISO
    {
        private Dictionary<int, object[]> tabellaGradi = new Dictionary<int, object[]>();
        private Dictionary<int, object[]> tabellaDeviazioni = new Dictionary<int, object[]>();
        private Dictionary<int, object[]> tabellaDelta = new Dictionary<int, object[]>();
        private Dictionary<string, int> lookupDeviazioniLettera = new Dictionary<string, int>();

        public TolleranzaISO()
        {
            PreparaTabellaGradi();
            PreparaTabellaDeviazioni();
            preparaTabellaDelta();
            PreparaLookUp();
        }

        //uyg

        private void PreparaTabellaGradi()
        {
            tabellaGradi.Add(3, new object[] { 0.8, 1.2, 2, 3, 4, 6, 10, 14, 25, 40, 60, 100, 140, 250, 400, 600, 1000, 1400 });
            tabellaGradi.Add(6, new object[] { 1, 1.5, 2.5, 4, 5, 8, 12, 18, 30, 48, 75, 120, 180, 300, 480, 750, 1200, 1800 });
            tabellaGradi.Add(10, new object[] { 1, 1.5, 2.5, 4, 6, 9, 15, 22, 36, 58, 90, 150, 220, 360, 580, 900, 1500, 2200 });
            tabellaGradi.Add(18, new object[] { 1.2, 2, 3, 5, 8, 11, 18, 27, 43, 70, 110, 180, 270, 430, 700, 1100, 1800, 2700 });
            tabellaGradi.Add(30, new object[] { 1.5, 2.5, 4, 6, 9, 13, 21, 33, 52, 84, 130, 210, 330, 520, 840, 1300, 2100, 3300 });
            tabellaGradi.Add(50, new object[] { 1.5, 2.5, 4, 7, 11, 16, 25, 39, 62, 100, 160, 250, 390, 620, 1000, 1600, 2500, 3900 });
            tabellaGradi.Add(80, new object[] { 2, 3, 5, 8, 13, 19, 30, 46, 74, 120, 190, 300, 460, 740, 1200, 1900, 3000, 4600 });
            tabellaGradi.Add(120, new object[] { 2.5, 4, 6, 10, 15, 22, 35, 54, 87, 140, 220, 350, 540, 870, 1400, 2200, 3500, 5400 });
            tabellaGradi.Add(180, new object[] { 3.5, 5, 8, 12, 18, 25, 40, 63, 100, 160, 250, 400, 630, 1000, 1600, 2500, 4000, 6300 });
            tabellaGradi.Add(250, new object[] { 4.5, 7, 10, 14, 20, 29, 46, 72, 115, 185, 290, 460, 720, 1150, 1850, 2900, 4600, 7200 });
            tabellaGradi.Add(315, new object[] { 6, 8, 12, 16, 23, 32, 52, 81, 130, 210, 320, 520, 810, 1300, 2100, 3200, 5200, 8100 });
            tabellaGradi.Add(400, new object[] { 7, 9, 13, 18, 25, 36, 57, 89, 140, 230, 360, 570, 890, 1400, 2300, 3600, 5700, 8900 });
            tabellaGradi.Add(500, new object[] { 8, 10, 15, 20, 27, 40, 63, 97, 156, 250, 400, 630, 970, 1550, 2500, 4000, 6300, 9700 });
            tabellaGradi.Add(630, new object[] { 9, 11, 16, 22, 32, 44, 70, 110, 175, 280, 440, 700, 1100, 1750, 2800, 4400, 7000, 11000 });
            tabellaGradi.Add(800, new object[] { 10, 13, 18, 25, 36, 50, 80, 125, 200, 320, 500, 800, 1250, 2000, 3200, 5000, 8000, 12500 });
            tabellaGradi.Add(1000, new object[] { 11, 15, 21, 28, 40, 56, 90, 140, 230, 360, 560, 900, 1400, 2300, 3600, 5600, 9000, 14000 });
            tabellaGradi.Add(1250, new object[] { 13, 18, 24, 33, 47, 66, 105, 165, 260, 420, 660, 1050, 1650, 2600, 4200, 6600, 10500, 16500 });
            tabellaGradi.Add(1600, new object[] { 15, 21, 29, 39, 55, 78, 125, 195, 310, 500, 780, 1250, 1950, 3100, 5000, 7800, 12500, 19500 });
            tabellaGradi.Add(2000, new object[] { 18, 25, 35, 46, 65, 92, 150, 230, 370, 600, 920, 1500, 2300, 3700, 6000, 9200, 15000, 23000 });
            tabellaGradi.Add(2500, new object[] { 22, 30, 41, 55, 78, 110, 175, 280, 440, 700, 1000, 1750, 2800, 4400, 7000, 11000, 17500, 28000 });
            tabellaGradi.Add(3150, new object[] { 26, 36, 50, 68, 96, 135, 210, 330, 540, 860, 1350, 2100, 3300, 5400, 8600, 13500, 21000, 33000 });
        }

        private void PreparaTabellaDeviazioni()
        {
            tabellaDeviazioni.Add(3, new object[] { -270, -140, -60, -34, -20, -14, -10, -6, -4, -2, 0, 999999999999, -2, -4, -6, 0, 0, 2, 4, 6, 10, 14, null, 18, null, 20, null, 26, 32, 40, 60, null, null, 60, 34, 20, 14, 10, 6, 4, 2, 0, 225, 2, 4, 6, 0, 0, -2, -2, null, null, -6, -10, -14, null, -18, null, -20, 0, -26, -32, -40, -60 });
            tabellaDeviazioni.Add(6, new object[] { -270, -140, -70, -46, -30, -20, -14, -10, -6, -4, 0, 999999999999, -2, -4, null, 1, 0, 4, 8, 12, 15, 19, null, 23, null, 28, null, 35, 42, 50, 80, 270, 140, 70, 46, 30, 20, 14, 10, 6, 4, 0, 225, 5, 6, 10, -1, null, -4, -4, -8, 0, -12, -15, -19, null, -23, null, -28, 0, -35, -42, -50, -80 });
            tabellaDeviazioni.Add(10, new object[] { -280, -150, -80, -56, -40, -25, -18, -13, -8, -5, 0, 999999999999, -2, -5, null, 1, 0, 6, 10, 15, 19, 23, null, 28, null, 34, null, 42, 52, 67, 97, 280, 150, 80, 56, 40, 25, 18, 13, 8, 5, 0, 225, 5, 8, 12, -1, null, -6, -6, -10, 0, -15, -19, -23, null, -28, null, -34, 0, -42, -52, -67, -97 });
            tabellaDeviazioni.Add(14, new object[] { -290, -150, -95, null, -50, -32, null, -16, null, -6, 0, 999999999999, -3, -6, null, 1, 0, 7, 12, 18, 23, 28, null, 33, null, 40, null, 50, 64, 90, 130, 290, 150, 95, null, 50, 32, null, 16, null, 6, 0, 225, 6, 10, 15, -1, null, -7, -7, -12, 0, -18, -23, -28, null, -33, null, -40, 0, -50, -64, -90, -130 });
            tabellaDeviazioni.Add(18, new object[] { -290, -150, -95, null, -50, -32, null, -16, null, -6, 0, 999999999999, -3, -6, null, 1, 0, 7, 12, 18, 23, 28, null, 33, 39, 45, null, 60, 77, 108, 150, 290, 150, 95, null, 50, 32, null, 16, null, 6, 0, 225, 6, 10, 15, -1, null, -7, -7, -12, 0, -18, -23, -28, null, -33, -39, -45, 0, -60, -77, -108, -150 });
            tabellaDeviazioni.Add(24, new object[] { -300, -160, -110, null, -65, -40, null, -20, null, -7, 0, 999999999999, -4, -8, null, 2, 0, 8, 15, 22, 28, 35, null, 41, 47, 54, 63, 73, 98, 136, 188, 300, 160, 110, null, 65, 40, null, 20, null, 7, 0, 225, 8, 12, 20, -2, null, -8, -8, -15, 0, -22, -28, -35, null, -41, -47, -54, -63, -73, -98, -136, -188 });
            tabellaDeviazioni.Add(30, new object[] { -300, -160, -110, null, -65, -40, null, -20, null, -7, 0, 999999999999, -4, -8, null, 2, 0, 8, 15, 22, 28, 35, 41, 48, 55, 64, 75, 88, 118, 160, 218, 300, 160, 110, null, 65, 40, null, 20, null, 7, 0, 225, 8, 12, 20, -2, null, -8, -8, -15, 0, -22, -28, -35, -41, -48, -55, -64, -75, -88, -118, -160, -218 });
            tabellaDeviazioni.Add(40, new object[] { -310, -170, -120, null, -80, -50, null, -25, null, -9, 0, 999999999999, -5, -10, null, 2, 0, 9, 17, 26, 34, 43, 48, 60, 68, 80, 94, 112, 148, 200, 274, 310, 170, 120, null, 80, 50, null, 25, null, 9, 0, 225, 10, 14, 24, -2, null, -9, -9, -17, 0, -26, -34, -43, -48, -60, -68, -80, -94, -112, -148, -200, -274 });
            tabellaDeviazioni.Add(50, new object[] { -320, -180, -130, null, -80, -50, null, -25, null, -9, 0, 999999999999, -5, -10, null, 2, 0, 9, 17, 26, 34, 43, 54, 70, 81, 97, 114, 136, 180, 242, 325, 320, 180, 130, null, 80, 50, null, 25, null, 9, 0, 225, 10, 14, 24, -2, null, -9, -9, -17, 0, -26, -34, -43, -54, -70, -81, -97, -114, -136, -180, -242, -325 });
            tabellaDeviazioni.Add(65, new object[] { -340, -190, -140, null, -100, -60, null, -30, null, -10, 0, 999999999999, -7, -12, null, 2, 0, 11, 20, 32, 41, 53, 66, 87, 102, 122, 144, 172, 226, 300, 405, 340, 190, 140, null, 100, 60, null, 30, null, 10, 0, 225, 13, 18, 28, -2, null, -11, -11, -20, 0, -32, -41, -53, -66, -87, -102, -122, -144, -172, -226, -300, -405 });
            tabellaDeviazioni.Add(80, new object[] { -360, -200, -150, null, -100, -60, null, -30, null, -10, 0, 999999999999, -7, -12, null, 2, 0, 11, 20, 32, 43, 59, 75, 102, 120, 146, 174, 210, 274, 360, 480, 360, 200, 150, null, 100, 60, null, 30, null, 10, 0, 225, 13, 18, 28, -2, null, -11, -11, -20, 0, -32, -43, -59, -75, -102, -120, -146, -174, -210, -274, -360, -490 });
            tabellaDeviazioni.Add(100, new object[] { -380, -220, -170, null, -120, -72, null, -36, null, -12, 0, 999999999999, -9, -15, null, 3, 0, 13, 23, 37, 51, 71, 91, 124, 146, 178, 214, 258, 335, 445, 585, 380, 220, 170, null, 120, 72, null, 36, null, 12, 0, 225, 16, 22, 34, -3, null, -13, -13, -23, 0, -37, -51, -71, -91, -124, -146, -178, -214, -258, -335, -445, -585 });
            tabellaDeviazioni.Add(120, new object[] { -410, -240, -180, null, -120, -72, null, -36, null, -12, 0, 999999999999, -9, -15, null, 3, 0, 13, 23, 37, 54, 79, 104, 144, 172, 210, 254, 310, 400, 525, 690, 410, 240, 180, null, 120, 72, null, 36, null, 12, 0, 225, 16, 22, 34, -3, null, -13, -13, -23, 0, -37, -54, -79, -104, -144, -172, -210, -254, -310, -400, -525, -690 });
            tabellaDeviazioni.Add(140, new object[] { -460, -260, -200, null, -145, -85, null, -43, null, -14, 0, 999999999999, -11, -18, null, 3, 0, 15, 27, 43, 63, 92, 122, 170, 202, 248, 300, 365, 470, 620, 800, 460, 260, 200, null, 145, 85, null, 43, null, 14, 0, 225, 18, 26, 41, -3, null, -15, -15, -27, 0, -43, -63, -92, -122, -170, -202, -248, -300, -365, -470, -620, -800 });
            tabellaDeviazioni.Add(160, new object[] { -520, -280, -210, null, -145, -85, null, -43, null, -14, 0, 999999999999, -11, -18, null, 3, 0, 15, 27, 43, 65, 100, 134, 190, 228, 280, 340, 415, 535, 700, 900, 520, 280, 210, null, 145, 85, null, 43, null, 14, 0, 225, 18, 26, 41, -3, null, -15, -15, -27, 0, -43, -65, -100, -134, -190, -228, -280, -340, -415, -535, -700, -900 });
            tabellaDeviazioni.Add(180, new object[] { -580, -310, -230, null, -145, -85, null, -43, null, -14, 0, 999999999999, -11, -18, null, 3, 0, 15, 27, 43, 68, 108, 146, 210, 252, 310, 380, 465, 600, 780, 1000, 580, 310, 230, null, 145, 85, null, 43, null, 14, 0, 225, 18, 26, 41, -3, null, -15, -15, -27, 0, -43, -68, -108, -146, -210, -252, -310, -380, -465, -600, -780, -1000 });
            tabellaDeviazioni.Add(200, new object[] { -660, -340, -240, null, -170, -100, null, -50, null, -15, 0, 999999999999, -13, -21, null, 4, 0, 17, 31, 50, 77, 122, 166, 236, 284, 350, 425, 520, 670, 880, 1150, 660, 340, 240, null, 170, 100, null, 50, null, 15, 0, 225, 22, 30, 47, -4, null, -17, -17, -31, 0, -50, -77, -122, -166, -236, -284, -340, -425, -520, -670, -880, -1150 });
            tabellaDeviazioni.Add(225, new object[] { -740, -380, -260, null, -170, -100, null, -50, null, -15, 0, 999999999999, -13, -21, null, 4, 0, 17, 31, 50, 80, 130, 180, 258, 310, 385, 470, 575, 740, 960, 1250, 740, 380, 260, null, 170, 100, null, 50, null, 15, 0, 225, 22, 30, 47, -4, null, -17, -17, -31, 0, -50, -80, -130, -180, -258, -310, -385, -470, -575, -740, -960, -1250 });
            tabellaDeviazioni.Add(250, new object[] { -820, -420, -280, null, -170, -100, null, -50, null, -15, 0, 999999999999, -13, -21, null, 4, 0, 17, 31, 50, 84, 140, 196, 284, 340, 425, 520, 640, 820, 1050, 1350, 820, 420, 280, null, 170, 100, null, 50, null, 15, 0, 225, 22, 30, 47, -4, null, -17, -17, -31, 0, -50, -84, -140, -196, -284, -340, -425, -520, -640, -820, -1050, -1350 });
            tabellaDeviazioni.Add(280, new object[] { -920, -480, -300, null, -190, -110, null, -56, null, -17, 0, 999999999999, -16, -26, null, 4, 0, 20, 34, 56, 94, 158, 218, 315, 385, 475, 580, 710, 920, 1200, 1550, 920, 480, 300, null, 190, 110, null, 56, null, 17, 0, 225, 25, 36, 55, -4, null, -20, -20, -34, 0, -56, -94, -158, -218, -315, -385, -475, -580, -710, -920, -1200, -1550 });
            tabellaDeviazioni.Add(315, new object[] { -1050, -540, -330, null, -190, -110, null, -56, null, -17, 0, 999999999999, -16, -26, null, 4, 0, 20, 34, 56, 98, 170, 240, 350, 425, 525, 650, 790, 1000, 1300, 1700, 1050, 540, 330, null, 190, 110, null, 56, null, 17, 0, 225, 25, 36, 55, -4, null, -20, -20, -34, 0, -56, -98, -170, -240, -350, -425, -525, -650, -790, -1000, -1300, -1700 });
            tabellaDeviazioni.Add(355, new object[] { -1200, -600, -360, null, -210, -125, null, -62, null, -18, 0, 999999999999, -18, -28, null, 4, 0, 21, 37, 62, 108, 190, 268, 390, 475, 590, 730, 900, 1150, 1500, 1900, 1200, 600, 360, null, 210, 125, null, 62, null, 18, 0, 225, 29, 39, 60, -4, null, -21, -21, -37, 0, -62, -108, -190, -268, -390, -475, -590, -730, -900, -1150, -1500, -1900 });
            tabellaDeviazioni.Add(400, new object[] { -1350, -680, -400, null, -210, -125, null, -62, null, -18, 0, 999999999999, -18, -28, null, 4, 0, 21, 37, 62, 114, 208, 294, 435, 530, 660, 820, 1000, 1300, 1650, 2100, 1350, 680, 400, null, 210, 125, null, 62, null, 18, 0, 225, 29, 39, 60, -4, null, -21, -21, -37, 0, -62, -114, -208, -294, -435, -530, -660, -820, -1000, -1300, -1650, -2100 });
            tabellaDeviazioni.Add(450, new object[] { -1500, -760, -440, null, -230, -135, null, -68, null, -20, 0, 999999999999, -20, -32, null, 5, 0, 23, 40, 68, 126, 232, 330, 490, 595, 740, 920, 1100, 1450, 1850, 2400, 1500, 760, 440, null, 230, 135, null, 68, null, 20, 0, 225, 33, 43, 66, -5, null, -23, -23, -40, 0, -68, -126, -232, -330, -490, -595, -740, -920, -1100, -1450, -1850, -2400 });
            tabellaDeviazioni.Add(500, new object[] { -1650, -840, -480, null, -230, -135, null, -68, null, -20, 0, 999999999999, -20, -32, null, 5, 0, 23, 40, 68, 132, 252, 360, 540, 660, 820, 1000, 1250, 1600, 2100, 2600, 1650, 840, 480, null, 230, 135, null, 68, null, 20, 0, 225, 33, 43, 66, -5, null, -23, -23, -40, 0, -68, -132, -252, -360, -540, -660, -820, -1000, -1250, -1600, -2100, -2600 });
            tabellaDeviazioni.Add(560, new object[] { null, null, null, null, -260, -145, null, -76, null, -22, 0, 999999999999, null, null, null, 0, 0, 26, 44, 78, 150, 280, 400, 600, null, null, null, null, null, null, null, null, null, null, null, 260, 145, null, 76, null, -22, 0, 225, null, null, null, 0, null, -26, -26, -44, -44, -78, -150, -280, -400, -600, null, null, null, null, null, null, null });
            tabellaDeviazioni.Add(630, new object[] { null, null, null, null, -260, -145, null, -76, null, -22, 0, 999999999999, null, null, null, 0, 0, 26, 44, 78, 155, 310, 450, 660, null, null, null, null, null, null, null, null, null, null, null, 260, 145, null, 76, null, -22, 0, 225, null, null, null, 0, null, -26, -26, -44, -44, -78, -155, -310, -450, -660, null, null, null, null, null, null, null });
            tabellaDeviazioni.Add(710, new object[] { null, null, null, null, -290, -160, null, -80, null, -24, 0, 999999999999, null, null, null, 0, 0, 30, 50, 88, 175, 340, 500, 740, null, null, null, null, null, null, null, null, null, null, null, 290, 160, null, 80, null, -24, 0, 225, null, null, null, 0, null, -30, -30, -50, -50, -88, -175, -340, -500, -740, null, null, null, null, null, null, null });
            tabellaDeviazioni.Add(800, new object[] { null, null, null, null, -290, -160, null, -80, null, -24, 0, 999999999999, null, null, null, 0, 0, 30, 50, 88, 185, 380, 560, 840, null, null, null, null, null, null, null, null, null, null, null, 290, 160, null, 80, null, -24, 0, 225, null, null, null, 0, null, -30, -30, -50, -50, -88, -185, -380, -560, -840, null, null, null, null, null, null, null });
            tabellaDeviazioni.Add(900, new object[] { null, null, null, null, -320, -170, null, -86, null, -26, 0, 999999999999, null, null, null, 0, 0, 34, 56, 100, 210, 430, 620, 940, null, null, null, null, null, null, null, null, null, null, null, 320, 170, null, 86, null, -26, 0, 225, null, null, null, 0, null, -34, -34, -56, -56, -100, -210, -430, -620, -940, null, null, null, null, null, null, null });
            tabellaDeviazioni.Add(1000, new object[] { null, null, null, null, -320, -170, null, -86, null, -26, 0, 999999999999, null, null, null, 0, 0, 34, 56, 100, 220, 470, 680, 1050, null, null, null, null, null, null, null, null, null, null, null, 320, 170, null, 86, null, -26, 0, 225, null, null, null, 0, null, -34, -34, -56, -56, -100, -220, -470, -680, -1050, null, null, null, null, null, null, null });
            tabellaDeviazioni.Add(1120, new object[] { null, null, null, null, -350, -195, null, -98, null, -28, 0, 999999999999, null, null, null, 0, 0, 40, 66, 120, 250, 520, 780, 1150, null, null, null, null, null, null, null, null, null, null, null, 350, 195, null, 98, null, -28, 0, 225, null, null, null, 0, null, -40, -40, -66, -66, -120, -250, -520, -780, -1150, null, null, null, null, null, null, null });
            tabellaDeviazioni.Add(1250, new object[] { null, null, null, null, -350, -195, null, -98, null, -28, 0, 999999999999, null, null, null, 0, 0, 40, 66, 120, 260, 580, 840, 1300, null, null, null, null, null, null, null, null, null, null, null, 350, 195, null, 98, null, -28, 0, 225, null, null, null, 0, null, -40, -40, -66, -66, -120, -260, -580, -840, -1300, null, null, null, null, null, null, null });
            tabellaDeviazioni.Add(1400, new object[] { null, null, null, null, -390, -220, null, -110, null, -30, 0, 999999999999, null, null, null, 0, 0, 48, 78, 140, 300, 640, 960, 1450, null, null, null, null, null, null, null, null, null, null, null, 390, 220, null, 110, null, -30, 0, 225, null, null, null, 0, null, -48, -48, -78, -78, -140, -300, -640, -960, -1450, null, null, null, null, null, null, null });
            tabellaDeviazioni.Add(1600, new object[] { null, null, null, null, -390, -220, null, -110, null, -30, 0, 999999999999, null, null, null, 0, 0, 48, 78, 140, 330, 720, 1050, 1600, null, null, null, null, null, null, null, null, null, null, null, 390, 220, null, 110, null, -30, 0, 225, null, null, null, 0, null, -48, -48, -78, -78, -140, -330, -720, -1050, -1600, null, null, null, null, null, null, null });
            tabellaDeviazioni.Add(1800, new object[] { null, null, null, null, -430, -240, null, -120, null, -32, 0, 999999999999, null, null, null, 0, 0, 58, 92, 170, 370, 820, 1200, 1850, null, null, null, null, null, null, null, null, null, null, null, 430, 240, null, 120, null, -32, 0, 225, null, null, null, 0, null, -58, -58, -92, -92, -170, -370, -820, -1200, -1850, null, null, null, null, null, null, null });
            tabellaDeviazioni.Add(2000, new object[] { null, null, null, null, -430, -240, null, -120, null, -32, 0, 999999999999, null, null, null, 0, 0, 58, 92, 170, 400, 920, 1350, 2000, null, null, null, null, null, null, null, null, null, null, null, 430, 240, null, 120, null, -32, 0, 225, null, null, null, 0, null, -58, -58, -92, -92, -170, -400, -920, -1350, -2000, null, null, null, null, null, null, null });
            tabellaDeviazioni.Add(2240, new object[] { null, null, null, null, -480, -260, null, -130, null, -34, 0, 999999999999, null, null, null, 0, 0, 68, 110, 195, 440, 1000, 1500, 2300, null, null, null, null, null, null, null, null, null, null, null, 480, 260, null, 130, null, -34, 0, 225, null, null, null, 0, null, -68, -68, -110, -110, -195, -440, -1000, -1500, -2300, null, null, null, null, null, null, null });
            tabellaDeviazioni.Add(2500, new object[] { null, null, null, null, -480, -260, null, -130, null, -34, 0, 999999999999, null, null, null, 0, 0, 68, 110, 195, 460, 1100, 1650, 2500, null, null, null, null, null, null, null, null, null, null, null, 480, 260, null, 130, null, -34, 0, 225, null, null, null, 0, null, -68, -68, -110, -110, -195, -460, -1100, -1650, -2500, null, null, null, null, null, null, null });
            tabellaDeviazioni.Add(2800, new object[] { null, null, null, null, -520, -290, null, -145, null, -38, 0, 999999999999, null, null, null, 0, 0, 76, 135, 240, 550, 1250, 1900, 2900, null, null, null, null, null, null, null, null, null, null, null, 520, 290, null, 145, null, -38, 0, 225, null, null, null, 0, null, -76, -76, -135, -135, -240, -550, -1250, -1900, -2900, null, null, null, null, null, null, null });
            tabellaDeviazioni.Add(3150, new object[] { null, null, null, null, -520, -290, null, -145, null, -38, 0, 999999999999, null, null, null, 0, 0, 76, 135, 240, 580, 1400, 2100, 3200, null, null, null, null, null, null, null, null, null, null, null, 520, 290, null, 145, null, -38, 0, 225, null, null, null, 0, null, -76, -76, -135, -135, -240, -580, -1400, -2100, -3200, null, null, null, null, null, null, null });
        }

        private void preparaTabellaDelta()
        {
            //tabellaDelta.Add();          // K3, 4, 5, 6, 7, 8
            tabellaDelta.Add(3, new object[] { 0, 0, 0, 0, 0, 0 });
            tabellaDelta.Add(6, new object[] { 1, 1.5, 1, 3, 4, 6 });
            tabellaDelta.Add(10, new object[] { 1, 1.5, 2, 3, 6, 7 });
            tabellaDelta.Add(14, new object[] { 1, 2, 3, 3, 7, 9 });
            tabellaDelta.Add(18, new object[] { 1, 2, 3, 3, 7, 9 });
            tabellaDelta.Add(24, new object[] { 1.5, 2, 3, 4, 8, 12 });
            tabellaDelta.Add(30, new object[] { 1.5, 2, 3, 4, 8, 12 });
            tabellaDelta.Add(40, new object[] { 1.5, 3, 4, 5, 9, 14 });
            tabellaDelta.Add(50, new object[] { 1.5, 3, 4, 5, 9, 14 });
            tabellaDelta.Add(65, new object[] { 2, 3, 5, 6, 11, 16 });
            tabellaDelta.Add(80, new object[] { 2, 3, 5, 6, 11, 16 });
            tabellaDelta.Add(100, new object[] { 2, 4, 5, 7, 13, 19 });
            tabellaDelta.Add(120, new object[] { 2, 4, 5, 7, 13, 19 });
            tabellaDelta.Add(140, new object[] { 3, 4, 6, 7, 15, 23 });
            tabellaDelta.Add(160, new object[] { 3, 4, 6, 7, 15, 23 });
            tabellaDelta.Add(180, new object[] { 3, 4, 6, 7, 15, 23 });
            tabellaDelta.Add(200, new object[] { 3, 4, 6, 9, 17, 26 });
            tabellaDelta.Add(225, new object[] { 3, 4, 6, 9, 17, 26 });
            tabellaDelta.Add(250, new object[] { 3, 4, 6, 9, 17, 26 });
            tabellaDelta.Add(280, new object[] { 4, 4, 7, 11, 20, 29 });
            tabellaDelta.Add(315, new object[] { 4, 4, 7, 11, 20, 29 });
            tabellaDelta.Add(355, new object[] { 4, 5, 7, 11, 21, 32 });
            tabellaDelta.Add(400, new object[] { 4, 5, 7, 11, 21, 32 });
            tabellaDelta.Add(450, new object[] { 5, 5, 7, 13, 23, 34 });
            tabellaDelta.Add(500, new object[] { 5, 5, 7, 13, 23, 34 });
        }

        private void PreparaLookUp()
        {
            //albero
            lookupDeviazioniLettera.Add("a", 0);
            lookupDeviazioniLettera.Add("b", 1);
            lookupDeviazioniLettera.Add("c", 2);
            lookupDeviazioniLettera.Add("cd", 3);
            lookupDeviazioniLettera.Add("d", 4);
            lookupDeviazioniLettera.Add("e", 5);
            lookupDeviazioniLettera.Add("ef", 6);
            lookupDeviazioniLettera.Add("f", 7);
            lookupDeviazioniLettera.Add("fg", 8);
            lookupDeviazioniLettera.Add("g", 9);
            lookupDeviazioniLettera.Add("h", 10);
            lookupDeviazioniLettera.Add("j5", 12);
            lookupDeviazioniLettera.Add("j6", 12);
            lookupDeviazioniLettera.Add("j7", 13);
            lookupDeviazioniLettera.Add("j8", 14);
            lookupDeviazioniLettera.Add("k4", 15);
            lookupDeviazioniLettera.Add("k5", 15);
            lookupDeviazioniLettera.Add("k6", 15);
            lookupDeviazioniLettera.Add("k7", 15);
            lookupDeviazioniLettera.Add("k", 16);
            lookupDeviazioniLettera.Add("m", 17);
            lookupDeviazioniLettera.Add("n", 18);
            lookupDeviazioniLettera.Add("p", 19);
            lookupDeviazioniLettera.Add("r", 20);
            lookupDeviazioniLettera.Add("s", 21);
            lookupDeviazioniLettera.Add("t", 22);
            lookupDeviazioniLettera.Add("u", 23);
            lookupDeviazioniLettera.Add("v", 24);
            lookupDeviazioniLettera.Add("x", 25);
            lookupDeviazioniLettera.Add("y", 26);
            lookupDeviazioniLettera.Add("z", 27);
            lookupDeviazioniLettera.Add("za", 28);
            lookupDeviazioniLettera.Add("zb", 29);
            lookupDeviazioniLettera.Add("zc", 30);

            //foro
            lookupDeviazioniLettera.Add("A", 31);
            lookupDeviazioniLettera.Add("B", 32);
            lookupDeviazioniLettera.Add("C", 33);
            lookupDeviazioniLettera.Add("CD", 34);
            lookupDeviazioniLettera.Add("D", 35);
            lookupDeviazioniLettera.Add("E", 36);
            lookupDeviazioniLettera.Add("EF", 37);
            lookupDeviazioniLettera.Add("F", 38);
            lookupDeviazioniLettera.Add("FG", 39);
            lookupDeviazioniLettera.Add("G", 40);
            lookupDeviazioniLettera.Add("H", 41);
            lookupDeviazioniLettera.Add("J6", 43);
            lookupDeviazioniLettera.Add("J7", 44);
            lookupDeviazioniLettera.Add("J8", 45);
            lookupDeviazioniLettera.Add("K8", 46);
            lookupDeviazioniLettera.Add("K9", 47);
            lookupDeviazioniLettera.Add("M8", 48);
            lookupDeviazioniLettera.Add("M9", 49);
            lookupDeviazioniLettera.Add("N8", 50);
            lookupDeviazioniLettera.Add("N9", 51);
            lookupDeviazioniLettera.Add("P", 52);
            lookupDeviazioniLettera.Add("R", 53);
            lookupDeviazioniLettera.Add("S", 54);
            lookupDeviazioniLettera.Add("T", 55);
            lookupDeviazioniLettera.Add("U", 56);
            lookupDeviazioniLettera.Add("V", 57);
            lookupDeviazioniLettera.Add("X", 58);
            lookupDeviazioniLettera.Add("Y", 59);
            lookupDeviazioniLettera.Add("Z", 60);
            lookupDeviazioniLettera.Add("ZA", 61);
            lookupDeviazioniLettera.Add("ZB", 62);
            lookupDeviazioniLettera.Add("ZC", 63);
        }

        public string[] LettereForo()
        {
            return new string[] {
                "A", "B", "C", "CD", "D", "E", "EF", "F", "FG", "G", "H", "J", "JS", "K", "M", "N", "P", "R", "S", "T", "U", "V", "X", "Y", "Z", "ZA", "ZB", "ZC"
            };
        }

        public string[] lettereAlbero()
        {
            return new string[] {
                "a", "b", "c", "cd", "d", "e", "ef", "f", "fg", "g", "h", "j", "js", "k", "m", "n", "p", "r", "s", "t", "u", "v", "x", "y", "z", "za", "zb", "zc"
            };
        }

        public bool Calcola(string lettera, int grado, double diametro, out double tolleranzaInferiore, out double tolleranzaSuperiore)
        {
            string letteraBkp = lettera;
            tolleranzaInferiore = 0.0;
            tolleranzaSuperiore = 0.0;
            if (grado < 1 || grado > 18) return false;
            if (lettera == "CD" ||
                lettera == "EF" ||
                lettera == "FG" ||
                lettera == "cd" ||
                lettera == "ef" ||
                lettera == "fg")
                if (diametro > 10)
                    return false;
            if (lettera == "J")
                if (grado < 6 || grado > 8)
                    return false;
            if (lettera == "j")
                if (grado < 5 || grado > 7)
                    return false;
            if (lettera == "A" ||
                lettera == "B" ||
                lettera == "C" ||
                lettera == "J" ||
                lettera == "a" ||
                lettera == "b" ||
                lettera == "c" ||
                lettera == "j")
                if (diametro > 500)
                    return false;
            if (lettera == "K")
                if (grado > 8)
                    return false;
            if (lettera == "T")
                if (diametro < 24)
                    return false;
            if (lettera == "v" ||
                lettera == "x" ||
                lettera == "y" ||
                lettera == "z" ||
                lettera == "za" ||
                lettera == "zb" ||
                lettera == "zc" ||
                lettera == "V" ||
                lettera == "X" ||
                lettera == "Y" ||
                lettera == "Z" ||
                lettera == "ZA" ||
                lettera == "ZB" ||
                lettera == "ZC")
                if (diametro > 500)
                    return false;

            object objRef = GetValoreRiferimento(grado, diametro);
            if (objRef == null) return false;
            double scostamento = Convert.ToDouble(objRef);

            //caso js/JS
            if (lettera == "js" || lettera == "JS")
            {
                scostamento = scostamento / 2;
                tolleranzaSuperiore = scostamento / 1000;
                tolleranzaInferiore = -scostamento / 1000;
                return true;
            }

            object oDeviazioneFondamentale = GetDeviazioneFondamentale(lettera + grado.ToString(), diametro);
            if (oDeviazioneFondamentale == null)
                oDeviazioneFondamentale = GetDeviazioneFondamentale(lettera, diametro);
            double deviazione = 0;
            if (oDeviazioneFondamentale != null)
                deviazione = Convert.ToDouble(oDeviazioneFondamentale);
            //else
            //    if (!((lettera == "K" && grado < 10) || lettera == "M"))
            //        return false;

            //custom: K1-8
            if (lettera == "K" && grado < 10)
            {
                object objDeviazione = GetDeviazioneDelta(grado, diametro);
                if (objDeviazione != null)
                    deviazione = Convert.ToDouble(objDeviazione);

                object oCorrettivo = GetDeviazioneFondamentale("K8", diametro);
                int correttivo = Convert.ToInt32(oCorrettivo);
                //VOODOO FROM Colonna K8
                if (diametro <= 500)
                    deviazione = deviazione + correttivo;
                else
                    deviazione = 0;

                tolleranzaSuperiore = deviazione / 1000;
                tolleranzaInferiore = (deviazione - scostamento) / 1000;
                return true;
            }

            if (lettera == "M")
            {
                object objDeviazione = GetDeviazioneDelta(grado, diametro);
                if (objDeviazione != null)
                    deviazione = Convert.ToDouble(objDeviazione);

                object oCorrettivo = GetDeviazioneFondamentale("M8", diametro);
                int correttivo = Convert.ToInt32(oCorrettivo);
                //VOODOO FROM Colonna M8
                if (grado == 9)
                    correttivo = 0;
                if (grado == 8)
                    if (diametro > 500)
                        correttivo = 0;
                deviazione = deviazione + correttivo;

                tolleranzaSuperiore = deviazione / 1000;
                tolleranzaInferiore = (deviazione - scostamento) / 1000;
                return true;
            }

            if (lettera == "N")
            {
                object objDeviazione = GetDeviazioneDelta(grado, diametro);
                if (objDeviazione != null)
                    deviazione = Convert.ToDouble(objDeviazione);
                int correttivo = 0;
                if (grado <= 9)
                    correttivo = Convert.ToInt32(GetDeviazioneFondamentale("N8", diametro));
                else
                    correttivo = Convert.ToInt32(GetDeviazioneFondamentale("N9", diametro));
                if (grado == 9)
                    correttivo = 0;
                if (grado == 8)
                    if (diametro > 500)
                        correttivo = 0;

                deviazione = deviazione + correttivo;

                tolleranzaSuperiore = deviazione / 1000;
                tolleranzaInferiore = (deviazione - scostamento) / 1000;
                return true;
            }

            int indexLettera = -1;
            if (lookupDeviazioniLettera.ContainsKey(lettera + grado.ToString()))
                indexLettera = lookupDeviazioniLettera[lettera + grado.ToString()];
            else if (lookupDeviazioniLettera.ContainsKey(lettera))
                indexLettera = lookupDeviazioniLettera[lettera];

            //procedura dedicata (j*-zc; J*-ZC)
            if ((indexLettera >= 12 && indexLettera <= 30) || (indexLettera >= 43 && indexLettera <= 63))
            {
                if (char.IsLower(lettera.ToCharArray()[0]))
                {
                    //albero
                    tolleranzaInferiore = deviazione / 1000;
                    tolleranzaSuperiore = (deviazione + scostamento) / 1000;
                }
                else
                {
                    //foro: calcolo delta
                    double delta = 0;
                    if (!lettera.StartsWith("J"))
                    {
                        if (grado > 2 && diametro <= 500 && grado < 8)
                        {
                            object objRef2 = GetValoreRiferimento(grado - 1, diametro);
                            if (objRef2 != null)
                            {
                                double riferimentoPrecedente = Convert.ToDouble(objRef2);
                                delta = scostamento - riferimentoPrecedente;
                            }
                        }
                    }

                    tolleranzaSuperiore = (deviazione + delta) / 1000;
                    tolleranzaInferiore = ((tolleranzaSuperiore * 1000) - scostamento) / 1000;
                }
                return true;
            }

            //procedura standard (a-h;A-H)
            if (char.IsLower(lettera.ToCharArray()[0]))
            {
                //albero
                tolleranzaSuperiore = deviazione / 1000;
                tolleranzaInferiore = (deviazione - scostamento) / 1000;
            }
            else
            {
                //foro
                tolleranzaInferiore = deviazione / 1000;
                tolleranzaSuperiore = (deviazione + scostamento) / 1000;
            }

            return true;
        }

        private object GetValoreRiferimento(int grado, double diametro)
        {
            foreach (KeyValuePair<int, object[]> pair in tabellaGradi)
            {
                if (diametro <= pair.Key)
                {
                    object[] tolleranze = tabellaGradi[pair.Key];
                    if ((grado - 1) < 0 || (grado - 1) >= tolleranze.Length)
                        return null;
                    return tolleranze[grado - 1];
                }
            }
            return null;
        }

        private object GetDeviazioneFondamentale(string lettera, double diametro)
        {
            if (!lookupDeviazioniLettera.ContainsKey(lettera)) return null;
            int indexLetter = lookupDeviazioniLettera[lettera];

            foreach (KeyValuePair<int, object[]> pair in tabellaDeviazioni)
            {
                if (diametro <= pair.Key)
                {
                    object[] oDeviazioni = tabellaDeviazioni[pair.Key];
                    if (indexLetter < 0 || indexLetter >= oDeviazioni.Length)
                        return null;
                    return oDeviazioni[indexLetter];
                }
            }
            return null;
        }

        private object GetDeviazioneDelta(int grado, double diametro)
        {
            int index = grado - 3;
            if (index < 0 || index > 5)
                return null; //ERRROR!!!
            foreach (KeyValuePair<int, object[]> pair in tabellaDelta)
            {
                if (diametro <= pair.Key)
                {
                    object[] oDelta = tabellaDelta[pair.Key];
                    return oDelta[index];
                }
            }
            return null;
        }
    }
}
// file ...\X\Renci.SshNet\AuthenticationMethod.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Base class for all supported authentication methods
    /// </summary>
    public abstract class AuthenticationMethod : IAuthenticationMethod
    {
        /// <summary>
        /// Gets the name of the authentication method.
        /// </summary>
        /// <value>
        /// The name of the authentication method.
        /// </value>
        public abstract string Name { get; }

        /// <summary>
        /// Gets connection username.
        /// </summary>
        public string Username { get; private set; }

        /// <summary>
        /// Gets list of allowed authentications.
        /// </summary>
        public IEnumerable<string> AllowedAuthentications { get; protected set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthenticationMethod"/> class.
        /// </summary>
        /// <param name="username">The username.</param>
        /// <exception cref="ArgumentException"><paramref name="username"/> is whitespace or null.</exception>
        protected AuthenticationMethod(string username)
        {
            if (username.IsNullOrWhiteSpace())
                throw new ArgumentException("username");

            this.Username = username;
        }

        /// <summary>
        /// Authenticates the specified session.
        /// </summary>
        /// <param name="session">The session to authenticate.</param>
        /// <returns>
        /// The result of the authentication process.
        /// </returns>
        public abstract AuthenticationResult Authenticate(Session session);

        /// <summary>
        /// Authenticates the specified session.
        /// </summary>
        /// <param name="session">The session to authenticate.</param>
        /// <returns>
        /// The result of the authentication process.
        /// </returns>
        AuthenticationResult IAuthenticationMethod.Authenticate(ISession session)
        {
            return Authenticate((Session) session);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\AuthenticationResult.cs
#if !MOBILE && !CORE
namespace Renci.SshNet
{
    /// <summary>
    /// Represents possible authentication methods results
    /// </summary>
    public enum AuthenticationResult
    {
        /// <summary>
        /// Authentication was successful.
        /// </summary>
        Success,
        /// <summary>
        /// Authentication completed with partial success.
        /// </summary>
        PartialSuccess,
        /// <summary>
        /// Authentication failed.
        /// </summary>
        Failure
    }
}

#endif
// file ...\X\Renci.SshNet\BaseClient.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Serves as base class for client implementations, provides common client functionality.
    /// </summary>
    public abstract class BaseClient : IDisposable
    {
        /// <summary>
        /// Holds value indicating whether the connection info is owned by this client.
        /// </summary>
        private readonly bool _ownsConnectionInfo;

        private readonly IServiceFactory _serviceFactory;
        private readonly object _keepAliveLock = new object();
        private TimeSpan _keepAliveInterval;
        private System.Threading.Timer _keepAliveTimer;
        private ConnectionInfo _connectionInfo;

        /// <summary>
        /// Gets the current session.
        /// </summary>
        /// <value>
        /// The current session.
        /// </value>
        internal ISession Session { get; private set; }

        /// <summary>
        /// Gets the factory for creating new services.
        /// </summary>
        /// <value>
        /// The factory for creating new services.
        /// </value>
        internal IServiceFactory ServiceFactory
        {
            get { return _serviceFactory; }
        }

        /// <summary>
        /// Gets the connection info.
        /// </summary>
        /// <value>
        /// The connection info.
        /// </value>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public ConnectionInfo ConnectionInfo
        {
            get
            {
                CheckDisposed();
                return _connectionInfo;
            }
            private set
            {
                _connectionInfo = value;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this client is connected to the server.
        /// </summary>
        /// <value>
        /// <c>true</c> if this client is connected; otherwise, <c>false</c>.
        /// </value>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public bool IsConnected
        {
            get
            {
                CheckDisposed();
                return Session != null && Session.IsConnected;
            }
        }

        /// <summary>
        /// Gets or sets the keep-alive interval.
        /// </summary>
        /// <value>
        /// The keep-alive interval. Specify negative one (-1) milliseconds to disable the
        /// keep-alive. This is the default value.
        /// </value>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public TimeSpan KeepAliveInterval
        {
            get
            {
                CheckDisposed();
                return _keepAliveInterval;
            }
            set
            {
                CheckDisposed();

                if (value == _keepAliveInterval)
                    return;

                if (value == SshNet.Session.InfiniteTimeSpan)
                {
                    // stop the timer when the value is -1 milliseconds
                    StopKeepAliveTimer();
                }
                else
                {
                    // change the due time and interval of the timer if has already
                    // been created (which means the client is connected)
                    // 
                    // if the client is not yet connected, then the timer will be
                    // created with the new interval when Connect() is invoked
                    if (_keepAliveTimer != null)
                        _keepAliveTimer.Change(value, value);
                }
                _keepAliveInterval = value;
            }
        }

        /// <summary>
        /// Occurs when an error occurred.
        /// </summary>
        /// <example>
        ///   <code source="..\..\Renci.SshNet.Tests\Classes\SshClientTest.cs" region="Example SshClient Connect ErrorOccurred" language="C#" title="Handle ErrorOccurred event" />
        /// </example>
        public event EventHandler<ExceptionEventArgs> ErrorOccurred;

        /// <summary>
        /// Occurs when host key received.
        /// </summary>
        /// <example>
        ///   <code source="..\..\Renci.SshNet.Tests\Classes\SshClientTest.cs" region="Example SshClient Connect HostKeyReceived" language="C#" title="Handle HostKeyReceived event" />
        /// </example>
        public event EventHandler<HostKeyEventArgs> HostKeyReceived;

        /// <summary>
        /// Initializes a new instance of the <see cref="BaseClient"/> class.
        /// </summary>
        /// <param name="connectionInfo">The connection info.</param>
        /// <param name="ownsConnectionInfo">Specified whether this instance owns the connection info.</param>
        /// <exception cref="ArgumentNullException"><paramref name="connectionInfo"/> is null.</exception>
        /// <remarks>
        /// If <paramref name="ownsConnectionInfo"/> is <c>true</c>, then the
        /// connection info will be disposed when this instance is disposed.
        /// </remarks>
        protected BaseClient(ConnectionInfo connectionInfo, bool ownsConnectionInfo)
            : this(connectionInfo, ownsConnectionInfo, new ServiceFactory())
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BaseClient"/> class.
        /// </summary>
        /// <param name="connectionInfo">The connection info.</param>
        /// <param name="ownsConnectionInfo">Specified whether this instance owns the connection info.</param>
        /// <param name="serviceFactory">The factory to use for creating new services.</param>
        /// <exception cref="ArgumentNullException"><paramref name="connectionInfo"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="serviceFactory"/> is null.</exception>
        /// <remarks>
        /// If <paramref name="ownsConnectionInfo"/> is <c>true</c>, then the
        /// connection info will be disposed when this instance is disposed.
        /// </remarks>
        internal BaseClient(ConnectionInfo connectionInfo, bool ownsConnectionInfo, IServiceFactory serviceFactory)
        {
            if (connectionInfo == null)
                throw new ArgumentNullException("connectionInfo");
            if (serviceFactory == null)
                throw new ArgumentNullException("serviceFactory");

            ConnectionInfo = connectionInfo;
            _ownsConnectionInfo = ownsConnectionInfo;
            _serviceFactory = serviceFactory;
            _keepAliveInterval = SshNet.Session.InfiniteTimeSpan;
        }

        /// <summary>
        /// Connects client to the server.
        /// </summary>
        /// <exception cref="InvalidOperationException">The client is already connected.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        /// <exception cref="SocketException">Socket connection to the SSH server or proxy server could not be established, or an error occurred while resolving the hostname.</exception>
        /// <exception cref="SshConnectionException">SSH session could not be established.</exception>
        /// <exception cref="SshAuthenticationException">Authentication of SSH session failed.</exception>
        /// <exception cref="ProxyException">Failed to establish proxy connection.</exception>
        public void Connect()
        {
            CheckDisposed();

            //OneCodeTODO (see issue #1758):
            // we're not stopping the keep-alive timer and disposing the session here
            // 
            // we could do this but there would still be side effects as concrete
            // implementations may still hang on to the original session
            // 
            // therefore it would be better to actually invoke the Disconnect method
            // (and then the Dispose on the session) but even that would have side effects
            // eg. it would remove all forwarded ports from SshClient
            // 
            // I think we should modify our concrete clients to better deal with a
            // disconnect. In case of SshClient this would mean not removing the 
            // forwarded ports on disconnect (but only on dispose ?) and link a
            // forwarded port with a client instead of with a session
            //
            // To be discussed with Oleg (or whoever is interested)
            if (Session != null && Session.IsConnected)
                throw new InvalidOperationException("The client is already connected.");

            OnConnecting();
            Session = _serviceFactory.CreateSession(ConnectionInfo);
            Session.HostKeyReceived += Session_HostKeyReceived;
            Session.ErrorOccured += Session_ErrorOccured;
            Session.Connect();
            StartKeepAliveTimer();
            OnConnected();
        }

        /// <summary>
        /// Disconnects client from the server.
        /// </summary>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void Disconnect()
        {
            CheckDisposed();

            OnDisconnecting();

            // stop sending keep-alive messages before we close the
            // session
            StopKeepAliveTimer();

            // disconnect and dispose the SSH session
            if (Session != null)
            {
                // a new session is created in Connect(), so we should dispose and
                // dereference the current session here
                Session.ErrorOccured -= Session_ErrorOccured;
                Session.HostKeyReceived -= Session_HostKeyReceived;
                Session.Disconnect();
                Session.Dispose();
                Session = null;
            }

            OnDisconnected();
        }

        /// <summary>
        /// Sends a keep-alive message to the server.
        /// </summary>
        /// <remarks>
        /// Use <see cref="KeepAliveInterval"/> to configure the client to send a keep-alive at regular
        /// intervals.
        /// </remarks>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        [Obsolete("Use KeepAliveInterval to send a keep-alive message at regular intervals.")]
        public void SendKeepAlive()
        {
            CheckDisposed();

            SendKeepAliveMessage();
        }

        /// <summary>
        /// Called when client is connecting to the server.
        /// </summary>
        protected virtual void OnConnecting()
        {
        }

        /// <summary>
        /// Called when client is connected to the server.
        /// </summary>
        protected virtual void OnConnected()
        {
        }

        /// <summary>
        /// Called when client is disconnecting from the server.
        /// </summary>
        protected virtual void OnDisconnecting()
        {
            if (Session != null)
                Session.OnDisconnecting();
        }

        /// <summary>
        /// Called when client is disconnected from the server.
        /// </summary>
        protected virtual void OnDisconnected()
        {
        }

        private void Session_ErrorOccured(object sender, ExceptionEventArgs e)
        {
            var handler = ErrorOccurred;
            if (handler != null)
            {
                handler(this, e);
            }
        }

        private void Session_HostKeyReceived(object sender, HostKeyEventArgs e)
        {
            var handler = HostKeyReceived;
            if (handler != null)
            {
                handler(this, e);
            }
        }

        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged ResourceMessages.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (!_isDisposed)
            {
                if (disposing)
                {
                    Disconnect();

                    if (_ownsConnectionInfo && _connectionInfo != null)
                    {
                        var connectionInfoDisposable = _connectionInfo as IDisposable;
                        if (connectionInfoDisposable != null)
                            connectionInfoDisposable.Dispose();
                        _connectionInfo = null;
                    }
                }

                _isDisposed = true;
            }
        }

        /// <summary>
        /// Check if the current instance is disposed.
        /// </summary>
        /// <exception cref="ObjectDisposedException">THe current instance is disposed.</exception>
        protected void CheckDisposed()
        {
            if (_isDisposed)
                throw new ObjectDisposedException(GetType().FullName);
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="BaseClient"/> is reclaimed by garbage collection.
        /// </summary>
        ~BaseClient()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion

        /// <summary>
        /// Stops the keep-alive timer, and waits until all timer callbacks have been
        /// executed.
        /// </summary>
        private void StopKeepAliveTimer()
        {
            if (_keepAliveTimer == null)
                return;

            var timerDisposed = new System.Threading.ManualResetEvent(false);
            _keepAliveTimer.Dispose(timerDisposed);
            timerDisposed.WaitOne();
            timerDisposed.Dispose();
            _keepAliveTimer = null;
        }

        private void SendKeepAliveMessage()
        {
            // do nothing if we have disposed or disconnected
            if (Session == null)
                return;

            // do not send multiple keep-alive messages concurrently
            if (System.Threading.Monitor.TryEnter(_keepAliveLock))
            {
                try
                {
                    Session.TrySendMessage(new IgnoreMessage());
                }
                finally
                {
                    System.Threading.Monitor.Exit(_keepAliveLock);
                }
            }
        }

        /// <summary>
        /// Starts the keep-alive timer.
        /// </summary>
        /// <remarks>
        /// When <see cref="KeepAliveInterval"/> is negative one (-1) milliseconds, then
        /// the timer will not be started.
        /// </remarks>
        private void StartKeepAliveTimer()
        {
            if (_keepAliveInterval == SshNet.Session.InfiniteTimeSpan)
                return;

            if (_keepAliveTimer == null)
                _keepAliveTimer = new System.Threading.Timer(state => SendKeepAliveMessage());
            _keepAliveTimer.Change(_keepAliveInterval, _keepAliveInterval);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\CipherInfo.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Holds information about key size and cipher to use
    /// </summary>
    public class CipherInfo
    {
        /// <summary>
        /// Gets the size of the key.
        /// </summary>
        /// <value>
        /// The size of the key.
        /// </value>
        public int KeySize { get; private set; }

        /// <summary>
        /// Gets the cipher.
        /// </summary>
        public Func<byte[], byte[], Cipher> Cipher { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="CipherInfo"/> class.
        /// </summary>
        /// <param name="keySize">Size of the key.</param>
        /// <param name="cipher">The cipher.</param>
        public CipherInfo(int keySize, Func<byte[], byte[], Cipher> cipher)
        {
            this.KeySize = keySize;
            this.Cipher = (key, iv) => (cipher(key.Take(this.KeySize / 8).ToArray(), iv));
        }
    }
}

#endif
// file ...\X\Renci.SshNet\ClientAuthentication.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    public class ClientAuthentication
    {
        public void Authenticate(IConnectionInfoInternal connectionInfo, ISession session)
        {
            if (connectionInfo == null)
                throw new ArgumentNullException("connectionInfo");
            if (session == null)
                throw new ArgumentNullException("session");

            session.RegisterMessage("SSH_MSG_USERAUTH_FAILURE");
            session.RegisterMessage("SSH_MSG_USERAUTH_SUCCESS");
            session.RegisterMessage("SSH_MSG_USERAUTH_BANNER");
            session.UserAuthenticationBannerReceived += connectionInfo.UserAuthenticationBannerReceived;

            try
            {
                // the exception to report an authentication failure with
                SshAuthenticationException authenticationException = null;

                // try to authenticate against none
                var noneAuthenticationMethod = connectionInfo.CreateNoneAuthenticationMethod();

                var authenticated = noneAuthenticationMethod.Authenticate(session);
                if (authenticated != AuthenticationResult.Success)
                {
                    if (!TryAuthenticate(session, new AuthenticationState(connectionInfo.AuthenticationMethods.ToList()), noneAuthenticationMethod.AllowedAuthentications.ToList(), ref authenticationException))
                    {
                        throw authenticationException;
                    }
                }
            }
            finally
            {
                session.UserAuthenticationBannerReceived -= connectionInfo.UserAuthenticationBannerReceived;
                session.UnRegisterMessage("SSH_MSG_USERAUTH_FAILURE");
                session.UnRegisterMessage("SSH_MSG_USERAUTH_SUCCESS");
                session.UnRegisterMessage("SSH_MSG_USERAUTH_BANNER");
            }

        }

        private bool TryAuthenticate(ISession session,
                                     AuthenticationState authenticationState,
                                     ICollection<string> allowedAuthenticationMethods,
                                     ref SshAuthenticationException authenticationException)
        {
            if (!allowedAuthenticationMethods.Any())
            {
                authenticationException = new SshAuthenticationException("No authentication methods defined on SSH server.");
                return false;
            }

            // we want to try authentication methods in the order in which they were
            // passed in the ctor, not the order in which the SSH server returns
            // the allowed authentication methods
            var matchingAuthenticationMethods = authenticationState.SupportedAuthenticationMethods.Where(a => allowedAuthenticationMethods.Contains(a.Name)).ToList();
            if (!matchingAuthenticationMethods.Any())
            {
                authenticationException = new SshAuthenticationException(string.Format("No suitable authentication method found to complete authentication ({0}).", string.Join(",", allowedAuthenticationMethods.ToArray())));
                return false;
            }

            foreach (var authenticationMethod in GetOrderedAuthenticationMethods(authenticationState, matchingAuthenticationMethods))
            {
                if (authenticationState.FailedAuthenticationMethods.Contains(authenticationMethod))
                    continue;

                // when the authentication method was previously executed, then skip the authentication
                // method as long as there's another authentication method to try; this is done to avoid
                // a stack overflow for servers that do not update the list of allowed authentication
                // methods after a partial success

                if (!authenticationState.ExecutedAuthenticationMethods.Contains(authenticationMethod))
                {
                    // update state to reflect previosuly executed authentication methods
                    authenticationState.ExecutedAuthenticationMethods.Add(authenticationMethod);
                }

                var authenticationResult = authenticationMethod.Authenticate(session);
                switch (authenticationResult)
                {
                    case AuthenticationResult.PartialSuccess:
                        if (TryAuthenticate(session, authenticationState, authenticationMethod.AllowedAuthentications.ToList(), ref authenticationException))
                        {
                            authenticationResult = AuthenticationResult.Success;
                        }
                        break;
                    case AuthenticationResult.Failure:
                        authenticationState.FailedAuthenticationMethods.Add(authenticationMethod);
                        authenticationException = new SshAuthenticationException(string.Format("Permission denied ({0}).", authenticationMethod.Name));
                        break;
                    case AuthenticationResult.Success:
                        authenticationException = null;
                        break;
                }

                if (authenticationResult == AuthenticationResult.Success)
                    return true;
            }

            return false;
        }

        private IEnumerable<IAuthenticationMethod> GetOrderedAuthenticationMethods(AuthenticationState authenticationState, IEnumerable<IAuthenticationMethod> matchingAuthenticationMethods)
        {
            var skippedAuthenticationMethods = new List<IAuthenticationMethod>();

            foreach (var authenticationMethod in matchingAuthenticationMethods)
            {
                if (authenticationState.ExecutedAuthenticationMethods.Contains(authenticationMethod))
                {
                    skippedAuthenticationMethods.Add(authenticationMethod);
                    continue;
                }

                yield return authenticationMethod;
            }

            foreach (var authenticationMethod in skippedAuthenticationMethods)
                yield return authenticationMethod;
        }

        private class AuthenticationState
        {
            private readonly IList<IAuthenticationMethod> _supportedAuthenticationMethods;

            public AuthenticationState(IList<IAuthenticationMethod> supportedAuthenticationMethods)
            {
                _supportedAuthenticationMethods = supportedAuthenticationMethods;
                ExecutedAuthenticationMethods = new List<IAuthenticationMethod>();
                FailedAuthenticationMethods = new List<IAuthenticationMethod>();
            }

            /// <summary>
            /// Gets the list of authentication methods that were previously executed.
            /// </summary>
            /// <value>
            /// The list of authentication methods that were previously executed.
            /// </value>
            public IList<IAuthenticationMethod> ExecutedAuthenticationMethods { get; private set; }

            /// <summary>
            /// Gets the list of authentications methods that failed.
            /// </summary>
            /// <value>
            /// The list of authentications methods that failed.
            /// </value>
            public IList<IAuthenticationMethod> FailedAuthenticationMethods { get; private set; }

            /// <summary>
            /// Gets the list of supported authentication methods.
            /// </summary>
            /// <value>
            /// The list of supported authentication methods.
            /// </value>
            public IEnumerable<IAuthenticationMethod> SupportedAuthenticationMethods
            {
                get { return _supportedAuthenticationMethods; }
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\CommandAsyncResult.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides additional information for asynchronous command execution
    /// </summary>
    public class CommandAsyncResult : IAsyncResult
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CommandAsyncResult"/> class.
        /// </summary>
        internal CommandAsyncResult()
        {
        }

        /// <summary>
        /// Gets or sets the bytes received. If SFTP only file bytes are counted.
        /// </summary>
        /// <value>Total bytes received.</value>
        public int BytesReceived { get; set; }

        /// <summary>
        /// Gets or sets the bytes sent by SFTP.
        /// </summary>
        /// <value>Total bytes sent.</value>
        public int BytesSent { get; set; }

        #region IAsyncResult Members

        /// <summary>
        /// Gets a user-defined object that qualifies or contains information about an asynchronous operation.
        /// </summary>
        /// <returns>A user-defined object that qualifies or contains information about an asynchronous operation.</returns>
        public object AsyncState { get; internal set; }

        /// <summary>
        /// Gets a <see cref="T:System.Threading.WaitHandle"/> that is used to wait for an asynchronous operation to complete.
        /// </summary>
        /// <returns>A <see cref="T:System.Threading.WaitHandle"/> that is used to wait for an asynchronous operation to complete.</returns>
        public WaitHandle AsyncWaitHandle { get; internal set; }

        /// <summary>
        /// Gets a value that indicates whether the asynchronous operation completed synchronously.
        /// </summary>
        /// <returns>true if the asynchronous operation completed synchronously; otherwise, false.</returns>
        public bool CompletedSynchronously { get; internal set; }

        /// <summary>
        /// Gets a value that indicates whether the asynchronous operation has completed.
        /// </summary>
        /// <returns>true if the operation is complete; otherwise, false.</returns>
        public bool IsCompleted { get; internal set; }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\ConnectionInfo.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Represents remote connection information class.
    /// </summary>
    /// <remarks>
    /// This class is NOT thread-safe. Do not use the same <see cref="ConnectionInfo"/> with multiple
    /// client instances.
    /// </remarks>
    public class ConnectionInfo : IConnectionInfoInternal
    {
        internal static int DEFAULT_PORT = 22;

        /// <summary>
        /// Gets supported key exchange algorithms for this connection.
        /// </summary>
        public IDictionary<string, Type> KeyExchangeAlgorithms { get; private set; }

        /// <summary>
        /// Gets supported encryptions for this connection.
        /// </summary>
        public IDictionary<string, CipherInfo> Encryptions { get; private set; }

        /// <summary>
        /// Gets supported hash algorithms for this connection.
        /// </summary>
        public IDictionary<string, HashInfo> HmacAlgorithms { get; private set; }

        /// <summary>
        /// Gets supported host key algorithms for this connection.
        /// </summary>
        public IDictionary<string, Func<byte[], KeyHostAlgorithm>> HostKeyAlgorithms { get; private set; }

        /// <summary>
        /// Gets supported authentication methods for this connection.
        /// </summary>
        public IEnumerable<AuthenticationMethod> AuthenticationMethods { get; private set; }

        /// <summary>
        /// Gets supported compression algorithms for this connection.
        /// </summary>
        public IDictionary<string, Type> CompressionAlgorithms { get; private set; }

        /// <summary>
        /// Gets the supported channel requests for this connection.
        /// </summary>
        /// <value>
        /// The supported channel requests for this connection.
        /// </value>
        public IDictionary<string, RequestInfo> ChannelRequests { get; private set; }

        /// <summary>
        /// Gets a value indicating whether connection is authenticated.
        /// </summary>
        /// <value>
        /// <c>true</c> if connection is authenticated; otherwise, <c>false</c>.
        /// </value>
        public bool IsAuthenticated { get; private set; }

        /// <summary>
        /// Gets connection host.
        /// </summary>
        public string Host { get; private set; }

        /// <summary>
        /// Gets connection port.
        /// </summary>
        /// <value>
        /// The connection port. The default value is 22.
        /// </value>
        public int Port { get; private set; }

        /// <summary>
        /// Gets connection username.
        /// </summary>
        public string Username { get; private set; }

        /// <summary>
        /// Gets proxy type.
        /// </summary>
        /// <value>
        /// The type of the proxy.
        /// </value>
        public ProxyTypes ProxyType { get; private set; }

        /// <summary>
        /// Gets proxy connection host.
        /// </summary>
        public string ProxyHost { get; private set; }

        /// <summary>
        /// Gets proxy connection port.
        /// </summary>
        public int ProxyPort { get; private set; }

        /// <summary>
        /// Gets proxy connection username.
        /// </summary>
        public string ProxyUsername { get; private set; }

        /// <summary>
        /// Gets proxy connection password.
        /// </summary>
        public string ProxyPassword { get; private set; }

        /// <summary>
        /// Gets or sets connection timeout.
        /// </summary>
        /// <value>
        /// The connection timeout. The default value is 30 seconds.
        /// </value>
        /// <example>
        ///   <code source="..\..\Renci.SshNet.Tests\Classes\SshClientTest.cs" region="Example SshClient Connect Timeout" language="C#" title="Specify connection timeout" />
        /// </example>
        public TimeSpan Timeout { get; set; }

        /// <summary>
        /// Gets or sets the character encoding.
        /// </summary>
        /// <value>
        /// The character encoding. The default is <see cref="System.Text.Encoding.UTF8"/>.
        /// </value>
        public Encoding Encoding { get; set; }

        /// <summary>
        /// Gets or sets number of retry attempts when session channel creation failed.
        /// </summary>
        /// <value>
        /// The number of retry attempts when session channel creation failed. The default
        /// value is 10.
        /// </value>
        public int RetryAttempts { get; set; }

        /// <summary>
        /// Gets or sets maximum number of session channels to be open simultaneously.
        /// </summary>
        /// <value>
        /// The maximum number of session channels to be open simultaneously. The default
        /// value is 10.
        /// </value>
        public int MaxSessions { get; set; }

        /// <summary>
        /// Occurs when authentication banner is sent by the server.
        /// </summary>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\PasswordConnectionInfoTest.cs" region="Example PasswordConnectionInfo AuthenticationBanner" language="C#" title="Display authentication banner" />
        /// </example>
        public event EventHandler<AuthenticationBannerEventArgs> AuthenticationBanner;

        /// <summary>
        /// Gets the current key exchange algorithm.
        /// </summary>
        public string CurrentKeyExchangeAlgorithm { get; internal set; }

        /// <summary>
        /// Gets the current server encryption.
        /// </summary>
        public string CurrentServerEncryption { get; internal set; }

        /// <summary>
        /// Gets the current client encryption.
        /// </summary>
        public string CurrentClientEncryption { get; internal set; }

        /// <summary>
        /// Gets the current server hash algorithm.
        /// </summary>
        public string CurrentServerHmacAlgorithm { get; internal set; }

        /// <summary>
        /// Gets the current client hash algorithm.
        /// </summary>
        public string CurrentClientHmacAlgorithm { get; internal set; }

        /// <summary>
        /// Gets the current host key algorithm.
        /// </summary>
        public string CurrentHostKeyAlgorithm { get; internal set; }

        /// <summary>
        /// Gets the current server compression algorithm.
        /// </summary>
        public string CurrentServerCompressionAlgorithm { get; internal set; }

        /// <summary>
        /// Gets the server version.
        /// </summary>
        public string ServerVersion { get; internal set; }

        /// <summary>
        /// Get the client version.
        /// </summary>
        public string ClientVersion { get; internal set; }

        /// <summary>
        /// Gets the current client compression algorithm.
        /// </summary>
        public string CurrentClientCompressionAlgorithm { get; internal set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">The host.</param>
        /// <param name="username">The username.</param>
        /// <param name="authenticationMethods">The authentication methods.</param>
        /// <exception cref="ArgumentNullException"><paramref name="host"/> is <c>null</c>.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is a zero-length string.</exception>
        /// <exception cref="ArgumentException"><paramref name="username" /> is null, a zero-length string or contains only whitespace characters.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="authenticationMethods"/> is <c>null</c>.</exception>
        /// <exception cref="ArgumentException">No <paramref name="authenticationMethods"/> specified.</exception>
        public ConnectionInfo(string host, string username, params AuthenticationMethod[] authenticationMethods)
            : this(host, DEFAULT_PORT, username, ProxyTypes.None, null, 0, null, null, authenticationMethods)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">The host.</param>
        /// <param name="port">The port.</param>
        /// <param name="username">The username.</param>
        /// <param name="authenticationMethods">The authentication methods.</param>
        /// <exception cref="ArgumentNullException"><paramref name="host"/> is <c>null</c>.</exception>
        /// <exception cref="ArgumentException"><paramref name="username" /> is null, a zero-length string or contains only whitespace characters.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="port" /> is not within <see cref="F:System.Net.IPEndPoint.MinPort" /> and <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="authenticationMethods"/> is <c>null</c>.</exception>
        /// <exception cref="ArgumentException">No <paramref name="authenticationMethods"/> specified.</exception>
        public ConnectionInfo(string host, int port, string username, params AuthenticationMethod[] authenticationMethods)
            : this(host, port, username, ProxyTypes.None, null, 0, null, null, authenticationMethods)
        {
        }

        //OneCodeTODO: DOCS Add exception documentation for this class.

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectionInfo" /> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">Connection port.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="proxyUsername">The proxy username.</param>
        /// <param name="proxyPassword">The proxy password.</param>
        /// <param name="authenticationMethods">The authentication methods.</param>
        /// <exception cref="ArgumentNullException"><paramref name="host"/> is <c>null</c>.</exception>
        /// <exception cref="ArgumentException"><paramref name="username" /> is null, a zero-length string or contains only whitespace characters.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="port" /> is not within <see cref="F:System.Net.IPEndPoint.MinPort" /> and <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="proxyType"/> is not <see cref="ProxyTypes.None"/> and <paramref name="proxyHost" /> is <c>null</c>.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="proxyType"/> is not <see cref="ProxyTypes.None"/> and <paramref name="proxyPort" /> is not within <see cref="F:System.Net.IPEndPoint.MinPort" /> and <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="authenticationMethods"/> is <c>null</c>.</exception>
        /// <exception cref="ArgumentException">No <paramref name="authenticationMethods"/> specified.</exception>
        public ConnectionInfo(string host, int port, string username, ProxyTypes proxyType, string proxyHost, int proxyPort, string proxyUsername, string proxyPassword, params AuthenticationMethod[] authenticationMethods)
        {
            if (host == null)
                throw new ArgumentNullException("host");
            port.ValidatePort("port");

            if (username == null)
                throw new ArgumentNullException("username");
            if (username.All(char.IsWhiteSpace))
                throw new ArgumentException("Cannot be empty or contain only whitespace.", "username");

            if (proxyType != ProxyTypes.None)
            {
                if (proxyHost == null)
                    throw new ArgumentNullException("proxyHost");
                proxyPort.ValidatePort("proxyPort");
            }

            if (authenticationMethods == null)
                throw new ArgumentNullException("authenticationMethods");
            if (!authenticationMethods.Any())
                throw new ArgumentException("At least one authentication method should be specified.", "authenticationMethods");

            //  Set default connection values
            this.Timeout = TimeSpan.FromSeconds(30);
            this.RetryAttempts = 10;
            this.MaxSessions = 10;
            this.Encoding = Encoding.UTF8;

            this.KeyExchangeAlgorithms = new Dictionary<string, Type>
                {
                    {"diffie-hellman-group-exchange-sha256", typeof (KeyExchangeDiffieHellmanGroupExchangeSha256)},
                    {"diffie-hellman-group-exchange-sha1", typeof (KeyExchangeDiffieHellmanGroupExchangeSha1)},
                    {"diffie-hellman-group14-sha1", typeof (KeyExchangeDiffieHellmanGroup14Sha1)},
                    {"diffie-hellman-group1-sha1", typeof (KeyExchangeDiffieHellmanGroup1Sha1)},
                    //{"ecdh-sha2-nistp256", typeof(KeyExchangeEllipticCurveDiffieHellman)},
                    //{"ecdh-sha2-nistp256", typeof(...)},
                    //{"ecdh-sha2-nistp384", typeof(...)},
                    //{"ecdh-sha2-nistp521", typeof(...)},
                    //"gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==" - WinSSHD
                    //"gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==" - WinSSHD
                };

            this.Encryptions = new Dictionary<string, CipherInfo>
                {
                    {"aes256-ctr", new CipherInfo(256, (key, iv) => new AesCipher(key, new CtrCipherMode(iv), null))},
                    {"3des-cbc", new CipherInfo(192, (key, iv) => new TripleDesCipher(key, new CbcCipherMode(iv), null))},
                    {"aes128-cbc", new CipherInfo(128, (key, iv) => new AesCipher(key, new CbcCipherMode(iv), null))},
                    {"aes192-cbc", new CipherInfo(192, (key, iv) => new AesCipher(key, new CbcCipherMode(iv), null))},
                    {"aes256-cbc", new CipherInfo(256, (key, iv) => new AesCipher(key, new CbcCipherMode(iv), null))},
                    {"blowfish-cbc", new CipherInfo(128, (key, iv) => new BlowfishCipher(key, new CbcCipherMode(iv), null))},
                    {"twofish-cbc", new CipherInfo(256, (key, iv) => new TwofishCipher(key, new CbcCipherMode(iv), null))},
                    {"twofish192-cbc", new CipherInfo(192, (key, iv) => new TwofishCipher(key, new CbcCipherMode(iv), null))},
                    {"twofish128-cbc", new CipherInfo(128, (key, iv) => new TwofishCipher(key, new CbcCipherMode(iv), null))},
                    {"twofish256-cbc", new CipherInfo(256, (key, iv) => new TwofishCipher(key, new CbcCipherMode(iv), null))},
                    ////{"serpent256-cbc", typeof(CipherSerpent256CBC)},
                    ////{"serpent192-cbc", typeof(...)},
                    ////{"serpent128-cbc", typeof(...)},
                    {"arcfour", new CipherInfo(128, (key, iv) => new Arc4Cipher(key, false))},
                    {"arcfour128", new CipherInfo(128, (key, iv) => new Arc4Cipher(key, true))},
                    {"arcfour256", new CipherInfo(256, (key, iv) => new Arc4Cipher(key, true))},
                    ////{"idea-cbc", typeof(...)},
                    {"cast128-cbc", new CipherInfo(128, (key, iv) => new CastCipher(key, new CbcCipherMode(iv), null))},
                    ////{"rijndael-cbc@lysator.liu.se", typeof(...)},                
                    {"aes128-ctr", new CipherInfo(128, (key, iv) => new AesCipher(key, new CtrCipherMode(iv), null))},
                    {"aes192-ctr", new CipherInfo(192, (key, iv) => new AesCipher(key, new CtrCipherMode(iv), null))},
                };

            this.HmacAlgorithms = new Dictionary<string, HashInfo>
                {
                    {"hmac-md5", new HashInfo(16*8, key => new HMac<MD5Hash>(key))},
                    {"hmac-sha1", new HashInfo(20*8, key => new HMac<SHA1Hash>(key))},
                    {"hmac-sha2-256", new HashInfo(32*8, key => new HMac<SHA256Hash>(key))},
                    {"hmac-sha2-256-96", new HashInfo(32*8, key => new HMac<SHA256Hash>(key, 96))},
                    //{"hmac-sha2-512", new HashInfo(64 * 8, key => new HMac<SHA512Hash>(key))},
                    //{"hmac-sha2-512-96", new HashInfo(64 * 8,  key => new HMac<SHA512Hash>(key, 96))},
                    //{"umac-64@openssh.com", typeof(HMacSha1)},
                    {"hmac-ripemd160", new HashInfo(160, key => new HMac<RIPEMD160Hash>(key))},
                    {"hmac-ripemd160@openssh.com", new HashInfo(160, key => new HMac<RIPEMD160Hash>(key))},
                    {"hmac-md5-96", new HashInfo(16*8, key => new HMac<MD5Hash>(key, 96))},
                    {"hmac-sha1-96", new HashInfo(20*8, key => new HMac<SHA1Hash>(key, 96))},
                    //{"none", typeof(...)},
                };

            this.HostKeyAlgorithms = new Dictionary<string, Func<byte[], KeyHostAlgorithm>>
                {
                    {"ssh-rsa", data => new KeyHostAlgorithm("ssh-rsa", new RsaKey(), data)},
                    {"ssh-dss", data => new KeyHostAlgorithm("ssh-dss", new DsaKey(), data)},
                    //{"ecdsa-sha2-nistp256 "}
                    //{"x509v3-sign-rsa", () => { ... },
                    //{"x509v3-sign-dss", () => { ... },
                    //{"spki-sign-rsa", () => { ... },
                    //{"spki-sign-dss", () => { ... },
                    //{"pgp-sign-rsa", () => { ... },
                    //{"pgp-sign-dss", () => { ... },
                };

            this.CompressionAlgorithms = new Dictionary<string, Type>
                {
                    //{"zlib@openssh.com", typeof(ZlibOpenSsh)}, 
                    //{"zlib", typeof(Zlib)}, 
                    {"none", null},
                };

            this.ChannelRequests = new Dictionary<string, RequestInfo>
                {
                    {EnvironmentVariableRequestInfo.NAME, new EnvironmentVariableRequestInfo()},
                    {ExecRequestInfo.NAME, new ExecRequestInfo()},
                    {ExitSignalRequestInfo.NAME, new ExitSignalRequestInfo()},
                    {ExitStatusRequestInfo.NAME, new ExitStatusRequestInfo()},
                    {PseudoTerminalRequestInfo.NAME, new PseudoTerminalRequestInfo()},
                    {ShellRequestInfo.NAME, new ShellRequestInfo()},
                    {SignalRequestInfo.NAME, new SignalRequestInfo()},
                    {SubsystemRequestInfo.NAME, new SubsystemRequestInfo()},
                    {WindowChangeRequestInfo.NAME, new WindowChangeRequestInfo()},
                    {X11ForwardingRequestInfo.NAME, new X11ForwardingRequestInfo()},
                    {XonXoffRequestInfo.NAME, new XonXoffRequestInfo()},
                    {EndOfWriteRequestInfo.NAME, new EndOfWriteRequestInfo()},
                    {KeepAliveRequestInfo.NAME, new KeepAliveRequestInfo()},
                };

            this.Host = host;
            this.Port = port;
            this.Username = username;

            this.ProxyType = proxyType;
            this.ProxyHost = proxyHost;
            this.ProxyPort = proxyPort;
            this.ProxyUsername = proxyUsername;
            this.ProxyPassword = proxyPassword;

            this.AuthenticationMethods = authenticationMethods;
        }

        /// <summary>
        /// Authenticates the specified session.
        /// </summary>
        /// <param name="session">The session to be authenticated.</param>
        /// <exception cref="ArgumentNullException"><paramref name="session"/> is null.</exception>
        /// <exception cref="SshAuthenticationException">No suitable authentication method found to complete authentication, or permission denied.</exception>
        internal void Authenticate(ISession session)
        {
            IsAuthenticated = false;
            var clientAuthentication = new ClientAuthentication();
            clientAuthentication.Authenticate(this, session);
            IsAuthenticated = true;
        }

        /// <summary>
        /// Signals that an authentication banner message was received from the server.
        /// </summary>
        /// <param name="sender">The session in which the banner message was received.</param>
        /// <param name="e">The banner message.{</param>
        void IConnectionInfoInternal.UserAuthenticationBannerReceived(object sender, MessageEventArgs<BannerMessage> e)
        {
            var authenticationBanner = AuthenticationBanner;
            if (authenticationBanner != null)
            {
                authenticationBanner(this,
                    new AuthenticationBannerEventArgs(Username, e.Message.Message, e.Message.Language));
            }
        }

        IAuthenticationMethod IConnectionInfoInternal.CreateNoneAuthenticationMethod()
        {
            return new NoneAuthenticationMethod(Username);
        }

        IEnumerable<IAuthenticationMethod> IConnectionInfoInternal.AuthenticationMethods
        {
            get { return AuthenticationMethods.Cast<IAuthenticationMethod>(); }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\ExpectAction.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Specifies behavior for expected expression
    /// </summary>
    public class ExpectAction
    {
        /// <summary>
        /// Gets the expected regular expression.
        /// </summary>
        public Regex Expect { get; private set; }

        /// <summary>
        /// Gets the action to perform when expected expression is found.
        /// </summary>
        public Action<string> Action { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExpectAction"/> class.
        /// </summary>
        /// <param name="expect">The expect regular expression.</param>
        /// <param name="action">The action to perform.</param>
        /// <exception cref="ArgumentNullException"><paramref name="expect"/> or <paramref name="action"/> is null.</exception>
        public ExpectAction(Regex expect, Action<string> action)
        {
            if (expect == null)
                throw new ArgumentNullException("expect");

            if (action == null)
                throw new ArgumentNullException("action");

            this.Expect = expect;
            this.Action = action;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExpectAction"/> class.
        /// </summary>
        /// <param name="expect">The expect expression.</param>
        /// <param name="action">The action to perform.</param>
        /// <exception cref="ArgumentNullException"><paramref name="expect"/> or <paramref name="action"/> is null.</exception>
        public ExpectAction(string expect, Action<string> action)
        {
            if (expect == null)
                throw new ArgumentNullException("expect");

            if (action == null)
                throw new ArgumentNullException("action");

            this.Expect = new Regex(Regex.Escape(expect));
            this.Action = action;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\ExpectAsyncResult.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides additional information for asynchronous command execution
    /// </summary>
    public class ExpectAsyncResult : AsyncResult<string>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ExpectAsyncResult" /> class.
        /// </summary>
        /// <param name="asyncCallback">The async callback.</param>
        /// <param name="state">The state.</param>
        internal ExpectAsyncResult(AsyncCallback asyncCallback, Object state)
            : base(asyncCallback, state)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\ForwardedPort.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Base class for port forwarding functionality.
    /// </summary>
    public abstract class ForwardedPort : IForwardedPort
    {
        /// <summary>
        /// Gets or sets the session.
        /// </summary>
        /// <value>
        /// The session.
        /// </value>
        internal ISession Session { get; set; }

        /// <summary>
        /// The <see cref="Closing"/> event occurs as the forwarded port is being stopped.
        /// </summary>
        internal event EventHandler Closing;

        /// <summary>
        /// The <see cref="IForwardedPort.Closing"/> event occurs as the forwarded port is being stopped.
        /// </summary>
        event EventHandler IForwardedPort.Closing
        {
            add { Closing += value; }
            remove { Closing -= value; }
        }

        /// <summary>
        /// Gets or sets a value indicating whether port forwarding is started.
        /// </summary>
        /// <value>
        /// <c>true</c> if port forwarding is started; otherwise, <c>false</c>.
        /// </value>
        public abstract bool IsStarted { get; }

        /// <summary>
        /// Occurs when an exception is thrown.
        /// </summary>
        public event EventHandler<ExceptionEventArgs> Exception;

        /// <summary>
        /// Occurs when a port forwarding request is received.
        /// </summary>
        public event EventHandler<PortForwardEventArgs> RequestReceived;

        /// <summary>
        /// Starts port forwarding.
        /// </summary>
        public virtual void Start()
        {
            CheckDisposed();

            if (IsStarted)
                throw new InvalidOperationException("Forwarded port is already started.");
            if (Session == null)
                throw new InvalidOperationException("Forwarded port is not added to a client.");
            if (!Session.IsConnected)
                throw new SshConnectionException("Client not connected.");

            Session.ErrorOccured += Session_ErrorOccured;
            StartPort();
        }

        /// <summary>
        /// Stops port forwarding.
        /// </summary>
        public virtual void Stop()
        {
            CheckDisposed();

            if (!IsStarted)
                return;

            StopPort(Session.ConnectionInfo.Timeout);
        }

        /// <summary>
        /// Starts port forwarding.
        /// </summary>
        protected abstract void StartPort();

        /// <summary>
        /// Stops port forwarding, and waits for the specified timeout until all pending
        /// requests are processed.
        /// </summary>
        /// <param name="timeout">The maximum amount of time to wait for pending requests to finish processing.</param>
        protected virtual void StopPort(TimeSpan timeout)
        {
            RaiseClosing();

            if (Session != null)
            {
                Session.ErrorOccured -= Session_ErrorOccured;
            }
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (Session != null)
                {
                    Session.ErrorOccured -= Session_ErrorOccured;
                    StopPort(Session.ConnectionInfo.Timeout);
                    Session = null;
                }
            }
        }

        /// <summary>
        /// Ensures the current instance is not disposed.
        /// </summary>
        /// <exception cref="ObjectDisposedException">The current instance is disposed.</exception>
        protected abstract void CheckDisposed();

        /// <summary>
        /// Raises <see cref="Renci.SshNet.ForwardedPort.Exception"/> event.
        /// </summary>
        /// <param name="exception">The exception.</param>
        protected void RaiseExceptionEvent(Exception exception)
        {
            var handlers = Exception;
            if (handlers != null)
            {
                handlers(this, new ExceptionEventArgs(exception));
            }
        }

        /// <summary>
        /// Raises <see cref="Renci.SshNet.ForwardedPort.RequestReceived"/> event.
        /// </summary>
        /// <param name="host">Request originator host.</param>
        /// <param name="port">Request originator port.</param>
        protected void RaiseRequestReceived(string host, uint port)
        {
            var handlers = RequestReceived;
            if (handlers != null)
            {
                RequestReceived(this, new PortForwardEventArgs(host, port));
            }
        }

        /// <summary>
        /// Raises the <see cref="IForwardedPort.Closing"/> event.
        /// </summary>
        private void RaiseClosing()
        {
            var handlers = Closing;
            if (handlers != null)
            {
                handlers(this, EventArgs.Empty);
            }
        }

        /// <summary>
        /// Handles session ErrorOccured event.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="ExceptionEventArgs"/> instance containing the event data.</param>
        private void Session_ErrorOccured(object sender, ExceptionEventArgs e)
        {
            RaiseExceptionEvent(e.Exception);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\ForwardedPortDynamic.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides functionality for dynamic port forwarding
    /// </summary>
    public partial class ForwardedPortDynamic : ForwardedPort
    {
        private EventWaitHandle _listenerCompleted;

        /// <summary>
        /// Gets the bound host.
        /// </summary>
        public string BoundHost { get; private set; }

        /// <summary>
        /// Gets the bound port.
        /// </summary>
        public uint BoundPort { get; private set; }

        /// <summary>
        /// Gets or sets a value indicating whether port forwarding is started.
        /// </summary>
        /// <value>
        /// <c>true</c> if port forwarding is started; otherwise, <c>false</c>.
        /// </value>
        public override bool IsStarted
        {
            get { return _listenerCompleted != null && !_listenerCompleted.WaitOne(0); }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ForwardedPortDynamic"/> class.
        /// </summary>
        /// <param name="port">The port.</param>
        public ForwardedPortDynamic(uint port)
            : this(string.Empty, port)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ForwardedPortDynamic"/> class.
        /// </summary>
        /// <param name="host">The host.</param>
        /// <param name="port">The port.</param>
        public ForwardedPortDynamic(string host, uint port)
        {
            BoundHost = host;
            BoundPort = port;
        }

        /// <summary>
        /// Starts local port forwarding.
        /// </summary>
        protected override void StartPort()
        {
            InternalStart();
        }

        /// <summary>
        /// Stops local port forwarding, and waits for the specified timeout until all pending
        /// requests are processed.
        /// </summary>
        /// <param name="timeout">The maximum amount of time to wait for pending requests to finish processing.</param>
        protected override void StopPort(TimeSpan timeout)
        {
            if (IsStarted)
            {
                // prevent new requests from getting processed before we signal existing
                // channels that the port is closing
                StopListener();
                // signal existing channels that the port is closing
                base.StopPort(timeout);
            }
            // wait for open channels to close
            InternalStop(timeout);
        }

        /// <summary>
        /// Ensures the current instance is not disposed.
        /// </summary>
        /// <exception cref="ObjectDisposedException">The current instance is disposed.</exception>
        protected override void CheckDisposed()
        {
            if (_isDisposed)
                throw new ObjectDisposedException(GetType().FullName);
        }

        partial void InternalStart();

        /// <summary>
        /// Stops the listener.
        /// </summary>
        partial void StopListener();

        /// <summary>
        /// Waits for pending requests to finish, and channels to close.
        /// </summary>
        /// <param name="timeout">The maximum time to wait for the forwarded port to stop.</param>
        partial void InternalStop(TimeSpan timeout);

        /// <summary>
        /// Executes the specified action in a separate thread.
        /// </summary>
        /// <param name="action">The action to execute.</param>
        partial void ExecuteThread(Action action);

        #region IDisposable Members

        /// <summary>
        /// Holds a value indicating whether the current instance is disposed.
        /// </summary>
        /// <value>
        /// <c>true</c> if the current instance is disposed; otherwise, <c>false</c>.
        /// </value>
        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged ResourceMessages.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        partial void InternalDispose(bool disposing);

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected override void Dispose(bool disposing)
        {
            if (!_isDisposed)
            {
                base.Dispose(disposing);

                if (disposing)
                {
                    if (_listenerCompleted != null)
                    {
                        _listenerCompleted.Dispose();
                        _listenerCompleted = null;
                    }
                }

                InternalDispose(disposing);

                _isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="ForwardedPortLocal"/> is reclaimed by garbage collection.
        /// </summary>
        ~ForwardedPortDynamic()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\ForwardedPortDynamic.NET.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    public partial class ForwardedPortDynamic
    {
        private Socket _listener;
        private int _pendingRequests;

        partial void InternalStart()
        {
            var ip = IPAddress.Any;
            if (!string.IsNullOrEmpty(BoundHost))
            {
                ip = BoundHost.GetIPAddress();
            }

            var ep = new IPEndPoint(ip, (int)BoundPort);

            _listener = new Socket(ep.AddressFamily, SocketType.Stream, ProtocolType.Tcp) { Blocking = true };
            _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.DontLinger, true);
            _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.NoDelay, true);
            _listener.Bind(ep);
            _listener.Listen(5);

            Session.ErrorOccured += Session_ErrorOccured;
            Session.Disconnected += Session_Disconnected;

            _listenerCompleted = new ManualResetEvent(false);

            ExecuteThread(() =>
                {
                    try
                    {
                        while (true)
                        {
                            // accept new inbound connection
                            var asyncResult = _listener.BeginAccept(AcceptCallback, _listener);
                            // wait for the connection to be established
                            asyncResult.AsyncWaitHandle.WaitOne();
                        }
                    }
                    catch (ObjectDisposedException)
                    {
                        // BeginAccept will throw an ObjectDisposedException when the
                        // socket is closed
                    }
                    catch (Exception ex)
                    {
                        RaiseExceptionEvent(ex);
                    }
                    finally
                    {
                        if (Session != null)
                        {
                            Session.ErrorOccured -= Session_ErrorOccured;
                            Session.Disconnected -= Session_Disconnected;
                        }

                        // mark listener stopped
                        _listenerCompleted.Set();
                    }
                });
        }

        private void Session_Disconnected(object sender, EventArgs e)
        {
            StopListener();
        }

        private void Session_ErrorOccured(object sender, ExceptionEventArgs e)
        {
            StopListener();
        }

        private void AcceptCallback(IAsyncResult ar)
        {
            // Get the socket that handles the client request
            var serverSocket = (Socket)ar.AsyncState;

            Socket clientSocket;

            try
            {
                clientSocket = serverSocket.EndAccept(ar);
            }
            catch (ObjectDisposedException)
            {
                // when the socket is closed, an ObjectDisposedException is thrown
                // by Socket.EndAccept(IAsyncResult)
                return;
            }

            Interlocked.Increment(ref _pendingRequests);

            try
            {
                clientSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.DontLinger, true);
                clientSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.NoDelay, true);

                using (var channel = Session.CreateChannelDirectTcpip())
                {
                    channel.Exception += Channel_Exception;

                    var version = new byte[1];

                    // create eventhandler which is to be invoked to interrupt a blocking receive
                    // when we're closing the forwarded port
                    EventHandler closeClientSocket = (sender, args) => CloseSocket(clientSocket);

                    try
                    {
                        Closing += closeClientSocket;

                        var bytesRead = clientSocket.Receive(version);
                        if (bytesRead == 0)
                        {
                            CloseSocket(clientSocket);
                            return;
                        }

                        if (version[0] == 4)
                        {
                            this.HandleSocks4(clientSocket, channel);
                        }
                        else if (version[0] == 5)
                        {
                            this.HandleSocks5(clientSocket, channel);
                        }
                        else
                        {
                            throw new NotSupportedException(string.Format("SOCKS version {0} is not supported.",
                                version[0]));
                        }

                        // interrupt of blocking receive is now handled by channel (SOCKS4 and SOCKS5)
                        // or no longer necessary
                        Closing -= closeClientSocket;

                        // start receiving from client socket (and sending to server)
                        channel.Bind();
                    }
                    finally
                    {
                        channel.Close();
                    }
                }
            }
            catch (SocketException ex)
            {
                // ignore exception thrown by interrupting the blocking receive as part of closing
                // the forwarded port
                if (ex.SocketErrorCode != SocketError.Interrupted)
                {
                    RaiseExceptionEvent(ex);
                }
                CloseSocket(clientSocket);
            }
            catch (Exception exp)
            {
                RaiseExceptionEvent(exp);
                CloseSocket(clientSocket);
            }
            finally
            {
                Interlocked.Decrement(ref _pendingRequests);
            }
        }

        private static void CloseSocket(Socket socket)
        {
            if (socket.Connected)
            {
                socket.Shutdown(SocketShutdown.Both);
                socket.Close();
            }
        }

        partial void StopListener()
        {
            //  if the port is not started then there's nothing to stop
            if (!IsStarted)
                return;

            // close listener socket
            _listener.Close();
            // wait for listener loop to finish
            _listenerCompleted.WaitOne();
        }

        /// <summary>
        /// Waits for pending requests to finish, and channels to close.
        /// </summary>
        /// <param name="timeout">The maximum time to wait for the forwarded port to stop.</param>
        partial void InternalStop(TimeSpan timeout)
        {
            if (timeout == TimeSpan.Zero)
                return;

            var stopWatch = new Stopwatch();
            stopWatch.Start();

            // break out of loop when one of the following conditions are met:
            // * the forwarded port is restarted
            // * all pending requests have been processed and corresponding channel are closed
            // * the specified timeout has elapsed
            while (!IsStarted)
            {
                // break out of loop when all pending requests have been processed
                if (Interlocked.CompareExchange(ref _pendingRequests, 0, 0) == 0)
                    break;
                // break out of loop when specified timeout has elapsed
                if (stopWatch.Elapsed >= timeout && timeout != SshNet.Session.InfiniteTimeSpan)
                    break;
                // give channels time to process pending requests
                Thread.Sleep(50);
            }

            stopWatch.Stop();
        }

        partial void InternalDispose(bool disposing)
        {
            if (disposing)
            {
                if (_listener != null)
                {
                    _listener.Dispose();
                    _listener = null;
                }
            }
        }

        private void HandleSocks4(Socket socket, IChannelDirectTcpip channel)
        {
            using (var stream = new NetworkStream(socket))
            {
                var commandCode = stream.ReadByte();
                //OneCodeTODO:   See what need to be done depends on the code

                var portBuffer = new byte[2];
                stream.Read(portBuffer, 0, portBuffer.Length);
                var port = (uint)(portBuffer[0] * 256 + portBuffer[1]);

                var ipBuffer = new byte[4];
                stream.Read(ipBuffer, 0, ipBuffer.Length);
                var ipAddress = new IPAddress(ipBuffer);

                var username = ReadString(stream);

                var host = ipAddress.ToString();

                this.RaiseRequestReceived(host, port);

                channel.Open(host, port, this, socket);

                using (var writeStream = new MemoryStream())
                {
                    writeStream.WriteByte(0x00);

                    if (channel.IsOpen)
                    {
                        writeStream.WriteByte(0x5a);
                    }
                    else
                    {
                        writeStream.WriteByte(0x5b);
                    }

                    writeStream.Write(portBuffer, 0, portBuffer.Length);
                    writeStream.Write(ipBuffer, 0, ipBuffer.Length);

                    // write buffer to stream
                    var writeBuffer = writeStream.ToArray();
                    stream.Write(writeBuffer, 0, writeBuffer.Length);
                    stream.Flush();
                }
            }
        }

        private void HandleSocks5(Socket socket, IChannelDirectTcpip channel)
        {
            using (var stream = new NetworkStream(socket))
            {
                var authenticationMethodsCount = stream.ReadByte();

                var authenticationMethods = new byte[authenticationMethodsCount];
                stream.Read(authenticationMethods, 0, authenticationMethods.Length);

                if (authenticationMethods.Min() == 0)
                {
                    stream.Write(new byte[] { 0x05, 0x00 }, 0, 2);
                }
                else
                {
                    stream.Write(new byte[] { 0x05, 0xFF }, 0, 2);
                }

                var version = stream.ReadByte();

                if (version != 5)
                    throw new ProxyException("SOCKS5: Version 5 is expected.");

                var commandCode = stream.ReadByte();

                if (stream.ReadByte() != 0)
                {
                    throw new ProxyException("SOCKS5: 0 is expected.");
                }

                var addressType = stream.ReadByte();

                IPAddress ipAddress;
                byte[] addressBuffer;
                switch (addressType)
                {
                    case 0x01:
                        {
                            addressBuffer = new byte[4];
                            stream.Read(addressBuffer, 0, 4);

                            ipAddress = new IPAddress(addressBuffer);
                        }
                        break;
                    case 0x03:
                        {
                            var length = stream.ReadByte();
                            addressBuffer = new byte[length];
                            stream.Read(addressBuffer, 0, addressBuffer.Length);

                            ipAddress = IPAddress.Parse(new Common.ASCIIEncoding().GetString(addressBuffer));

                            //var hostName = new Common.ASCIIEncoding().GetString(addressBuffer);

                            //ipAddress = Dns.GetHostEntry(hostName).AddressList[0];
                        }
                        break;
                    case 0x04:
                        {
                            addressBuffer = new byte[16];
                            stream.Read(addressBuffer, 0, 16);

                            ipAddress = new IPAddress(addressBuffer);
                        }
                        break;
                    default:
                        throw new ProxyException(string.Format("SOCKS5: Address type '{0}' is not supported.", addressType));
                }

                var portBuffer = new byte[2];
                stream.Read(portBuffer, 0, portBuffer.Length);
                var port = (uint)(portBuffer[0] * 256 + portBuffer[1]);
                var host = ipAddress.ToString();

                this.RaiseRequestReceived(host, port);

                channel.Open(host, port, this, socket);

                using (var writeStream = new MemoryStream())
                {
                    writeStream.WriteByte(0x05);

                    if (channel.IsOpen)
                    {
                        writeStream.WriteByte(0x00);
                    }
                    else
                    {
                        writeStream.WriteByte(0x01);
                    }

                    writeStream.WriteByte(0x00);

                    if (ipAddress.AddressFamily == AddressFamily.InterNetwork)
                    {
                        writeStream.WriteByte(0x01);
                    }
                    else if (ipAddress.AddressFamily == AddressFamily.InterNetworkV6)
                    {
                        writeStream.WriteByte(0x04);
                    }
                    else
                    {
                        throw new NotSupportedException("Not supported address family.");
                    }

                    var addressBytes = ipAddress.GetAddressBytes();
                    writeStream.Write(addressBytes, 0, addressBytes.Length);
                    writeStream.Write(portBuffer, 0, portBuffer.Length);

                    // write buffer to stream
                    var writeBuffer = writeStream.ToArray();
                    stream.Write(writeBuffer, 0, writeBuffer.Length);
                    stream.Flush();
                }
            }
        }

        private void Channel_Exception(object sender, ExceptionEventArgs e)
        {
            RaiseExceptionEvent(e.Exception);
        }

        private static string ReadString(Stream stream)
        {
            var text = new StringBuilder();
            while (true)
            {
                var byteRead = stream.ReadByte();
                if (byteRead == 0)
                {
                    // end of the string
                    break;
                }

                if (byteRead == -1)
                {
                    // the client shut down the socket
                    break;
                }

                var c = (char)byteRead;
                text.Append(c);
            }
            return text.ToString();
        }
    }
}

#endif
// file ...\X\Renci.SshNet\ForwardedPortDynamic.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    public partial class ForwardedPortDynamic
    {
        /// <summary>
        /// Executes the specified action in a separate thread.
        /// </summary>
        /// <param name="action">The action to execute.</param>
        partial void ExecuteThread(Action action)
        {
            ThreadPool.QueueUserWorkItem(o => action());
        }
    }
}

#endif
// file ...\X\Renci.SshNet\ForwardedPortLocal.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides functionality for local port forwarding
    /// </summary>
    public partial class ForwardedPortLocal : ForwardedPort, IDisposable
    {
        private EventWaitHandle _listenerTaskCompleted;

        /// <summary>
        /// Gets the bound host.
        /// </summary>
        public string BoundHost { get; private set; }

        /// <summary>
        /// Gets the bound port.
        /// </summary>
        public uint BoundPort { get; private set; }

        /// <summary>
        /// Gets the forwarded host.
        /// </summary>
        public string Host { get; private set; }

        /// <summary>
        /// Gets the forwarded port.
        /// </summary>
        public uint Port { get; private set; }

        /// <summary>
        /// Gets or sets a value indicating whether port forwarding is started.
        /// </summary>
        /// <value>
        /// <c>true</c> if port forwarding is started; otherwise, <c>false</c>.
        /// </value>
        public override bool IsStarted
        {
            get { return _listenerTaskCompleted != null && !_listenerTaskCompleted.WaitOne(0); }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ForwardedPortLocal"/> class.
        /// </summary>
        /// <param name="boundPort">The bound port.</param>
        /// <param name="host">The host.</param>
        /// <param name="port">The port.</param>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="boundPort" /> is greater than <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="host"/> is <c>null</c>.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="port" /> is greater than <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\ForwardedPortLocalTest.cs" region="Example SshClient AddForwardedPort Start Stop ForwardedPortLocal" language="C#" title="Local port forwarding" />
        /// </example>
        public ForwardedPortLocal(uint boundPort, string host, uint port)
            : this(string.Empty, boundPort, host, port)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ForwardedPortLocal"/> class.
        /// </summary>
        /// <param name="boundHost">The bound host.</param>
        /// <param name="host">The host.</param>
        /// <param name="port">The port.</param>
        /// <exception cref="ArgumentNullException"><paramref name="boundHost"/> is <c>null</c>.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="host"/> is <c>null</c>.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="port" /> is greater than <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        public ForwardedPortLocal(string boundHost, string host, uint port)
            : this(boundHost, 0, host, port) 
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ForwardedPortLocal"/> class.
        /// </summary>
        /// <param name="boundHost">The bound host.</param>
        /// <param name="boundPort">The bound port.</param>
        /// <param name="host">The host.</param>
        /// <param name="port">The port.</param>
        /// <exception cref="ArgumentNullException"><paramref name="boundHost"/> is <c>null</c>.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="host"/> is <c>null</c>.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="boundPort" /> is greater than <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="port" /> is greater than <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        public ForwardedPortLocal(string boundHost, uint boundPort, string host, uint port)
        {
            if (boundHost == null)
                throw new ArgumentNullException("boundHost");

            if (host == null)
                throw new ArgumentNullException("host");

            boundPort.ValidatePort("boundPort");
            port.ValidatePort("port");

            this.BoundHost = boundHost;
            this.BoundPort = boundPort;
            this.Host = host;
            this.Port = port;
        }

        /// <summary>
        /// Starts local port forwarding.
        /// </summary>
        protected override void StartPort()
        {
            this.InternalStart();
        }

        /// <summary>
        /// Stops local port forwarding, and waits for the specified timeout until all pending
        /// requests are processed.
        /// </summary>
        /// <param name="timeout">The maximum amount of time to wait for pending requests to finish processing.</param>
        protected override void StopPort(TimeSpan timeout)
        {
            if (IsStarted)
            {
                // prevent new requests from getting processed before we signal existing
                // channels that the port is closing
                StopListener();
                // signal existing channels that the port is closing
                base.StopPort(timeout);
            }
            // wait for open channels to close
            InternalStop(timeout);
        }

        /// <summary>
        /// Ensures the current instance is not disposed.
        /// </summary>
        /// <exception cref="ObjectDisposedException">The current instance is disposed.</exception>
        protected override void CheckDisposed()
        {
            if (_isDisposed)
                throw new ObjectDisposedException(GetType().FullName);
        }

        partial void InternalStart();

        /// <summary>
        /// Interrupts the listener, and waits for the listener loop to finish.
        /// </summary>
        /// <remarks>
        /// When the forwarded port is stopped, then any further action is skipped.
        /// </remarks>
        partial void StopListener();

        partial void InternalStop(TimeSpan timeout);

        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected override void Dispose(bool disposing)
        {
            if (!_isDisposed)
            {
                base.Dispose(disposing);

                if (disposing)
                {
                    if (_listenerTaskCompleted != null)
                    {
                        _listenerTaskCompleted.Dispose();
                        _listenerTaskCompleted = null;
                    }
                }

                _isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="ForwardedPortLocal"/> is reclaimed by garbage collection.
        /// </summary>
        ~ForwardedPortLocal()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\ForwardedPortLocal.NET.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides functionality for local port forwarding
    /// </summary>
    public partial class ForwardedPortLocal
    {
        private Socket _listener;
        private int _pendingRequests;

        partial void ExecuteThread(Action action);

        partial void InternalStart()
        {
            var addr = BoundHost.GetIPAddress();
            var ep = new IPEndPoint(addr, (int) BoundPort);

            _listener = new Socket(ep.AddressFamily, SocketType.Stream, ProtocolType.Tcp) {Blocking = true};
            _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.NoDelay, true);
            _listener.Bind(ep);
            _listener.Listen(1);

            // update bound port (in case original was passed as zero)
            BoundPort = (uint)((IPEndPoint)_listener.LocalEndPoint).Port;

            Session.ErrorOccured += Session_ErrorOccured;
            Session.Disconnected += Session_Disconnected;

            _listenerTaskCompleted = new ManualResetEvent(false);

            ExecuteThread(() =>
                {
                    try
                    {
                        while (true)
                        {
                            // accept new inbound connection
                            var asyncResult = _listener.BeginAccept(AcceptCallback, _listener);
                            // wait for the connection to be established
                            asyncResult.AsyncWaitHandle.WaitOne();
                        }
                    }
                    catch (ObjectDisposedException)
                    {
                        // BeginAccept will throw an ObjectDisposedException when the
                        // socket is closed
                    }
                    catch (Exception ex)
                    {
                        RaiseExceptionEvent(ex);
                    }
                    finally
                    {
                        // mark listener stopped
                        _listenerTaskCompleted.Set();
                    }
                });
        }

        private void AcceptCallback(IAsyncResult ar)
        {
            // Get the socket that handles the client request
            var serverSocket = (Socket)ar.AsyncState;

            Socket clientSocket;

            try
            {
                clientSocket = serverSocket.EndAccept(ar);
            }
            catch (ObjectDisposedException)
            {
                // when the socket is closed, an ObjectDisposedException is thrown
                // by Socket.EndAccept(IAsyncResult)
                return;
            }

            Interlocked.Increment(ref _pendingRequests);

            try
            {
                clientSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.DontLinger, true);
                clientSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.NoDelay, true);

                var originatorEndPoint = (IPEndPoint) clientSocket.RemoteEndPoint;

                RaiseRequestReceived(originatorEndPoint.Address.ToString(),
                    (uint)originatorEndPoint.Port);

                using (var channel = Session.CreateChannelDirectTcpip())
                {
                    channel.Exception += Channel_Exception;
                    channel.Open(Host, Port, this, clientSocket);
                    channel.Bind();
                    channel.Close();
                }
            }
            catch (Exception exp)
            {
                RaiseExceptionEvent(exp);
                CloseSocket(clientSocket);
            }
            finally
            {
                Interlocked.Decrement(ref _pendingRequests);
            }
        }

        private static void CloseSocket(Socket socket)
        {
            if (socket.Connected)
            {
                socket.Shutdown(SocketShutdown.Both);
                socket.Close();
            }
        }

        partial void InternalStop(TimeSpan timeout)
        {
            if (timeout == TimeSpan.Zero)
                return;

            var stopWatch = new Stopwatch();
            stopWatch.Start();

            while (true)
            {
                // break out of loop when all pending requests have been processed
                if (Interlocked.CompareExchange(ref _pendingRequests, 0, 0) == 0)
                    break;
                // break out of loop when specified timeout has elapsed
                if (stopWatch.Elapsed >= timeout && timeout != SshNet.Session.InfiniteTimeSpan)
                    break;
                // give channels time to process pending requests
                Thread.Sleep(50);
            }

            stopWatch.Stop();
        }

        /// <summary>
        /// Interrupts the listener, and waits for the listener loop to finish.
        /// </summary>
        /// <remarks>
        /// When the forwarded port is stopped, then any further action is skipped.
        /// </remarks>
        partial void StopListener()
        {
            if (!IsStarted)
                return;

            Session.Disconnected -= Session_Disconnected;
            Session.ErrorOccured -= Session_ErrorOccured;

            // close listener socket
            _listener.Close();
            // wait for listener loop to finish
            _listenerTaskCompleted.WaitOne();
        }

        private void Session_ErrorOccured(object sender, Common.ExceptionEventArgs e)
        {
            StopListener();
        }

        private void Session_Disconnected(object sender, EventArgs e)
        {
            StopListener();
        }

        private void Channel_Exception(object sender, ExceptionEventArgs e)
        {
            RaiseExceptionEvent(e.Exception);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\ForwardedPortLocal.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides functionality for local port forwarding
    /// </summary>
    public partial class ForwardedPortLocal 
    {
        /// <summary>
        /// Executes the specified action in a separate thread.
        /// </summary>
        /// <param name="action">The action to execute.</param>
        partial void ExecuteThread(Action action)
        {
            ThreadPool.QueueUserWorkItem(o => action());
        }
    }
}

#endif
// file ...\X\Renci.SshNet\ForwardedPortRemote.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides functionality for remote port forwarding
    /// </summary>
    public partial class ForwardedPortRemote : ForwardedPort, IDisposable
    {
        private bool _requestStatus;

        private EventWaitHandle _globalRequestResponse = new AutoResetEvent(false);
        private int _pendingRequests;
        private bool _isStarted;

        /// <summary>
        /// Gets or sets a value indicating whether port forwarding is started.
        /// </summary>
        /// <value>
        /// <c>true</c> if port forwarding is started; otherwise, <c>false</c>.
        /// </value>
        public override bool IsStarted
        {
            get { return _isStarted; }
        }

        /// <summary>
        /// Gets the bound host.
        /// </summary>
        public IPAddress BoundHostAddress { get; private set; }

        /// <summary>
        /// Gets the bound host.
        /// </summary>
        public string BoundHost
        {
            get
            {
                return BoundHostAddress.ToString();
            }
        }

        /// <summary>
        /// Gets the bound port.
        /// </summary>
        public uint BoundPort { get; private set; }

        /// <summary>
        /// Gets the forwarded host.
        /// </summary>
        public IPAddress HostAddress { get; private set; }

        /// <summary>
        /// Gets the forwarded host.
        /// </summary>
        public string Host
        {
            get
            {
                return HostAddress.ToString();
            }
        }

        /// <summary>
        /// Gets the forwarded port.
        /// </summary>
        public uint Port { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ForwardedPortRemote" /> class.
        /// </summary>
        /// <param name="boundHostAddress">The bound host address.</param>
        /// <param name="boundPort">The bound port.</param>
        /// <param name="hostAddress">The host address.</param>
        /// <param name="port">The port.</param>
        /// <exception cref="ArgumentNullException"><paramref name="boundHostAddress"/> is <c>null</c>.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="hostAddress"/> is <c>null</c>.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="boundPort" /> is greater than <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="port" /> is greater than <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        public ForwardedPortRemote(IPAddress boundHostAddress, uint boundPort, IPAddress hostAddress, uint port)
        {
            if (boundHostAddress == null)
                throw new ArgumentNullException("boundHostAddress");
            if (hostAddress == null)
                throw new ArgumentNullException("hostAddress");

            boundPort.ValidatePort("boundPort");
            port.ValidatePort("port");

            BoundHostAddress = boundHostAddress;
            BoundPort = boundPort;
            HostAddress = hostAddress;
            Port = port;
        }

        /// <summary>
        /// Starts remote port forwarding.
        /// </summary>
        protected override void StartPort()
        {
            Session.RegisterMessage("SSH_MSG_REQUEST_FAILURE");
            Session.RegisterMessage("SSH_MSG_REQUEST_SUCCESS");
            Session.RegisterMessage("SSH_MSG_CHANNEL_OPEN");

            Session.RequestSuccessReceived += Session_RequestSuccess;
            Session.RequestFailureReceived += Session_RequestFailure;
            Session.ChannelOpenReceived += Session_ChannelOpening;

            // send global request to start direct tcpip
            Session.SendMessage(new GlobalRequestMessage(GlobalRequestName.TcpIpForward, true, BoundHost, BoundPort));
            // wat for response on global request to start direct tcpip
            Session.WaitOnHandle(_globalRequestResponse);

            if (!_requestStatus)
            {
                // when the request to start port forward was rejected, then we're no longer
                // interested in these events
                Session.RequestSuccessReceived -= Session_RequestSuccess;
                Session.RequestFailureReceived -= Session_RequestFailure;
                Session.ChannelOpenReceived -= Session_ChannelOpening;

                throw new SshException(string.Format(CultureInfo.CurrentCulture, "Port forwarding for '{0}' port '{1}' failed to start.", Host, Port));
            }

            _isStarted = true;
        }

        /// <summary>
        /// Stops remote port forwarding.
        /// </summary>
        /// <param name="timeout">The maximum amount of time to wait for pending requests to finish processing.</param>
        protected override void StopPort(TimeSpan timeout)
        {
            // if the port not started, then there's nothing to stop
            if (!IsStarted)
                return;

            // mark forwarded port stopped, this also causes open of new channels to be rejected
            _isStarted = false;

            base.StopPort(timeout);

            // send global request to cancel direct tcpip
            Session.SendMessage(new GlobalRequestMessage(GlobalRequestName.CancelTcpIpForward, true, BoundHost, BoundPort));
            // wait for response on global request to cancel direct tcpip or completion of message
            // listener loop (in which case response on global request can never be received)
            WaitHandle.WaitAny(new[] { _globalRequestResponse, Session.MessageListenerCompleted }, timeout);

            // unsubscribe from session events as either the tcpip forward is cancelled at the
            // server, or our session message loop has completed
            Session.RequestSuccessReceived -= Session_RequestSuccess;
            Session.RequestFailureReceived -= Session_RequestFailure;
            Session.ChannelOpenReceived -= Session_ChannelOpening;

            var startWaiting = DateTime.Now;

            while (true)
            {
                // break out of loop when all pending requests have been processed
                if (Interlocked.CompareExchange(ref _pendingRequests, 0, 0) == 0)
                    break;
                // determine time elapsed since waiting for pending requests to finish
                var elapsed = DateTime.Now - startWaiting;
                // break out of loop when specified timeout has elapsed
                if (elapsed >= timeout && timeout != SshNet.Session.InfiniteTimeSpan)
                    break;
                // give channels time to process pending requests
                Thread.Sleep(50);
            }
        }

        /// <summary>
        /// Ensures the current instance is not disposed.
        /// </summary>
        /// <exception cref="ObjectDisposedException">The current instance is disposed.</exception>
        protected override void CheckDisposed()
        {
            if (_isDisposed)
                throw new ObjectDisposedException(GetType().FullName);
        }

        private void Session_ChannelOpening(object sender, MessageEventArgs<ChannelOpenMessage> e)
        {
            var channelOpenMessage = e.Message;
            var info = channelOpenMessage.Info as ForwardedTcpipChannelInfo;
            if (info != null)
            {
                //  Ensure this is the corresponding request
                if (info.ConnectedAddress == BoundHost && info.ConnectedPort == BoundPort)
                {
                    if (!_isStarted)
                    {
                        Session.SendMessage(new ChannelOpenFailureMessage(channelOpenMessage.LocalChannelNumber, "", ChannelOpenFailureMessage.AdministrativelyProhibited));
                        return;
                    }

                    ExecuteThread(() =>
                        {
                            Interlocked.Increment(ref _pendingRequests);

                            try
                            {
                                RaiseRequestReceived(info.OriginatorAddress, info.OriginatorPort);

                                using (var channel = Session.CreateChannelForwardedTcpip(channelOpenMessage.LocalChannelNumber, channelOpenMessage.InitialWindowSize, channelOpenMessage.MaximumPacketSize))
                                {
                                    channel.Exception += Channel_Exception;
                                    channel.Bind(new IPEndPoint(HostAddress, (int) Port), this);
                                    channel.Close();
                                }
                            }
                            catch (Exception exp)
                            {
                                RaiseExceptionEvent(exp);
                            }
                            finally
                            {
                                Interlocked.Decrement(ref _pendingRequests);
                            }
                        });
                }
            }
        }

        private void Channel_Exception(object sender, ExceptionEventArgs exceptionEventArgs)
        {
            RaiseExceptionEvent(exceptionEventArgs.Exception);
        }

        private void Session_RequestFailure(object sender, EventArgs e)
        {
            _requestStatus = false;
            _globalRequestResponse.Set();
        }

        private void Session_RequestSuccess(object sender, MessageEventArgs<RequestSuccessMessage> e)
        {
            _requestStatus = true;
            if (BoundPort == 0)
            {
                BoundPort = (e.Message.BoundPort == null) ? 0 : e.Message.BoundPort.Value;
            }

            _globalRequestResponse.Set();
        }

        partial void ExecuteThread(Action action);

        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected override void Dispose(bool disposing)
        {
            if (!_isDisposed)
            {
                base.Dispose(disposing);

                if (disposing)
                {
                    if (Session != null)
                    {
                        Session.RequestSuccessReceived -= Session_RequestSuccess;
                        Session.RequestFailureReceived -= Session_RequestFailure;
                        Session.ChannelOpenReceived -= Session_ChannelOpening;
                        Session = null;
                    }
                    if (_globalRequestResponse != null)
                    {
                        _globalRequestResponse.Dispose();
                        _globalRequestResponse = null;
                    }
                }

                _isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="ForwardedPortRemote"/> is reclaimed by garbage collection.
        /// </summary>
        ~ForwardedPortRemote()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\ForwardedPortRemote.NET.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides functionality for remote port forwarding
    /// </summary>
    public partial class ForwardedPortRemote
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ForwardedPortRemote"/> class.
        /// </summary>
        /// <param name="boundPort">The bound port.</param>
        /// <param name="host">The host.</param>
        /// <param name="port">The port.</param>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\ForwardedPortRemoteTest.cs" region="Example SshClient AddForwardedPort Start Stop ForwardedPortRemote" language="C#" title="Remote port forwarding" />
        /// </example>
        public ForwardedPortRemote(uint boundPort, string host, uint port)
            : this(string.Empty, boundPort, host, port)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ForwardedPortRemote"/> class.
        /// </summary>
        /// <param name="boundHost">The bound host.</param>
        /// <param name="boundPort">The bound port.</param>
        /// <param name="host">The host.</param>
        /// <param name="port">The port.</param>
        public ForwardedPortRemote(string boundHost, uint boundPort, string host, uint port)
            : this(Dns.GetHostEntry(boundHost).AddressList[0], boundPort, Dns.GetHostEntry(host).AddressList[0], port)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\ForwardedPortRemote.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides functionality for remote port forwarding
    /// </summary>
    public partial class ForwardedPortRemote
    {
        /// <summary>
        /// Executes the specified action in a separate thread.
        /// </summary>
        /// <param name="action">The action to execute.</param>
        partial void ExecuteThread(Action action)
        {
            ThreadPool.QueueUserWorkItem(o => action());
        }
    }
}

#endif
// file ...\X\Renci.SshNet\HashInfo.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Holds information about key size and cipher to use
    /// </summary>
    public class HashInfo
    {
        /// <summary>
        /// Gets the size of the key.
        /// </summary>
        /// <value>
        /// The size of the key.
        /// </value>
        public int KeySize { get; private set; }

        /// <summary>
        /// Gets the cipher.
        /// </summary>
        public Func<byte[], HashAlgorithm> HashAlgorithm { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="CipherInfo"/> class.
        /// </summary>
        /// <param name="keySize">Size of the key.</param>
        /// <param name="hash">The hash algorithm to use for a given key.</param>
        public HashInfo(int keySize, Func<byte[], HashAlgorithm> hash)
        {
            this.KeySize = keySize;
            this.HashAlgorithm = key => (hash(key.Take(this.KeySize / 8).ToArray()));
        }
    }
}

#endif
// file ...\X\Renci.SshNet\IAuthenticationMethod.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Base interface for authentication of a session using a given method.
    /// </summary>
    public interface IAuthenticationMethod
    {
        /// <summary>
        /// Authenticates the specified session.
        /// </summary>
        /// <param name="session">The session to authenticate.</param>
        /// <returns>
        /// The result of the authentication process.
        /// </returns>
        AuthenticationResult Authenticate(ISession session);

        /// <summary>
        /// Gets the list of allowed authentications.
        /// </summary>
        /// <value>
        /// The list of allowed authentications.
        /// </value>
        IEnumerable<string> AllowedAuthentications { get; }

        /// <summary>
        /// Gets the name of the authentication method.
        /// </summary>
        /// <value>
        /// The name of the authentication method.
        /// </value>
        string Name { get; }
    }
}

#endif
// file ...\X\Renci.SshNet\IConnectionInfo.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    public interface IConnectionInfoInternal : IConnectionInfo
    {
        /// <summary>
        /// Signals that an authentication banner message was received from the server.
        /// </summary>
        /// <param name="sender">The session in which the banner message was received.</param>
        /// <param name="e">The banner message.{</param>
        void UserAuthenticationBannerReceived(object sender, MessageEventArgs<BannerMessage> e);

        /// <summary>
        /// Gets the supported authentication methods for this connection.
        /// </summary>
        /// <value>
        /// The supported authentication methods for this connection.
        /// </value>
        IEnumerable<IAuthenticationMethod> AuthenticationMethods { get; }

        /// <summary>
        /// Creates a <see cref="NoneAuthenticationMethod"/> for the credentials represented
        /// by the current <see cref="IConnectionInfo"/>.
        /// </summary>
        /// <returns>
        /// A <see cref="NoneAuthenticationMethod"/> for the credentials represented by the
        /// current <see cref="IConnectionInfo"/>.
        /// </returns>
        IAuthenticationMethod CreateNoneAuthenticationMethod();
    }

    /// <summary>
    /// Represents remote connection information.
    /// </summary>
    public interface IConnectionInfo
    {
        /// <summary>
        /// Gets the supported channel requests for this connection.
        /// </summary>
        /// <value>
        /// The supported channel requests for this connection.
        /// </value>
        IDictionary<string, RequestInfo> ChannelRequests { get; }

        /// <summary>
        /// Gets the character encoding.
        /// </summary>
        /// <value>
        /// The character encoding.
        /// </value>
        Encoding Encoding { get; }

        /// <summary>
        /// Gets the number of retry attempts when session channel creation failed.
        /// </summary>
        /// <value>
        /// The number of retry attempts when session channel creation failed.
        /// </value>
        int RetryAttempts { get; }

        /// <summary>
        /// Gets or sets connection timeout.
        /// </summary>
        /// <value>
        /// The connection timeout. The default value is 30 seconds.
        /// </value>
        /// <example>
        ///   <code source="..\..\Renci.SshNet.Tests\Classes\SshClientTest.cs" region="Example SshClient Connect Timeout" language="C#" title="Specify connection timeout" />
        /// </example>
        TimeSpan Timeout { get; }

        /// <summary>
        /// Occurs when authentication banner is sent by the server.
        /// </summary>
        event EventHandler<AuthenticationBannerEventArgs> AuthenticationBanner;
    }
}

#endif
// file ...\X\Renci.SshNet\IForwardedPort.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Supports port forwarding functionality.
    /// </summary>
    public interface IForwardedPort
    {
        /// <summary>
        /// The <see cref="Closing"/> event occurs as the forwarded port is being stopped.
        /// </summary>
        event EventHandler Closing;
    }
}

#endif
// file ...\X\Renci.SshNet\IServiceFactory.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Factory for creating new services.
    /// </summary>
    public partial interface IServiceFactory
    {
        /// <summary>
        /// Creates a new <see cref="ISession"/> with the specified <see cref="ConnectionInfo"/>.
        /// </summary>
        /// <param name="connectionInfo">The <see cref="ConnectionInfo"/> to use for creating a new session.</param>
        /// <returns>
        /// An <see cref="ISession"/> for the specified <see cref="ConnectionInfo"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="connectionInfo"/> is <c>null</c>.</exception>
        ISession CreateSession(ConnectionInfo connectionInfo);

        /// <summary>
        /// Creates a new <see cref="ISftpSession"/> in a given <see cref="ISession"/> and with
        /// the specified operation timeout and encoding.
        /// </summary>
        /// <param name="session">The <see cref="ISession"/> to create the <see cref="ISftpSession"/> in.</param>
        /// <param name="operationTimeout">The operation timeout.</param>
        /// <param name="encoding">The encoding.</param>
        /// <returns>
        /// An <see cref="ISftpSession"/>.
        /// </returns>
        ISftpSession CreateSftpSession(ISession session, TimeSpan operationTimeout, Encoding encoding);

        /// <summary>
        /// Create a new <see cref="PipeStream"/>.
        /// </summary>
        /// <returns>
        /// A <see cref="PipeStream"/>.
        /// </returns>
        PipeStream CreatePipeStream();
    }
}

#endif
// file ...\X\Renci.SshNet\IServiceFactory.NET.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    public partial interface IServiceFactory
    {
        /// <summary>
        /// Creates a new <see cref="INetConfSession"/> in a given <see cref="ISession"/>
        /// and with the specified operation timeout.
        /// </summary>
        /// <param name="session">The <see cref="ISession"/> to create the <see cref="INetConfSession"/> in.</param>
        /// <param name="operationTimeout">The operation timeout.</param>
        /// <returns>
        /// An <see cref="INetConfSession"/>.
        /// </returns>
        INetConfSession CreateNetConfSession(ISession session, TimeSpan operationTimeout);
    }
}

#endif
// file ...\X\Renci.SshNet\ISession.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides functionality to connect and interact with SSH server.
    /// </summary>
    public interface ISession : IDisposable
    {
        /// <summary>
        /// Gets or sets the connection info.
        /// </summary>
        /// <value>The connection info.</value>
        IConnectionInfo ConnectionInfo { get; }

        /// <summary>
        /// Gets a value indicating whether the session is connected.
        /// </summary>
        /// <value>
        /// <c>true</c> if the session is connected; otherwise, <c>false</c>.
        /// </value>
        bool IsConnected { get; }

        /// <summary>
        /// Gets the session semaphore that controls session channels.
        /// </summary>
        /// <value>
        /// The session semaphore.
        /// </value>
        SemaphoreLight SessionSemaphore { get; }

        /// <summary>
        /// Gets a <see cref="WaitHandle"/> that can be used to wait for the message listener loop to complete.
        /// </summary>
        /// <value>
        /// A <see cref="WaitHandle"/> that can be used to wait for the message listener loop to complete, or
        /// <c>null</c> when the session has not been connected.
        /// </value>
        WaitHandle MessageListenerCompleted { get; }

        /// <summary>
        /// Connects to the server.
        /// </summary>
        /// <exception cref="SocketException">Socket connection to the SSH server or proxy server could not be established, or an error occurred while resolving the hostname.</exception>
        /// <exception cref="SshConnectionException">SSH session could not be established.</exception>
        /// <exception cref="SshAuthenticationException">Authentication of SSH session failed.</exception>
        /// <exception cref="ProxyException">Failed to establish proxy connection.</exception>
        void Connect();

        /// <summary>
        /// Create a new SSH session channel.
        /// </summary>
        /// <returns>
        /// A new SSH session channel.
        /// </returns>
        IChannelSession CreateChannelSession();

        /// <summary>
        /// Create a new channel for a locally forwarded TCP/IP port.
        /// </summary>
        /// <returns>
        /// A new channel for a locally forwarded TCP/IP port.
        /// </returns>
        IChannelDirectTcpip CreateChannelDirectTcpip();

        /// <summary>
        /// Creates a "forwarded-tcpip" SSH channel.
        /// </summary>
        /// <returns>
        /// A new "forwarded-tcpip" SSH channel.
        /// </returns>
        IChannelForwardedTcpip CreateChannelForwardedTcpip(uint remoteChannelNumber, uint remoteWindowSize, uint remoteChannelDataPacketSize);

        /// <summary>
        /// Disconnects from the server.
        /// </summary>
        /// <remarks>
        /// This sends a <b>SSH_MSG_DISCONNECT</b> message to the server, waits for the
        /// server to close the socket on its end and subsequently closes the client socket.
        /// </remarks>
        void Disconnect();

        /// <summary>
        /// Called when client is disconnecting from the server.
        /// </summary>
        void OnDisconnecting();

        /// <summary>
        /// Registers SSH message with the session.
        /// </summary>
        /// <param name="messageName">The name of the message to register with the session.</param>
        void RegisterMessage(string messageName);

        /// <summary>
        /// Sends a message to the server.
        /// </summary>
        /// <param name="message">The message to send.</param>
        /// <exception cref="SshConnectionException">The client is not connected.</exception>
        /// <exception cref="SshOperationTimeoutException">The operation timed out.</exception>
        /// <exception cref="InvalidOperationException">The size of the packet exceeds the maximum size defined by the protocol.</exception>
        void SendMessage(MessageRenci message);

        /// <summary>
        /// Sends a message to the server.
        /// </summary>
        /// <param name="message">The message to send.</param>
        /// <returns>
        /// <c>true</c> if the message was sent to the server; otherwise, <c>false</c>.
        /// </returns>
        /// <exception cref="InvalidOperationException">The size of the packet exceeds the maximum size defined by the protocol.</exception>
        /// <remarks>
        /// This methods returns <c>false</c> when the attempt to send the message results in a
        /// <see cref="SocketException"/> or a <see cref="SshException"/>.
        /// </remarks>
        bool TrySendMessage(MessageRenci message);

        /// <summary>
        /// Unregister SSH message from the session.
        /// </summary>
        /// <param name="messageName">The name of the message to unregister with the session.</param>
        void UnRegisterMessage(string messageName);

        /// <summary>
        /// Waits for the specified handle or the exception handle for the receive thread
        /// to signal within the connection timeout.
        /// </summary>
        /// <param name="waitHandle">The wait handle.</param>
        /// <exception cref="SshConnectionException">A received package was invalid or failed the message integrity check.</exception>
        /// <exception cref="SshOperationTimeoutException">None of the handles are signaled in time and the session is not disconnecting.</exception>
        /// <exception cref="SocketException">A socket error was signaled while receiving messages from the server.</exception>
        /// <remarks>
        /// When neither handles are signaled in time and the session is not closing, then the
        /// session is disconnected.
        /// </remarks>
        void WaitOnHandle(WaitHandle waitHandle);

        /// <summary>
        /// Waits for the specified handle or the exception handle for the receive thread
        /// to signal within the specified timeout.
        /// </summary>
        /// <param name="waitHandle">The wait handle.</param>
        /// <param name="timeout">The time to wait for any of the handles to become signaled.</param>
        /// <exception cref="SshConnectionException">A received package was invalid or failed the message integrity check.</exception>
        /// <exception cref="SshOperationTimeoutException">None of the handles are signaled in time and the session is not disconnecting.</exception>
        /// <exception cref="SocketException">A socket error was signaled while receiving messages from the server.</exception>
        /// <remarks>
        /// When neither handles are signaled in time and the session is not closing, then the
        /// session is disconnected.
        /// </remarks>
        void WaitOnHandle(WaitHandle waitHandle, TimeSpan timeout);

        /// <summary>
        /// Occurs when <see cref="ChannelCloseMessage"/> message received
        /// </summary>
        event EventHandler<MessageEventArgs<ChannelCloseMessage>> ChannelCloseReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelDataMessage"/> message received
        /// </summary>
        event EventHandler<MessageEventArgs<ChannelDataMessage>> ChannelDataReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelEofMessage"/> message received
        /// </summary>
        event EventHandler<MessageEventArgs<ChannelEofMessage>> ChannelEofReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelExtendedDataMessage"/> message received
        /// </summary>
        event EventHandler<MessageEventArgs<ChannelExtendedDataMessage>> ChannelExtendedDataReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelFailureMessage"/> message received
        /// </summary>
        event EventHandler<MessageEventArgs<ChannelFailureMessage>> ChannelFailureReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelOpenConfirmationMessage"/> message received
        /// </summary>
        event EventHandler<MessageEventArgs<ChannelOpenConfirmationMessage>> ChannelOpenConfirmationReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelOpenFailureMessage"/> message received
        /// </summary>
        event EventHandler<MessageEventArgs<ChannelOpenFailureMessage>> ChannelOpenFailureReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelOpenMessage"/> message received
        /// </summary>
        event EventHandler<MessageEventArgs<ChannelOpenMessage>> ChannelOpenReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelRequestMessage"/> message received
        /// </summary>
        event EventHandler<MessageEventArgs<ChannelRequestMessage>> ChannelRequestReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelSuccessMessage"/> message received
        /// </summary>
        event EventHandler<MessageEventArgs<ChannelSuccessMessage>> ChannelSuccessReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelWindowAdjustMessage"/> message received
        /// </summary>
        event EventHandler<MessageEventArgs<ChannelWindowAdjustMessage>> ChannelWindowAdjustReceived;

        /// <summary>
        /// Occurs when session has been disconnected from the server.
        /// </summary>
        event EventHandler<EventArgs> Disconnected;

        /// <summary>
        /// Occurs when an error occurred.
        /// </summary>
        event EventHandler<ExceptionEventArgs> ErrorOccured;

        /// <summary>
        /// Occurs when host key received.
        /// </summary>
        event EventHandler<HostKeyEventArgs> HostKeyReceived;

        /// <summary>
        /// Occurs when <see cref="RequestSuccessMessage"/> message received
        /// </summary>
        event EventHandler<MessageEventArgs<RequestSuccessMessage>> RequestSuccessReceived;

        /// <summary>
        /// Occurs when <see cref="RequestFailureMessage"/> message received
        /// </summary>
        event EventHandler<MessageEventArgs<RequestFailureMessage>> RequestFailureReceived;

        /// <summary>
        /// Occurs when <see cref="BannerMessage"/> message is received from the server.
        /// </summary>
        event EventHandler<MessageEventArgs<BannerMessage>> UserAuthenticationBannerReceived;
    }
}

#endif
// file ...\X\Renci.SshNet\ISubsystemSession.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Base interface for SSH subsystem implementations.
    /// </summary>
    public interface ISubsystemSession : IDisposable
    {
        /// <summary>
        /// Gets a value indicating whether this session is open.
        /// </summary>
        /// <value>
        /// <c>true</c> if this session is open; otherwise, <c>false</c>.
        /// </value>
        bool IsOpen { get; }

        /// <summary>
        /// Connects the subsystem using a new SSH channel session.
        /// </summary>
        /// <exception cref="InvalidOperationException">The session is already connected.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the session was disposed.</exception>
        void Connect();

        /// <summary>
        /// Disconnects the subsystem channel.
        /// </summary>
        void Disconnect();

        /// <summary>
        /// Waits a specified time for a given <see cref="WaitHandle"/> to get signaled.
        /// </summary>
        /// <param name="waitHandle">The handle to wait for.</param>
        /// <param name="operationTimeout">The time to wait for <paramref name="waitHandle"/> to get signaled.</param>
        /// <exception cref="SshException">The connection was closed by the server.</exception>
        /// <exception cref="SshException">The channel was closed.</exception>
        /// <exception cref="SshOperationTimeoutException">The handle did not get signaled within the specified <paramref name="operationTimeout"/>.</exception>
        void WaitOnHandle(WaitHandle waitHandle, TimeSpan operationTimeout);
    }
}

#endif
// file ...\X\Renci.SshNet\KeyboardInteractiveAuthenticationMethod.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides functionality to perform keyboard interactive authentication.
    /// </summary>
    public partial class KeyboardInteractiveAuthenticationMethod : AuthenticationMethod, IDisposable
    {
        private AuthenticationResult _authenticationResult = AuthenticationResult.Failure;

        private Session _session;

        private EventWaitHandle _authenticationCompleted = new AutoResetEvent(false);

        private Exception _exception;

        private readonly RequestMessage _requestMessage;

        /// <summary>
        /// Gets authentication method name
        /// </summary>
        public override string Name
        {
            get { return this._requestMessage.MethodName; }
        }

        /// <summary>
        /// Occurs when server prompts for more authentication information.
        /// </summary>
        public event EventHandler<AuthenticationPromptEventArgs> AuthenticationPrompt;

        /// <summary>
        /// Initializes a new instance of the <see cref="KeyboardInteractiveAuthenticationMethod"/> class.
        /// </summary>
        /// <param name="username">The username.</param>
        /// <exception cref="ArgumentException"><paramref name="username"/> is whitespace or null.</exception>
        public KeyboardInteractiveAuthenticationMethod(string username)
            : base(username)
        {
            this._requestMessage = new RequestMessageKeyboardInteractive(ServiceName.Connection, username);
        }

        /// <summary>
        /// Authenticates the specified session.
        /// </summary>
        /// <param name="session">The session to authenticate.</param>
        /// <returns>Result of authentication  process.</returns>
        public override AuthenticationResult Authenticate(Session session)
        {
            this._session = session;

            session.UserAuthenticationSuccessReceived += Session_UserAuthenticationSuccessReceived;
            session.UserAuthenticationFailureReceived += Session_UserAuthenticationFailureReceived;
            session.MessageReceived += Session_MessageReceived;

            session.RegisterMessage("SSH_MSG_USERAUTH_INFO_REQUEST");

            session.SendMessage(this._requestMessage);

            session.WaitOnHandle(this._authenticationCompleted);

            session.UnRegisterMessage("SSH_MSG_USERAUTH_INFO_REQUEST");


            session.UserAuthenticationSuccessReceived -= Session_UserAuthenticationSuccessReceived;
            session.UserAuthenticationFailureReceived -= Session_UserAuthenticationFailureReceived;
            session.MessageReceived -= Session_MessageReceived;


            if (this._exception != null)
            {
                throw this._exception;
            }

            return this._authenticationResult;
        }

        private void Session_UserAuthenticationSuccessReceived(object sender, MessageEventArgs<SuccessMessage> e)
        {
            this._authenticationResult = AuthenticationResult.Success;

            this._authenticationCompleted.Set();
        }

        private void Session_UserAuthenticationFailureReceived(object sender, MessageEventArgs<FailureMessage> e)
        {
            if (e.Message.PartialSuccess)
                this._authenticationResult = AuthenticationResult.PartialSuccess;
            else
                this._authenticationResult = AuthenticationResult.Failure;

            //  Copy allowed authentication methods
            this.AllowedAuthentications = e.Message.AllowedAuthentications.ToList();

            this._authenticationCompleted.Set();
        }

        private void Session_MessageReceived(object sender, MessageEventArgs<MessageRenci> e)
        {
            var informationRequestMessage = e.Message as InformationRequestMessage;
            if (informationRequestMessage != null)
            {
                var eventArgs = new AuthenticationPromptEventArgs(this.Username, informationRequestMessage.Instruction, informationRequestMessage.Language, informationRequestMessage.Prompts);

                this.ExecuteThread(() =>
                {
                    try
                    {
                        if (this.AuthenticationPrompt != null)
                        {
                            this.AuthenticationPrompt(this, eventArgs);
                        }

                        var informationResponse = new InformationResponseMessage();

                        foreach (var response in from r in eventArgs.Prompts orderby r.Id ascending select r.Response)
                        {
                            informationResponse.Responses.Add(response);
                        }

                        //  Send information response message
                        this._session.SendMessage(informationResponse);
                    }
                    catch (Exception exp)
                    {
                        this._exception = exp;
                        this._authenticationCompleted.Set();
                    }
                });
            }
        }

        partial void ExecuteThread(Action action);

        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!this._isDisposed)
            {
                // If disposing equals true, dispose all managed
                // and unmanaged resources.
                if (disposing)
                {
                    // Dispose managed resources.
                    if (this._authenticationCompleted != null)
                    {
                        this._authenticationCompleted.Dispose();
                        this._authenticationCompleted = null;
                    }
                }

                // Note disposing has been done.
                _isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="PasswordConnectionInfo"/> is reclaimed by garbage collection.
        /// </summary>
        ~KeyboardInteractiveAuthenticationMethod()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion

    }
}

#endif
// file ...\X\Renci.SshNet\KeyboardInteractiveAuthenticationMethod.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    public partial  class KeyboardInteractiveAuthenticationMethod : AuthenticationMethod
    {
        /// <summary>
        /// Executes the specified action in a separate thread.
        /// </summary>
        /// <param name="action">The action to execute.</param>
        partial void ExecuteThread(Action action)
        {
            ThreadPool.QueueUserWorkItem(o => action());
        }
    }
}

#endif
// file ...\X\Renci.SshNet\KeyboardInteractiveConnectionInfo.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides connection information when keyboard interactive authentication method is used
    /// </summary>
    /// <example>
    ///     <code source="..\..\Renci.SshNet.Tests\Classes\KeyboardInteractiveConnectionInfoTest.cs" region="Example KeyboardInteractiveConnectionInfo AuthenticationPrompt" language="C#" title="Connect using interactive method" />
    /// </example>
    public class KeyboardInteractiveConnectionInfo : ConnectionInfo, IDisposable
    {
        /// <summary>
        /// Occurs when server prompts for more authentication information.
        /// </summary>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\KeyboardInteractiveConnectionInfoTest.cs" region="Example KeyboardInteractiveConnectionInfo AuthenticationPrompt" language="C#" title="Connect using interactive method" />
        /// </example>
        public event EventHandler<AuthenticationPromptEventArgs> AuthenticationPrompt;

        //OneCodeTODO: DOCS Add exception documentation for this class.

        /// <summary>
        /// Initializes a new instance of the <see cref="KeyboardInteractiveConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">The host.</param>
        /// <param name="username">The username.</param>
        public KeyboardInteractiveConnectionInfo(string host, string username)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, ProxyTypes.None, string.Empty, 0, string.Empty, string.Empty)
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="KeyboardInteractiveConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">The host.</param>
        /// <param name="port">The port.</param>
        /// <param name="username">The username.</param>
        public KeyboardInteractiveConnectionInfo(string host, int port, string username)
            : this(host, port, username, ProxyTypes.None, string.Empty, 0, string.Empty, string.Empty)
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="KeyboardInteractiveConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">Connection port.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        public KeyboardInteractiveConnectionInfo(string host, int port, string username, ProxyTypes proxyType, string proxyHost, int proxyPort)
            : this(host, port, username, proxyType, proxyHost, proxyPort, string.Empty, string.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="KeyboardInteractiveConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">Connection port.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="proxyUsername">The proxy username.</param>
        public KeyboardInteractiveConnectionInfo(string host, int port, string username, ProxyTypes proxyType, string proxyHost, int proxyPort, string proxyUsername)
            : this(host, port, username, proxyType, proxyHost, proxyPort, proxyUsername, string.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="KeyboardInteractiveConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        public KeyboardInteractiveConnectionInfo(string host, string username, ProxyTypes proxyType, string proxyHost, int proxyPort)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, proxyType, proxyHost, proxyPort, string.Empty, string.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="KeyboardInteractiveConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="proxyUsername">The proxy username.</param>
        public KeyboardInteractiveConnectionInfo(string host, string username, ProxyTypes proxyType, string proxyHost, int proxyPort, string proxyUsername)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, proxyType, proxyHost, proxyPort, proxyUsername, string.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="KeyboardInteractiveConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="proxyUsername">The proxy username.</param>
        /// <param name="proxyPassword">The proxy password.</param>
        public KeyboardInteractiveConnectionInfo(string host, string username, ProxyTypes proxyType, string proxyHost, int proxyPort, string proxyUsername, string proxyPassword)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, proxyType, proxyHost, proxyPort, proxyUsername, proxyPassword)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="KeyboardInteractiveConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">Connection port.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="proxyUsername">The proxy username.</param>
        /// <param name="proxyPassword">The proxy password.</param>
        public KeyboardInteractiveConnectionInfo(string host, int port, string username, ProxyTypes proxyType, string proxyHost, int proxyPort, string proxyUsername, string proxyPassword)
            : base(host, port, username, proxyType, proxyHost, proxyPort, proxyUsername, proxyPassword, new KeyboardInteractiveAuthenticationMethod(username))
        {
            foreach (var authenticationMethod in this.AuthenticationMethods.OfType<KeyboardInteractiveAuthenticationMethod>())
            {
                authenticationMethod.AuthenticationPrompt += AuthenticationMethod_AuthenticationPrompt;
            }

        }

        private void AuthenticationMethod_AuthenticationPrompt(object sender, AuthenticationPromptEventArgs e)
        {
            if (this.AuthenticationPrompt != null)
            {
                this.AuthenticationPrompt(sender, e);
            }
        }


        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!this._isDisposed)
            {
                // If disposing equals true, dispose all managed
                // and unmanaged resources.
                if (disposing)
                {
                    // Dispose managed resources.
                    if (this.AuthenticationMethods != null)
                    {
                        foreach (var authenticationMethods in this.AuthenticationMethods.OfType<IDisposable>())
                        {
                            authenticationMethods.Dispose();
                        }
                    }
                }

                // Note disposing has been done.
                _isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="PasswordConnectionInfo"/> is reclaimed by garbage collection.
        /// </summary>
        ~KeyboardInteractiveConnectionInfo()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\MessageEventArgs.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides data for message events.
    /// </summary>
    /// <typeparam name="T">Message type</typeparam>
    public class MessageEventArgs<T> : EventArgs
    {
        /// <summary>
        /// Gets the message.
        /// </summary>
        public T Message { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessageEventArgs&lt;T&gt;"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        /// <exception cref="ArgumentNullException"><paramref name="message"/> is null.</exception>
        public MessageEventArgs(T message)
        {
            if (message == null)
                throw new ArgumentNullException("message");

            this.Message = message;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\NetConfClient.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    //OneCodeTODO:   Please help with documentation here, as I don't know the details, specially for the methods not documented.
    /// <summary>
    /// Contains operation for working with NetConf server.
    /// </summary>
    public class NetConfClient : BaseClient
    {
        /// <summary>
        /// Holds <see cref="INetConfSession"/> instance that used to communicate to the server
        /// </summary>
        private INetConfSession _netConfSession;

        /// <summary>
        /// Gets or sets the operation timeout.
        /// </summary>
        /// <value>
        /// The timeout to wait until an operation completes. The default value is negative
        /// one (-1) milliseconds, which indicates an infinite time-out period.
        /// </value>
        public TimeSpan OperationTimeout { get; set; }

        #region Constructors

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpClient"/> class.
        /// </summary>
        /// <param name="connectionInfo">The connection info.</param>
        /// <exception cref="ArgumentNullException"><paramref name="connectionInfo"/> is null.</exception>
        public NetConfClient(ConnectionInfo connectionInfo)
            : this(connectionInfo, false)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpClient"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">Connection port.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="password">Authentication password.</param>
        /// <exception cref="ArgumentNullException"><paramref name="password"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid, or <paramref name="username"/> is null or contains whitespace characters.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="port"/> is not within <see cref="F:System.Net.IPEndPoint.MinPort"/> and <see cref="System.Net.IPEndPoint.MaxPort"/>.</exception>
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "Disposed in Dispose(bool) method.")]
        public NetConfClient(string host, int port, string username, string password)
            : this(new PasswordConnectionInfo(host, port, username, password), true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpClient"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="password">Authentication password.</param>
        /// <exception cref="ArgumentNullException"><paramref name="password"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid, or <paramref name="username"/> is null or contains whitespace characters.</exception>
        public NetConfClient(string host, string username, string password)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, password)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpClient"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">Connection port.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="keyFiles">Authentication private key file(s) .</param>
        /// <exception cref="ArgumentNullException"><paramref name="keyFiles"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid, -or- <paramref name="username"/> is null or contains whitespace characters.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="port"/> is not within <see cref="F:System.Net.IPEndPoint.MinPort"/> and <see cref="System.Net.IPEndPoint.MaxPort"/>.</exception>
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "Disposed in Dispose(bool) method.")]
        public NetConfClient(string host, int port, string username, params PrivateKeyFile[] keyFiles)
            : this(new PrivateKeyConnectionInfo(host, port, username, keyFiles), true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpClient"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="keyFiles">Authentication private key file(s) .</param>
        /// <exception cref="ArgumentNullException"><paramref name="keyFiles"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid, -or- <paramref name="username"/> is null or contains whitespace characters.</exception>
        public NetConfClient(string host, string username, params PrivateKeyFile[] keyFiles)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, keyFiles)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NetConfClient"/> class.
        /// </summary>
        /// <param name="connectionInfo">The connection info.</param>
        /// <param name="ownsConnectionInfo">Specified whether this instance owns the connection info.</param>
        /// <exception cref="ArgumentNullException"><paramref name="connectionInfo"/> is null.</exception>
        /// <remarks>
        /// If <paramref name="ownsConnectionInfo"/> is <c>true</c>, then the
        /// connection info will be disposed when this instance is disposed.
        /// </remarks>
        private NetConfClient(ConnectionInfo connectionInfo, bool ownsConnectionInfo)
            : this(connectionInfo, ownsConnectionInfo, new ServiceFactory())
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NetConfClient"/> class.
        /// </summary>
        /// <param name="connectionInfo">The connection info.</param>
        /// <param name="ownsConnectionInfo">Specified whether this instance owns the connection info.</param>
        /// <param name="serviceFactory">The factory to use for creating new services.</param>
        /// <exception cref="ArgumentNullException"><paramref name="connectionInfo"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="serviceFactory"/> is null.</exception>
        /// <remarks>
        /// If <paramref name="ownsConnectionInfo"/> is <c>true</c>, then the
        /// connection info will be disposed when this instance is disposed.
        /// </remarks>
        internal NetConfClient(ConnectionInfo connectionInfo, bool ownsConnectionInfo, IServiceFactory serviceFactory)
            : base(connectionInfo, ownsConnectionInfo, serviceFactory)
        {
            OperationTimeout = new TimeSpan(0, 0, 0, 0, -1);
            AutomaticMessageIdHandling = true;
        }

        #endregion

        /// <summary>
        /// Gets the NetConf server capabilities.
        /// </summary>
        /// <value>
        /// The NetConf server capabilities.
        /// </value>
        public XmlDocument ServerCapabilities 
        {
            get { return _netConfSession.ServerCapabilities; }
        }

        /// <summary>
        /// Gets the NetConf client capabilities.
        /// </summary>
        /// <value>
        /// The NetConf client capabilities.
        /// </value>
        public XmlDocument ClientCapabilities
        {
            get { return _netConfSession.ClientCapabilities; }
        }

        /// <summary>
        /// Gets or sets a value indicating whether automatic message id handling is
        /// enabled.
        /// </summary>
        /// <value>
        /// <c>true</c> if automatic message id handling is enabled; otherwise, <c>false</c>.
        /// The default value is <c>true</c>.
        /// </value>
        public bool AutomaticMessageIdHandling { get; set; }

        /// <summary>
        /// Sends the receive RPC.
        /// </summary>
        /// <param name="rpc">The RPC.</param>
        /// <returns>Reply message to RPC request</returns>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        public XmlDocument SendReceiveRpc(XmlDocument rpc)
        {
            return _netConfSession.SendReceiveRpc(rpc, AutomaticMessageIdHandling);
        }

        /// <summary>
        /// Sends the receive RPC.
        /// </summary>
        /// <param name="xml">The XML.</param>
        /// <returns>Reply message to RPC request</returns>
        public XmlDocument SendReceiveRpc(string xml)
        {
            var rpc = new XmlDocument();
            rpc.LoadXml(xml);
            return SendReceiveRpc(rpc);
        }

        /// <summary>
        /// Sends the close RPC.
        /// </summary>
        /// <returns>Reply message to closing RPC request</returns>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        public XmlDocument SendCloseRpc()
        {
            var rpc = new XmlDocument();
            rpc.LoadXml("<?xml version=\"1.0\" encoding=\"UTF-8\"?><rpc message-id=\"6666\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"><close-session/></rpc>");
            return _netConfSession.SendReceiveRpc(rpc, AutomaticMessageIdHandling);
        }

        /// <summary>
        /// Called when client is connected to the server.
        /// </summary>
        protected override void OnConnected()
        {
            base.OnConnected();

            _netConfSession = ServiceFactory.CreateNetConfSession(Session, OperationTimeout);
            _netConfSession.Connect();
        }

        /// <summary>
        /// Called when client is disconnecting from the server.
        /// </summary>
        protected override void OnDisconnecting()
        {
            base.OnDisconnecting();

            _netConfSession.Disconnect();
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);

            if (disposing)
            {
                if (_netConfSession != null)
                {
                    _netConfSession.Dispose();
                    _netConfSession = null;
                }
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\NoneAuthenticationMethod.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides functionality for "none" authentication method
    /// </summary>
    public class NoneAuthenticationMethod : AuthenticationMethod, IDisposable
    {
        private AuthenticationResult _authenticationResult = AuthenticationResult.Failure;

        private EventWaitHandle _authenticationCompleted = new AutoResetEvent(false);

        /// <summary>
        /// Gets connection name
        /// </summary>
        public override string Name
        {
            get { return "none"; }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NoneAuthenticationMethod"/> class.
        /// </summary>
        /// <param name="username">The username.</param>
        /// <exception cref="ArgumentException"><paramref name="username"/> is whitespace or null.</exception>
        public NoneAuthenticationMethod(string username)
            : base(username)
        {

        }

        /// <summary>
        /// Authenticates the specified session.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <returns>
        /// Result of authentication  process.
        /// </returns>
        /// <exception cref="System.ArgumentNullException"><paramref name="session" /> is null.</exception>
        public override AuthenticationResult Authenticate(Session session)
        {
            if (session == null)
                throw new ArgumentNullException("session");

            session.UserAuthenticationSuccessReceived += Session_UserAuthenticationSuccessReceived;
            session.UserAuthenticationFailureReceived += Session_UserAuthenticationFailureReceived;

            session.SendMessage(new RequestMessageNone(ServiceName.Connection, this.Username));

            session.WaitOnHandle(this._authenticationCompleted);

            session.UserAuthenticationSuccessReceived -= Session_UserAuthenticationSuccessReceived;
            session.UserAuthenticationFailureReceived -= Session_UserAuthenticationFailureReceived;

            return this._authenticationResult;
        }

        private void Session_UserAuthenticationSuccessReceived(object sender, MessageEventArgs<SuccessMessage> e)
        {
            this._authenticationResult = AuthenticationResult.Success;

            this._authenticationCompleted.Set();
        }

        private void Session_UserAuthenticationFailureReceived(object sender, MessageEventArgs<FailureMessage> e)
        {
            if (e.Message.PartialSuccess)
                this._authenticationResult = AuthenticationResult.PartialSuccess;
            else
                this._authenticationResult = AuthenticationResult.Failure;

            //  Copy allowed authentication methods
            this.AllowedAuthentications = e.Message.AllowedAuthentications.ToList();

            this._authenticationCompleted.Set();
        }
        
        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!this._isDisposed)
            {
                // If disposing equals true, dispose all managed
                // and unmanaged resources.
                if (disposing)
                {
                    // Dispose managed resources.
                    if (this._authenticationCompleted != null)
                    {
                        this._authenticationCompleted.Dispose();
                        this._authenticationCompleted = null;
                    }
                }

                // Note disposing has been done.
                _isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="PasswordConnectionInfo"/> is reclaimed by garbage collection.
        /// </summary>
        ~NoneAuthenticationMethod()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion

    }
}

#endif
// file ...\X\Renci.SshNet\PasswordAuthenticationMethod.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides functionality to perform password authentication.
    /// </summary>
    public partial class PasswordAuthenticationMethod : AuthenticationMethod, IDisposable
    {
        private AuthenticationResult _authenticationResult = AuthenticationResult.Failure;

        private Session _session;

        private EventWaitHandle _authenticationCompleted = new AutoResetEvent(false);

        private Exception _exception;

        private readonly RequestMessage _requestMessage;

        private readonly byte[] _password;

        /// <summary>
        /// Gets authentication method name
        /// </summary>
        public override string Name
        {
            get { return this._requestMessage.MethodName; }
        }

        /// <summary>
        /// Occurs when user's password has expired and needs to be changed.
        /// </summary>
        public event EventHandler<AuthenticationPasswordChangeEventArgs> PasswordExpired;

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordAuthenticationMethod"/> class.
        /// </summary>
        /// <param name="username">The username.</param>
        /// <param name="password">The password.</param>
        /// <exception cref="ArgumentException"><paramref name="username"/> is whitespace or null.</exception>
        /// <exception cref="ArgumentException"><paramref name="password"/> is null.</exception>
        public PasswordAuthenticationMethod(string username, string password)
            : this(username, Encoding.UTF8.GetBytes(password))
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordAuthenticationMethod"/> class.
        /// </summary>
        /// <param name="username">The username.</param>
        /// <param name="password">The password.</param>
        /// <exception cref="ArgumentException"><paramref name="username"/> is whitespace or null.</exception>
        /// <exception cref="ArgumentException"><paramref name="password"/> is null.</exception>
        public PasswordAuthenticationMethod(string username, byte[] password)
            : base(username)
        {
            if (password == null)
                throw new ArgumentNullException("password");

            this._password = password;

            this._requestMessage = new RequestMessagePassword(ServiceName.Connection, this.Username, this._password);
        }

        /// <summary>
        /// Authenticates the specified session.
        /// </summary>
        /// <param name="session">The session to authenticate.</param>
        /// <returns>
        /// Result of authentication  process.
        /// </returns>
        /// <exception cref="System.ArgumentNullException"><paramref name="session" /> is null.</exception>
        public override AuthenticationResult Authenticate(Session session)
        {
            if (session == null)
                throw new ArgumentNullException("session");

            this._session = session;

            session.UserAuthenticationSuccessReceived += Session_UserAuthenticationSuccessReceived;
            session.UserAuthenticationFailureReceived += Session_UserAuthenticationFailureReceived;
            session.MessageReceived += Session_MessageReceived;

            session.RegisterMessage("SSH_MSG_USERAUTH_PASSWD_CHANGEREQ");

            session.SendMessage(this._requestMessage);

            session.WaitOnHandle(this._authenticationCompleted);
            
            session.UserAuthenticationSuccessReceived -= Session_UserAuthenticationSuccessReceived;
            session.UserAuthenticationFailureReceived -= Session_UserAuthenticationFailureReceived;
            session.MessageReceived -= Session_MessageReceived;


            if (this._exception != null)
            {
                throw this._exception;
            }

            return this._authenticationResult;
        }

        private void Session_UserAuthenticationSuccessReceived(object sender, MessageEventArgs<SuccessMessage> e)
        {
            this._authenticationResult = AuthenticationResult.Success;

            this._authenticationCompleted.Set();
        }

        private void Session_UserAuthenticationFailureReceived(object sender, MessageEventArgs<FailureMessage> e)
        {
            if (e.Message.PartialSuccess)
                this._authenticationResult = AuthenticationResult.PartialSuccess;
            else
                this._authenticationResult = AuthenticationResult.Failure;

            //  Copy allowed authentication methods
            this.AllowedAuthentications = e.Message.AllowedAuthentications.ToList();

            this._authenticationCompleted.Set();
        }

        private void Session_MessageReceived(object sender, MessageEventArgs<MessageRenci> e)
        {
            if (e.Message is PasswordChangeRequiredMessage)
            {
                this._session.UnRegisterMessage("SSH_MSG_USERAUTH_PASSWD_CHANGEREQ");

                this.ExecuteThread(() =>
                {
                    try
                    {
                        var eventArgs = new AuthenticationPasswordChangeEventArgs(this.Username);

                        //  Raise an event to allow user to supply a new password
                        if (this.PasswordExpired != null)
                        {
                            this.PasswordExpired(this, eventArgs);
                        }

                        //  Send new authentication request with new password
                        this._session.SendMessage(new RequestMessagePassword(ServiceName.Connection, this.Username, this._password, eventArgs.NewPassword));
                    }
                    catch (Exception exp)
                    {
                        this._exception = exp;
                        this._authenticationCompleted.Set();
                    }
                });
            }
        }

        partial void ExecuteThread(Action action);

        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!this._isDisposed)
            {
                // If disposing equals true, dispose all managed
                // and unmanaged resources.
                if (disposing)
                {
                    // Dispose managed resources.
                    if (this._authenticationCompleted != null)
                    {
                        this._authenticationCompleted.Dispose();
                        this._authenticationCompleted = null;
                    }
                }

                // Note disposing has been done.
                _isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="PasswordConnectionInfo"/> is reclaimed by garbage collection.
        /// </summary>
        ~PasswordAuthenticationMethod()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion

    }
}

#endif
// file ...\X\Renci.SshNet\PasswordAuthenticationMethod.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    public partial class PasswordAuthenticationMethod : AuthenticationMethod
    {
        /// <summary>
        /// Executes the specified action in a separate thread.
        /// </summary>
        /// <param name="action">The action to execute.</param>
        partial void ExecuteThread(Action action)
        {
            ThreadPool.QueueUserWorkItem(o => action());
        }
    }
}

#endif
// file ...\X\Renci.SshNet\PasswordConnectionInfo.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides connection information when password authentication method is used
    /// </summary>
    /// <example>
    ///     <code source="..\..\Renci.SshNet.Tests\Classes\PasswordConnectionInfoTest.cs" region="Example PasswordConnectionInfo" language="C#" title="Connect using username and password" />
    ///     <code source="..\..\Renci.SshNet.Tests\Classes\PasswordConnectionInfoTest.cs" region="Example PasswordConnectionInfo PasswordExpired" language="C#" title="Change password when connecting" />
    ///     <code source="..\..\Renci.SshNet.Tests\Classes\PasswordConnectionInfoTest.cs" region="Example PasswordConnectionInfo AuthenticationBanner" language="C#" title="Display authentication banner" />
    /// </example>
    public class PasswordConnectionInfo : ConnectionInfo, IDisposable
    {
        /// <summary>
        /// Occurs when user's password has expired and needs to be changed.
        /// </summary>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\PasswordConnectionInfoTest.cs" region="Example PasswordConnectionInfo PasswordExpired" language="C#" title="Change password when connecting" />
        /// </example>
        public event EventHandler<AuthenticationPasswordChangeEventArgs> PasswordExpired;

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo" /> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="password">Connection password.</param>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\PasswordConnectionInfoTest.cs" region="Example PasswordConnectionInfo" language="C#" title="Connect using username and password" />
        /// </example>
        /// <exception cref="ArgumentNullException"><paramref name="password"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid, or <paramref name="username"/> is null or contains whitespace characters.</exception>
        public PasswordConnectionInfo(string host, string username, string password)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, Encoding.UTF8.GetBytes(password))
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">Connection port.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="password">Connection password.</param>
        /// <exception cref="ArgumentNullException"><paramref name="password"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid, or <paramref name="username"/> is null or contains whitespace characters.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="port"/> is not within <see cref="F:System.Net.IPEndPoint.MinPort"/> and <see cref="F:System.Net.IPEndPoint.MaxPort"/>.</exception>
        public PasswordConnectionInfo(string host, int port, string username, string password)
            : this(host, port, username, Encoding.UTF8.GetBytes(password), ProxyTypes.None, string.Empty, 0, string.Empty, string.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">The port.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="password">Connection password.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        public PasswordConnectionInfo(string host, int port, string username, string password, ProxyTypes proxyType, string proxyHost, int proxyPort)
            : this(host, port, username, Encoding.UTF8.GetBytes(password), proxyType, proxyHost, proxyPort, string.Empty, string.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">The port.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="password">Connection password.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="proxyUsername">The proxy username.</param>
        public PasswordConnectionInfo(string host, int port, string username, string password, ProxyTypes proxyType, string proxyHost, int proxyPort, string proxyUsername)
            : this(host, port, username, Encoding.UTF8.GetBytes(password), proxyType, proxyHost, proxyPort, proxyUsername, string.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="password">Connection password.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        public PasswordConnectionInfo(string host, string username, string password, ProxyTypes proxyType, string proxyHost, int proxyPort)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, Encoding.UTF8.GetBytes(password), proxyType, proxyHost, proxyPort, string.Empty, string.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="password">Connection password.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="proxyUsername">The proxy username.</param>
        public PasswordConnectionInfo(string host, string username, string password, ProxyTypes proxyType, string proxyHost, int proxyPort, string proxyUsername)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, Encoding.UTF8.GetBytes(password), proxyType, proxyHost, proxyPort, proxyUsername, string.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="password">Connection password.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="proxyUsername">The proxy username.</param>
        /// <param name="proxyPassword">The proxy password.</param>
        public PasswordConnectionInfo(string host, string username, string password, ProxyTypes proxyType, string proxyHost, int proxyPort, string proxyUsername, string proxyPassword)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, Encoding.UTF8.GetBytes(password), proxyType, proxyHost, proxyPort, proxyUsername, proxyPassword)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="password">Connection password.</param>
        public PasswordConnectionInfo(string host, string username, byte[] password)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, password)
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo" /> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">Connection port.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="password">Connection password.</param>
        /// <exception cref="ArgumentNullException"><paramref name="password" /> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="host" /> is invalid, or <paramref name="username" /> is null or contains whitespace characters.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="port" /> is not within <see cref="F:System.Net.IPEndPoint.MinPort" /> and <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        public PasswordConnectionInfo(string host, int port, string username, byte[] password)
            : this(host, port, username, password, ProxyTypes.None, string.Empty, 0, string.Empty, string.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">The port.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="password">Connection password.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        public PasswordConnectionInfo(string host, int port, string username, byte[] password, ProxyTypes proxyType, string proxyHost, int proxyPort)
            : this(host, port, username, password, proxyType, proxyHost, proxyPort, string.Empty, string.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">The port.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="password">Connection password.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="proxyUsername">The proxy username.</param>
        public PasswordConnectionInfo(string host, int port, string username, byte[] password, ProxyTypes proxyType, string proxyHost, int proxyPort, string proxyUsername)
            : this(host, port, username, password, proxyType, proxyHost, proxyPort, proxyUsername, string.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="password">Connection password.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        public PasswordConnectionInfo(string host, string username, byte[] password, ProxyTypes proxyType, string proxyHost, int proxyPort)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, password, proxyType, proxyHost, proxyPort, string.Empty, string.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="password">Connection password.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="proxyUsername">The proxy username.</param>
        public PasswordConnectionInfo(string host, string username, byte[] password, ProxyTypes proxyType, string proxyHost, int proxyPort, string proxyUsername)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, password, proxyType, proxyHost, proxyPort, proxyUsername, string.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="password">Connection password.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="proxyUsername">The proxy username.</param>
        /// <param name="proxyPassword">The proxy password.</param>
        public PasswordConnectionInfo(string host, string username, byte[] password, ProxyTypes proxyType, string proxyHost, int proxyPort, string proxyUsername, string proxyPassword)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, password, proxyType, proxyHost, proxyPort, proxyUsername, proxyPassword)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">The port.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="password">Connection password.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="proxyUsername">The proxy username.</param>
        /// <param name="proxyPassword">The proxy password.</param>
        public PasswordConnectionInfo(string host, int port, string username, byte[] password, ProxyTypes proxyType, string proxyHost, int proxyPort, string proxyUsername, string proxyPassword)
            : base(host, port, username, proxyType, proxyHost, proxyPort, proxyUsername, proxyPassword, new PasswordAuthenticationMethod(username, password))
        {
            foreach (var authenticationMethod in this.AuthenticationMethods.OfType<PasswordAuthenticationMethod>())
            {
                authenticationMethod.PasswordExpired += AuthenticationMethod_PasswordExpired;
            }
        }

        private void AuthenticationMethod_PasswordExpired(object sender, AuthenticationPasswordChangeEventArgs e)
        {
            if (this.PasswordExpired != null)
            {
                this.PasswordExpired(sender, e);
            }
        }

        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!this._isDisposed)
            {
                // If disposing equals true, dispose all managed
                // and unmanaged resources.
                if (disposing)
                {
                    // Dispose managed resources.
                    if (this.AuthenticationMethods != null)
                    {
                        foreach (var authenticationMethods in this.AuthenticationMethods.OfType<IDisposable>())
                        {
                            authenticationMethods.Dispose();
                        }
                    }
                }

                // Note disposing has been done.
                _isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="PasswordConnectionInfo"/> is reclaimed by garbage collection.
        /// </summary>
        ~PasswordConnectionInfo()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\PrivateKeyAuthenticationMethod.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides functionality to perform private key authentication.
    /// </summary>
    public class PrivateKeyAuthenticationMethod : AuthenticationMethod, IDisposable
    {
        private AuthenticationResult _authenticationResult = AuthenticationResult.Failure;

        private EventWaitHandle _authenticationCompleted = new ManualResetEvent(false);

        private bool _isSignatureRequired;

        /// <summary>
        /// Gets authentication method name
        /// </summary>
        public override string Name
        {
            get { return "publickey"; }
        }

        /// <summary>
        /// Gets the key files used for authentication.
        /// </summary>
        public ICollection<PrivateKeyFile> KeyFiles { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="PrivateKeyAuthenticationMethod"/> class.
        /// </summary>
        /// <param name="username">The username.</param>
        /// <param name="keyFiles">The key files.</param>
        /// <exception cref="ArgumentException"><paramref name="username"/> is whitespace or null.</exception>
        public PrivateKeyAuthenticationMethod(string username, params PrivateKeyFile[] keyFiles)
            : base(username)
        {
            if (keyFiles == null)
                throw new ArgumentNullException("keyFiles");

            this.KeyFiles = new Collection<PrivateKeyFile>(keyFiles);
        }

        /// <summary>
        /// Authenticates the specified session.
        /// </summary>
        /// <param name="session">The session to authenticate.</param>
        /// <returns>
        /// Result of authentication  process.
        /// </returns>
        public override AuthenticationResult Authenticate(Session session)
        {
            session.UserAuthenticationSuccessReceived += Session_UserAuthenticationSuccessReceived;
            session.UserAuthenticationFailureReceived += Session_UserAuthenticationFailureReceived;
            session.MessageReceived += Session_MessageReceived;

            session.RegisterMessage("SSH_MSG_USERAUTH_PK_OK");

            foreach (var keyFile in this.KeyFiles)
            {
                this._authenticationCompleted.Reset();
                this._isSignatureRequired = false;

                var message = new RequestMessagePublicKey(ServiceName.Connection, this.Username, keyFile.HostKey.Name, keyFile.HostKey.Data);

                if (this.KeyFiles.Count < 2)
                {
                    //  If only one key file provided then send signature for very first request
                    var signatureData = new SignatureData(message, session.SessionId).GetBytes();

                    message.Signature = keyFile.HostKey.Sign(signatureData);
                }

                //  Send public key authentication request
                session.SendMessage(message);

                session.WaitOnHandle(this._authenticationCompleted);

                if (this._isSignatureRequired)
                {
                    this._authenticationCompleted.Reset();

                    var signatureMessage = new RequestMessagePublicKey(ServiceName.Connection, this.Username, keyFile.HostKey.Name, keyFile.HostKey.Data);

                    var signatureData = new SignatureData(message, session.SessionId).GetBytes();

                    signatureMessage.Signature = keyFile.HostKey.Sign(signatureData);

                    //  Send public key authentication request with signature
                    session.SendMessage(signatureMessage);
                }

                session.WaitOnHandle(this._authenticationCompleted);

                if (this._authenticationResult == AuthenticationResult.Success)
                {
                    break;
                }
            }
            
            session.UserAuthenticationSuccessReceived -= Session_UserAuthenticationSuccessReceived;
            session.UserAuthenticationFailureReceived -= Session_UserAuthenticationFailureReceived;
            session.MessageReceived -= Session_MessageReceived;

            session.UnRegisterMessage("SSH_MSG_USERAUTH_PK_OK");

            return this._authenticationResult;
        }

        private void Session_UserAuthenticationSuccessReceived(object sender, MessageEventArgs<SuccessMessage> e)
        {
            this._authenticationResult = AuthenticationResult.Success;

            this._authenticationCompleted.Set();
        }

        private void Session_UserAuthenticationFailureReceived(object sender, MessageEventArgs<FailureMessage> e)
        {
            if (e.Message.PartialSuccess)
                this._authenticationResult = AuthenticationResult.PartialSuccess;
            else
                this._authenticationResult = AuthenticationResult.Failure;

            //  Copy allowed authentication methods
            this.AllowedAuthentications = e.Message.AllowedAuthentications.ToList();

            this._authenticationCompleted.Set();
        }

        private void Session_MessageReceived(object sender, MessageEventArgs<MessageRenci> e)
        {
            var publicKeyMessage = e.Message as PublicKeyMessage;
            if (publicKeyMessage != null)
            {
                this._isSignatureRequired = true;
                this._authenticationCompleted.Set();
            }
        }

        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!this._isDisposed)
            {
                // If disposing equals true, dispose all managed
                // and unmanaged resources.
                if (disposing)
                {
                    // Dispose managed resources.
                    if (this._authenticationCompleted != null)
                    {
                        this._authenticationCompleted.Dispose();
                        this._authenticationCompleted = null;
                    }
                }

                // Note disposing has been done.
                _isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="PasswordConnectionInfo"/> is reclaimed by garbage collection.
        /// </summary>
        ~PrivateKeyAuthenticationMethod()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion

        private class SignatureData : SshData
        {
            private readonly RequestMessagePublicKey _message;

            private readonly byte[] _sessionId;

            public SignatureData(RequestMessagePublicKey message, byte[] sessionId)
            {
                this._message = message;
                this._sessionId = sessionId;
            }

            protected override void LoadData()
            {
                throw new NotImplementedException();
            }

            protected override void SaveData()
            {
                this.WriteBinaryString(this._sessionId);
                this.Write((byte)50);
                this.Write(this._message.Username);
                this.WriteAscii("ssh-connection");
                this.WriteAscii("publickey");
                this.Write((byte)1);
                this.WriteAscii(this._message.PublicKeyAlgorithmName);
                this.WriteBinaryString(this._message.PublicKeyData);
            }
        }

    }
}

#endif
// file ...\X\Renci.SshNet\PrivateKeyConnectionInfo.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides connection information when private key authentication method is used
    /// </summary>
    /// <example>
    ///   <code source="..\..\Renci.SshNet.Tests\Classes\PrivateKeyConnectionInfoTest.cs" region="Example PrivateKeyConnectionInfo PrivateKeyFile" language="C#" title="Connect using private key" />
    ///   </example>
    public class PrivateKeyConnectionInfo : ConnectionInfo, IDisposable
    {
        /// <summary>
        /// Gets the key files used for authentication.
        /// </summary>
        public ICollection<PrivateKeyFile> KeyFiles { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="PrivateKeyConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="keyFiles">Connection key files.</param>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\PrivateKeyConnectionInfoTest.cs" region="Example PrivateKeyConnectionInfo PrivateKeyFile" language="C#" title="Connect using private key" />
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\PrivateKeyConnectionInfoTest.cs" region="Example PrivateKeyConnectionInfo PrivateKeyFile Multiple" language="C#" title="Connect using multiple private key" />
        /// </example>
        public PrivateKeyConnectionInfo(string host, string username, params PrivateKeyFile[] keyFiles)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, ProxyTypes.None, string.Empty, 0, string.Empty, string.Empty, keyFiles)
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PrivateKeyConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">Connection port.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="keyFiles">Connection key files.</param>
        public PrivateKeyConnectionInfo(string host, int port, string username, params PrivateKeyFile[] keyFiles)
            : this(host, port, username, ProxyTypes.None, string.Empty, 0, string.Empty, string.Empty, keyFiles)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">The port.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="keyFiles">The key files.</param>
        public PrivateKeyConnectionInfo(string host, int port, string username, ProxyTypes proxyType, string proxyHost, int proxyPort, params PrivateKeyFile[] keyFiles)
            : this(host, port, username, proxyType, proxyHost, proxyPort, string.Empty, string.Empty, keyFiles)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">The port.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="proxyUsername">The proxy username.</param>
        /// <param name="keyFiles">The key files.</param>
        public PrivateKeyConnectionInfo(string host, int port, string username, ProxyTypes proxyType, string proxyHost, int proxyPort, string proxyUsername, params PrivateKeyFile[] keyFiles)
            : this(host, port, username, proxyType, proxyHost, proxyPort, proxyUsername, string.Empty, keyFiles)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="keyFiles">The key files.</param>
        public PrivateKeyConnectionInfo(string host, string username, ProxyTypes proxyType, string proxyHost, int proxyPort, params PrivateKeyFile[] keyFiles)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, proxyType, proxyHost, proxyPort, string.Empty, string.Empty, keyFiles)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="proxyUsername">The proxy username.</param>
        /// <param name="keyFiles">The key files.</param>
        public PrivateKeyConnectionInfo(string host, string username, ProxyTypes proxyType, string proxyHost, int proxyPort, string proxyUsername, params PrivateKeyFile[] keyFiles)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, proxyType, proxyHost, proxyPort, proxyUsername, string.Empty, keyFiles)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="proxyUsername">The proxy username.</param>
        /// <param name="proxyPassword">The proxy password.</param>
        /// <param name="keyFiles">The key files.</param>
        public PrivateKeyConnectionInfo(string host, string username, ProxyTypes proxyType, string proxyHost, int proxyPort, string proxyUsername, string proxyPassword, params PrivateKeyFile[] keyFiles)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, proxyType, proxyHost, proxyPort, proxyUsername, proxyPassword, keyFiles)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PasswordConnectionInfo"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">The port.</param>
        /// <param name="username">Connection username.</param>
        /// <param name="proxyType">Type of the proxy.</param>
        /// <param name="proxyHost">The proxy host.</param>
        /// <param name="proxyPort">The proxy port.</param>
        /// <param name="proxyUsername">The proxy username.</param>
        /// <param name="proxyPassword">The proxy password.</param>
        /// <param name="keyFiles">The key files.</param>
        public PrivateKeyConnectionInfo(string host, int port, string username, ProxyTypes proxyType, string proxyHost, int proxyPort, string proxyUsername, string proxyPassword, params PrivateKeyFile[] keyFiles)
            : base(host, port, username, proxyType, proxyHost, proxyPort, proxyUsername, proxyPassword, new PrivateKeyAuthenticationMethod(username, keyFiles))
        {
            this.KeyFiles = new Collection<PrivateKeyFile>(keyFiles);
        }

        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!this._isDisposed)
            {
                // If disposing equals true, dispose all managed
                // and unmanaged resources.
                if (disposing)
                {
                    // Dispose managed resources.
                    if (this.AuthenticationMethods != null)
                    {
                        foreach (var authenticationMethods in this.AuthenticationMethods.OfType<IDisposable>())
                        {
                            authenticationMethods.Dispose();
                        }
                    }
                }

                // Note disposing has been done.
                _isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="PasswordConnectionInfo"/> is reclaimed by garbage collection.
        /// </summary>
        ~PrivateKeyConnectionInfo()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\PrivateKeyFile.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Represents private key information.
    /// </summary>
    /// <example>
    ///     <code source="..\..\Renci.SshNet.Tests\Data\Key.RSA.txt" language="Text" title="Private RSA key example" />
    /// </example>
    /// <remarks>
    /// <para>
    /// Supports RSA and DSA private key in both <c>OpenSSH</c> and <c>ssh.com</c> format.
    /// </para>
    /// <para>
    /// The following encryption algorithms are supported:
    /// <list type="bullet">
    ///     <item>
    ///         <description>DES-EDE3-CBC</description>
    ///     </item>
    ///     <item>
    ///         <description>DES-EDE3-CFB</description>
    ///     </item>
    ///     <item>
    ///         <description>DES-CBC</description>
    ///     </item>
    ///     <item>
    ///         <description>AES-128-CBC</description>
    ///     </item>
    ///     <item>
    ///         <description>AES-192-CBC</description>
    ///     </item>
    ///     <item>
    ///         <description>AES-256-CBC</description>
    ///     </item>
    /// </list>
    /// </para>
    /// </remarks>
    public class PrivateKeyFile : IDisposable
    {
        private static readonly Regex PrivateKeyRegex = new Regex(@"^-+ *BEGIN (?<keyName>\w+( \w+)*) PRIVATE KEY *-+\r?\n((Proc-Type: 4,ENCRYPTED\r?\nDEK-Info: (?<cipherName>[A-Z0-9-]+),(?<salt>[A-F0-9]+)\r?\n\r?\n)|(Comment: ""?[^\r\n]*""?\r?\n))?(?<data>([a-zA-Z0-9/+=]{1,80}\r?\n)+)-+ *END \k<keyName> PRIVATE KEY *-+",
#if SILVERLIGHT
            RegexOptions.Multiline);
#else
            RegexOptions.Compiled | RegexOptions.Multiline);
#endif

        private Key _key;

        /// <summary>
        /// Gets the host key.
        /// </summary>
        public HostAlgorithm HostKey { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="PrivateKeyFile"/> class.
        /// </summary>
        /// <param name="privateKey">The private key.</param>
        public PrivateKeyFile(Stream privateKey)
        {
            this.Open(privateKey, null);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PrivateKeyFile"/> class.
        /// </summary>
        /// <param name="fileName">Name of the file.</param>
        /// <exception cref="ArgumentNullException"><paramref name="fileName"/> is null or empty.</exception>
        /// <remarks>This method calls <see cref="System.IO.File.Open(string, System.IO.FileMode)"/> internally, this method does not catch exceptions from <see cref="System.IO.File.Open(string, System.IO.FileMode)"/>.</remarks>
        public PrivateKeyFile(string fileName)
            : this(fileName, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PrivateKeyFile"/> class.
        /// </summary>
        /// <param name="fileName">Name of the file.</param>
        /// <param name="passPhrase">The pass phrase.</param>
        /// <exception cref="ArgumentNullException"><paramref name="fileName"/> is null or empty, or <paramref name="passPhrase"/> is null.</exception>
        /// <remarks>This method calls <see cref="System.IO.File.Open(string, System.IO.FileMode)"/> internally, this method does not catch exceptions from <see cref="System.IO.File.Open(string, System.IO.FileMode)"/>.</remarks>
        public PrivateKeyFile(string fileName, string passPhrase)
        {
            if (string.IsNullOrEmpty(fileName))
                throw new ArgumentNullException("fileName");

            using (var keyFile = File.Open(fileName, FileMode.Open, FileAccess.Read, FileShare.Read))
            {
                this.Open(keyFile, passPhrase);
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PrivateKeyFile"/> class.
        /// </summary>
        /// <param name="privateKey">The private key.</param>
        /// <param name="passPhrase">The pass phrase.</param>
        /// <exception cref="ArgumentNullException"><paramref name="privateKey"/> or <paramref name="passPhrase"/> is null.</exception>
        public PrivateKeyFile(Stream privateKey, string passPhrase)
        {
            this.Open(privateKey, passPhrase);
        }

        /// <summary>
        /// Opens the specified private key.
        /// </summary>
        /// <param name="privateKey">The private key.</param>
        /// <param name="passPhrase">The pass phrase.</param>
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "this._key disposed in Dispose(bool) method.")]
        private void Open(Stream privateKey, string passPhrase)
        {
            if (privateKey == null)
                throw new ArgumentNullException("privateKey");

            Match privateKeyMatch;

            using (var sr = new StreamReader(privateKey))
            {
                var text = sr.ReadToEnd();
                privateKeyMatch = PrivateKeyRegex.Match(text);
            }

            if (!privateKeyMatch.Success)
            {
                throw new SshException("Invalid private key file.");
            }

            var keyName = privateKeyMatch.Result("${keyName}");
            var cipherName = privateKeyMatch.Result("${cipherName}");
            var salt = privateKeyMatch.Result("${salt}");
            var data = privateKeyMatch.Result("${data}");

            var binaryData = Convert.FromBase64String(data);

            byte[] decryptedData;

            if (!string.IsNullOrEmpty(cipherName) && !string.IsNullOrEmpty(salt))
            {
                if (string.IsNullOrEmpty(passPhrase))
                    throw new SshPassPhraseNullOrEmptyException("Private key is encrypted but passphrase is empty.");

                var binarySalt = new byte[salt.Length / 2];
                for (var i = 0; i < binarySalt.Length; i++)
                    binarySalt[i] = Convert.ToByte(salt.Substring(i * 2, 2), 16);

                CipherInfo cipher;
                switch (cipherName)
                {
                    case "DES-EDE3-CBC":
                        cipher = new CipherInfo(192, (key, iv) => new TripleDesCipher(key, new CbcCipherMode(iv), new PKCS7Padding()));
                        break;
                    case "DES-EDE3-CFB":
                        cipher = new CipherInfo(192, (key, iv) => new TripleDesCipher(key, new CfbCipherMode(iv), new PKCS7Padding()));
                        break;
                    case "DES-CBC":
                        cipher = new CipherInfo(64, (key, iv) => new DesCipher(key, new CbcCipherMode(iv), new PKCS7Padding()));
                        break;
                    case "AES-128-CBC":
                        cipher = new CipherInfo(128, (key, iv) => new AesCipher(key, new CbcCipherMode(iv), new PKCS7Padding()));
                        break;
                    case "AES-192-CBC":
                        cipher = new CipherInfo(192, (key, iv) => new AesCipher(key, new CbcCipherMode(iv), new PKCS7Padding()));
                        break;
                    case "AES-256-CBC":
                        cipher = new CipherInfo(256, (key, iv) => new AesCipher(key, new CbcCipherMode(iv), new PKCS7Padding()));
                        break;
                    default:
                        throw new SshException(string.Format(CultureInfo.CurrentCulture, "Private key cipher \"{0}\" is not supported.", cipherName));
                }

                decryptedData = DecryptKey(cipher, binaryData, passPhrase, binarySalt);
            }
            else
            {
                decryptedData = binaryData;
            }

            switch (keyName)
            {
                case "RSA":
                    this._key = new RsaKey(decryptedData.ToArray());
                    this.HostKey = new KeyHostAlgorithm("ssh-rsa", this._key);
                    break;
                case "DSA":
                    this._key = new DsaKey(decryptedData.ToArray());
                    this.HostKey = new KeyHostAlgorithm("ssh-dss", this._key);
                    break;
                case "SSH2 ENCRYPTED":
                    var reader = new SshDataReader(decryptedData);
                    var magicNumber = reader.ReadUInt32();
                    if (magicNumber != 0x3f6ff9eb)
                    {
                        throw new SshException("Invalid SSH2 private key.");
                    }

                    reader.ReadUInt32(); //  Read total bytes length including magic number
                    var keyType = reader.ReadString();
                    var ssh2CipherName = reader.ReadString();
                    var blobSize = (int)reader.ReadUInt32();

                    byte[] keyData;
                    if (ssh2CipherName == "none")
                    {
                        keyData = reader.ReadBytes(blobSize);
                    }
                    else if (ssh2CipherName == "3des-cbc")
                    {
                        if (string.IsNullOrEmpty(passPhrase))
                            throw new SshPassPhraseNullOrEmptyException("Private key is encrypted but passphrase is empty.");

                        var key = GetCipherKey(passPhrase, 192 / 8);
                        var ssh2Сipher = new TripleDesCipher(key, new CbcCipherMode(new byte[8]), new PKCS7Padding());
                        keyData = ssh2Сipher.Decrypt(reader.ReadBytes(blobSize));
                    }
                    else
                    {
                        throw new SshException(string.Format("Cipher method '{0}' is not supported.", cipherName));
                    }

                    //OneCodeTODO:   Create two specific data types to avoid using SshDataReader class

                    reader = new SshDataReader(keyData);

                    var decryptedLength = reader.ReadUInt32();

                    if (decryptedLength > blobSize - 4)
                        throw new SshException("Invalid passphrase.");
                    
                    if (keyType == "if-modn{sign{rsa-pkcs1-sha1},encrypt{rsa-pkcs1v2-oaep}}")
                    {
                        var exponent = reader.ReadBigIntWithBits();//e
                        var d = reader.ReadBigIntWithBits();//d
                        var modulus = reader.ReadBigIntWithBits();//n
                        var inverseQ = reader.ReadBigIntWithBits();//u
                        var q = reader.ReadBigIntWithBits();//p
                        var p = reader.ReadBigIntWithBits();//q
                        this._key = new RsaKey(modulus, exponent, d, p, q, inverseQ);
                        this.HostKey = new KeyHostAlgorithm("ssh-rsa", this._key);
                    }
                    else if (keyType == "dl-modp{sign{dsa-nist-sha1},dh{plain}}")
                    {
                        var zero = reader.ReadUInt32();
                        if (zero != 0)
                        {
                            throw new SshException("Invalid private key");
                        }
                        var p = reader.ReadBigIntWithBits();
                        var g = reader.ReadBigIntWithBits();
                        var q = reader.ReadBigIntWithBits();
                        var y = reader.ReadBigIntWithBits();
                        var x = reader.ReadBigIntWithBits();
                        this._key = new DsaKey(p, q, g, y, x);
                        this.HostKey = new KeyHostAlgorithm("ssh-dss", this._key);
                    }
                    else
                    {
                        throw new NotSupportedException(string.Format("Key type '{0}' is not supported.", keyType));
                    }
                    break;
                default:
                    throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "Key '{0}' is not supported.", keyName));
            }
        }

        private static byte[] GetCipherKey(string passphrase, int length)
        {
            var cipherKey = new List<byte>();

            using (var md5 = new MD5Hash())
            {
                var passwordBytes = Encoding.UTF8.GetBytes(passphrase);

                var hash = md5.ComputeHash(passwordBytes);
                cipherKey.AddRange(hash);

                while (cipherKey.Count < length)
                {
                    hash = passwordBytes.Concat(hash).ToArray();
                    hash = md5.ComputeHash(hash);
                    cipherKey.AddRange(hash);
                }
            }

            return cipherKey.Take(length).ToArray();
        }

        /// <summary>
        /// Decrypts encrypted private key file data.
        /// </summary>
        /// <param name="cipherInfo">The cipher info.</param>
        /// <param name="cipherData">Encrypted data.</param>
        /// <param name="passPhrase">Decryption pass phrase.</param>
        /// <param name="binarySalt">Decryption binary salt.</param>
        /// <returns>Decrypted byte array.</returns>
        /// <exception cref="System.ArgumentNullException">cipherInfo</exception>
        /// <exception cref="ArgumentNullException"><paramref name="cipherInfo" />, <paramref name="cipherData" />, <paramref name="passPhrase" /> or <paramref name="binarySalt" /> is null.</exception>
        private static byte[] DecryptKey(CipherInfo cipherInfo, byte[] cipherData, string passPhrase, byte[] binarySalt)
        {
            if (cipherInfo == null)
                throw new ArgumentNullException("cipherInfo");

            if (cipherData == null)
                throw new ArgumentNullException("cipherData");

            if (binarySalt == null)
                throw new ArgumentNullException("binarySalt");

            var cipherKey = new List<byte>();

            using (var md5 = new MD5Hash())
            {
                var passwordBytes = Encoding.UTF8.GetBytes(passPhrase);

                //  Use 8 bytes binary salt
                var initVector = passwordBytes.Concat(binarySalt.Take(8)).ToArray();

                var hash = md5.ComputeHash(initVector);
                cipherKey.AddRange(hash);

                while (cipherKey.Count < cipherInfo.KeySize / 8)
                {
                    hash = hash.Concat(initVector).ToArray();
                    hash = md5.ComputeHash(hash);
                    cipherKey.AddRange(hash);
                }
            }

            var cipher = cipherInfo.Cipher(cipherKey.ToArray(), binarySalt);

            return cipher.Decrypt(cipherData);
        }

        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged ResourceMessages.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!this._isDisposed)
            {
                // If disposing equals true, dispose all managed
                // and unmanaged ResourceMessages.
                if (disposing)
                {
                    // Dispose managed ResourceMessages.
                    if (this._key != null)
                    {
                        ((IDisposable)this._key).Dispose();
                        this._key = null;
                    }
                }

                // Note disposing has been done.
                _isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="BaseClient"/> is reclaimed by garbage collection.
        /// </summary>
        ~PrivateKeyFile()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion

        private class SshDataReader : SshData
        {
            public SshDataReader(byte[] data)
            {
                this.LoadBytes(data);
            }

            public new UInt32 ReadUInt32()
            {
                return base.ReadUInt32();
            }

            public new string ReadString()
            {
                return base.ReadString();
            }

            public new byte[] ReadBytes(int length)
            {
                return base.ReadBytes(length);
            }

            /// <summary>
            /// Reads next mpint data type from internal buffer where length specified in bits.
            /// </summary>
            /// <returns>mpint read.</returns>
            public BigInteger ReadBigIntWithBits()
            {
                var length = (int)base.ReadUInt32();

                length = (length + 7) / 8;

                var data = base.ReadBytes(length);
                var bytesArray = new byte[data.Length + 1];
                Buffer.BlockCopy(data, 0, bytesArray, 1, data.Length);

                return new BigInteger(bytesArray.Reverse().ToArray());
            }

            protected override void LoadData()
            {
            }

            protected override void SaveData()
            {
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\ProxyTypes.cs
#if !MOBILE && !CORE
namespace Renci.SshNet
{
    /// <summary>
    /// Specifies the type of proxy client will use to connect to server.
    /// </summary>
    public enum ProxyTypes
    {
        /// <summary>No proxy server.</summary>
        None,
        /// <summary>A SOCKS4 proxy server.</summary>
        Socks4,
        /// <summary>A SOCKS5 proxy server.</summary>
        Socks5,
        /// <summary>A HTTP proxy server.</summary>
        Http,
    }
}

#endif
// file ...\X\Renci.SshNet\ScpClient.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides SCP client functionality.
    /// </summary>
    public partial class ScpClient : BaseClient
    {
        private static readonly Regex _fileInfoRe = new Regex(@"C(?<mode>\d{4}) (?<length>\d+) (?<filename>.+)");
        private static char[] _byteToChar;

        /// <summary>
        /// Gets or sets the operation timeout.
        /// </summary>
        /// <value>
        /// The timeout to wait until an operation completes. The default value is negative
        /// one (-1) milliseconds, which indicates an infinite time-out period.
        /// </value>
        public TimeSpan OperationTimeout { get; set; }

        /// <summary>
        /// Gets or sets the size of the buffer.
        /// </summary>
        /// <value>
        /// The size of the buffer. The default buffer size is 16384 bytes.
        /// </value>
        public uint BufferSize { get; set; }

        /// <summary>
        /// Occurs when downloading file.
        /// </summary>
        public event EventHandler<ScpDownloadEventArgs> Downloading;

        /// <summary>
        /// Occurs when uploading file.
        /// </summary>
        public event EventHandler<ScpUploadEventArgs> Uploading;

        #region Constructors

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpClient"/> class.
        /// </summary>
        /// <param name="connectionInfo">The connection info.</param>
        /// <exception cref="ArgumentNullException"><paramref name="connectionInfo"/> is null.</exception>
        public ScpClient(ConnectionInfo connectionInfo)
            : this(connectionInfo, false)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpClient"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">Connection port.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="password">Authentication password.</param>
        /// <exception cref="ArgumentNullException"><paramref name="password"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid, or <paramref name="username"/> is null or contains whitespace characters.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="port"/> is not within <see cref="F:System.Net.IPEndPoint.MinPort"/> and <see cref="System.Net.IPEndPoint.MaxPort"/>.</exception>
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "Disposed in Dispose(bool) method.")]
        public ScpClient(string host, int port, string username, string password)
            : this(new PasswordConnectionInfo(host, port, username, password), true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpClient"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="password">Authentication password.</param>
        /// <exception cref="ArgumentNullException"><paramref name="password"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid, or <paramref name="username"/> is null or contains whitespace characters.</exception>
        public ScpClient(string host, string username, string password)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, password)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpClient"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">Connection port.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="keyFiles">Authentication private key file(s) .</param>
        /// <exception cref="ArgumentNullException"><paramref name="keyFiles"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid, -or- <paramref name="username"/> is null or contains whitespace characters.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="port"/> is not within <see cref="F:System.Net.IPEndPoint.MinPort"/> and <see cref="System.Net.IPEndPoint.MaxPort"/>.</exception>
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "Disposed in Dispose(bool) method.")]
        public ScpClient(string host, int port, string username, params PrivateKeyFile[] keyFiles)
            : this(new PrivateKeyConnectionInfo(host, port, username, keyFiles), true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpClient"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="keyFiles">Authentication private key file(s) .</param>
        /// <exception cref="ArgumentNullException"><paramref name="keyFiles"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid, -or- <paramref name="username"/> is null or contains whitespace characters.</exception>
        public ScpClient(string host, string username, params PrivateKeyFile[] keyFiles)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, keyFiles)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ScpClient"/> class.
        /// </summary>
        /// <param name="connectionInfo">The connection info.</param>
        /// <param name="ownsConnectionInfo">Specified whether this instance owns the connection info.</param>
        /// <exception cref="ArgumentNullException"><paramref name="connectionInfo"/> is null.</exception>
        /// <remarks>
        /// If <paramref name="ownsConnectionInfo"/> is <c>true</c>, then the
        /// connection info will be disposed when this instance is disposed.
        /// </remarks>
        private ScpClient(ConnectionInfo connectionInfo, bool ownsConnectionInfo)
            : this(connectionInfo, ownsConnectionInfo, new ServiceFactory())
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ScpClient"/> class.
        /// </summary>
        /// <param name="connectionInfo">The connection info.</param>
        /// <param name="ownsConnectionInfo">Specified whether this instance owns the connection info.</param>
        /// <param name="serviceFactory">The factory to use for creating new services.</param>
        /// <exception cref="ArgumentNullException"><paramref name="connectionInfo"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="serviceFactory"/> is null.</exception>
        /// <remarks>
        /// If <paramref name="ownsConnectionInfo"/> is <c>true</c>, then the
        /// connection info will be disposed when this instance is disposed.
        /// </remarks>
        internal ScpClient(ConnectionInfo connectionInfo, bool ownsConnectionInfo, IServiceFactory serviceFactory)
            : base(connectionInfo, ownsConnectionInfo, serviceFactory)
        {
            this.OperationTimeout = new TimeSpan(0, 0, 0, 0, -1);
            this.BufferSize = 1024 * 16;

            if (_byteToChar == null)
            {
                _byteToChar = new char[128];
                var ch = '\0';
                for (int i = 0; i < 128; i++)
                {
                    _byteToChar[i] = ch++;
                }
            }
        }

        #endregion

        /// <summary>
        /// Uploads the specified stream to the remote host.
        /// </summary>
        /// <param name="source">Stream to upload.</param>
        /// <param name="path">Remote host file name.</param>
        public void Upload(Stream source, string path)
        {
            using (var input = ServiceFactory.CreatePipeStream())
            using (var channel = this.Session.CreateChannelSession())
            {
                channel.DataReceived += delegate(object sender, ChannelDataEventArgs e)
                {
                    input.Write(e.Data, 0, e.Data.Length);
                    input.Flush();
                };

                channel.Open();

                int pathEnd = path.LastIndexOfAny(new[] { '\\', '/' });
                if (pathEnd != -1)
                {
                    // split the path from the file
                    string pathOnly = path.Substring(0, pathEnd);
                    string fileOnly = path.Substring(pathEnd + 1);
                    //  Send channel command request
                    channel.SendExecRequest(string.Format("scp -t \"{0}\"", pathOnly));
                    this.CheckReturnCode(input);

                    path = fileOnly;
                }

                this.InternalUpload(channel, input, source, path);

                channel.Close();
            }
        }

        /// <summary>
        /// Downloads the specified file from the remote host to the stream.
        /// </summary>
        /// <param name="filename">Remote host file name.</param>
        /// <param name="destination">The stream where to download remote file.</param>
        /// <exception cref="ArgumentException"><paramref name="filename"/> is null or contains whitespace characters.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="destination"/> is null.</exception>
        /// <remarks>Method calls made by this method to <paramref name="destination"/>, may under certain conditions result in exceptions thrown by the stream.</remarks>
        public void Download(string filename, Stream destination)
        {
            if (filename.IsNullOrWhiteSpace())
                throw new ArgumentException("filename");

            if (destination == null)
                throw new ArgumentNullException("destination");

            using (var input = new PipeStream())
            using (var channel = this.Session.CreateChannelSession())
            {
                channel.DataReceived += delegate(object sender, ChannelDataEventArgs e)
                {
                    input.Write(e.Data, 0, e.Data.Length);
                    input.Flush();
                };

                channel.Open();

                //  Send channel command request
                channel.SendExecRequest(string.Format("scp -f \"{0}\"", filename));
                this.SendConfirmation(channel); //  Send reply

                var message = ReadString(input);
                var match = _fileInfoRe.Match(message);

                if (match.Success)
                {
                    //  Read file
                    this.SendConfirmation(channel); //  Send reply

                    var mode = match.Result("${mode}");
                    var length = long.Parse(match.Result("${length}"));
                    var fileName = match.Result("${filename}");

                    this.InternalDownload(channel, input, destination, fileName, length);
                }
                else
                {
                    this.SendConfirmation(channel, 1, string.Format("\"{0}\" is not valid protocol message.", message));
                }

                channel.Close();
            }
        }

        private void InternalSetTimestamp(IChannelSession channel, Stream input, DateTime lastWriteTime, DateTime lastAccessime)
        {
            var zeroTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
            var modificationSeconds = (long)(lastWriteTime - zeroTime).TotalSeconds;
            var accessSeconds = (long)(lastAccessime - zeroTime).TotalSeconds;
            this.SendData(channel, string.Format("T{0} 0 {1} 0\n", modificationSeconds, accessSeconds));
            this.CheckReturnCode(input);
        }

        private void InternalUpload(IChannelSession channel, Stream input, Stream source, string filename)
        {
            var length = source.Length;

            this.SendData(channel, string.Format("C0644 {0} {1}\n", length, Path.GetFileName(filename)));
            this.CheckReturnCode(input);

            var buffer = new byte[this.BufferSize];

            var read = source.Read(buffer, 0, buffer.Length);

            long totalRead = 0;

            while (read > 0)
            {
                this.SendData(channel, buffer, read);

                totalRead += read;

                this.RaiseUploadingEvent(filename, length, totalRead);

                read = source.Read(buffer, 0, buffer.Length);
            }

            this.SendConfirmation(channel);
            this.CheckReturnCode(input);
        }

        private void InternalDownload(IChannelSession channel, Stream input, Stream output, string filename, long length)
        {
            var buffer = new byte[Math.Min(length, this.BufferSize)];
            var needToRead = length;

            do
            {
                var read = input.Read(buffer, 0, (int)Math.Min(needToRead, this.BufferSize));

                output.Write(buffer, 0, read);

                this.RaiseDownloadingEvent(filename, length, length - needToRead);

                needToRead -= read;
            }
            while (needToRead > 0);

            output.Flush();

            //  Raise one more time when file downloaded
            this.RaiseDownloadingEvent(filename, length, length - needToRead);

            //  Send confirmation byte after last data byte was read
            this.SendConfirmation(channel);

            this.CheckReturnCode(input);
        }

        private void RaiseDownloadingEvent(string filename, long size, long downloaded)
        {
            if (this.Downloading != null)
            {
                this.Downloading(this, new ScpDownloadEventArgs(filename, size, downloaded));
            }
        }

        private void RaiseUploadingEvent(string filename, long size, long uploaded)
        {
            if (this.Uploading != null)
            {
                this.Uploading(this, new ScpUploadEventArgs(filename, size, uploaded));
            }
        }

        private void SendConfirmation(IChannelSession channel)
        {
            this.SendData(channel, new byte[] { 0 });
        }

        private void SendConfirmation(IChannelSession channel, byte errorCode, string message)
        {
            this.SendData(channel, new[] { errorCode });
            this.SendData(channel, string.Format("{0}\n", message));
        }

        /// <summary>
        /// Checks the return code.
        /// </summary>
        /// <param name="input">The output stream.</param>
        private void CheckReturnCode(Stream input)
        {
            var b = ReadByte(input);

            if (b > 0)
            {
                var errorText = ReadString(input);

                throw new ScpException(errorText);
            }
        }

        partial void SendData(IChannelSession channel, string command);

        private void SendData(IChannelSession channel, byte[] buffer, int length)
        {
            if (length == buffer.Length)
            {
                channel.SendData(buffer);
            }
            else
            {
                channel.SendData(buffer.Take(length).ToArray());
            }
        }

        private void SendData(IChannelSession channel, byte[] buffer)
        {
            channel.SendData(buffer);
        }

        private static int ReadByte(Stream stream)
        {
            var b = stream.ReadByte();

            while (b < 0)
            {
                Thread.Sleep(100);
                b = stream.ReadByte();
            }

            return b;
        }

        private static string ReadString(Stream stream)
        {
            var hasError = false;

            var sb = new StringBuilder();

            var b = ReadByte(stream);

            if (b == 1 || b == 2)
            {
                hasError = true;
                b = ReadByte(stream);
            }

            var ch = _byteToChar[b];

            while (ch != '\n')
            {
                sb.Append(ch);

                b = ReadByte(stream);

                ch = _byteToChar[b];
            }

            if (hasError)
                throw new ScpException(sb.ToString());

            return sb.ToString();
        }
    }
}

#endif
// file ...\X\Renci.SshNet\ScpClient.NET.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides SCP client functionality.
    /// </summary>
    public partial class ScpClient
    {
        private static readonly Regex _directoryInfoRe = new Regex(@"D(?<mode>\d{4}) (?<length>\d+) (?<filename>.+)");
        private static readonly Regex _timestampRe = new Regex(@"T(?<mtime>\d+) 0 (?<atime>\d+) 0");

        /// <summary>
        /// Uploads the specified file to the remote host.
        /// </summary>
        /// <param name="fileInfo">The file system info.</param>
        /// <param name="path">The path.</param>
        /// <exception cref="ArgumentNullException"><paramref name="fileInfo" /> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="path"/> is null or empty.</exception>
        public void Upload(FileInfo fileInfo, string path)
        {
            if (fileInfo == null)
                throw new ArgumentNullException("fileInfo");
            if (string.IsNullOrEmpty(path))
                throw new ArgumentException("path");

            using (var input = ServiceFactory.CreatePipeStream())
            using (var channel = this.Session.CreateChannelSession())
            {
                channel.DataReceived += delegate(object sender, ChannelDataEventArgs e)
                {
                    input.Write(e.Data, 0, e.Data.Length);
                    input.Flush();
                };

                channel.Open();

                if (!channel.SendExecRequest(string.Format("scp -t \"{0}\"", path)))
                    throw new SshException("Secure copy execution request was rejected by the server. Please consult the server logs.");

                this.CheckReturnCode(input);

                this.InternalUpload(channel, input, fileInfo, fileInfo.Name);

                channel.Close();
            }
        }

        /// <summary>
        /// Uploads the specified directory to the remote host.
        /// </summary>
        /// <param name="directoryInfo">The directory info.</param>
        /// <param name="path">The path.</param>
        /// <exception cref="ArgumentNullException">fileSystemInfo</exception>
        /// <exception cref="ArgumentException"><paramref name="path"/> is null or empty.</exception>
        public void Upload(DirectoryInfo directoryInfo, string path)
        {
            if (directoryInfo == null)
                throw new ArgumentNullException("directoryInfo");
            if (string.IsNullOrEmpty(path))
                throw new ArgumentException("path");

            using (var input = new PipeStream())
            using (var channel = this.Session.CreateChannelSession())
            {
                channel.DataReceived += delegate(object sender, ChannelDataEventArgs e)
                {
                    input.Write(e.Data, 0, e.Data.Length);
                    input.Flush();
                };

                channel.Open();

                //  Send channel command request
                channel.SendExecRequest(string.Format("scp -rt \"{0}\"", path));
                this.CheckReturnCode(input);

                this.InternalSetTimestamp(channel, input, directoryInfo.LastWriteTimeUtc, directoryInfo.LastAccessTimeUtc);
                this.SendData(channel, string.Format("D0755 0 {0}\n", Path.GetFileName(path)));
                this.CheckReturnCode(input);

                this.InternalUpload(channel, input, directoryInfo);

                this.SendData(channel, "E\n");
                this.CheckReturnCode(input);

                channel.Close();
            }
        }

        /// <summary>
        /// Downloads the specified file from the remote host to local file.
        /// </summary>
        /// <param name="filename">Remote host file name.</param>
        /// <param name="fileInfo">Local file information.</param>
        /// <exception cref="ArgumentNullException"><paramref name="fileInfo"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="filename"/> is null or empty.</exception>
        public void Download(string filename, FileInfo fileInfo)
        {
            if (string.IsNullOrEmpty(filename))
                throw new ArgumentException("filename");
            if (fileInfo == null)
                throw new ArgumentNullException("fileInfo");

            using (var input = new PipeStream())
            using (var channel = this.Session.CreateChannelSession())
            {
                channel.DataReceived += delegate(object sender, ChannelDataEventArgs e)
                {
                    input.Write(e.Data, 0, e.Data.Length);
                    input.Flush();
                };

                channel.Open();

                //  Send channel command request
                channel.SendExecRequest(string.Format("scp -pf \"{0}\"", filename));
                this.SendConfirmation(channel); //  Send reply

                this.InternalDownload(channel, input, fileInfo);

                channel.Close();
            }
        }

        /// <summary>
        /// Downloads the specified directory from the remote host to local directory.
        /// </summary>
        /// <param name="directoryName">Remote host directory name.</param>
        /// <param name="directoryInfo">Local directory information.</param>
        /// <exception cref="ArgumentException"><paramref name="directoryName"/> is null or empty.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="directoryInfo"/> is null.</exception>
        public void Download(string directoryName, DirectoryInfo directoryInfo)
        {
            if (string.IsNullOrEmpty(directoryName))
                throw new ArgumentException("directoryName");
            if (directoryInfo == null)
                throw new ArgumentNullException("directoryInfo");

            using (var input = new PipeStream())
            using (var channel = this.Session.CreateChannelSession())
            {
                channel.DataReceived += delegate(object sender, ChannelDataEventArgs e)
                {
                    input.Write(e.Data, 0, e.Data.Length);
                    input.Flush();
                };

                channel.Open();

                //  Send channel command request
                channel.SendExecRequest(string.Format("scp -prf \"{0}\"", directoryName));
                this.SendConfirmation(channel); //  Send reply

                this.InternalDownload(channel, input, directoryInfo);

                channel.Close();
            }
        }

        private void InternalUpload(IChannelSession channel, Stream input, FileInfo fileInfo, string filename)
        {
            this.InternalSetTimestamp(channel, input, fileInfo.LastWriteTimeUtc, fileInfo.LastAccessTimeUtc);
            using (var source = fileInfo.OpenRead())
            {
                this.InternalUpload(channel, input, source, filename);
            }
        }

        private void InternalUpload(IChannelSession channel, Stream input, DirectoryInfo directoryInfo)
        {
            //  Upload files
            var files = directoryInfo.GetFiles();
            foreach (var file in files)
            {
                this.InternalUpload(channel, input, file, file.Name);
            }

            //  Upload directories
            var directories = directoryInfo.GetDirectories();
            foreach (var directory in directories)
            {
                this.InternalSetTimestamp(channel, input, directoryInfo.LastWriteTimeUtc, directoryInfo.LastAccessTimeUtc);
                this.SendData(channel, string.Format("D0755 0 {0}\n", directory.Name));
                this.CheckReturnCode(input);

                this.InternalUpload(channel, input, directory);

                this.SendData(channel, "E\n");
                this.CheckReturnCode(input);
            }
        }

        private void InternalDownload(IChannelSession channel, Stream input, FileSystemInfo fileSystemInfo)
        {
            DateTime modifiedTime = DateTime.Now;
            DateTime accessedTime = DateTime.Now;

            var startDirectoryFullName = fileSystemInfo.FullName;
            var currentDirectoryFullName = startDirectoryFullName;
            var directoryCounter = 0;

            while (true)
            {
                var message = ReadString(input);

                if (message == "E")
                {
                    this.SendConfirmation(channel); //  Send reply

                    directoryCounter--;

                    currentDirectoryFullName = new DirectoryInfo(currentDirectoryFullName).Parent.FullName;

                    if (directoryCounter == 0)
                        break;
                    continue;
                }

                var match = _directoryInfoRe.Match(message);
                if (match.Success)
                {
                    this.SendConfirmation(channel); //  Send reply

                    //  Read directory
                    var mode = long.Parse(match.Result("${mode}"));
                    var filename = match.Result("${filename}");

                    DirectoryInfo newDirectoryInfo;
                    if (directoryCounter > 0)
                    {
                        newDirectoryInfo = Directory.CreateDirectory(string.Format("{0}{1}{2}", currentDirectoryFullName, Path.DirectorySeparatorChar, filename));
                        newDirectoryInfo.LastAccessTime = accessedTime;
                        newDirectoryInfo.LastWriteTime = modifiedTime;
                    }
                    else
                    {
                        //  Dont create directory for first level
                        newDirectoryInfo = fileSystemInfo as DirectoryInfo;
                    }

                    directoryCounter++;

                    currentDirectoryFullName = newDirectoryInfo.FullName;
                    continue;
                }

                match = _fileInfoRe.Match(message);
                if (match.Success)
                {
                    //  Read file
                    this.SendConfirmation(channel); //  Send reply

                    var mode = match.Result("${mode}");
                    var length = long.Parse(match.Result("${length}"));
                    var fileName = match.Result("${filename}");

                    var fileInfo = fileSystemInfo as FileInfo;

                    if (fileInfo == null)
                        fileInfo = new FileInfo(string.Format("{0}{1}{2}", currentDirectoryFullName, Path.DirectorySeparatorChar, fileName));

                    using (var output = fileInfo.OpenWrite())
                    {
                        this.InternalDownload(channel, input, output, fileName, length);
                    }

                    fileInfo.LastAccessTime = accessedTime;
                    fileInfo.LastWriteTime = modifiedTime;

                    if (directoryCounter == 0)
                        break;
                    continue;
                }

                match = _timestampRe.Match(message);
                if (match.Success)
                {
                    //  Read timestamp
                    this.SendConfirmation(channel); //  Send reply

                    var mtime = long.Parse(match.Result("${mtime}"));
                    var atime = long.Parse(match.Result("${atime}"));

                    var zeroTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
                    modifiedTime = zeroTime.AddSeconds(mtime);
                    accessedTime = zeroTime.AddSeconds(atime);
                    continue;
                }

                this.SendConfirmation(channel, 1, string.Format("\"{0}\" is not valid protocol message.", message));
            }
        }

        partial void SendData(IChannelSession channel, string command)
        {
            channel.SendData(System.Text.Encoding.Default.GetBytes(command));
        }
    }
}

#endif
// file ...\X\Renci.SshNet\ServiceFactory.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Basic factory for creating new services.
    /// </summary>
    public partial class ServiceFactory : IServiceFactory
    {
        /// <summary>
        /// Creates a new <see cref="ISession"/> with the specified <see cref="ConnectionInfo"/>.
        /// </summary>
        /// <param name="connectionInfo">The <see cref="ConnectionInfo"/> to use for creating a new session.</param>
        /// <returns>
        /// An <see cref="ISession"/> for the specified <see cref="ConnectionInfo"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="connectionInfo"/> is <c>null</c>.</exception>
        public ISession CreateSession(ConnectionInfo connectionInfo)
        {
            return new Session(connectionInfo);
        }

        /// <summary>
        /// Creates a new <see cref="ISftpSession"/> in a given <see cref="ISession"/> and with
        /// the specified operation timeout and encoding.
        /// </summary>
        /// <param name="session">The <see cref="ISession"/> to create the <see cref="ISftpSession"/> in.</param>
        /// <param name="operationTimeout">The operation timeout.</param>
        /// <param name="encoding">The encoding.</param>
        /// <returns>
        /// An <see cref="ISftpSession"/>.
        /// </returns>
        public ISftpSession CreateSftpSession(ISession session, TimeSpan operationTimeout, Encoding encoding)
        {
            return new SftpSession(session, operationTimeout, encoding);
        }

        /// <summary>
        /// Create a new <see cref="PipeStream"/>.
        /// </summary>
        /// <returns>
        /// A <see cref="PipeStream"/>.
        /// </returns>
        public PipeStream CreatePipeStream()
        {
            return new PipeStream();
        }
    }
}

#endif
// file ...\X\Renci.SshNet\ServiceFactory.NET.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    public partial class ServiceFactory
    {
        /// <summary>
        /// Creates a new <see cref="INetConfSession"/> in a given <see cref="ISession"/>
        /// and with the specified operation timeout.
        /// </summary>
        /// <param name="session">The <see cref="ISession"/> to create the <see cref="INetConfSession"/> in.</param>
        /// <param name="operationTimeout">The operation timeout.</param>
        /// <returns>
        /// An <see cref="INetConfSession"/>.
        /// </returns>
        public INetConfSession CreateNetConfSession(ISession session, TimeSpan operationTimeout)
        {
            return new NetConfSession(session, operationTimeout);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Session.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides functionality to connect and interact with SSH server.
    /// </summary>
    public partial class Session : ISession
    {
        /// <summary>
        /// Specifies an infinite waiting period.
        /// </summary>
        /// <remarks>
        /// The value of this field is <c>-1</c> millisecond. 
        /// </remarks>
        internal static readonly TimeSpan InfiniteTimeSpan = new TimeSpan(0, 0, 0, 0, -1);

        /// <summary>
        /// Specifies an infinite waiting period.
        /// </summary>
        /// <remarks>
        /// The value of this field is <c>-1</c>.
        /// </remarks>
        internal static readonly int Infinite = -1;

        /// <summary>
        /// Specifies maximum packet size defined by the protocol.
        /// </summary>
        private const int MaximumSshPacketSize = LocalChannelDataPacketSize + 3000;

        /// <summary>
        /// Holds the initial local window size for the channels.
        /// </summary>
        /// <value>
        /// 2 MB.
        /// </value>
        private const int InitialLocalWindowSize = LocalChannelDataPacketSize * 32;

        /// <summary>
        /// Holds the maximum size of channel data packets that we receive.
        /// </summary>
        /// <value>
        /// 64 KB.
        /// </value>
        private const int LocalChannelDataPacketSize = 1024*64;

        private static readonly RNGCryptoServiceProvider Randomizer = new RNGCryptoServiceProvider();

#if SILVERLIGHT
        private static readonly Regex ServerVersionRe = new Regex("^SSH-(?<protoversion>[^-]+)-(?<softwareversion>.+)( SP.+)?$");
#else
        private static readonly Regex ServerVersionRe = new Regex("^SSH-(?<protoversion>[^-]+)-(?<softwareversion>.+)( SP.+)?$", RegexOptions.Compiled);
#endif

        /// <summary>
        /// Controls how many authentication attempts can take place at the same time.
        /// </summary>
        /// <remarks>
        /// Some server may restrict number to prevent authentication attacks
        /// </remarks>
        private static readonly SemaphoreLight AuthenticationConnection = new SemaphoreLight(3);

        /// <summary>
        /// Holds metada about session messages
        /// </summary>
        private IEnumerable<MessageMetadata> _messagesMetadata;

        /// <summary>
        /// Holds connection socket.
        /// </summary>
        private Socket _socket;

        /// <summary>
        /// Holds locker object for the socket
        /// </summary>
        private readonly object _socketLock = new object();

        /// <summary>
        /// Holds a <see cref="WaitHandle"/> that is signaled when the message listener loop has completed.
        /// </summary>
        private EventWaitHandle _messageListenerCompleted;

        /// <summary>
        /// Specifies outbound packet number
        /// </summary>
        private volatile UInt32 _outboundPacketSequence;

        /// <summary>
        /// Specifies incoming packet number
        /// </summary>
        private UInt32 _inboundPacketSequence;

        /// <summary>
        /// WaitHandle to signal that last service request was accepted
        /// </summary>
        private EventWaitHandle _serviceAccepted = new AutoResetEvent(false);

        /// <summary>
        /// WaitHandle to signal that exception was thrown by another thread.
        /// </summary>
        private EventWaitHandle _exceptionWaitHandle = new ManualResetEvent(false);

        /// <summary>
        /// WaitHandle to signal that key exchange was completed.
        /// </summary>
        private EventWaitHandle _keyExchangeCompletedWaitHandle = new ManualResetEvent(false);

        /// <summary>
        /// WaitHandle to signal that bytes have been read from the socket.
        /// </summary>
        private EventWaitHandle _bytesReadFromSocket = new ManualResetEvent(false);

        /// <summary>
        /// WaitHandle to signal that key exchange is in progress.
        /// </summary>
        private bool _keyExchangeInProgress;

        /// <summary>
        /// Exception that need to be thrown by waiting thread
        /// </summary>
        private Exception _exception;

        /// <summary>
        /// Specifies whether connection is authenticated
        /// </summary>
        private bool _isAuthenticated;

        /// <summary>
        /// Specifies whether user issued Disconnect command or not
        /// </summary>
        private bool _isDisconnecting;

        private KeyExchange _keyExchange;

        private HashAlgorithm _serverMac;

        private HashAlgorithm _clientMac;

        private Cipher _clientCipher;

        private Cipher _serverCipher;

        private Compressor _serverDecompression;

        private Compressor _clientCompression;

        private SemaphoreLight _sessionSemaphore;

        /// <summary>
        /// Gets the session semaphore that controls session channels.
        /// </summary>
        /// <value>
        /// The session semaphore.
        /// </value>
        public SemaphoreLight SessionSemaphore
        {
            get
            {
                if (_sessionSemaphore == null)
                {
                    lock (this)
                    {
                        if (_sessionSemaphore == null)
                        {
                            _sessionSemaphore = new SemaphoreLight(ConnectionInfo.MaxSessions);
                        }
                    }
                }

                return _sessionSemaphore;
            }
        }

        private bool _isDisconnectMessageSent;

        private uint _nextChannelNumber;

        /// <summary>
        /// Gets the next channel number.
        /// </summary>
        /// <value>
        /// The next channel number.
        /// </value>
        private uint NextChannelNumber
        {
            get
            {
                uint result;

                lock (this)
                {
                    result = _nextChannelNumber++;
                }

                return result;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the session is connected.
        /// </summary>
        /// <value>
        /// <c>true</c> if the session is connected; otherwise, <c>false</c>.
        /// </value>
        /// <remarks>
        /// This methods returns true in all but the following cases:
        /// <list type="bullet">
        ///     <item>
        ///         <description>The SSH_MSG_DISCONNECT message - which is used to disconnect from the server - has been sent.</description>
        ///     </item>
        ///     <item>
        ///         <description>The client has not been authenticated successfully.</description>
        ///     </item>
        ///     <item>
        ///         <description>The listener thread - which is used to receive messages from the server - has stopped.</description>
        ///     </item>
        ///     <item>
        ///         <description>The socket used to communicate with the server is no longer connected.</description>
        ///     </item>
        /// </list>
        /// </remarks>
        public bool IsConnected
        {
            get
            {
                if (_isDisconnectMessageSent || !_isAuthenticated)
                    return false;
                if (_messageListenerCompleted == null || _messageListenerCompleted.WaitOne(0))
                    return false;

                var isSocketConnected = false;
                IsSocketConnected(ref isSocketConnected);
                return isSocketConnected;
            }
        }

        /// <summary>
        /// Gets the session id.
        /// </summary>
        /// <value>
        /// The session id, or <c>null</c> if the client has not been authenticated.
        /// </value>
        public byte[] SessionId { get; private set; }

        private MessageRenci _clientInitMessage;
        /// <summary>
        /// Gets the client init message.
        /// </summary>
        /// <value>The client init message.</value>
        public MessageRenci ClientInitMessage
        {
            get
            {
                if (_clientInitMessage == null)
                {
                    _clientInitMessage = new KeyExchangeInitMessage
                    {
                        KeyExchangeAlgorithms = ConnectionInfo.KeyExchangeAlgorithms.Keys.ToArray(),
                        ServerHostKeyAlgorithms = ConnectionInfo.HostKeyAlgorithms.Keys.ToArray(),
                        EncryptionAlgorithmsClientToServer = ConnectionInfo.Encryptions.Keys.ToArray(),
                        EncryptionAlgorithmsServerToClient = ConnectionInfo.Encryptions.Keys.ToArray(),
                        MacAlgorithmsClientToServer = ConnectionInfo.HmacAlgorithms.Keys.ToArray(),
                        MacAlgorithmsServerToClient = ConnectionInfo.HmacAlgorithms.Keys.ToArray(),
                        CompressionAlgorithmsClientToServer = ConnectionInfo.CompressionAlgorithms.Keys.ToArray(),
                        CompressionAlgorithmsServerToClient = ConnectionInfo.CompressionAlgorithms.Keys.ToArray(),
                        LanguagesClientToServer = new[] {string.Empty},
                        LanguagesServerToClient = new[] {string.Empty},
                        FirstKexPacketFollows = false,
                        Reserved = 0
                    };
                }
                return _clientInitMessage;
            }
        }

        /// <summary>
        /// Gets or sets the server version string.
        /// </summary>
        /// <value>The server version.</value>
        public string ServerVersion { get; private set; }

        /// <summary>
        /// Gets or sets the client version string.
        /// </summary>
        /// <value>The client version.</value>
        public string ClientVersion { get; private set; }

        /// <summary>
        /// Gets or sets the connection info.
        /// </summary>
        /// <value>The connection info.</value>
        public ConnectionInfo ConnectionInfo { get; private set; }

        /// <summary>
        /// Occurs when an error occurred.
        /// </summary>
        public event EventHandler<ExceptionEventArgs> ErrorOccured;

        /// <summary>
        /// Occurs when session has been disconnected from the server.
        /// </summary>
        public event EventHandler<EventArgs> Disconnected;

        /// <summary>
        /// Occurs when host key received.
        /// </summary>
        public event EventHandler<HostKeyEventArgs> HostKeyReceived;

        /// <summary>
        /// Occurs when <see cref="BannerMessage"/> message is received from the server.
        /// </summary>
        public event EventHandler<MessageEventArgs<BannerMessage>> UserAuthenticationBannerReceived;

        #region Message events

        /// <summary>
        /// Occurs when <see cref="DisconnectMessage"/> message received
        /// </summary>
        internal event EventHandler<MessageEventArgs<DisconnectMessage>> DisconnectReceived;

        /// <summary>
        /// Occurs when <see cref="IgnoreMessage"/> message received
        /// </summary>
        internal event EventHandler<MessageEventArgs<IgnoreMessage>> IgnoreReceived;

        /// <summary>
        /// Occurs when <see cref="UnimplementedMessage"/> message received
        /// </summary>
        internal event EventHandler<MessageEventArgs<UnimplementedMessage>> UnimplementedReceived;

        /// <summary>
        /// Occurs when <see cref="DebugMessage"/> message received
        /// </summary>
        internal event EventHandler<MessageEventArgs<DebugMessage>> DebugReceived;

        /// <summary>
        /// Occurs when <see cref="ServiceRequestMessage"/> message received
        /// </summary>
        internal event EventHandler<MessageEventArgs<ServiceRequestMessage>> ServiceRequestReceived;

        /// <summary>
        /// Occurs when <see cref="ServiceAcceptMessage"/> message received
        /// </summary>
        internal event EventHandler<MessageEventArgs<ServiceAcceptMessage>> ServiceAcceptReceived;

        /// <summary>
        /// Occurs when <see cref="KeyExchangeInitMessage"/> message received
        /// </summary>
        internal event EventHandler<MessageEventArgs<KeyExchangeInitMessage>> KeyExchangeInitReceived;

        /// <summary>
        /// Occurs when <see cref="NewKeysMessage"/> message received
        /// </summary>
        internal event EventHandler<MessageEventArgs<NewKeysMessage>> NewKeysReceived;

        /// <summary>
        /// Occurs when <see cref="RequestMessage"/> message received
        /// </summary>
        internal event EventHandler<MessageEventArgs<RequestMessage>> UserAuthenticationRequestReceived;

        /// <summary>
        /// Occurs when <see cref="FailureMessage"/> message received
        /// </summary>
        internal event EventHandler<MessageEventArgs<FailureMessage>> UserAuthenticationFailureReceived;

        /// <summary>
        /// Occurs when <see cref="SuccessMessage"/> message received
        /// </summary>
        internal event EventHandler<MessageEventArgs<SuccessMessage>> UserAuthenticationSuccessReceived;

        /// <summary>
        /// Occurs when <see cref="GlobalRequestMessage"/> message received
        /// </summary>
        internal event EventHandler<MessageEventArgs<GlobalRequestMessage>> GlobalRequestReceived;

        /// <summary>
        /// Occurs when <see cref="RequestSuccessMessage"/> message received
        /// </summary>
        public event EventHandler<MessageEventArgs<RequestSuccessMessage>> RequestSuccessReceived;

        /// <summary>
        /// Occurs when <see cref="RequestFailureMessage"/> message received
        /// </summary>
        public event EventHandler<MessageEventArgs<RequestFailureMessage>> RequestFailureReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelOpenMessage"/> message received
        /// </summary>
        public event EventHandler<MessageEventArgs<ChannelOpenMessage>> ChannelOpenReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelOpenConfirmationMessage"/> message received
        /// </summary>
        public event EventHandler<MessageEventArgs<ChannelOpenConfirmationMessage>> ChannelOpenConfirmationReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelOpenFailureMessage"/> message received
        /// </summary>
        public event EventHandler<MessageEventArgs<ChannelOpenFailureMessage>> ChannelOpenFailureReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelWindowAdjustMessage"/> message received
        /// </summary>
        public event EventHandler<MessageEventArgs<ChannelWindowAdjustMessage>> ChannelWindowAdjustReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelDataMessage"/> message received
        /// </summary>
        public event EventHandler<MessageEventArgs<ChannelDataMessage>> ChannelDataReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelExtendedDataMessage"/> message received
        /// </summary>
        public event EventHandler<MessageEventArgs<ChannelExtendedDataMessage>> ChannelExtendedDataReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelEofMessage"/> message received
        /// </summary>
        public event EventHandler<MessageEventArgs<ChannelEofMessage>> ChannelEofReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelCloseMessage"/> message received
        /// </summary>
        public event EventHandler<MessageEventArgs<ChannelCloseMessage>> ChannelCloseReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelRequestMessage"/> message received
        /// </summary>
        public event EventHandler<MessageEventArgs<ChannelRequestMessage>> ChannelRequestReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelSuccessMessage"/> message received
        /// </summary>
        public event EventHandler<MessageEventArgs<ChannelSuccessMessage>> ChannelSuccessReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelFailureMessage"/> message received
        /// </summary>
        public event EventHandler<MessageEventArgs<ChannelFailureMessage>> ChannelFailureReceived;

        /// <summary>
        /// Occurs when message received and is not handled by any of the event handlers
        /// </summary>
        internal event EventHandler<MessageEventArgs<MessageRenci>> MessageReceived;

        #endregion

        /// <summary>
        /// Initializes a new instance of the <see cref="Session"/> class.
        /// </summary>
        /// <param name="connectionInfo">The connection info.</param>
        /// <exception cref="ArgumentNullException"><paramref name="connectionInfo"/> is <c>null</c>.</exception>
        internal Session(ConnectionInfo connectionInfo)
        {
            if (connectionInfo == null)
                throw new ArgumentNullException("connectionInfo");

            ConnectionInfo = connectionInfo;
            //this.ClientVersion = string.Format(CultureInfo.CurrentCulture, "SSH-2.0-Renci.SshNet.SshClient.{0}", this.GetType().Assembly.GetName().Version);
            ClientVersion = string.Format(CultureInfo.CurrentCulture, "SSH-2.0-Renci.SshNet.SshClient.0.0.1");
        }

        /// <summary>
        /// Connects to the server.
        /// </summary>
        /// <exception cref="SocketException">Socket connection to the SSH server or proxy server could not be established, or an error occurred while resolving the hostname.</exception>
        /// <exception cref="SshConnectionException">SSH session could not be established.</exception>
        /// <exception cref="SshAuthenticationException">Authentication of SSH session failed.</exception>
        /// <exception cref="ProxyException">Failed to establish proxy connection.</exception>
        public void Connect()
        {
            if (IsConnected)
                return;

            try
            {
                AuthenticationConnection.Wait();

                if (IsConnected)
                    return;

                lock (this)
                {
                    //  If connected don't connect again
                    if (IsConnected)
                        return;

                    // reset connection specific information
                    Reset();

                    //  Build list of available messages while connecting
                    _messagesMetadata = GetMessagesMetadata();

                    switch (ConnectionInfo.ProxyType)
                    {
                        case ProxyTypes.None:
                            SocketConnect(ConnectionInfo.Host, ConnectionInfo.Port);
                            break;
                        case ProxyTypes.Socks4:
                            SocketConnect(ConnectionInfo.ProxyHost, ConnectionInfo.ProxyPort);
                            ConnectSocks4();
                            break;
                        case ProxyTypes.Socks5:
                            SocketConnect(ConnectionInfo.ProxyHost, ConnectionInfo.ProxyPort);
                            ConnectSocks5();
                            break;
                        case ProxyTypes.Http:
                            SocketConnect(ConnectionInfo.ProxyHost, ConnectionInfo.ProxyPort);
                            ConnectHttp();
                            break;
                    }

                    Match versionMatch;

                    //  Get server version from the server,
                    //  ignore text lines which are sent before if any
                    while (true)
                    {
                        var serverVersion = string.Empty;
                        SocketReadLine(ref serverVersion, ConnectionInfo.Timeout);
                        if (serverVersion == null)
                            throw new SshConnectionException("Server response does not contain SSH protocol identification.");
                        versionMatch = ServerVersionRe.Match(serverVersion);
                        if (versionMatch.Success)
                        {
                            ServerVersion = serverVersion;
                            break;
                        }
                    }

                    //  Set connection versions
                    ConnectionInfo.ServerVersion = ServerVersion;
                    ConnectionInfo.ClientVersion = ClientVersion;

                    //  Get server SSH version
                    var version = versionMatch.Result("${protoversion}");

                    var softwareName = versionMatch.Result("${softwareversion}");

                    Log(string.Format("Server version '{0}' on '{1}'.", version, softwareName));

                    if (!(version.Equals("2.0") || version.Equals("1.99")))
                    {
                        throw new SshConnectionException(string.Format(CultureInfo.CurrentCulture, "Server version '{0}' is not supported.", version), DisconnectReason.ProtocolVersionNotSupported);
                    }

                    SocketWrite(Encoding.UTF8.GetBytes(string.Format(CultureInfo.InvariantCulture, "{0}\x0D\x0A", ClientVersion)));

                    //  Register Transport response messages
                    RegisterMessage("SSH_MSG_DISCONNECT");
                    RegisterMessage("SSH_MSG_IGNORE");
                    RegisterMessage("SSH_MSG_UNIMPLEMENTED");
                    RegisterMessage("SSH_MSG_DEBUG");
                    RegisterMessage("SSH_MSG_SERVICE_ACCEPT");
                    RegisterMessage("SSH_MSG_KEXINIT");
                    RegisterMessage("SSH_MSG_NEWKEYS");

                    //  Some server implementations might sent this message first, prior establishing encryption algorithm
                    RegisterMessage("SSH_MSG_USERAUTH_BANNER");

                    //  Start incoming request listener
                    _messageListenerCompleted = new ManualResetEvent(false);

                    ExecuteThread(() =>
                    {
                        try
                        {
                            MessageListener();
                        }
                        finally
                        {
                            _messageListenerCompleted.Set();
                        }
                    });

                    //  Wait for key exchange to be completed
                    WaitOnHandle(_keyExchangeCompletedWaitHandle);

                    //  If sessionId is not set then its not connected
                    if (SessionId == null)
                    {
                        Disconnect();
                        return;
                    }

                    //  Request user authorization service
                    SendMessage(new ServiceRequestMessage(ServiceName.UserAuthentication));

                    //  Wait for service to be accepted
                    WaitOnHandle(_serviceAccepted);

                    if (string.IsNullOrEmpty(ConnectionInfo.Username))
                    {
                        throw new SshException("Username is not specified.");
                    }

                    ConnectionInfo.Authenticate(this);
                    _isAuthenticated = true;

                    //  Register Connection messages
                    RegisterMessage("SSH_MSG_GLOBAL_REQUEST");
                    RegisterMessage("SSH_MSG_REQUEST_SUCCESS");
                    RegisterMessage("SSH_MSG_REQUEST_FAILURE");
                    RegisterMessage("SSH_MSG_CHANNEL_OPEN_CONFIRMATION");
                    RegisterMessage("SSH_MSG_CHANNEL_OPEN_FAILURE");
                    RegisterMessage("SSH_MSG_CHANNEL_WINDOW_ADJUST");
                    RegisterMessage("SSH_MSG_CHANNEL_EXTENDED_DATA");
                    RegisterMessage("SSH_MSG_CHANNEL_REQUEST");
                    RegisterMessage("SSH_MSG_CHANNEL_SUCCESS");
                    RegisterMessage("SSH_MSG_CHANNEL_FAILURE");
                    RegisterMessage("SSH_MSG_CHANNEL_DATA");
                    RegisterMessage("SSH_MSG_CHANNEL_EOF");
                    RegisterMessage("SSH_MSG_CHANNEL_CLOSE");

                    Monitor.Pulse(this);
                }
            }
            finally
            {
                AuthenticationConnection.Release();
            }
        }

        /// <summary>
        /// Disconnects from the server.
        /// </summary>
        /// <remarks>
        /// This sends a <b>SSH_MSG_DISCONNECT</b> message to the server, waits for the
        /// server to close the socket on its end and subsequently closes the client socket.
        /// </remarks>
        public void Disconnect()
        {
            Disconnect(DisconnectReason.ByApplication, "Connection terminated by the client.");
        }

        private void Disconnect(DisconnectReason reason, string message)
        {
            _isDisconnecting = true;

            // send disconnect message to the server if the connection is still open
            // and the disconnect message has not yet been sent
            //
            // note that this should also cause the listener thread to be stopped as
            // the server should respond by closing the socket
            SendDisconnect(reason, message);

            // disconnect socket, and dispose it
            SocketDisconnectAndDispose();

            if (_messageListenerCompleted != null)
            {
                // at this point, we are sure that the listener thread will stop
                // as we've disconnected the socket
                _messageListenerCompleted.WaitOne();
                _messageListenerCompleted.Dispose();
                _messageListenerCompleted = null;
            }
        }

        /// <summary>
        /// Waits for the specified handle or the exception handle for the receive thread
        /// to signal within the connection timeout.
        /// </summary>
        /// <param name="waitHandle">The wait handle.</param>
        /// <exception cref="SshConnectionException">A received package was invalid or failed the message integrity check.</exception>
        /// <exception cref="SshOperationTimeoutException">None of the handles are signaled in time and the session is not disconnecting.</exception>
        /// <exception cref="SocketException">A socket error was signaled while receiving messages from the server.</exception>
        /// <remarks>
        /// When neither handles are signaled in time and the session is not closing, then the
        /// session is disconnected.
        /// </remarks>
        void ISession.WaitOnHandle(WaitHandle waitHandle)
        {
            WaitOnHandle(waitHandle, ConnectionInfo.Timeout);
        }

        /// <summary>
        /// Waits for the specified handle or the exception handle for the receive thread
        /// to signal within the specified timeout.
        /// </summary>
        /// <param name="waitHandle">The wait handle.</param>
        /// <param name="timeout">The time to wait for any of the handles to become signaled.</param>
        /// <exception cref="SshConnectionException">A received package was invalid or failed the message integrity check.</exception>
        /// <exception cref="SshOperationTimeoutException">None of the handles are signaled in time and the session is not disconnecting.</exception>
        /// <exception cref="SocketException">A socket error was signaled while receiving messages from the server.</exception>
        /// <remarks>
        /// When neither handles are signaled in time and the session is not closing, then the
        /// session is disconnected.
        /// </remarks>
        void ISession.WaitOnHandle(WaitHandle waitHandle, TimeSpan timeout)
        {
            WaitOnHandle(waitHandle, timeout);
        }

        /// <summary>
        /// Waits for the specified handle or the exception handle for the receive thread
        /// to signal within the connection timeout.
        /// </summary>
        /// <param name="waitHandle">The wait handle.</param>
        /// <exception cref="SshConnectionException">A received package was invalid or failed the message integrity check.</exception>
        /// <exception cref="SshOperationTimeoutException">None of the handles are signaled in time and the session is not disconnecting.</exception>
        /// <exception cref="SocketException">A socket error was signaled while receiving messages from the server.</exception>
        /// <remarks>
        /// When neither handles are signaled in time and the session is not closing, then the
        /// session is disconnected.
        /// </remarks>
        internal void WaitOnHandle(WaitHandle waitHandle)
        {
            WaitOnHandle(waitHandle, ConnectionInfo.Timeout);
        }

        /// <summary>
        /// Waits for the specified handle or the exception handle for the receive thread
        /// to signal within the specified timeout.
        /// </summary>
        /// <param name="waitHandle">The wait handle.</param>
        /// <param name="timeout">The time to wait for any of the handles to become signaled.</param>
        /// <exception cref="SshConnectionException">A received package was invalid or failed the message integrity check.</exception>
        /// <exception cref="SshOperationTimeoutException">None of the handles are signaled in time and the session is not disconnecting.</exception>
        /// <exception cref="SocketException">A socket error was signaled while receiving messages from the server.</exception>
        internal void WaitOnHandle(WaitHandle waitHandle, TimeSpan timeout)
        {
            if (waitHandle == null)
                throw new ArgumentNullException("waitHandle");

            var waitHandles = new[]
                {
                    _exceptionWaitHandle,
                    _messageListenerCompleted,
                    waitHandle
                };

            switch (WaitHandle.WaitAny(waitHandles, timeout))
            {
                case 0:
                    throw _exception;
                case 1:
                    // when the session is NOT disconnecting, the listener should actually
                    // never complete without setting the exception wait handle and should
                    // end up in case 0... 
                    //
                    // when the session is disconnecting, the completion of the listener
                    // should not be considered an error (quite the oppposite actually)
                    if (!_isDisconnecting)
                    {
                        throw new SshConnectionException("Client not connected.");
                    }
                    break;
                case WaitHandle.WaitTimeout:
                    // when the session is disconnecting, a timeout is likely when no
                    // network connectivity is available; depending on the configured
                    // timeout either the WaitAny times out first or a SocketException
                    // detailing a timeout thrown hereby completing the listener thread
                    // (which makes us end up in case 1). Either way, we do not want to
                    // report an exception to the client when we're disconnecting anyway
                    if (!_isDisconnecting)
                    {
                        throw new SshOperationTimeoutException("Session operation has timed out");
                    }
                    break;
            }
        }

        /// <summary>
        /// Sends a message to the server.
        /// </summary>
        /// <param name="message">The message to send.</param>
        /// <exception cref="SshConnectionException">The client is not connected.</exception>
        /// <exception cref="SshOperationTimeoutException">The operation timed out.</exception>
        /// <exception cref="InvalidOperationException">The size of the packet exceeds the maximum size defined by the protocol.</exception>
        internal void SendMessage(MessageRenci message)
        {
            if (_socket == null || !_socket.CanWrite())
                throw new SshConnectionException("Client not connected.");

            if (_keyExchangeInProgress && !(message is IKeyExchangedAllowed))
            {
                //  Wait for key exchange to be completed
                WaitOnHandle(_keyExchangeCompletedWaitHandle);
            }

            Log(string.Format("SendMessage to server '{0}': '{1}'.", message.GetType().Name, message));

            //  Messages can be sent by different thread so we need to synchronize it
            var paddingMultiplier = _clientCipher == null ? (byte)8 : Math.Max((byte)8, _serverCipher.MinimumSize);    //    Should be recalculate base on cipher min length if cipher specified

            var messageData = message.GetBytes();

            if (_clientCompression != null)
            {
                messageData = _clientCompression.Compress(messageData);
            }

            var packetLength = messageData.Length + 4 + 1; //  add length bytes and padding byte
            var paddingLength = (byte)((-packetLength) & (paddingMultiplier - 1));
            if (paddingLength < paddingMultiplier)
            {
                paddingLength += paddingMultiplier;
            }

            //  Build Packet data
            var packetData = new byte[4 + 1 + messageData.Length + paddingLength];

            //  Add packet length
            ((uint)packetData.Length - 4).GetBytes().CopyTo(packetData, 0);

            //  Add packet padding length
            packetData[4] = paddingLength;

            //  Add packet payload
            messageData.CopyTo(packetData, 4 + 1);

            //  Add random padding
            var paddingBytes = new byte[paddingLength];
            Randomizer.GetBytes(paddingBytes);
            paddingBytes.CopyTo(packetData, 4 + 1 + messageData.Length);

            //  Lock handling of _outboundPacketSequence since it must be sent sequently to server
            lock (_socketLock)
            {
                if (_socket == null || !_socket.Connected)
                    throw new SshConnectionException("Client not connected.");

                //  Calculate packet hash
                var hashData = new byte[4 + packetData.Length];
                _outboundPacketSequence.GetBytes().CopyTo(hashData, 0);
                packetData.CopyTo(hashData, 4);

                //  Encrypt packet data
                if (_clientCipher != null)
                {
                    packetData = _clientCipher.Encrypt(packetData);
                }

                if (packetData.Length > MaximumSshPacketSize)
                {
                    throw new InvalidOperationException(string.Format(CultureInfo.CurrentCulture, "Packet is too big. Maximum packet size is {0} bytes.", MaximumSshPacketSize));
                }

                if (_clientMac == null)
                {
                    SocketWrite(packetData);
                }
                else
                {
                    var hash = _clientMac.ComputeHash(hashData.ToArray());

                    var data = new byte[packetData.Length + _clientMac.HashSize / 8];
                    packetData.CopyTo(data, 0);
                    hash.CopyTo(data, packetData.Length);

                    SocketWrite(data);
                }

                _outboundPacketSequence++;

                Monitor.Pulse(_socketLock);
            }
        }

        /// <summary>
        /// Sends a message to the server.
        /// </summary>
        /// <param name="message">The message to send.</param>
        /// <returns>
        /// <c>true</c> if the message was sent to the server; otherwise, <c>false</c>.
        /// </returns>
        /// <exception cref="InvalidOperationException">The size of the packet exceeds the maximum size defined by the protocol.</exception>
        /// <remarks>
        /// This methods returns <c>false</c> when the attempt to send the message results in a
        /// <see cref="SocketException"/> or a <see cref="SshException"/>.
        /// </remarks>
        private bool TrySendMessage(MessageRenci message)
        {
            try
            {
                SendMessage(message);
                return true;
            }
            catch (SshException ex)
            {
                Log(string.Format("Failure sending message server '{0}': '{1}' => {2}", message.GetType().Name, message, ex));
                return false;
            }
            catch (SocketException ex)
            {
                Log(string.Format("Failure sending message server '{0}': '{1}' => {2}", message.GetType().Name, message, ex));
                return false;
            }
        }

        private static IEnumerable<MessageMetadata> GetMessagesMetadata()
        {
            return new []
                {
                    new MessageMetadata { Name = "SSH_MSG_NEWKEYS", Number = 21, Type = typeof(NewKeysMessage) },
                    new MessageMetadata { Name = "SSH_MSG_REQUEST_FAILURE", Number = 82, Type = typeof(RequestFailureMessage) },
                    new MessageMetadata { Name = "SSH_MSG_KEXINIT", Number = 20, Type = typeof(KeyExchangeInitMessage) },
                    new MessageMetadata { Name = "SSH_MSG_CHANNEL_OPEN_FAILURE", Number = 92, Type = typeof(ChannelOpenFailureMessage) },
                    new MessageMetadata { Name = "SSH_MSG_CHANNEL_FAILURE", Number = 100, Type = typeof(ChannelFailureMessage) },
                    new MessageMetadata { Name = "SSH_MSG_CHANNEL_EXTENDED_DATA", Number = 95, Type = typeof(ChannelExtendedDataMessage) },
                    new MessageMetadata { Name = "SSH_MSG_CHANNEL_DATA", Number = 94, Type = typeof(ChannelDataMessage) },
                    new MessageMetadata { Name = "SSH_MSG_USERAUTH_REQUEST", Number = 50, Type = typeof(RequestMessage) },
                    new MessageMetadata { Name = "SSH_MSG_CHANNEL_REQUEST", Number = 98, Type = typeof(ChannelRequestMessage) },
                    new MessageMetadata { Name = "SSH_MSG_USERAUTH_BANNER", Number = 53, Type = typeof(BannerMessage) },
                    new MessageMetadata { Name = "SSH_MSG_USERAUTH_INFO_RESPONSE", Number = 61, Type = typeof(InformationResponseMessage) },
                    new MessageMetadata { Name = "SSH_MSG_USERAUTH_FAILURE", Number = 51, Type = typeof(FailureMessage) },
                    new MessageMetadata { Name = "SSH_MSG_DEBUG", Number = 4, Type = typeof(DebugMessage), },
                    new MessageMetadata { Name = "SSH_MSG_KEXDH_INIT", Number = 30, Type = typeof(KeyExchangeDhInitMessage) },
                    new MessageMetadata { Name = "SSH_MSG_GLOBAL_REQUEST", Number = 80, Type = typeof(GlobalRequestMessage) },
                    new MessageMetadata { Name = "SSH_MSG_CHANNEL_OPEN", Number = 90, Type = typeof(ChannelOpenMessage) },
                    new MessageMetadata { Name = "SSH_MSG_CHANNEL_OPEN_CONFIRMATION", Number = 91, Type = typeof(ChannelOpenConfirmationMessage) },
                    new MessageMetadata { Name = "SSH_MSG_USERAUTH_INFO_REQUEST", Number = 60, Type = typeof(InformationRequestMessage) },
                    new MessageMetadata { Name = "SSH_MSG_UNIMPLEMENTED", Number = 3, Type = typeof(UnimplementedMessage) },
                    new MessageMetadata { Name = "SSH_MSG_REQUEST_SUCCESS", Number = 81, Type = typeof(RequestSuccessMessage) },
                    new MessageMetadata { Name = "SSH_MSG_CHANNEL_SUCCESS", Number = 99, Type = typeof(ChannelSuccessMessage) },
                    new MessageMetadata { Name = "SSH_MSG_USERAUTH_PASSWD_CHANGEREQ", Number = 60, Type = typeof(PasswordChangeRequiredMessage) },
                    new MessageMetadata { Name = "SSH_MSG_DISCONNECT", Number = 1, Type = typeof(DisconnectMessage) },
                    new MessageMetadata { Name = "SSH_MSG_SERVICE_REQUEST", Number = 5, Type = typeof(ServiceRequestMessage) },
                    new MessageMetadata { Name = "SSH_MSG_KEX_DH_GEX_REQUEST", Number = 34, Type = typeof(KeyExchangeDhGroupExchangeRequest) },
                    new MessageMetadata { Name = "SSH_MSG_KEX_DH_GEX_GROUP", Number = 31, Type = typeof(KeyExchangeDhGroupExchangeGroup) },
                    new MessageMetadata { Name = "SSH_MSG_USERAUTH_SUCCESS", Number = 52, Type = typeof(SuccessMessage) },
                    new MessageMetadata { Name = "SSH_MSG_USERAUTH_PK_OK", Number = 60, Type = typeof(PublicKeyMessage) },
                    new MessageMetadata { Name = "SSH_MSG_IGNORE", Number = 2, Type = typeof(IgnoreMessage) },
                    new MessageMetadata { Name = "SSH_MSG_CHANNEL_WINDOW_ADJUST", Number = 93, Type = typeof(ChannelWindowAdjustMessage) },
                    new MessageMetadata { Name = "SSH_MSG_CHANNEL_EOF", Number = 96, Type = typeof(ChannelEofMessage) },
                    new MessageMetadata { Name = "SSH_MSG_CHANNEL_CLOSE", Number = 97, Type = typeof(ChannelCloseMessage) },
                    new MessageMetadata { Name = "SSH_MSG_SERVICE_ACCEPT", Number = 6, Type = typeof(ServiceAcceptMessage) },
                    new MessageMetadata { Name = "SSH_MSG_KEXDH_REPLY", Number = 31, Type = typeof(KeyExchangeDhReplyMessage) },
                    new MessageMetadata { Name = "SSH_MSG_KEX_DH_GEX_INIT", Number = 32, Type = typeof(KeyExchangeDhGroupExchangeInit) },
                    new MessageMetadata { Name = "SSH_MSG_KEX_DH_GEX_REPLY", Number = 33, Type = typeof(KeyExchangeDhGroupExchangeReply) }
                };
        }

        /// <summary>
        /// Receives the message from the server.
        /// </summary>
        /// <returns>Incoming SSH message.</returns>
        /// <exception cref="SshConnectionException"></exception>
        private MessageRenci ReceiveMessage()
        {
            //  No lock needed since all messages read by only one thread
            var blockSize = _serverCipher == null ? (byte)8 : Math.Max((byte)8, _serverCipher.MinimumSize);

            //  Read packet length first
            var firstBlock = Read(blockSize);

            if (_serverCipher != null)
            {
                firstBlock = _serverCipher.Decrypt(firstBlock);
            }

            var packetLength = (uint)(firstBlock[0] << 24 | firstBlock[1] << 16 | firstBlock[2] << 8 | firstBlock[3]);

            //  Test packet minimum and maximum boundaries
            if (packetLength < Math.Max((byte)16, blockSize) - 4 || packetLength > MaximumSshPacketSize - 4)
                throw new SshConnectionException(string.Format(CultureInfo.CurrentCulture, "Bad packet length {0}", packetLength), DisconnectReason.ProtocolError);

            //  Read rest of the packet data
            var bytesToRead = (int)(packetLength - (blockSize - 4));

            var data = new byte[bytesToRead + blockSize];

            firstBlock.CopyTo(data, 0);

            byte[] serverHash = null;
            if (_serverMac != null)
            {
                serverHash = new byte[_serverMac.HashSize / 8];
                bytesToRead += serverHash.Length;
            }

            if (bytesToRead > 0)
            {
                var nextBlocks = Read(bytesToRead);

                if (serverHash != null)
                {
                    Buffer.BlockCopy(nextBlocks, nextBlocks.Length - serverHash.Length, serverHash, 0, serverHash.Length);
                    nextBlocks = nextBlocks.Take(nextBlocks.Length - serverHash.Length).ToArray();
                }

                if (nextBlocks.Length > 0)
                {
                    if (_serverCipher != null)
                    {
                        nextBlocks = _serverCipher.Decrypt(nextBlocks);
                    }
                    nextBlocks.CopyTo(data, blockSize);
                }
            }

            var paddingLength = data[4];

            var messagePayload = new byte[packetLength - paddingLength - 1];
            Buffer.BlockCopy(data, 5, messagePayload, 0, messagePayload.Length);

            if (_serverDecompression != null)
            {
                messagePayload = _serverDecompression.Decompress(messagePayload);
            }

            //  Validate message against MAC
            if (_serverMac != null)
            {
                var clientHashData = new byte[4 + data.Length];
                var lengthBytes = _inboundPacketSequence.GetBytes();

                lengthBytes.CopyTo(clientHashData, 0);
                data.CopyTo(clientHashData, 4);

                //  Calculate packet hash
                var clientHash = _serverMac.ComputeHash(clientHashData);

                if (!serverHash.SequenceEqual(clientHash))
                {
                    throw new SshConnectionException("MAC error", DisconnectReason.MacError);
                }
            }

            _inboundPacketSequence++;

            return LoadMessage(messagePayload);
        }

        private void SendDisconnect(DisconnectReason reasonCode, string message)
        {
            // only send a disconnect message if it wasn't already sent, and we're
            // still connected
            if (_isDisconnectMessageSent || !IsConnected)
                return;

            var disconnectMessage = new DisconnectMessage(reasonCode, message);

            // send the disconnect message, but ignore the outcome
            TrySendMessage(disconnectMessage);

            _isDisconnectMessageSent = true;
        }

        partial void HandleMessageCore(MessageRenci message);

        /// <summary>
        /// Handles the message.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="message">The message.</param>
        private void HandleMessage<T>(T message) where T : MessageRenci
        {
            OnMessageReceived(message);
        }

        #region Handle transport messages

        private void HandleMessage(DisconnectMessage message)
        {
            OnDisconnectReceived(message);

            //  disconnect from the socket, and dispose it
            SocketDisconnectAndDispose();
        }

        private void HandleMessage(IgnoreMessage message)
        {
            OnIgnoreReceived(message);
        }

        private void HandleMessage(UnimplementedMessage message)
        {
            OnUnimplementedReceived(message);
        }

        private void HandleMessage(DebugMessage message)
        {
            OnDebugReceived(message);
        }

        private void HandleMessage(ServiceRequestMessage message)
        {
            OnServiceRequestReceived(message);
        }

        private void HandleMessage(ServiceAcceptMessage message)
        {
            //OneCodeTODO:   Refactor to avoid this method here
            OnServiceAcceptReceived(message);

            _serviceAccepted.Set();
        }

        private void HandleMessage(KeyExchangeInitMessage message)
        {
            OnKeyExchangeInitReceived(message);
        }

        private void HandleMessage(NewKeysMessage message)
        {
            OnNewKeysReceived(message);
        }

        #endregion

        #region Handle User Authentication messages

        private void HandleMessage(RequestMessage message)
        {
            OnUserAuthenticationRequestReceived(message);
        }

        private void HandleMessage(FailureMessage message)
        {
            OnUserAuthenticationFailureReceived(message);
        }

        private void HandleMessage(SuccessMessage message)
        {
            OnUserAuthenticationSuccessReceived(message);
        }

        private void HandleMessage(BannerMessage message)
        {
            OnUserAuthenticationBannerReceived(message);
        }

        #endregion

        #region Handle connection messages

        private void HandleMessage(GlobalRequestMessage message)
        {
            OnGlobalRequestReceived(message);
        }

        private void HandleMessage(RequestSuccessMessage message)
        {
            OnRequestSuccessReceived(message);
        }

        private void HandleMessage(RequestFailureMessage message)
        {
            OnRequestFailureReceived(message);
        }

        private void HandleMessage(ChannelOpenMessage message)
        {
            OnChannelOpenReceived(message);
        }

        private void HandleMessage(ChannelOpenConfirmationMessage message)
        {
            OnChannelOpenConfirmationReceived(message);
        }

        private void HandleMessage(ChannelOpenFailureMessage message)
        {
            OnChannelOpenFailureReceived(message);
        }

        private void HandleMessage(ChannelWindowAdjustMessage message)
        {
            OnChannelWindowAdjustReceived(message);
        }

        private void HandleMessage(ChannelDataMessage message)
        {
            OnChannelDataReceived(message);
        }

        private void HandleMessage(ChannelExtendedDataMessage message)
        {
            OnChannelExtendedDataReceived(message);
        }

        private void HandleMessage(ChannelEofMessage message)
        {
            OnChannelEofReceived(message);
        }

        private void HandleMessage(ChannelCloseMessage message)
        {
            OnChannelCloseReceived(message);
        }

        private void HandleMessage(ChannelRequestMessage message)
        {
            OnChannelRequestReceived(message);
        }

        private void HandleMessage(ChannelSuccessMessage message)
        {
            OnChannelSuccessReceived(message);
        }

        private void HandleMessage(ChannelFailureMessage message)
        {
            OnChannelFailureReceived(message);
        }

        #endregion

        #region Handle received message events

        /// <summary>
        /// Called when <see cref="DisconnectMessage"/> received.
        /// </summary>
        /// <param name="message"><see cref="DisconnectMessage"/> message.</param>
        protected virtual void OnDisconnectReceived(DisconnectMessage message)
        {
            Log(string.Format("Disconnect received: {0} {1}", message.ReasonCode, message.Description));

            var disconnectReceived = DisconnectReceived;
            if (disconnectReceived != null)
                disconnectReceived(this, new MessageEventArgs<DisconnectMessage>(message));

            var disconnected = Disconnected;
            if (disconnected != null)
                disconnected(this, new EventArgs());
        }

        /// <summary>
        /// Called when <see cref="IgnoreMessage"/> received.
        /// </summary>
        /// <param name="message"><see cref="IgnoreMessage"/> message.</param>
        protected virtual void OnIgnoreReceived(IgnoreMessage message)
        {
            var handlers = IgnoreReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<IgnoreMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="UnimplementedMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="UnimplementedMessage"/> message.</param>
        protected virtual void OnUnimplementedReceived(UnimplementedMessage message)
        {
            var handlers = UnimplementedReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<UnimplementedMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="DebugMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="DebugMessage"/> message.</param>
        protected virtual void OnDebugReceived(DebugMessage message)
        {
            var handlers = DebugReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<DebugMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="ServiceRequestMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="ServiceRequestMessage"/> message.</param>
        protected virtual void OnServiceRequestReceived(ServiceRequestMessage message)
        {
            var handlers = ServiceRequestReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<ServiceRequestMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="ServiceAcceptMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="ServiceAcceptMessage"/> message.</param>
        protected virtual void OnServiceAcceptReceived(ServiceAcceptMessage message)
        {
            var handlers = ServiceAcceptReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<ServiceAcceptMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="KeyExchangeInitMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="KeyExchangeInitMessage"/> message.</param>
        protected virtual void OnKeyExchangeInitReceived(KeyExchangeInitMessage message)
        {
            _keyExchangeInProgress = true;

            _keyExchangeCompletedWaitHandle.Reset();

            //  Disable all registered messages except key exchange related
            foreach (var messageMetadata in _messagesMetadata)
            {
                if (messageMetadata.Activated && messageMetadata.Number > 2 && (messageMetadata.Number < 20 || messageMetadata.Number > 30))
                    messageMetadata.Enabled = false;
            }

            var keyExchangeAlgorithmName = (from c in ConnectionInfo.KeyExchangeAlgorithms.Keys
                                            from s in message.KeyExchangeAlgorithms
                                            where s == c
                                            select c).FirstOrDefault();

            if (keyExchangeAlgorithmName == null)
            {
                throw new SshConnectionException("Failed to negotiate key exchange algorithm.", DisconnectReason.KeyExchangeFailed);
            }

            //  Create instance of key exchange algorithm that will be used
            _keyExchange = ConnectionInfo.KeyExchangeAlgorithms[keyExchangeAlgorithmName].CreateInstance<KeyExchange>();

            ConnectionInfo.CurrentKeyExchangeAlgorithm = keyExchangeAlgorithmName;

            _keyExchange.HostKeyReceived += KeyExchange_HostKeyReceived;

            //  Start the algorithm implementation
            _keyExchange.Start(this, message);

            var keyExchangeInitReceived = KeyExchangeInitReceived;
            if (keyExchangeInitReceived != null)
                keyExchangeInitReceived(this, new MessageEventArgs<KeyExchangeInitMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="NewKeysMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="NewKeysMessage"/> message.</param>
        protected virtual void OnNewKeysReceived(NewKeysMessage message)
        {
            //  Update sessionId
            if (SessionId == null)
            {
                SessionId = _keyExchange.ExchangeHash;
            }

            //  Dispose of old ciphers and hash algorithms
            if (_serverMac != null)
            {
                _serverMac.Clear();
                _serverMac = null;
            }

            if (_clientMac != null)
            {
                _clientMac.Clear();
                _clientMac = null;
            }

            //  Update negotiated algorithms
            _serverCipher = _keyExchange.CreateServerCipher();
            _clientCipher = _keyExchange.CreateClientCipher();
            _serverMac = _keyExchange.CreateServerHash();
            _clientMac = _keyExchange.CreateClientHash();
            _clientCompression = _keyExchange.CreateCompressor();
            _serverDecompression = _keyExchange.CreateDecompressor();

            //  Dispose of old KeyExchange object as it is no longer needed.
            if (_keyExchange != null)
            {
                _keyExchange.HostKeyReceived -= KeyExchange_HostKeyReceived;
                _keyExchange.Dispose();
                _keyExchange = null;
            }

            //  Enable all active registered messages
            foreach (var messageMetadata in _messagesMetadata)
            {
                if (messageMetadata.Activated)
                    messageMetadata.Enabled = true;
            }

            var newKeysReceived = NewKeysReceived;
            if (newKeysReceived != null)
                newKeysReceived(this, new MessageEventArgs<NewKeysMessage>(message));

            //  Signal that key exchange completed
            _keyExchangeCompletedWaitHandle.Set();

            _keyExchangeInProgress = false;
        }

        /// <summary>
        /// Called when client is disconnecting from the server.
        /// </summary>
        void ISession.OnDisconnecting()
        {
            _isDisconnecting = true;
        }

        /// <summary>
        /// Called when <see cref="RequestMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="RequestMessage"/> message.</param>
        protected virtual void OnUserAuthenticationRequestReceived(RequestMessage message)
        {
            var handlers = UserAuthenticationRequestReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<RequestMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="FailureMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="FailureMessage"/> message.</param>
        protected virtual void OnUserAuthenticationFailureReceived(FailureMessage message)
        {
            var handlers = UserAuthenticationFailureReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<FailureMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="SuccessMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="SuccessMessage"/> message.</param>
        protected virtual void OnUserAuthenticationSuccessReceived(SuccessMessage message)
        {
            var handlers = UserAuthenticationSuccessReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<SuccessMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="BannerMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="BannerMessage"/> message.</param>
        protected virtual void OnUserAuthenticationBannerReceived(BannerMessage message)
        {
            var handlers = UserAuthenticationBannerReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<BannerMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="GlobalRequestMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="GlobalRequestMessage"/> message.</param>
        protected virtual void OnGlobalRequestReceived(GlobalRequestMessage message)
        {
            var handlers = GlobalRequestReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<GlobalRequestMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="RequestSuccessMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="RequestSuccessMessage"/> message.</param>
        protected virtual void OnRequestSuccessReceived(RequestSuccessMessage message)
        {
            var handlers = RequestSuccessReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<RequestSuccessMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="RequestFailureMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="RequestFailureMessage"/> message.</param>
        protected virtual void OnRequestFailureReceived(RequestFailureMessage message)
        {
            var handlers = RequestFailureReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<RequestFailureMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="ChannelOpenMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="ChannelOpenMessage"/> message.</param>
        protected virtual void OnChannelOpenReceived(ChannelOpenMessage message)
        {
            var handlers = ChannelOpenReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<ChannelOpenMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="ChannelOpenConfirmationMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="ChannelOpenConfirmationMessage"/> message.</param>
        protected virtual void OnChannelOpenConfirmationReceived(ChannelOpenConfirmationMessage message)
        {
            var handlers = ChannelOpenConfirmationReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<ChannelOpenConfirmationMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="ChannelOpenFailureMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="ChannelOpenFailureMessage"/> message.</param>
        protected virtual void OnChannelOpenFailureReceived(ChannelOpenFailureMessage message)
        {
            var handlers = ChannelOpenFailureReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<ChannelOpenFailureMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="ChannelWindowAdjustMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="ChannelWindowAdjustMessage"/> message.</param>
        protected virtual void OnChannelWindowAdjustReceived(ChannelWindowAdjustMessage message)
        {
            var handlers = ChannelWindowAdjustReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<ChannelWindowAdjustMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="ChannelDataMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="ChannelDataMessage"/> message.</param>
        protected virtual void OnChannelDataReceived(ChannelDataMessage message)
        {
            var handlers = ChannelDataReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<ChannelDataMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="ChannelExtendedDataMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="ChannelExtendedDataMessage"/> message.</param>
        protected virtual void OnChannelExtendedDataReceived(ChannelExtendedDataMessage message)
        {
            var handlers = ChannelExtendedDataReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<ChannelExtendedDataMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="ChannelCloseMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="ChannelCloseMessage"/> message.</param>
        protected virtual void OnChannelEofReceived(ChannelEofMessage message)
        {
            var handlers = ChannelEofReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<ChannelEofMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="ChannelCloseMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="ChannelCloseMessage"/> message.</param>
        protected virtual void OnChannelCloseReceived(ChannelCloseMessage message)
        {
            var handlers = ChannelCloseReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<ChannelCloseMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="ChannelRequestMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="ChannelRequestMessage"/> message.</param>
        protected virtual void OnChannelRequestReceived(ChannelRequestMessage message)
        {
            var handlers = ChannelRequestReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<ChannelRequestMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="ChannelSuccessMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="ChannelSuccessMessage"/> message.</param>
        protected virtual void OnChannelSuccessReceived(ChannelSuccessMessage message)
        {
            var handlers = ChannelSuccessReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<ChannelSuccessMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="ChannelFailureMessage"/> message received.
        /// </summary>
        /// <param name="message"><see cref="ChannelFailureMessage"/> message.</param>
        protected virtual void OnChannelFailureReceived(ChannelFailureMessage message)
        {
            var handlers = ChannelFailureReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<ChannelFailureMessage>(message));
        }

        /// <summary>
        /// Called when <see cref="MessageRenci"/> message received.
        /// </summary>
        /// <param name="message"><see cref="MessageRenci"/> message.</param>
        protected virtual void OnMessageReceived(MessageRenci message)
        {
            var handlers = MessageReceived;
            if (handlers != null)
                handlers(this, new MessageEventArgs<MessageRenci>(message));
        }

        #endregion

        private void KeyExchange_HostKeyReceived(object sender, HostKeyEventArgs e)
        {
            var handlers = HostKeyReceived;
            if (handlers != null)
                handlers(this, e);
        }

        /// <summary>
        /// Reads the specified length of bytes from the server.
        /// </summary>
        /// <param name="length">The length.</param>
        /// <returns>
        /// The bytes read from the server.
        /// </returns>
        private byte[] Read(int length)
        {
            var buffer = new byte[length];

            SocketRead(length, ref buffer);

            return buffer;
        }

        #region Message loading functions

        /// <summary>
        /// Registers SSH message with the session.
        /// </summary>
        /// <param name="messageName">The name of the message to register with the session.</param>
        public void RegisterMessage(string messageName)
        {
            InternalRegisterMessage(messageName);
        }

        /// <summary>
        /// Unregister SSH message from the session.
        /// </summary>
        /// <param name="messageName">The name of the message to unregister with the session.</param>
        public void UnRegisterMessage(string messageName)
        {
            InternalUnRegisterMessage(messageName);
        }

        /// <summary>
        /// Loads the message.
        /// </summary>
        /// <param name="data">Message data.</param>
        /// <returns>New message</returns>
        private MessageRenci LoadMessage(byte[] data)
        {
            var messageType = data[0];
            var messageMetadata = (from m in _messagesMetadata where m.Number == messageType && m.Enabled && m.Activated select m).SingleOrDefault();
            if (messageMetadata == null)
                throw new SshException(string.Format(CultureInfo.CurrentCulture, "Message type {0} is not valid.", messageType));

            var message = messageMetadata.Type.CreateInstance<MessageRenci>();

            message.Load(data);

            Log(string.Format("ReceiveMessage from server: '{0}': '{1}'.", message.GetType().Name, message));

            return message;
        }

        partial void InternalRegisterMessage(string messageName);

        partial void InternalUnRegisterMessage(string messageName);

        #endregion

        partial void ExecuteThread(Action action);

        /// <summary>
        /// Gets a value indicating whether the socket is connected.
        /// </summary>
        /// <value>
        /// <c>true</c> if the socket is connected; otherwise, <c>false</c>.
        /// </value>
        partial void IsSocketConnected(ref bool isConnected);

        /// <summary>
        /// Establishes a socket connection to the specified host and port.
        /// </summary>
        /// <param name="host">The host name of the server to connect to.</param>
        /// <param name="port">The port to connect to.</param>
        /// <exception cref="SshOperationTimeoutException">The connection failed to establish within the configured <see cref="Renci.SshNet.ConnectionInfo.Timeout"/>.</exception>
        /// <exception cref="SocketException">An error occurred trying to establish the connection.</exception>
        partial void SocketConnect(string host, int port);

        /// <summary>
        /// Closes the socket.
        /// </summary>
        /// <exception cref="SocketException">An error occurred when trying to access the socket.</exception>
        partial void SocketDisconnect();

        /// <summary>
        /// Performs a blocking read on the socket until <paramref name="length"/> bytes are received.
        /// </summary>
        /// <param name="length">The number of bytes to read.</param>
        /// <param name="buffer">The buffer to read to.</param>
        /// <exception cref="SshConnectionException">The socket is closed.</exception>
        /// <exception cref="SshOperationTimeoutException">The read has timed-out.</exception>
        /// <exception cref="SocketException">The read failed.</exception>
        partial void SocketRead(int length, ref byte[] buffer);

        /// <summary>
        /// Performs a blocking read on the socket until a line is read.
        /// </summary>
        /// <param name="response">The line read from the socket, or <c>null</c> when the remote server has shutdown and all data has been received.</param>
        /// <param name="timeout">A <see cref="TimeSpan"/> that represents the time to wait until a line is read.</param>
        /// <exception cref="SshOperationTimeoutException">The read has timed-out.</exception>
        /// <exception cref="SocketException">An error occurred when trying to access the socket.</exception>
        partial void SocketReadLine(ref string response, TimeSpan timeout);

        partial void Log(string text);

        /// <summary>
        /// Writes the specified data to the server.
        /// </summary>
        /// <param name="data">The data to write to the server.</param>
        /// <exception cref="SshOperationTimeoutException">The write has timed-out.</exception>
        /// <exception cref="SocketException">The write failed.</exception>
        partial void SocketWrite(byte[] data);

        /// <summary>
        /// Disconnects and disposes the socket.
        /// </summary>
        private void SocketDisconnectAndDispose()
        {
            if (_socket != null)
            {
                lock (_socketLock)
                {
                    if (_socket != null)
                    {
                        if (_socket.Connected)
                            SocketDisconnect();
                        _socket.Dispose();
                        _socket = null;
                    }
                }
            }
        }

        /// <summary>
        /// Listens for incoming message from the server and handles them. This method run as a task on separate thread.
        /// </summary>
        private void MessageListener()
        {
            try
            {
                while (_socket != null && _socket.Connected)
                {
                    var message = ReceiveMessage();
                    HandleMessageCore(message);
                }
            }
            catch (Exception exp)
            {
                RaiseError(exp);
            }
        }

        private byte SocketReadByte()
        {
            var buffer = new byte[1];

            SocketRead(1, ref buffer);

            return buffer[0];
        }

        private void SocketWriteByte(byte data)
        {
            SocketWrite(new[] {data});
        }

        private void ConnectSocks4()
        {
            //  Send socks version number
            SocketWriteByte(0x04);

            //  Send command code
            SocketWriteByte(0x01);

            //  Send port
            SocketWriteByte((byte)(ConnectionInfo.Port / 0xFF));
            SocketWriteByte((byte)(ConnectionInfo.Port % 0xFF));

            //  Send IP
            var ipAddress = ConnectionInfo.Host.GetIPAddress();
            SocketWrite(ipAddress.GetAddressBytes());

            //  Send username
            var username = new Renci.SshNet.Common.ASCIIEncoding().GetBytes(ConnectionInfo.ProxyUsername);
            SocketWrite(username);
            SocketWriteByte(0x00);

            //  Read 0
            if (SocketReadByte() != 0)
            {
                throw new ProxyException("SOCKS4: Null is expected.");
            }

            //  Read response code
            var code = SocketReadByte();

            switch (code)
            {
                case 0x5a:
                    break;
                case 0x5b:
                    throw new ProxyException("SOCKS4: Connection rejected.");
                case 0x5c:
                    throw new ProxyException("SOCKS4: Client is not running identd or not reachable from the server.");
                case 0x5d:
                    throw new ProxyException("SOCKS4: Client's identd could not confirm the user ID string in the request.");
                default:
                    throw new ProxyException("SOCKS4: Not valid response.");
            }

            var dummyBuffer = new byte[4];

            //  Read 2 bytes to be ignored
            SocketRead(2, ref dummyBuffer);

            //  Read 4 bytes to be ignored
            SocketRead(4, ref dummyBuffer);
        }

        private void ConnectSocks5()
        {
            //  Send socks version number
            SocketWriteByte(0x05);

            //  Send number of supported authentication methods
            SocketWriteByte(0x02);

            //  Send supported authentication methods
            SocketWriteByte(0x00); //  No authentication
            SocketWriteByte(0x02); //  Username/Password

            var socksVersion = SocketReadByte();
            if (socksVersion != 0x05)
                throw new ProxyException(string.Format("SOCKS Version '{0}' is not supported.", socksVersion));

            var authenticationMethod = SocketReadByte();
            switch (authenticationMethod)
            {
                case 0x00:
                    break;
                case 0x02:

                    //  Send version
                    SocketWriteByte(0x01);

                    var encoding = new Renci.SshNet.Common.ASCIIEncoding();

                    var username = encoding.GetBytes(ConnectionInfo.ProxyUsername);

                    if (username.Length > byte.MaxValue)
                        throw new ProxyException("Proxy username is too long.");

                    //  Send username length
                    SocketWriteByte((byte)username.Length);

                    //  Send username
                    SocketWrite(username);

                    var password = encoding.GetBytes(ConnectionInfo.ProxyPassword);

                    if (password.Length > byte.MaxValue)
                        throw new ProxyException("Proxy password is too long.");

                    //  Send username length
                    SocketWriteByte((byte)password.Length);

                    //  Send username
                    SocketWrite(password);

                    var serverVersion = SocketReadByte();

                    if (serverVersion != 1)
                        throw new ProxyException("SOCKS5: Server authentication version is not valid.");

                    var statusCode = SocketReadByte();
                    if (statusCode != 0)
                        throw new ProxyException("SOCKS5: Username/Password authentication failed.");

                    break;
                case 0xFF:
                    throw new ProxyException("SOCKS5: No acceptable authentication methods were offered.");
            }

            //  Send socks version number
            SocketWriteByte(0x05);

            //  Send command code
            SocketWriteByte(0x01); //  establish a TCP/IP stream connection

            //  Send reserved, must be 0x00
            SocketWriteByte(0x00);

            var ip = ConnectionInfo.Host.GetIPAddress();

            //  Send address type and address
            if (ip.AddressFamily == AddressFamily.InterNetwork)
            {
                SocketWriteByte(0x01);
                var address = ip.GetAddressBytes();
                SocketWrite(address);
            }
            else if (ip.AddressFamily == AddressFamily.InterNetworkV6)
            {
                SocketWriteByte(0x04);
                var address = ip.GetAddressBytes();
                SocketWrite(address);
            }
            else
            {
                throw new ProxyException(string.Format("SOCKS5: IP address '{0}' is not supported.", ip));
            }

            //  Send port
            SocketWriteByte((byte)(ConnectionInfo.Port / 0xFF));
            SocketWriteByte((byte)(ConnectionInfo.Port % 0xFF));

            //  Read Server SOCKS5 version
            if (SocketReadByte() != 5)
            {
                throw new ProxyException("SOCKS5: Version 5 is expected.");
            }

            //  Read response code
            var status = SocketReadByte();

            switch (status)
            {
                case 0x00:
                    break;
                case 0x01:
                    throw new ProxyException("SOCKS5: General failure.");
                case 0x02:
                    throw new ProxyException("SOCKS5: Connection not allowed by ruleset.");
                case 0x03:
                    throw new ProxyException("SOCKS5: Network unreachable.");
                case 0x04:
                    throw new ProxyException("SOCKS5: Host unreachable.");
                case 0x05:
                    throw new ProxyException("SOCKS5: Connection refused by destination host.");
                case 0x06:
                    throw new ProxyException("SOCKS5: TTL expired.");
                case 0x07:
                    throw new ProxyException("SOCKS5: Command not supported or protocol error.");
                case 0x08:
                    throw new ProxyException("SOCKS5: Address type not supported.");
                default:
                    throw new ProxyException("SOCKS4: Not valid response.");
            }

            //  Read 0
            if (SocketReadByte() != 0)
            {
                throw new ProxyException("SOCKS5: 0 byte is expected.");
            }

            var addressType = SocketReadByte();
            var responseIp = new byte[16];

            switch (addressType)
            {
                case 0x01:
                    SocketRead(4, ref responseIp);
                    break;
                case 0x04:
                    SocketRead(16, ref responseIp);
                    break;
                default:
                    throw new ProxyException(string.Format("Address type '{0}' is not supported.", addressType));
            }

            var port = new byte[2];

            //  Read 2 bytes to be ignored
            SocketRead(2, ref port);
        }

        private void ConnectHttp()
        {
            var httpResponseRe = new Regex(@"HTTP/(?<version>\d[.]\d) (?<statusCode>\d{3}) (?<reasonPhrase>.+)$");
            var httpHeaderRe = new Regex(@"(?<fieldName>[^\[\]()<>@,;:\""/?={} \t]+):(?<fieldValue>.+)?");

            var encoding = new Renci.SshNet.Common.ASCIIEncoding();

            SocketWrite(encoding.GetBytes(string.Format("CONNECT {0}:{1} HTTP/1.0\r\n", ConnectionInfo.Host, ConnectionInfo.Port)));

            //  Sent proxy authorization is specified
            if (!string.IsNullOrEmpty(ConnectionInfo.ProxyUsername))
            {
                var authorization = string.Format("Proxy-Authorization: Basic {0}\r\n",
                                                  Convert.ToBase64String(encoding.GetBytes(string.Format("{0}:{1}", ConnectionInfo.ProxyUsername, ConnectionInfo.ProxyPassword)))
                                                  );
                SocketWrite(encoding.GetBytes(authorization));
            }

            SocketWrite(encoding.GetBytes("\r\n"));

            HttpStatusCode? statusCode = null;
            var response = string.Empty;
            var contentLength = 0;

            while (true)
            {
                SocketReadLine(ref response, ConnectionInfo.Timeout);
                if (response == null)
                    // server shut down socket
                    break;

                if (statusCode == null)
                {
                    var statusMatch = httpResponseRe.Match(response);
                    if (statusMatch.Success)
                    {
                        var httpStatusCode = statusMatch.Result("${statusCode}");
                        statusCode = (HttpStatusCode) int.Parse(httpStatusCode);
                        if (statusCode != HttpStatusCode.OK)
                        {
                            var reasonPhrase = statusMatch.Result("${reasonPhrase}");
                            throw new ProxyException(string.Format("HTTP: Status code {0}, \"{1}\"", httpStatusCode,
                                reasonPhrase));
                        }
                    }

                    continue;
                }

                // continue on parsing message headers coming from the server
                var headerMatch = httpHeaderRe.Match(response);
                if (headerMatch.Success)
                {
                    var fieldName = headerMatch.Result("${fieldName}");
                    if (fieldName.Equals("Content-Length", StringComparison.InvariantCultureIgnoreCase))
                    {
                        contentLength = int.Parse(headerMatch.Result("${fieldValue}"));
                    }
                    continue;
                }

                // check if we've reached the CRLF which separates request line and headers from the message body
                if (response.Length == 0)
                {
                    //  read response body if specified
                    if (contentLength > 0)
                    {
                        var contentBody = new byte[contentLength];
                        SocketRead(contentLength, ref contentBody);
                    }
                    break;
                }
            }

            if (statusCode == null)
                throw new ProxyException("HTTP response does not contain status line.");
        }

        /// <summary>
        /// Raises the <see cref="ErrorOccured"/> event.
        /// </summary>
        /// <param name="exp">The exp.</param>
        private void RaiseError(Exception exp)
        {
            var connectionException = exp as SshConnectionException;

            if (_isDisconnecting)
            {
                //  a connection exception which is raised while isDisconnecting is normal and
                //  should be ignored
                if (connectionException != null)
                    return;

                // any timeout while disconnecting can be caused by loss of connectivity
                // altogether and should be ignored
                var socketException = exp as SocketException;
                if (socketException != null && socketException.SocketErrorCode == SocketError.TimedOut)
                    return;
            }

            _exception = exp;

            _exceptionWaitHandle.Set();

            var errorOccured = ErrorOccured;
            if (errorOccured != null)
                errorOccured(this, new ExceptionEventArgs(exp));

            if (connectionException != null && connectionException.DisconnectReason != DisconnectReason.ConnectionLost)
            {
                Disconnect(connectionException.DisconnectReason, exp.ToString());
            }
        }

        /// <summary>
        /// Resets connection-specific information to ensure state of a previous connection
        /// does not affect new connections.
        /// </summary>
        private void Reset()
        {
            if (_exceptionWaitHandle != null)
                _exceptionWaitHandle.Reset();
            if (_keyExchangeCompletedWaitHandle != null)
                _keyExchangeCompletedWaitHandle.Reset();
            if (_messageListenerCompleted != null)
                _messageListenerCompleted.Reset();

            SessionId = null;
            _isDisconnectMessageSent = false;
            _isDisconnecting = false;
            _isAuthenticated = false;
            _exception = null;
            _keyExchangeInProgress = false;
        }

        #region IDisposable implementation

        private bool _disposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged ResourceMessages.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!_disposed)
            {
                // If disposing equals true, dispose all managed
                // and unmanaged ResourceMessages.
                if (disposing)
                {
                    Disconnect();

                    if (_serviceAccepted != null)
                    {
                        _serviceAccepted.Dispose();
                        _serviceAccepted = null;
                    }

                    if (_exceptionWaitHandle != null)
                    {
                        _exceptionWaitHandle.Dispose();
                        _exceptionWaitHandle = null;
                    }

                    if (_keyExchangeCompletedWaitHandle != null)
                    {
                        _keyExchangeCompletedWaitHandle.Dispose();
                        _keyExchangeCompletedWaitHandle = null;
                    }

                    if (_serverMac != null)
                    {
                        _serverMac.Clear();
                        _serverMac = null;
                    }

                    if (_clientMac != null)
                    {
                        _clientMac.Clear();
                        _clientMac = null;
                    }

                    if (_keyExchange != null)
                    {
                        _keyExchange.HostKeyReceived -= KeyExchange_HostKeyReceived;
                        _keyExchange.Dispose();
                        _keyExchange = null;
                    }

                    if (_bytesReadFromSocket != null)
                    {
                        _bytesReadFromSocket.Dispose();
                        _bytesReadFromSocket = null;
                    }
                }

                // Note disposing has been done.
                _disposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="Session"/> is reclaimed by garbage collection.
        /// </summary>
        ~Session()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion IDisposable implementation

        #region ISession implementation

        /// <summary>
        /// Gets or sets the connection info.
        /// </summary>
        /// <value>The connection info.</value>
        IConnectionInfo ISession.ConnectionInfo
        {
            get { return ConnectionInfo; }
        }

        WaitHandle ISession.MessageListenerCompleted
        {
            get { return _messageListenerCompleted; }
        }

        /// <summary>
        /// Create a new SSH session channel.
        /// </summary>
        /// <returns>
        /// A new SSH session channel.
        /// </returns>
        IChannelSession ISession.CreateChannelSession()
        {
            return new ChannelSession(this, NextChannelNumber, InitialLocalWindowSize, LocalChannelDataPacketSize);
        }

        /// <summary>
        /// Create a new channel for a locally forwarded TCP/IP port.
        /// </summary>
        /// <returns>
        /// A new channel for a locally forwarded TCP/IP port.
        /// </returns>
        IChannelDirectTcpip ISession.CreateChannelDirectTcpip()
        {
            return new ChannelDirectTcpip(this, NextChannelNumber, InitialLocalWindowSize, LocalChannelDataPacketSize);
        }

        /// <summary>
        /// Creates a "forwarded-tcpip" SSH channel.
        /// </summary>
        /// <returns>
        /// A new "forwarded-tcpip" SSH channel.
        /// </returns>
        IChannelForwardedTcpip ISession.CreateChannelForwardedTcpip(uint remoteChannelNumber, uint remoteWindowSize,
            uint remoteChannelDataPacketSize)
        {
            return new ChannelForwardedTcpip(this,
                                             NextChannelNumber,
                                             InitialLocalWindowSize,
                                             LocalChannelDataPacketSize,
                                             remoteChannelNumber,
                                             remoteWindowSize,
                                             remoteChannelDataPacketSize);
        }

        /// <summary>
        /// Sends a message to the server.
        /// </summary>
        /// <param name="message">The message to send.</param>
        /// <exception cref="SshConnectionException">The client is not connected.</exception>
        /// <exception cref="SshOperationTimeoutException">The operation timed out.</exception>
        /// <exception cref="InvalidOperationException">The size of the packet exceeds the maximum size defined by the protocol.</exception>
        void ISession.SendMessage(MessageRenci message)
        {
            SendMessage(message);
        }

        /// <summary>
        /// Sends a message to the server.
        /// </summary>
        /// <param name="message">The message to send.</param>
        /// <returns>
        /// <c>true</c> if the message was sent to the server; otherwise, <c>false</c>.
        /// </returns>
        /// <exception cref="InvalidOperationException">The size of the packet exceeds the maximum size defined by the protocol.</exception>
        /// <remarks>
        /// This methods returns <c>false</c> when the attempt to send the message results in a
        /// <see cref="SocketException"/> or a <see cref="SshException"/>.
        /// </remarks>
        bool ISession.TrySendMessage(MessageRenci message)
        {
            return TrySendMessage(message);
        }

        #endregion ISession implementation

        private class MessageMetadata
        {
            public string Name { get; set; }

            public byte Number { get; set; }

            public bool Enabled { get; set; }

            public bool Activated { get; set; }

            public Type Type { get; set; }
        }
    }
}
#endif
// file ...\X\Renci.SshNet\Session.NET.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    public partial class Session
    {
        private const byte Null = 0x00;
        private const byte CarriageReturn = 0x0d;
        private const byte LineFeed = 0x0a;

        private readonly TraceSource _log =
#if DEBUG
            new TraceSource("SshNet.Logging", SourceLevels.All);
#else
            new TraceSource("SshNet.Logging");
#endif

        /// <summary>
        /// Holds the lock object to ensure read access to the socket is synchronized.
        /// </summary>
        private readonly object _socketReadLock = new object();

        /// <summary>
        /// Gets a value indicating whether the socket is connected.
        /// </summary>
        /// <param name="isConnected"><c>true</c> if the socket is connected; otherwise, <c>false</c></param>
        /// <remarks>
        /// <para>
        /// As a first check we verify whether <see cref="Socket.Connected"/> is
        /// <c>true</c>. However, this only returns the state of the socket as of
        /// the last I/O operation. Therefore we use the combination of Socket.Poll
        /// with mode SelectRead and Socket.Available to verify if the socket is
        /// still connected.
        /// </para>
        /// <para>
        /// The MSDN doc mention the following on the return value of <see cref="Socket.Poll(int, SelectMode)"/>
        /// with mode <see cref="SelectMode.SelectRead"/>:
        /// <list type="bullet">
        ///     <item>
        ///         <description><c>true</c> if data is available for reading;</description>
        ///     </item>
        ///     <item>
        ///         <description><c>true</c> if the connection has been closed, reset, or terminated; otherwise, returns <c>false</c>.</description>
        ///     </item>
        /// </list>
        /// </para>
        /// <para>
        /// <c>Conclusion:</c> when the return value is <c>true</c> - but no data is available for reading - then
        /// the socket is no longer connected.
        /// </para>
        /// <para>
        /// When a <see cref="Socket"/> is used from multiple threads, there's a race condition
        /// between the invocation of <see cref="Socket.Poll(int, SelectMode)"/> and the moment
        /// when the value of <see cref="Socket.Available"/> is obtained. As a workaround, we signal
        /// when bytes are read from the <see cref="Socket"/>.
        /// </para>
        /// </remarks>
        partial void IsSocketConnected(ref bool isConnected)
        {
            isConnected = (_socket != null && _socket.Connected);
            if (isConnected)
            {
                // synchronize this to ensure thread B does not reset the wait handle before
                // thread A was able to check whether "bytes read from socket" signal was
                // actually received
                lock (_socketReadLock)
                {
                    _bytesReadFromSocket.Reset();
                    var connectionClosedOrDataAvailable = _socket.Poll(1000, SelectMode.SelectRead);
                    isConnected = !(connectionClosedOrDataAvailable && _socket.Available == 0);
                    if (!isConnected)
                    {
                        // the race condition is between the Socket.Poll call and
                        // Socket.Available, but the event handler - where we signal that
                        // bytes have been received from the socket - is sometimes invoked
                        // shortly after
                        isConnected = _bytesReadFromSocket.WaitOne(500);
                    }
                }
            }
        }

        /// <summary>
        /// Establishes a socket connection to the specified host and port.
        /// </summary>
        /// <param name="host">The host name of the server to connect to.</param>
        /// <param name="port">The port to connect to.</param>
        /// <exception cref="SshOperationTimeoutException">The connection failed to establish within the configured <see cref="Renci.SshNet.ConnectionInfo.Timeout"/>.</exception>
        /// <exception cref="SocketException">An error occurred trying to establish the connection.</exception>
        partial void SocketConnect(string host, int port)
        {
            const int socketBufferSize = 2 * MaximumSshPacketSize;

            var ipAddress = host.GetIPAddress();
            var timeout = ConnectionInfo.Timeout;
            var ep = new IPEndPoint(ipAddress, port);

            _socket = new Socket(ep.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
            _socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);
            _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendBuffer, socketBufferSize);
            _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, socketBufferSize);

            Log(string.Format("Initiating connect to '{0}:{1}'.", ConnectionInfo.Host, ConnectionInfo.Port));

            var connectResult = _socket.BeginConnect(ep, null, null);
            if (!connectResult.AsyncWaitHandle.WaitOne(timeout, false))
                throw new SshOperationTimeoutException(string.Format(CultureInfo.InvariantCulture,
                    "Connection failed to establish within {0:F0} milliseconds.", timeout.TotalMilliseconds));

            _socket.EndConnect(connectResult);
        }

        /// <summary>
        /// Closes the socket and allows the socket to be reused after the current connection is closed.
        /// </summary>
        /// <exception cref="SocketException">An error occurred when trying to access the socket.</exception>
        partial void SocketDisconnect()
        {
            _socket.Disconnect(true);
        }

        /// <summary>
        /// Performs a blocking read on the socket until a line is read.
        /// </summary>
        /// <param name="response">The line read from the socket, or <c>null</c> when the remote server has shutdown and all data has been received.</param>
        /// <param name="timeout">A <see cref="TimeSpan"/> that represents the time to wait until a line is read.</param>
        /// <exception cref="SshOperationTimeoutException">The read has timed-out.</exception>
        /// <exception cref="SocketException">An error occurred when trying to access the socket.</exception>
        partial void SocketReadLine(ref string response, TimeSpan timeout)
        {
            var encoding = new Renci.SshNet.Common.ASCIIEncoding();
            var buffer = new List<byte>();
            var data = new byte[1];

            // read data one byte at a time to find end of line and leave any unhandled information in the buffer
            // to be processed by subsequent invocations
            do
            {
                var asyncResult = _socket.BeginReceive(data, 0, data.Length, SocketFlags.None, null, null);
                if (!asyncResult.AsyncWaitHandle.WaitOne(timeout))
                    throw new SshOperationTimeoutException(string.Format(CultureInfo.InvariantCulture,
                        "Socket read operation has timed out after {0:F0} milliseconds.", timeout.TotalMilliseconds));

                var received = _socket.EndReceive(asyncResult);

                if (received == 0)
                    // the remote server shut down the socket
                    break;

                buffer.Add(data[0]);
            }
            while (!(buffer.Count > 0 && (buffer[buffer.Count - 1] == LineFeed || buffer[buffer.Count - 1] == Null)));

            if (buffer.Count == 0)
                response = null;
            else if (buffer.Count == 1 && buffer[buffer.Count - 1] == 0x00)
                // return an empty version string if the buffer consists of only a 0x00 character
                response = string.Empty;
            else if (buffer.Count > 1 && buffer[buffer.Count - 2] == CarriageReturn)
                // strip trailing CRLF
                response = encoding.GetString(buffer.Take(buffer.Count - 2).ToArray());
            else if (buffer.Count > 1 && buffer[buffer.Count - 1] == LineFeed)
                // strip trailing LF
                response = encoding.GetString(buffer.Take(buffer.Count - 1).ToArray());
            else
                response = encoding.GetString(buffer.ToArray());
        }

        /// <summary>
        /// Performs a blocking read on the socket until <paramref name="length"/> bytes are received.
        /// </summary>
        /// <param name="length">The number of bytes to read.</param>
        /// <param name="buffer">The buffer to read to.</param>
        /// <exception cref="SshConnectionException">The socket is closed.</exception>
        /// <exception cref="SocketException">The read failed.</exception>
        partial void SocketRead(int length, ref byte[] buffer)
        {
            var receivedTotal = 0;  // how many bytes is already received

            do
            {
                try
                {
                    var receivedBytes = _socket.Receive(buffer, receivedTotal, length - receivedTotal, SocketFlags.None);
                    if (receivedBytes > 0)
                    {
                        // signal that bytes have been read from the socket
                        // this is used to improve accuracy of Session.IsSocketConnected
                        _bytesReadFromSocket.Set();
                        receivedTotal += receivedBytes;
                        continue;
                    }

                    // 2012-09-11: Kenneth_aa
                    // When Disconnect or Dispose is called, this throws SshConnectionException(), which...
                    // 1 - goes up to ReceiveMessage() 
                    // 2 - up again to MessageListener()
                    // which is where there is a catch-all exception block so it can notify event listeners.
                    // 3 - MessageListener then again calls RaiseError().
                    // There the exception is checked for the exception thrown here (ConnectionLost), and if it matches it will not call Session.SendDisconnect().
                    //
                    // Adding a check for _isDisconnecting causes ReceiveMessage() to throw SshConnectionException: "Bad packet length {0}".
                    //

                    if (_isDisconnecting)
                        throw new SshConnectionException("An established connection was aborted by the software in your host machine.", DisconnectReason.ConnectionLost);
                    throw new SshConnectionException("An established connection was aborted by the server.", DisconnectReason.ConnectionLost);
                }
                catch (SocketException exp)
                {
                    if (exp.SocketErrorCode == SocketError.ConnectionAborted)
                    {
                        buffer = new byte[length];
                        Disconnect();
                        return;
                    }

                    if (exp.SocketErrorCode == SocketError.WouldBlock ||
                        exp.SocketErrorCode == SocketError.IOPending ||
                        exp.SocketErrorCode == SocketError.NoBufferSpaceAvailable)
                    {
                        // socket buffer is probably empty, wait and try again
                        Thread.Sleep(30);
                    }
                    else
                        throw;  // any serious error occurred
                }
            } while (receivedTotal < length);
        }

        /// <summary>
        /// Writes the specified data to the server.
        /// </summary>
        /// <param name="data">The data to write to the server.</param>
        /// <exception cref="SshOperationTimeoutException">The write has timed-out.</exception>
        /// <exception cref="SocketException">The write failed.</exception>
        partial void SocketWrite(byte[] data)
        {
            var totalBytesSent = 0;  // how many bytes are already sent
            var totalBytesToSend = data.Length;

            do
            {
                try
                {
                    totalBytesSent += _socket.Send(data, totalBytesSent, totalBytesToSend - totalBytesSent,
                        SocketFlags.None);
                }
                catch (SocketException ex)
                {
                    if (ex.SocketErrorCode == SocketError.WouldBlock ||
                        ex.SocketErrorCode == SocketError.IOPending ||
                        ex.SocketErrorCode == SocketError.NoBufferSpaceAvailable)
                    {
                        // socket buffer is probably full, wait and try again
                        Thread.Sleep(30);
                    }
                    else
                        throw;  // any serious error occurr
                }
            } while (totalBytesSent < totalBytesToSend);
        }

        [Conditional("DEBUG")]
        partial void Log(string text)
        {
            _log.TraceEvent(TraceEventType.Verbose, 1, text);
        }

#if ASYNC_SOCKET_READ
        private void SocketRead(int length, ref byte[] buffer)
        {
            var state = new SocketReadState(_socket, length, ref buffer);

            _socket.BeginReceive(buffer, 0, length, SocketFlags.None, SocketReceiveCallback, state);

            var readResult = state.Wait();
            switch (readResult)
            {
                case SocketReadResult.Complete:
                    break;
                case SocketReadResult.ConnectionLost:
                    if (_isDisconnecting)
                        throw new SshConnectionException(
                            "An established connection was aborted by the software in your host machine.",
                            DisconnectReason.ConnectionLost);
                    throw new SshConnectionException("An established connection was aborted by the server.",
                        DisconnectReason.ConnectionLost);
                case SocketReadResult.Failed:
                    var socketException = state.Exception as SocketException;
                    if (socketException != null)
                    {
                        if (socketException.SocketErrorCode == SocketError.ConnectionAborted)
                        {
                            buffer = new byte[length];
                            Disconnect();
                            return;
                        }
                    }
                    throw state.Exception;
            }
        }

        private void SocketReceiveCallback(IAsyncResult ar)
        {
            var state = ar.AsyncState as SocketReadState;
            var socket = state.Socket;

            try
            {
                var bytesReceived = socket.EndReceive(ar);
                if (bytesReceived > 0)
                {
                    _bytesReadFromSocket.Set();
                    state.BytesRead += bytesReceived;
                    if (state.BytesRead < state.TotalBytesToRead)
                    {
                        socket.BeginReceive(state.Buffer, state.BytesRead, state.TotalBytesToRead - state.BytesRead,
                            SocketFlags.None, SocketReceiveCallback, state);
                    }
                    else
                    {
                        // we received all bytes that we wanted, so lets mark the read
                        // complete
                        state.Complete();
                    }
                }
                else
                {
                    // the remote host shut down the connection; this could also have been
                    // triggered by a SSH_MSG_DISCONNECT sent by the client
                    state.ConnectionLost();
                }
            }
            catch (SocketException ex)
            {
                if (ex.SocketErrorCode != SocketError.ConnectionAborted)
                {
                    if (ex.SocketErrorCode == SocketError.WouldBlock ||
                        ex.SocketErrorCode == SocketError.IOPending ||
                        ex.SocketErrorCode == SocketError.NoBufferSpaceAvailable)
                    {
                        // socket buffer is probably empty, wait and try again
                        Thread.Sleep(30);

                        socket.BeginReceive(state.Buffer, state.BytesRead, state.TotalBytesToRead - state.BytesRead,
                            SocketFlags.None, SocketReceiveCallback, state);
                        return;
                    }
                }

                state.Fail(ex);
            }
            catch (Exception ex)
            {
                state.Fail(ex);
            }
        }

        private class SocketReadState
        {
            private SocketReadResult _result;

            /// <summary>
            /// WaitHandle to signal that read from socket has completed (either successfully
            /// or with failure)
            /// </summary>
            private EventWaitHandle _socketReadComplete;

            public SocketReadState(Socket socket, int totalBytesToRead, ref byte[] buffer)
            {
                Socket = socket;
                TotalBytesToRead = totalBytesToRead;
                Buffer = buffer;
                _socketReadComplete = new ManualResetEvent(false);
            }

            /// <summary>
            /// Gets the <see cref="Socket"/> to read from.
            /// </summary>
            /// <value>
            /// The <see cref="Socket"/> to read from.
            /// </value>
            public Socket Socket { get; private set; }

            /// <summary>
            /// Gets or sets the number of bytes that have been read from the <see cref="Socket"/>.
            /// </summary>
            /// <value>
            /// The number of bytes that have been read from the <see cref="Socket"/>.
            /// </value>
            public int BytesRead { get; set; }

            /// <summary>
            /// Gets the total number of bytes to read from the <see cref="Socket"/>.
            /// </summary>
            /// <value>
            /// The total number of bytes to read from the <see cref="Socket"/>.
            /// </value>
            public int TotalBytesToRead { get; private set; }

            /// <summary>
            /// Gets or sets the buffer to hold the bytes that have been read.
            /// </summary>
            /// <value>
            /// The buffer to hold the bytes that have been read.
            /// </value>
            public byte[] Buffer { get; private set; }

            /// <summary>
            /// Gets or sets the exception that was thrown while reading from the
            /// <see cref="Socket"/>.
            /// </summary>
            /// <value>
            /// The exception that was thrown while reading from the <see cref="Socket"/>,
            /// or <c>null</c> if no exception was thrown.
            /// </value>
            public Exception Exception { get; private set; }

            /// <summary>
            /// Signals that the total number of bytes has been read successfully.
            /// </summary>
            public void Complete()
            {
                _result = SocketReadResult.Complete;
                _socketReadComplete.Set();
            }

            /// <summary>
            /// Signals that the socket read failed.
            /// </summary>
            /// <param name="cause">The <see cref="Exception"/> that caused the read to fail.</param>
            public void Fail(Exception cause)
            {
                Exception = cause;
                _result = SocketReadResult.Failed;
                _socketReadComplete.Set();
            }

            /// <summary>
            /// Signals that the connection to the server was lost.
            /// </summary>
            public void ConnectionLost()
            {
                _result = SocketReadResult.ConnectionLost;
                _socketReadComplete.Set();
            }

            public SocketReadResult Wait()
            {
                _socketReadComplete.WaitOne();
                _socketReadComplete.Dispose();
                _socketReadComplete = null;
                return _result;
            }
        }

        private enum SocketReadResult
        {
            Complete,
            ConnectionLost,
            Failed
        }
#endif
    }
}

#endif
// file ...\X\Renci.SshNet\Session.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides functionality to connect and interact with SSH server.
    /// </summary>
    public partial class Session
    {
        partial void HandleMessageCore(MessageRenci message)
        {
            if (message is Renci.SshNet.Messages.Connection.GlobalRequestMessage) this.HandleMessage((Renci.SshNet.Messages.Connection.GlobalRequestMessage)message);
            else if (message is Renci.SshNet.Messages.Connection.RequestSuccessMessage) this.HandleMessage((Renci.SshNet.Messages.Connection.RequestSuccessMessage)message);
            else if (message is Renci.SshNet.Messages.Connection.RequestFailureMessage) this.HandleMessage((Renci.SshNet.Messages.Connection.RequestFailureMessage)message);
            else if (message is Renci.SshNet.Messages.Connection.ChannelOpenMessage) this.HandleMessage((Renci.SshNet.Messages.Connection.ChannelOpenMessage)message);
            else if (message is Renci.SshNet.Messages.Connection.ChannelOpenConfirmationMessage) this.HandleMessage((Renci.SshNet.Messages.Connection.ChannelOpenConfirmationMessage)message);
            else if (message is Renci.SshNet.Messages.Connection.ChannelOpenFailureMessage) this.HandleMessage((Renci.SshNet.Messages.Connection.ChannelOpenFailureMessage)message);
            else if (message is Renci.SshNet.Messages.Connection.ChannelWindowAdjustMessage) this.HandleMessage((Renci.SshNet.Messages.Connection.ChannelWindowAdjustMessage)message);
            else if (message is Renci.SshNet.Messages.Connection.ChannelDataMessage) this.HandleMessage((Renci.SshNet.Messages.Connection.ChannelDataMessage)message);
            else if (message is Renci.SshNet.Messages.Connection.ChannelExtendedDataMessage) this.HandleMessage((Renci.SshNet.Messages.Connection.ChannelExtendedDataMessage)message);
            else if (message is Renci.SshNet.Messages.Connection.ChannelEofMessage) this.HandleMessage((Renci.SshNet.Messages.Connection.ChannelEofMessage)message);
            else if (message is Renci.SshNet.Messages.Connection.ChannelCloseMessage) this.HandleMessage((Renci.SshNet.Messages.Connection.ChannelCloseMessage)message);
            else if (message is Renci.SshNet.Messages.Connection.ChannelRequestMessage) this.HandleMessage((Renci.SshNet.Messages.Connection.ChannelRequestMessage)message);
            else if (message is Renci.SshNet.Messages.Connection.ChannelSuccessMessage) this.HandleMessage((Renci.SshNet.Messages.Connection.ChannelSuccessMessage)message);
            else if (message is Renci.SshNet.Messages.Connection.ChannelFailureMessage) this.HandleMessage((Renci.SshNet.Messages.Connection.ChannelFailureMessage)message);
            else if (message is Renci.SshNet.Messages.Transport.DisconnectMessage) this.HandleMessage((Renci.SshNet.Messages.Transport.DisconnectMessage)message);
            else if (message is Renci.SshNet.Messages.Transport.IgnoreMessage) this.HandleMessage((Renci.SshNet.Messages.Transport.IgnoreMessage)message);
            else if (message is Renci.SshNet.Messages.Transport.UnimplementedMessage) this.HandleMessage((Renci.SshNet.Messages.Transport.UnimplementedMessage)message);
            else if (message is Renci.SshNet.Messages.Transport.DebugMessage) this.HandleMessage((Renci.SshNet.Messages.Transport.DebugMessage)message);
            else if (message is Renci.SshNet.Messages.Transport.ServiceRequestMessage) this.HandleMessage((Renci.SshNet.Messages.Transport.ServiceRequestMessage)message);
            else if (message is Renci.SshNet.Messages.Transport.ServiceAcceptMessage) this.HandleMessage((Renci.SshNet.Messages.Transport.ServiceAcceptMessage)message);
            else if (message is Renci.SshNet.Messages.Transport.KeyExchangeInitMessage) this.HandleMessage((Renci.SshNet.Messages.Transport.KeyExchangeInitMessage)message);
            else if (message is Renci.SshNet.Messages.Transport.NewKeysMessage) this.HandleMessage((Renci.SshNet.Messages.Transport.NewKeysMessage)message);
            else if (message is Renci.SshNet.Messages.Authentication.RequestMessage) this.HandleMessage((Renci.SshNet.Messages.Authentication.RequestMessage)message);
            else if (message is Renci.SshNet.Messages.Authentication.FailureMessage) this.HandleMessage((Renci.SshNet.Messages.Authentication.FailureMessage)message);
            else if (message is Renci.SshNet.Messages.Authentication.SuccessMessage) this.HandleMessage((Renci.SshNet.Messages.Authentication.SuccessMessage)message);
            else if (message is Renci.SshNet.Messages.Authentication.BannerMessage) this.HandleMessage((Renci.SshNet.Messages.Authentication.BannerMessage)message);
            else this.HandleMessage(message);
        }

        /// <summary>
        /// Executes the specified action in a separate thread.
        /// </summary>
        /// <param name="action">The action to execute.</param>
        partial void ExecuteThread(Action action)
        {
            ThreadPool.QueueUserWorkItem(o => action());
        }

        partial void InternalRegisterMessage(string messageName)
        {
            lock (this._messagesMetadata)
            {
                Parallel.ForEach(
                    from m in this._messagesMetadata where m.Name == messageName select m,
                    item => { item.Enabled = true; item.Activated = true; });
            }
        }

        partial void InternalUnRegisterMessage(string messageName)
        {
            lock (this._messagesMetadata)
            {
                Parallel.ForEach(
                    from m in this._messagesMetadata where m.Name == messageName select m,
                    item => { item.Enabled = false; item.Activated = false; });
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\SftpClient.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Implementation of the SSH File Transfer Protocol (SFTP) over SSH.
    /// </summary>
    public partial class SftpClient : BaseClient
    {
        /// <summary>
        /// Holds the <see cref="ISftpSession"/> instance that is used to communicate to the
        /// SFTP server.
        /// </summary>
        private ISftpSession _sftpSession;

        /// <summary>
        /// Holds the operation timeout.
        /// </summary>
        private TimeSpan _operationTimeout;

        /// <summary>
        /// Holds the size of the buffer.
        /// </summary>
        private uint _bufferSize;

        /// <summary>
        /// Gets or sets the operation timeout.
        /// </summary>
        /// <value>
        /// The timeout to wait until an operation completes. The default value is negative
        /// one (-1) milliseconds, which indicates an infinite timeout period.
        /// </value>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public TimeSpan OperationTimeout
        {
            get
            {
                CheckDisposed();
                return _operationTimeout;
            }
            set
            {
                CheckDisposed();
                _operationTimeout = value;
            }
        }

        /// <summary>
        /// Gets or sets the maximum size of the buffer in bytes.
        /// </summary>
        /// <value>
        /// The size of the buffer. The default buffer size is 32768 bytes (32 KB).
        /// </value>
        /// <remarks>
        /// <para>
        /// For write operations, this limits the size of the payload for
        /// individual SSH_FXP_WRITE messages. The actual size is always
        /// capped at the maximum packet size supported by the peer
        /// (minus the size of protocol fields).
        /// </para>
        /// <para>
        /// For read operations, this controls the size of the payload which
        /// is requested from the peer in each SSH_FXP_READ message. The peer
        /// will send the requested number of bytes in one or more SSH_FXP_DATA
        /// messages. To optimize the size of the SSH packets sent by the peer,
        /// the actual requested size will take into account the size of the
        /// SSH_FXP_DATA protocol fields.
        /// </para>
        /// <para>
        /// The size of the each indivual SSH_FXP_DATA message is limited to the
        /// local maximum packet size of the channel, which is set to <c>64 KB</c>
        /// for SSH.NET. However, the peer can limit this even further.
        /// </para>
        /// </remarks>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public uint BufferSize
        {
            get
            {
                CheckDisposed();
                return _bufferSize;
            }
            set
            {
                CheckDisposed();
                _bufferSize = value;
            }
        }

        /// <summary>
        /// Gets remote working directory.
        /// </summary>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public string WorkingDirectory
        {
            get
            {
                CheckDisposed();
                if (_sftpSession == null)
                    throw new SshConnectionException("Client not connected.");
                return _sftpSession.WorkingDirectory;
            }
        }

        /// <summary>
        /// Gets sftp protocol version.
        /// </summary>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public int ProtocolVersion
        {
            get
            {
                CheckDisposed();
                if (_sftpSession == null)
                    throw new SshConnectionException("Client not connected.");
                return (int) _sftpSession.ProtocolVersion;
            }
        }

        #region Constructors

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpClient"/> class.
        /// </summary>
        /// <param name="connectionInfo">The connection info.</param>
        /// <exception cref="ArgumentNullException"><paramref name="connectionInfo"/> is <b>null</b>.</exception>
        public SftpClient(ConnectionInfo connectionInfo)
            : this(connectionInfo, false)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpClient"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">Connection port.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="password">Authentication password.</param>
        /// <exception cref="ArgumentNullException"><paramref name="password"/> is <b>null</b>.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid. <para>-or-</para> <paramref name="username"/> is <b>null</b> or contains whitespace characters.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="port"/> is not within <see cref="F:System.Net.IPEndPoint.MinPort"/> and <see cref="System.Net.IPEndPoint.MaxPort"/>.</exception>
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "Disposed in Dispose(bool) method.")]
        public SftpClient(string host, int port, string username, string password)
            : this(new PasswordConnectionInfo(host, port, username, password), true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpClient"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="password">Authentication password.</param>
        /// <exception cref="ArgumentNullException"><paramref name="password"/> is <b>null</b>.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid. <para>-or-</para> <paramref name="username"/> is <b>null</b> contains whitespace characters.</exception>
        public SftpClient(string host, string username, string password)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, password)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpClient"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">Connection port.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="keyFiles">Authentication private key file(s) .</param>
        /// <exception cref="ArgumentNullException"><paramref name="keyFiles"/> is <b>null</b>.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid. <para>-or-</para> <paramref name="username"/> is nu<b>null</b>ll or contains whitespace characters.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="port"/> is not within <see cref="F:System.Net.IPEndPoint.MinPort"/> and <see cref="System.Net.IPEndPoint.MaxPort"/>.</exception>
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "Disposed in Dispose(bool) method.")]
        public SftpClient(string host, int port, string username, params PrivateKeyFile[] keyFiles)
            : this(new PrivateKeyConnectionInfo(host, port, username, keyFiles), true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpClient"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="keyFiles">Authentication private key file(s) .</param>
        /// <exception cref="ArgumentNullException"><paramref name="keyFiles"/> is <b>null</b>.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid. <para>-or-</para> <paramref name="username"/> is <b>null</b> or contains whitespace characters.</exception>
        public SftpClient(string host, string username, params PrivateKeyFile[] keyFiles)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, keyFiles)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpClient"/> class.
        /// </summary>
        /// <param name="connectionInfo">The connection info.</param>
        /// <param name="ownsConnectionInfo">Specified whether this instance owns the connection info.</param>
        /// <exception cref="ArgumentNullException"><paramref name="connectionInfo"/> is null.</exception>
        /// <remarks>
        /// If <paramref name="ownsConnectionInfo"/> is <c>true</c>, then the
        /// connection info will be disposed when this instance is disposed.
        /// </remarks>
        private SftpClient(ConnectionInfo connectionInfo, bool ownsConnectionInfo)
            : this(connectionInfo, ownsConnectionInfo, new ServiceFactory())
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpClient"/> class.
        /// </summary>
        /// <param name="connectionInfo">The connection info.</param>
        /// <param name="ownsConnectionInfo">Specified whether this instance owns the connection info.</param>
        /// <param name="serviceFactory">The factory to use for creating new services.</param>
        /// <exception cref="ArgumentNullException"><paramref name="connectionInfo"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="serviceFactory"/> is null.</exception>
        /// <remarks>
        /// If <paramref name="ownsConnectionInfo"/> is <c>true</c>, then the
        /// connection info will be disposed when this instance is disposed.
        /// </remarks>
        internal SftpClient(ConnectionInfo connectionInfo, bool ownsConnectionInfo, IServiceFactory serviceFactory)
            : base(connectionInfo, ownsConnectionInfo, serviceFactory)
        {
            OperationTimeout = new TimeSpan(0, 0, 0, 0, -1);
            BufferSize = 1024 * 32;
        }

        #endregion

        /// <summary>
        /// Changes remote directory to path.
        /// </summary>
        /// <param name="path">New directory path.</param>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to change directory denied by remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SftpPathNotFoundException"><paramref name="path"/> was not found on the remote host.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message"/> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void ChangeDirectory(string path)
        {
            CheckDisposed();

            if (path == null)
                throw new ArgumentNullException("path");

            if (_sftpSession == null)
                throw new SshConnectionException("Client not connected.");

            _sftpSession.ChangeDirectory(path);
        }

        /// <summary>
        /// Changes permissions of file(s) to specified mode.
        /// </summary>
        /// <param name="path">File(s) path, may match multiple files.</param>
        /// <param name="mode">The mode.</param>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to change permission on the path(s) was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SftpPathNotFoundException"><paramref name="path"/> was not found on the remote host.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message"/> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void ChangePermissions(string path, short mode)
        {
            var file = Get(path);
            file.SetPermissions(mode);
        }

        /// <summary>
        /// Creates remote directory specified by path.
        /// </summary>
        /// <param name="path">Directory path to create.</param>
        /// <exception cref="ArgumentException"><paramref name="path"/> is <b>null</b> or contains whitespace characters.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to create the directory was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message"/> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void CreateDirectory(string path)
        {
            CheckDisposed();

            if (path.IsNullOrWhiteSpace())
                throw new ArgumentException(path);

            if (_sftpSession == null)
                throw new SshConnectionException("Client not connected.");

            var fullPath = _sftpSession.GetCanonicalPath(path);

            _sftpSession.RequestMkDir(fullPath);
        }

        /// <summary>
        /// Deletes remote directory specified by path.
        /// </summary>
        /// <param name="path">Directory to be deleted path.</param>
        /// <exception cref="ArgumentException"><paramref name="path"/> is <b>null</b> or contains whitespace characters.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPathNotFoundException"><paramref name="path"/> was not found on the remote host.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to delete the directory was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message"/> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void DeleteDirectory(string path)
        {
            CheckDisposed();

            if (path.IsNullOrWhiteSpace())
                throw new ArgumentException("path");

            if (_sftpSession == null)
                throw new SshConnectionException("Client not connected.");

            var fullPath = _sftpSession.GetCanonicalPath(path);

            _sftpSession.RequestRmDir(fullPath);
        }

        /// <summary>
        /// Deletes remote file specified by path.
        /// </summary>
        /// <param name="path">File to be deleted path.</param>
        /// <exception cref="ArgumentException"><paramref name="path"/> is <b>null</b> or contains whitespace characters.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPathNotFoundException"><paramref name="path"/> was not found on the remote host.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to delete the file was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message"/> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void DeleteFile(string path)
        {
            CheckDisposed();

            if (path.IsNullOrWhiteSpace())
                throw new ArgumentException("path");

            if (_sftpSession == null)
                throw new SshConnectionException("Client not connected.");

            var fullPath = _sftpSession.GetCanonicalPath(path);

            _sftpSession.RequestRemove(fullPath);
        }

        /// <summary>
        /// Renames remote file from old path to new path.
        /// </summary>
        /// <param name="oldPath">Path to the old file location.</param>
        /// <param name="newPath">Path to the new file location.</param>
        /// <exception cref="ArgumentNullException"><paramref name="oldPath"/> is <b>null</b>. <para>-or-</para> or <paramref name="newPath"/> is <b>null</b>.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to rename the file was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message"/> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void RenameFile(string oldPath, string newPath)
        {
            RenameFile(oldPath, newPath, false);
        }

        /// <summary>
        /// Renames remote file from old path to new path.
        /// </summary>
        /// <param name="oldPath">Path to the old file location.</param>
        /// <param name="newPath">Path to the new file location.</param>
        /// <param name="isPosix">if set to <c>true</c> then perform a posix rename.</param>
        /// <exception cref="ArgumentNullException"><paramref name="oldPath" /> is <b>null</b>. <para>-or-</para> or <paramref name="newPath" /> is <b>null</b>.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to rename the file was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message" /> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void RenameFile(string oldPath, string newPath, bool isPosix)
        {
            CheckDisposed();

            if (oldPath == null)
                throw new ArgumentNullException("oldPath");

            if (newPath == null)
                throw new ArgumentNullException("newPath");

            if (_sftpSession == null)
                throw new SshConnectionException("Client not connected.");

            var oldFullPath = _sftpSession.GetCanonicalPath(oldPath);

            var newFullPath = _sftpSession.GetCanonicalPath(newPath);

            if (isPosix)
            {
                _sftpSession.RequestPosixRename(oldFullPath, newFullPath);
            }
            else
            {
                _sftpSession.RequestRename(oldFullPath, newFullPath);
            }
        }

        /// <summary>
        /// Creates a symbolic link from old path to new path.
        /// </summary>
        /// <param name="path">The old path.</param>
        /// <param name="linkPath">The new path.</param>
        /// <exception cref="ArgumentException"><paramref name="path"/> is <b>null</b>. <para>-or-</para> <paramref name="linkPath"/> is <b>null</b> or contains whitespace characters.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to create the symbolic link was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message"/> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void SymbolicLink(string path, string linkPath)
        {
            CheckDisposed();

            if (path.IsNullOrWhiteSpace())
                throw new ArgumentException("path");

            if (linkPath.IsNullOrWhiteSpace())
                throw new ArgumentException("linkPath");

            if (_sftpSession == null)
                throw new SshConnectionException("Client not connected.");

            var fullPath = _sftpSession.GetCanonicalPath(path);

            var linkFullPath = _sftpSession.GetCanonicalPath(linkPath);

            _sftpSession.RequestSymLink(fullPath, linkFullPath);
        }

        /// <summary>
        /// Retrieves list of files in remote directory.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="listCallback">The list callback.</param>
        /// <returns>
        /// List of directory entries
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="path" /> is <b>null</b>.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to list the contents of the directory was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message" /> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public IEnumerable<SftpFile> ListDirectory(string path, Action<int> listCallback = null)
        {
            CheckDisposed();

            return InternalListDirectory(path, listCallback);
        }

        /// <summary>
        /// Begins an asynchronous operation of retrieving list of files in remote directory.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="asyncCallback">The method to be called when the asynchronous write operation is completed.</param>
        /// <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests.</param>
        /// <param name="listCallback">The list callback.</param>
        /// <returns>
        /// An <see cref="IAsyncResult" /> that references the asynchronous operation.
        /// </returns>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public IAsyncResult BeginListDirectory(string path, AsyncCallback asyncCallback, object state, Action<int> listCallback = null)
        {
            CheckDisposed();

            var asyncResult = new SftpListDirectoryAsyncResult(asyncCallback, state);

            ExecuteThread(() =>
            {
                try
                {
                    var result = InternalListDirectory(path, count =>
                    {
                        asyncResult.Update(count);

                        if (listCallback != null)
                        {
                            listCallback(count);
                        }
                    });

                    asyncResult.SetAsCompleted(result, false);
                }
                catch (Exception exp)
                {
                    asyncResult.SetAsCompleted(exp, false);
                }
            });

            return asyncResult;
        }

        /// <summary>
        /// Ends an asynchronous operation of retrieving list of files in remote directory.
        /// </summary>
        /// <param name="asyncResult">The pending asynchronous SFTP request.</param>
        /// <returns>
        /// List of files
        /// </returns>
        /// <exception cref="ArgumentException">The IAsyncResult object (<paramref name="asyncResult"/>) did not come from the corresponding async method on this type. <para>-or-</para> EndExecute was called multiple times with the same IAsyncResult.</exception>
        public IEnumerable<SftpFile> EndListDirectory(IAsyncResult asyncResult)
        {
            var ar = asyncResult as SftpListDirectoryAsyncResult;

            if (ar == null || ar.EndInvokeCalled)
                throw new ArgumentException("Either the IAsyncResult object did not come from the corresponding async method on this type, or EndExecute was called multiple times with the same IAsyncResult.");

            // Wait for operation to complete, then return result or throw exception
            return ar.EndInvoke();
        }

        /// <summary>
        /// Gets reference to remote file or directory.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <returns>Reference to <see cref="Renci.SshNet.Sftp.SftpFile"/> file object.</returns>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPathNotFoundException"><paramref name="path"/> was not found on the remote host.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="path" /> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public SftpFile Get(string path)
        {
            CheckDisposed();

            if (path == null)
                throw new ArgumentNullException("path");

            if (_sftpSession == null)
                throw new SshConnectionException("Client not connected.");

            var fullPath = _sftpSession.GetCanonicalPath(path);

            var attributes = _sftpSession.RequestLStat(fullPath);

            return new SftpFile(_sftpSession, fullPath, attributes);
        }

        /// <summary>
        /// Checks whether file or directory exists;
        /// </summary>
        /// <param name="path">The path.</param>
        /// <returns><c>true</c> if directory or file exists; otherwise <c>false</c>.</returns>
        /// <exception cref="ArgumentException"><paramref name="path"/> is <b>null</b> or contains whitespace characters.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to perform the operation was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message"/> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public bool Exists(string path)
        {
            CheckDisposed();

            if (path.IsNullOrWhiteSpace())
                throw new ArgumentException("path");

            if (_sftpSession == null)
                throw new SshConnectionException("Client not connected.");

            var fullPath = _sftpSession.GetCanonicalPath(path);

            // using SSH_FXP_REALPATH is not an alternative the SFTP specification has not always
            // been clear on how the server should respond when the specified path is not present
            // on the server:
            // 
            // SSH 1 to 4:
            // No mention of how the server should respond if the path is not present on the server.
            //
            // SSH 5:
            // The server SHOULD fail the request if the path is not present on the server.
            // 
            // SSH 6:
            // Draft 06: The server SHOULD fail the request if the path is not present on the server.
            // Draft 07 to 13: The server MUST NOT fail the request if the path does not exist.
            //
            // Note that SSH 6 (draft 06 and forward) allows for more control options, but we
            // currently only support up to v3.

            try
            {
                _sftpSession.RequestLStat(fullPath);
                return true;
            }
            catch (SftpPathNotFoundException)
            {
                return false;
            }
        }

        /// <summary>
        /// Downloads remote file specified by the path into the stream.
        /// </summary>
        /// <param name="path">File to download.</param>
        /// <param name="output">Stream to write the file into.</param>
        /// <param name="downloadCallback">The download callback.</param>
        /// <exception cref="ArgumentNullException"><paramref name="output" /> is <b>null</b>.</exception>
        /// <exception cref="ArgumentException"><paramref name="path" /> is <b>null</b> or contains whitespace characters.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to perform the operation was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message" /> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        /// <remarks>
        /// Method calls made by this method to <paramref name="output" />, may under certain conditions result in exceptions thrown by the stream.
        /// </remarks>
        public void DownloadFile(string path, Stream output, Action<ulong> downloadCallback = null)
        {
            CheckDisposed();

            InternalDownloadFile(path, output, null, downloadCallback);
        }

        /// <summary>
        /// Begins an asynchronous file downloading into the stream.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="output">The output.</param>
        /// <returns>
        /// An <see cref="IAsyncResult" /> that references the asynchronous operation.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="output" /> is <b>null</b>.</exception>
        /// <exception cref="ArgumentException"><paramref name="path" /> is <b>null</b> or contains whitespace characters.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to perform the operation was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message" /> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        /// <remarks>
        /// Method calls made by this method to <paramref name="output" />, may under certain conditions result in exceptions thrown by the stream.
        /// </remarks>
        public IAsyncResult BeginDownloadFile(string path, Stream output)
        {
            return BeginDownloadFile(path, output, null, null);
        }

        /// <summary>
        /// Begins an asynchronous file downloading into the stream.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="output">The output.</param>
        /// <param name="asyncCallback">The method to be called when the asynchronous write operation is completed.</param>
        /// <returns>
        /// An <see cref="IAsyncResult" /> that references the asynchronous operation.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="output" /> is <b>null</b>.</exception>
        /// <exception cref="ArgumentException"><paramref name="path" /> is <b>null</b> or contains whitespace characters.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to perform the operation was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message" /> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        /// <remarks>
        /// Method calls made by this method to <paramref name="output" />, may under certain conditions result in exceptions thrown by the stream.
        /// </remarks>
        public IAsyncResult BeginDownloadFile(string path, Stream output, AsyncCallback asyncCallback)
        {
            return BeginDownloadFile(path, output, asyncCallback, null);
        }

        /// <summary>
        /// Begins an asynchronous file downloading into the stream.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="output">The output.</param>
        /// <param name="asyncCallback">The method to be called when the asynchronous write operation is completed.</param>
        /// <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests.</param>
        /// <param name="downloadCallback">The download callback.</param>
        /// <returns>
        /// An <see cref="IAsyncResult" /> that references the asynchronous operation.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="output" /> is <b>null</b>.</exception>
        /// <exception cref="ArgumentException"><paramref name="path" /> is <b>null</b> or contains whitespace characters.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to perform the operation was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message" /> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        /// <remarks>
        /// Method calls made by this method to <paramref name="output" />, may under certain conditions result in exceptions thrown by the stream.
        /// </remarks>
        public IAsyncResult BeginDownloadFile(string path, Stream output, AsyncCallback asyncCallback, object state, Action<ulong> downloadCallback = null)
        {
            CheckDisposed();

            if (path.IsNullOrWhiteSpace())
                throw new ArgumentException("path");

            if (output == null)
                throw new ArgumentNullException("output");

            var asyncResult = new SftpDownloadAsyncResult(asyncCallback, state);

            ExecuteThread(() =>
            {
                try
                {
                    InternalDownloadFile(path, output, asyncResult, offset =>
                    {
                        asyncResult.Update(offset);

                        if (downloadCallback != null)
                        {
                            downloadCallback(offset);
                        }
                    });

                    asyncResult.SetAsCompleted(null, false);
                }
                catch (Exception exp)
                {
                    asyncResult.SetAsCompleted(exp, false);
                }
            });

            return asyncResult;
        }

        /// <summary>
        /// Ends an asynchronous file downloading into the stream.
        /// </summary>
        /// <param name="asyncResult">The pending asynchronous SFTP request.</param>
        /// <exception cref="ArgumentException">The IAsyncResult object (<paramref name="asyncResult"/>) did not come from the corresponding async method on this type. <para>-or-</para> EndExecute was called multiple times with the same IAsyncResult.</exception>
        public void EndDownloadFile(IAsyncResult asyncResult)
        {
            var ar = asyncResult as SftpDownloadAsyncResult;

            if (ar == null || ar.EndInvokeCalled)
                throw new ArgumentException("Either the IAsyncResult object did not come from the corresponding async method on this type, or EndExecute was called multiple times with the same IAsyncResult.");

            // Wait for operation to complete, then return result or throw exception
            ar.EndInvoke();
        }

        /// <summary>
        /// Uploads stream into remote file.
        /// </summary>
        /// <param name="input">Data input stream.</param>
        /// <param name="path">Remote file path.</param>
        /// <param name="uploadCallback">The upload callback.</param>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is <b>null</b>.</exception>
        /// <exception cref="ArgumentException"><paramref name="path" /> is <b>null</b> or contains whitespace characters.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to upload the file was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message" /> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        /// <remarks>
        /// Method calls made by this method to <paramref name="input" />, may under certain conditions result in exceptions thrown by the stream.
        /// </remarks>
        public void UploadFile(Stream input, string path, Action<ulong> uploadCallback = null)
        {
            UploadFile(input, path, true, uploadCallback);
        }

        /// <summary>
        /// Uploads stream into remote file.
        /// </summary>
        /// <param name="input">Data input stream.</param>
        /// <param name="path">Remote file path.</param>
        /// <param name="canOverride">if set to <c>true</c> then existing file will be overwritten.</param>
        /// <param name="uploadCallback">The upload callback.</param>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is <b>null</b>.</exception>
        /// <exception cref="ArgumentException"><paramref name="path" /> is <b>null</b> or contains whitespace characters.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to upload the file was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message" /> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        /// <remarks>
        /// Method calls made by this method to <paramref name="input" />, may under certain conditions result in exceptions thrown by the stream.
        /// </remarks>
        public void UploadFile(Stream input, string path, bool canOverride, Action<ulong> uploadCallback = null)
        {
            CheckDisposed();

            var flags = Flags.Write | Flags.Truncate;

            if (canOverride)
                flags |= Flags.CreateNewOrOpen;
            else
                flags |= Flags.CreateNew;

            InternalUploadFile(input, path, flags, null, uploadCallback);
        }

        /// <summary>
        /// Begins an asynchronous uploading the steam into remote file.
        /// </summary>
        /// <param name="input">Data input stream.</param>
        /// <param name="path">Remote file path.</param>
        /// <returns>
        /// An <see cref="IAsyncResult" /> that references the asynchronous operation.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is <b>null</b>.</exception>
        /// <exception cref="ArgumentException"><paramref name="path" /> is <b>null</b> or contains whitespace characters.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to list the contents of the directory was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message" /> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        /// <remarks>
        /// Method calls made by this method to <paramref name="input" />, may under certain conditions result in exceptions thrown by the stream.
        /// </remarks>
        public IAsyncResult BeginUploadFile(Stream input, string path)
        {
            return BeginUploadFile(input, path, true, null, null);
        }

        /// <summary>
        /// Begins an asynchronous uploading the steam into remote file.
        /// </summary>
        /// <param name="input">Data input stream.</param>
        /// <param name="path">Remote file path.</param>
        /// <param name="asyncCallback">The method to be called when the asynchronous write operation is completed.</param>
        /// <returns>
        /// An <see cref="IAsyncResult" /> that references the asynchronous operation.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is <b>null</b>.</exception>
        /// <exception cref="ArgumentException"><paramref name="path" /> is <b>null</b> or contains whitespace characters.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to list the contents of the directory was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message" /> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        /// <remarks>
        /// Method calls made by this method to <paramref name="input" />, may under certain conditions result in exceptions thrown by the stream.
        /// </remarks>
        public IAsyncResult BeginUploadFile(Stream input, string path, AsyncCallback asyncCallback)
        {
            return BeginUploadFile(input, path, true, asyncCallback, null);
        }

        /// <summary>
        /// Begins an asynchronous uploading the steam into remote file.
        /// </summary>
        /// <param name="input">Data input stream.</param>
        /// <param name="path">Remote file path.</param>
        /// <param name="asyncCallback">The method to be called when the asynchronous write operation is completed.</param>
        /// <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests.</param>
        /// <param name="uploadCallback">The upload callback.</param>
        /// <returns>
        /// An <see cref="IAsyncResult" /> that references the asynchronous operation.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is <b>null</b>.</exception>
        /// <exception cref="ArgumentException"><paramref name="path" /> is <b>null</b> or contains whitespace characters.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to list the contents of the directory was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message" /> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        /// <remarks>
        /// Method calls made by this method to <paramref name="input" />, may under certain conditions result in exceptions thrown by the stream.
        /// </remarks>
        public IAsyncResult BeginUploadFile(Stream input, string path, AsyncCallback asyncCallback, object state, Action<ulong> uploadCallback = null)
        {
            return BeginUploadFile(input, path, true, asyncCallback, state, uploadCallback);
        }

        /// <summary>
        /// Begins an asynchronous uploading the steam into remote file.
        /// </summary>
        /// <param name="input">Data input stream.</param>
        /// <param name="path">Remote file path.</param>
        /// <param name="canOverride">if set to <c>true</c> then existing file will be overwritten.</param>
        /// <param name="asyncCallback">The method to be called when the asynchronous write operation is completed.</param>
        /// <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests.</param>
        /// <param name="uploadCallback">The upload callback.</param>
        /// <returns>
        /// An <see cref="IAsyncResult" /> that references the asynchronous operation.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is <b>null</b>.</exception>
        /// <exception cref="ArgumentException"><paramref name="path" /> is <b>null</b> or contains whitespace characters.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPermissionDeniedException">Permission to list the contents of the directory was denied by the remote host. <para>-or-</para> A SSH command was denied by the server.</exception>
        /// <exception cref="SshException">A SSH error where <see cref="P:System.Exception.Message" /> is the message from the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        /// <remarks>
        /// Method calls made by this method to <paramref name="input" />, may under certain conditions result in exceptions thrown by the stream.
        /// </remarks>
        public IAsyncResult BeginUploadFile(Stream input, string path, bool canOverride, AsyncCallback asyncCallback, object state, Action<ulong> uploadCallback = null)
        {
            CheckDisposed();

            if (input == null)
                throw new ArgumentNullException("input");

            if (path.IsNullOrWhiteSpace())
                throw new ArgumentException("path");

            var flags = Flags.Write | Flags.Truncate;

            if (canOverride)
                flags |= Flags.CreateNewOrOpen;
            else
                flags |= Flags.CreateNew;

            var asyncResult = new SftpUploadAsyncResult(asyncCallback, state);

            ExecuteThread(() =>
            {
                try
                {
                    InternalUploadFile(input, path, flags, asyncResult, offset =>
                    {
                        asyncResult.Update(offset);

                        if (uploadCallback != null)
                        {
                            uploadCallback(offset);
                        }

                    });

                    asyncResult.SetAsCompleted(null, false);
                }
                catch (Exception exp)
                {
                    asyncResult.SetAsCompleted(exp, false);
                }
            });

            return asyncResult;
        }

        /// <summary>
        /// Ends an asynchronous uploading the steam into remote file.
        /// </summary>
        /// <param name="asyncResult">The pending asynchronous SFTP request.</param>
        /// <exception cref="System.ArgumentException">Either the IAsyncResult object did not come from the corresponding async method on this type, or EndExecute was called multiple times with the same IAsyncResult.</exception>
        /// <exception cref="ArgumentException">The IAsyncResult object (<paramref name="asyncResult" />) did not come from the corresponding async method on this type. <para>-or-</para> EndExecute was called multiple times with the same IAsyncResult.</exception>
        public void EndUploadFile(IAsyncResult asyncResult)
        {
            var ar = asyncResult as SftpUploadAsyncResult;

            if (ar == null || ar.EndInvokeCalled)
                throw new ArgumentException("Either the IAsyncResult object did not come from the corresponding async method on this type, or EndExecute was called multiple times with the same IAsyncResult.");

            // Wait for operation to complete, then return result or throw exception
            ar.EndInvoke();
        }

        /// <summary>
        /// Gets status using statvfs@openssh.com request.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <returns>Reference to <see cref="Renci.SshNet.Sftp.SftpFileSytemInformation"/> object that contains file status information.</returns>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="path" /> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public SftpFileSytemInformation GetStatus(string path)
        {
            CheckDisposed();

            if (path == null)
                throw new ArgumentNullException("path");

            if (_sftpSession == null)
                throw new SshConnectionException("Client not connected.");

            var fullPath = _sftpSession.GetCanonicalPath(path);

            return _sftpSession.RequestStatVfs(fullPath);
        }

        #region File Methods

        /// <summary>
        /// Appends lines to a file, and then closes the file.
        /// </summary>
        /// <param name="path">The file to append the lines to. The file is created if it does not already exist.</param>
        /// <param name="contents">The lines to append to the file.</param>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is<b>null</b> <para>-or-</para> <paramref name="contents"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void AppendAllLines(string path, IEnumerable<string> contents)
        {
            CheckDisposed();

            if (contents == null)
                throw new ArgumentNullException("contents");

            using (var stream = AppendText(path))
            {
                foreach (var line in contents)
                {
                    stream.WriteLine(line);
                }
            }
        }

        /// <summary>
        /// Appends lines to a file by using a specified encoding, and then closes the file.
        /// </summary>
        /// <param name="path">The file to append the lines to. The file is created if it does not already exist.</param>
        /// <param name="contents">The lines to append to the file.</param>
        /// <param name="encoding">The character encoding to use.</param>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>. <para>-or-</para> <paramref name="contents"/> is <b>null</b>. <para>-or-</para> <paramref name="encoding"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void AppendAllLines(string path, IEnumerable<string> contents, Encoding encoding)
        {
            CheckDisposed();

            if (contents == null)
                throw new ArgumentNullException("contents");

            using (var stream = AppendText(path, encoding))
            {
                foreach (var line in contents)
                {
                    stream.WriteLine(line);
                }
            }
        }

        /// <summary>
        ///  Opens a file, appends the specified string to the file, and then closes the file. 
        ///  If the file does not exist, this method creates a file, writes the specified string to the file, then closes the file.
        /// </summary>
        /// <param name="path">The file to append the specified string to.</param>
        /// <param name="contents">The string to append to the file.</param>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>. <para>-or-</para> <paramref name="contents"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void AppendAllText(string path, string contents)
        {
            using (var stream = AppendText(path))
            {
                stream.Write(contents);
            }
        }

        /// <summary>
        /// Opens a file, appends the specified string to the file, and then closes the file.
        /// If the file does not exist, this method creates a file, writes the specified string to the file, then closes the file.
        /// </summary>
        /// <param name="path">The file to append the specified string to.</param>
        /// <param name="contents">The string to append to the file.</param>
        /// <param name="encoding">The character encoding to use.</param>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>. <para>-or-</para> <paramref name="contents"/> is <b>null</b>. <para>-or-</para> <paramref name="encoding"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void AppendAllText(string path, string contents, Encoding encoding)
        {
            using (var stream = AppendText(path, encoding))
            {
                stream.Write(contents);
            }
        }

        /// <summary>
        /// Creates a <see cref="System.IO.StreamWriter"/> that appends UTF-8 encoded text to an existing file.
        /// </summary>
        /// <param name="path">The path to the file to append to.</param>
        /// <returns>A StreamWriter that appends UTF-8 encoded text to an existing file.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public StreamWriter AppendText(string path)
        {
            return AppendText(path, Encoding.UTF8);
        }

        /// <summary>
        /// Creates a <see cref="System.IO.StreamWriter"/> that appends UTF-8 encoded text to an existing file.
        /// </summary>
        /// <param name="path">The path to the file to append to.</param>
        /// <param name="encoding">The character encoding to use.</param>
        /// <returns>
        /// A StreamWriter that appends UTF-8 encoded text to an existing file.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>. <para>-or-</para> <paramref name="encoding"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public StreamWriter AppendText(string path, Encoding encoding)
        {
            CheckDisposed();

            if (encoding == null)
                throw new ArgumentNullException("encoding");

            return new StreamWriter(new SftpFileStream(_sftpSession, path, FileMode.Append, FileAccess.Write, (int) _bufferSize), encoding);
        }

        /// <summary>
        /// Creates or overwrites a file in the specified path.
        /// </summary>
        /// <param name="path">The path and name of the file to create.</param>
        /// <returns>A <see cref="SftpFileStream"/> that provides read/write access to the file specified in path</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public SftpFileStream Create(string path)
        {
            CheckDisposed();

            return new SftpFileStream(_sftpSession, path, FileMode.Create, FileAccess.ReadWrite, (int) _bufferSize);
        }

        /// <summary>
        /// Creates or overwrites the specified file.
        /// </summary>
        /// <param name="path">The path and name of the file to create.</param>
        /// <param name="bufferSize">The number of bytes buffered for reads and writes to the file.</param>
        /// <returns>A <see cref="SftpFileStream"/> that provides read/write access to the file specified in path</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public SftpFileStream Create(string path, int bufferSize)
        {
            CheckDisposed();

            return new SftpFileStream(_sftpSession, path, FileMode.Create, FileAccess.ReadWrite, bufferSize);
        }

        /// <summary>
        /// Creates or opens a file for writing UTF-8 encoded text.
        /// </summary>
        /// <param name="path">The file to be opened for writing.</param>
        /// <returns>A <see cref="System.IO.StreamWriter"/> that writes to the specified file using UTF-8 encoding.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public StreamWriter CreateText(string path)
        {
            return CreateText(path, Encoding.UTF8);
        }

        /// <summary>
        /// Creates or opens a file for writing UTF-8 encoded text.
        /// </summary>
        /// <param name="path">The file to be opened for writing.</param>
        /// <param name="encoding">The character encoding to use.</param>
        /// <returns> A <see cref="System.IO.StreamWriter"/> that writes to the specified file using UTF-8 encoding. </returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public StreamWriter CreateText(string path, Encoding encoding)
        {
            CheckDisposed();

            return new StreamWriter(OpenWrite(path), encoding);
        }

        /// <summary>
        /// Deletes the specified file or directory.
        /// </summary>
        /// <param name="path">The name of the file or directory to be deleted. Wildcard characters are not supported.</param>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="SftpPathNotFoundException"><paramref name="path"/> was not found on the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void Delete(string path)
        {
            var file = Get(path);
            file.Delete();
        }

        /// <summary>
        /// Returns the date and time the specified file or directory was last accessed.
        /// </summary>
        /// <param name="path">The file or directory for which to obtain access date and time information.</param>
        /// <returns>A <see cref="System.DateTime"/> structure set to the date and time that the specified file or directory was last accessed. This value is expressed in local time.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public DateTime GetLastAccessTime(string path)
        {
            var file = Get(path);
            return file.LastAccessTime;
        }

        /// <summary>
        /// Returns the date and time, in coordinated universal time (UTC), that the specified file or directory was last accessed.
        /// </summary>
        /// <param name="path">The file or directory for which to obtain access date and time information.</param>
        /// <returns>A <see cref="System.DateTime"/> structure set to the date and time that the specified file or directory was last accessed. This value is expressed in UTC time.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public DateTime GetLastAccessTimeUtc(string path)
        {
            var lastAccessTime = GetLastAccessTime(path);
            return lastAccessTime.ToUniversalTime();
        }

        /// <summary>
        /// Returns the date and time the specified file or directory was last written to.
        /// </summary>
        /// <param name="path">The file or directory for which to obtain write date and time information.</param>
        /// <returns>A <see cref="System.DateTime"/> structure set to the date and time that the specified file or directory was last written to. This value is expressed in local time.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public DateTime GetLastWriteTime(string path)
        {
            var file = Get(path);
            return file.LastWriteTime;
        }

        /// <summary>
        /// Returns the date and time, in coordinated universal time (UTC), that the specified file or directory was last written to.
        /// </summary>
        /// <param name="path">The file or directory for which to obtain write date and time information.</param>
        /// <returns>A <see cref="System.DateTime"/> structure set to the date and time that the specified file or directory was last written to. This value is expressed in UTC time.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public DateTime GetLastWriteTimeUtc(string path)
        {
            var lastWriteTime = GetLastWriteTime(path);
            return lastWriteTime.ToUniversalTime();
        }

        /// <summary>
        /// Opens a <see cref="SftpFileStream"/> on the specified path with read/write access.
        /// </summary>
        /// <param name="path">The file to open.</param>
        /// <param name="mode">A <see cref="System.IO.FileMode"/> value that specifies whether a file is created if one does not exist, and determines whether the contents of existing files are retained or overwritten.</param>
        /// <returns>An unshared <see cref="SftpFileStream"/> that provides access to the specified file, with the specified mode and access.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public SftpFileStream Open(string path, FileMode mode)
        {
            return Open(path, mode, FileAccess.ReadWrite);
        }

        /// <summary>
        /// Opens a <see cref="SftpFileStream"/> on the specified path, with the specified mode and access.
        /// </summary>
        /// <param name="path">The file to open.</param>
        /// <param name="mode">A <see cref="System.IO.FileMode"/> value that specifies whether a file is created if one does not exist, and determines whether the contents of existing files are retained or overwritten.</param>
        /// <param name="access">A <see cref="System.IO.FileAccess"/> value that specifies the operations that can be performed on the file.</param>
        /// <returns>An unshared <see cref="SftpFileStream"/> that provides access to the specified file, with the specified mode and access.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public SftpFileStream Open(string path, FileMode mode, FileAccess access)
        {
            CheckDisposed();

            return new SftpFileStream(_sftpSession, path, mode, access, (int) _bufferSize);
        }

        /// <summary>
        /// Opens an existing file for reading.
        /// </summary>
        /// <param name="path">The file to be opened for reading.</param>
        /// <returns>A read-only System.IO.FileStream on the specified path.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public SftpFileStream OpenRead(string path)
        {
            return Open(path, FileMode.Open, FileAccess.Read);
        }

        /// <summary>
        /// Opens an existing UTF-8 encoded text file for reading.
        /// </summary>
        /// <param name="path">The file to be opened for reading.</param>
        /// <returns>A <see cref="System.IO.StreamReader"/> on the specified path.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public StreamReader OpenText(string path)
        {
            return new StreamReader(OpenRead(path), Encoding.UTF8);
        }

        /// <summary>
        /// Opens an existing file for writing.
        /// </summary>
        /// <param name="path">The file to be opened for writing.</param>
        /// <returns>An unshared <see cref="SftpFileStream"/> object on the specified path with <see cref="System.IO.FileAccess.Write"/> access.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public SftpFileStream OpenWrite(string path)
        {
            CheckDisposed();

            return new SftpFileStream(_sftpSession, path, FileMode.OpenOrCreate, FileAccess.Write,
                (int) _bufferSize);
        }

        /// <summary>
        /// Opens a binary file, reads the contents of the file into a byte array, and then closes the file.
        /// </summary>
        /// <param name="path">The file to open for reading.</param>
        /// <returns>A byte array containing the contents of the file.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public byte[] ReadAllBytes(string path)
        {
            using (var stream = OpenRead(path))
            {
                var buffer = new byte[stream.Length];
                stream.Read(buffer, 0, buffer.Length);
                return buffer;
            }
        }

        /// <summary>
        /// Opens a text file, reads all lines of the file, and then closes the file.
        /// </summary>
        /// <param name="path">The file to open for reading.</param>
        /// <returns>A string array containing all lines of the file.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public string[] ReadAllLines(string path)
        {
            return ReadAllLines(path, Encoding.UTF8);
        }

        /// <summary>
        /// Opens a file, reads all lines of the file with the specified encoding, and then closes the file.
        /// </summary>
        /// <param name="path">The file to open for reading.</param>
        /// <param name="encoding">The encoding applied to the contents of the file.</param>
        /// <returns>A string array containing all lines of the file.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public string[] ReadAllLines(string path, Encoding encoding)
        {
            var lines = new List<string>();
            using (var stream = new StreamReader(OpenRead(path), encoding))
            {
                while (!stream.EndOfStream)
                {
                    lines.Add(stream.ReadLine());
                }
            }
            return lines.ToArray();
        }

        /// <summary>
        /// Opens a text file, reads all lines of the file, and then closes the file.
        /// </summary>
        /// <param name="path">The file to open for reading.</param>
        /// <returns>A string containing all lines of the file.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public string ReadAllText(string path)
        {
            return ReadAllText(path, Encoding.UTF8);
        }

        /// <summary>
        /// Opens a file, reads all lines of the file with the specified encoding, and then closes the file.
        /// </summary>
        /// <param name="path">The file to open for reading.</param>
        /// <param name="encoding">The encoding applied to the contents of the file.</param>
        /// <returns>A string containing all lines of the file.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public string ReadAllText(string path, Encoding encoding)
        {
            using (var stream = new StreamReader(OpenRead(path), encoding))
            {
                return stream.ReadToEnd();
            }
        }

        /// <summary>
        /// Reads the lines of a file.
        /// </summary>
        /// <param name="path">The file to read.</param>
        /// <returns>The lines of the file.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public IEnumerable<string> ReadLines(string path)
        {
            return ReadAllLines(path);
        }

        /// <summary>
        /// Read the lines of a file that has a specified encoding.
        /// </summary>
        /// <param name="path">The file to read.</param>
        /// <param name="encoding">The encoding that is applied to the contents of the file.</param>
        /// <returns>The lines of the file.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public IEnumerable<string> ReadLines(string path, Encoding encoding)
        {
            return ReadAllLines(path, encoding);
        }

        /// <summary>
        /// Sets the date and time the specified file was last accessed.
        /// </summary>
        /// <param name="path">The file for which to set the access date and time information.</param>
        /// <param name="lastAccessTime">A <see cref="System.DateTime"/> containing the value to set for the last access date and time of path. This value is expressed in local time.</param>
        [Obsolete("Note: This method currently throws NotImplementedException because it has not yet been implemented.")]
        public void SetLastAccessTime(string path, DateTime lastAccessTime)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Sets the date and time, in coordinated universal time (UTC), that the specified file was last accessed.
        /// </summary>
        /// <param name="path">The file for which to set the access date and time information.</param>
        /// <param name="lastAccessTimeUtc">A <see cref="System.DateTime"/> containing the value to set for the last access date and time of path. This value is expressed in UTC time.</param>
        [Obsolete("Note: This method currently throws NotImplementedException because it has not yet been implemented.")]
        public void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Sets the date and time that the specified file was last written to.
        /// </summary>
        /// <param name="path">The file for which to set the date and time information.</param>
        /// <param name="lastWriteTime">A System.DateTime containing the value to set for the last write date and time of path. This value is expressed in local time.</param>
        [Obsolete("Note: This method currently throws NotImplementedException because it has not yet been implemented.")]
        public void SetLastWriteTime(string path, DateTime lastWriteTime)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Sets the date and time, in coordinated universal time (UTC), that the specified file was last written to.
        /// </summary>
        /// <param name="path">The file for which to set the date and time information.</param>
        /// <param name="lastWriteTimeUtc">A System.DateTime containing the value to set for the last write date and time of path. This value is expressed in UTC time.</param>
        [Obsolete("Note: This method currently throws NotImplementedException because it has not yet been implemented.")]
        public void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Creates a new file, writes the specified byte array to the file, and then closes the file. If the target file already exists, it is overwritten.
        /// </summary>
        /// <param name="path">The file to write to.</param>
        /// <param name="bytes">The bytes to write to the file.</param>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void WriteAllBytes(string path, byte[] bytes)
        {
            using (var stream = OpenWrite(path))
            {
                stream.Write(bytes, 0, bytes.Length);
            }
        }

        /// <summary>
        /// Creates a new file, writes a collection of strings to the file, and then closes the file.
        /// </summary>
        /// <param name="path">The file to write to.</param>
        /// <param name="contents">The lines to write to the file.</param>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void WriteAllLines(string path, IEnumerable<string> contents)
        {
            WriteAllLines(path, contents, Encoding.UTF8);
        }

        /// <summary>
        /// Creates a new file, write the specified string array to the file, and then closes the file.
        /// </summary>
        /// <param name="path">The file to write to.</param>
        /// <param name="contents">The string array to write to the file.</param>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void WriteAllLines(string path, string[] contents)
        {
            WriteAllLines(path, contents, Encoding.UTF8);
        }

        /// <summary>
        /// Creates a new file by using the specified encoding, writes a collection of strings to the file, and then closes the file.
        /// </summary>
        /// <param name="path">The file to write to.</param>
        /// <param name="contents">The lines to write to the file.</param>
        /// <param name="encoding">The character encoding to use.</param>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void WriteAllLines(string path, IEnumerable<string> contents, Encoding encoding)
        {
            using (var stream = CreateText(path, encoding))
            {
                foreach (var line in contents)
                {
                    stream.WriteLine(line);
                }
            }
        }

        /// <summary>
        /// Creates a new file, writes the specified string array to the file by using the specified encoding, and then closes the file.
        /// </summary>
        /// <param name="path">The file to write to.</param>
        /// <param name="contents">The string array to write to the file.</param>
        /// <param name="encoding">An <see cref="System.Text.Encoding"/> object that represents the character encoding applied to the string array.</param>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void WriteAllLines(string path, string[] contents, Encoding encoding)
        {
            using (var stream = CreateText(path, encoding))
            {
                foreach (var line in contents)
                {
                    stream.WriteLine(line);
                }
            }
        }

        /// <summary>
        /// Creates a new file, writes the specified string to the file, and then closes the file. If the target file already exists, it is overwritten.
        /// </summary>
        /// <param name="path">The file to write to.</param>
        /// <param name="contents">The string to write to the file.</param>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void WriteAllText(string path, string contents)
        {
            using (var stream = CreateText(path))
            {
                stream.Write(contents);
            }
        }

        /// <summary>
        /// Creates a new file, writes the specified string to the file using the specified encoding, and then closes the file. If the target file already exists, it is overwritten.
        /// </summary>
        /// <param name="path">The file to write to.</param>
        /// <param name="contents">The string to write to the file.</param>
        /// <param name="encoding">The encoding to apply to the string.</param>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void WriteAllText(string path, string contents, Encoding encoding)
        {
            using (var stream = CreateText(path, encoding))
            {
                stream.Write(contents);
            }
        }

        /// <summary>
        /// Gets the <see cref="SftpFileAttributes"/> of the file on the path.
        /// </summary>
        /// <param name="path">The path to the file.</param>
        /// <returns>The <see cref="SftpFileAttributes"/> of the file on the path.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="SftpPathNotFoundException"><paramref name="path"/> was not found on the remote host.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public SftpFileAttributes GetAttributes(string path)
        {
            CheckDisposed();

            if (_sftpSession == null)
                throw new SshConnectionException("Client not connected.");

            var fullPath = _sftpSession.GetCanonicalPath(path);

            return _sftpSession.RequestLStat(fullPath);
        }

        /// <summary>
        /// Sets the specified <see cref="SftpFileAttributes"/> of the file on the specified path.
        /// </summary>
        /// <param name="path">The path to the file.</param>
        /// <param name="fileAttributes">The desired <see cref="SftpFileAttributes"/>.</param>
        /// <exception cref="ArgumentNullException"><paramref name="path"/> is <b>null</b>.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the client was disposed.</exception>
        public void SetAttributes(string path, SftpFileAttributes fileAttributes)
        {
            CheckDisposed();

            if (_sftpSession == null)
                throw new SshConnectionException("Client not connected.");

            var fullPath = _sftpSession.GetCanonicalPath(path);

            _sftpSession.RequestSetStat(fullPath, fileAttributes);
        }

        // Please don't forget this when you implement these methods: <exception cref="ArgumentNullException"><paramref name="path"/> is null.</exception>
        //public FileSecurity GetAccessControl(string path);
        //public FileSecurity GetAccessControl(string path, AccessControlSections includeSections);
        //public DateTime GetCreationTime(string path);
        //public DateTime GetCreationTimeUtc(string path);
        //public void SetAccessControl(string path, FileSecurity fileSecurity);
        //public void SetCreationTime(string path, DateTime creationTime);
        //public void SetCreationTimeUtc(string path, DateTime creationTimeUtc);

        #endregion

        /// <summary>
        /// Internals the list directory.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="listCallback">The list callback.</param>
        /// <returns></returns>
        /// <exception cref="System.ArgumentNullException">path</exception>
        /// <exception cref="ArgumentNullException"><paramref name="path" /> is <b>null</b>.</exception>
        /// <exception cref="SshConnectionException">Client not connected.</exception>
        private IEnumerable<SftpFile> InternalListDirectory(string path, Action<int> listCallback)
        {
            if (path == null)
                throw new ArgumentNullException("path");

            if (_sftpSession == null)
                throw new SshConnectionException("Client not connected.");

            var fullPath = _sftpSession.GetCanonicalPath(path);

            var handle = _sftpSession.RequestOpenDir(fullPath);

            var basePath = fullPath;

            if (!basePath.EndsWith("/"))
                basePath = string.Format("{0}/", fullPath);

            var result = new List<SftpFile>();

            var files = _sftpSession.RequestReadDir(handle);

            while (files != null)
            {
                result.AddRange(from f in files
                                select new SftpFile(_sftpSession, string.Format(CultureInfo.InvariantCulture, "{0}{1}", basePath, f.Key), f.Value));

                //  Call callback to report number of files read
                if (listCallback != null)
                {
                    //  Execute callback on different thread
                    ExecuteThread(() => listCallback(result.Count));
                }

                files = _sftpSession.RequestReadDir(handle);
            }

            _sftpSession.RequestClose(handle);

            return result;
        }

        /// <summary>
        /// Internals the download file.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="output">The output.</param>
        /// <param name="asyncResult">An <see cref="IAsyncResult"/> that references the asynchronous request.</param>
        /// <param name="downloadCallback">The download callback.</param>
        /// <exception cref="ArgumentNullException"><paramref name="output" /> is <b>null</b>.</exception>
        /// <exception cref="ArgumentException"><paramref name="path" /> is <b>null</b> or contains whitespace.</exception>
        /// <exception cref="SshConnectionException">Client not connected.</exception>
        private void InternalDownloadFile(string path, Stream output, SftpDownloadAsyncResult asyncResult, Action<ulong> downloadCallback)
        {
            if (output == null)
                throw new ArgumentNullException("output");

            if (path.IsNullOrWhiteSpace())
                throw new ArgumentException("path");

            if (_sftpSession == null)
                throw new SshConnectionException("Client not connected.");

            var fullPath = _sftpSession.GetCanonicalPath(path);

            var handle = _sftpSession.RequestOpen(fullPath, Flags.Read);

            ulong offset = 0;

            var optimalReadLength = _sftpSession.CalculateOptimalReadLength(_bufferSize);

            var data = _sftpSession.RequestRead(handle, offset, optimalReadLength);

            //  Read data while available
            while (data.Length > 0)
            {
                //  Cancel download
                if (asyncResult != null && asyncResult.IsDownloadCanceled)
                    break;

                output.Write(data, 0, data.Length);

                output.Flush();

                offset += (ulong)data.Length;

                //  Call callback to report number of bytes read
                if (downloadCallback != null)
                {
                    //  Execute callback on different thread
                    ExecuteThread(() => { downloadCallback(offset); });
                }

                data = _sftpSession.RequestRead(handle, offset, optimalReadLength);
            }

            _sftpSession.RequestClose(handle);
        }

        /// <summary>
        /// Internals the upload file.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <param name="path">The path.</param>
        /// <param name="flags">The flags.</param>
        /// <param name="asyncResult">An <see cref="IAsyncResult"/> that references the asynchronous request.</param>
        /// <param name="uploadCallback">The upload callback.</param>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is <b>null</b>.</exception>
        /// <exception cref="ArgumentException"><paramref name="path" /> is <b>null</b> or contains whitespace.</exception>
        /// <exception cref="SshConnectionException">Client not connected.</exception>
        private void InternalUploadFile(Stream input, string path, Flags flags, SftpUploadAsyncResult asyncResult, Action<ulong> uploadCallback)
        {
            if (input == null)
                throw new ArgumentNullException("input");

            if (path.IsNullOrWhiteSpace())
                throw new ArgumentException("path");

            if (_sftpSession == null)
                throw new SshConnectionException("Client not connected.");

            var fullPath = _sftpSession.GetCanonicalPath(path);

            var handle = _sftpSession.RequestOpen(fullPath, flags);

            ulong offset = 0;

            // create buffer of optimal length
            var buffer = new byte[_sftpSession.CalculateOptimalWriteLength(_bufferSize, handle)];

            var bytesRead = input.Read(buffer, 0, buffer.Length);
            var expectedResponses = 0;
            var responseReceivedWaitHandle = new AutoResetEvent(false);

            do
            {
                //  Cancel upload
                if (asyncResult != null && asyncResult.IsUploadCanceled)
                    break;

                if (bytesRead > 0)
                {
                    if (bytesRead < buffer.Length)
                    {
                        //  Replace buffer for last chunk of data
                        var data = new byte[bytesRead];
                        Buffer.BlockCopy(buffer, 0, data, 0, bytesRead);
                        buffer = data;
                    }

                    var writtenBytes = offset + (ulong)buffer.Length;
                    _sftpSession.RequestWrite(handle, offset, buffer, null, s =>
                    {
                        if (s.StatusCode == StatusCodes.Ok)
                        {
                            Interlocked.Decrement(ref expectedResponses); 
                            responseReceivedWaitHandle.Set();

                            //  Call callback to report number of bytes written
                            if (uploadCallback != null)
                            {
                                //  Execute callback on different thread
                                ExecuteThread(() => uploadCallback(writtenBytes));
                            }
                        }
                    });
                    Interlocked.Increment(ref expectedResponses);

                    offset += (uint)bytesRead;

                    bytesRead = input.Read(buffer, 0, buffer.Length);
                }
                else if (expectedResponses > 0)
                {
                    //  Wait for expectedResponses to change
                    _sftpSession.WaitOnHandle(responseReceivedWaitHandle, OperationTimeout);
                }
            } while (expectedResponses > 0 || bytesRead > 0);

            _sftpSession.RequestClose(handle);
        }

        partial void ExecuteThread(Action action);

        /// <summary>
        /// Called when client is connected to the server.
        /// </summary>
        protected override void OnConnected()
        {
            base.OnConnected();

            _sftpSession = ServiceFactory.CreateSftpSession(Session, OperationTimeout, ConnectionInfo.Encoding);
            _sftpSession.Connect();
        }

        /// <summary>
        /// Called when client is disconnecting from the server.
        /// </summary>
        protected override void OnDisconnecting()
        {
            base.OnDisconnecting();

            // disconnect, dispose and dereference the SFTP session since we create a new SFTP session
            // on each connect
            if (_sftpSession != null)
            {
                _sftpSession.Disconnect();
                _sftpSession.Dispose();
                _sftpSession = null;
            }
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);

            if (disposing)
            {
                if (_sftpSession != null)
                {
                    _sftpSession.Dispose();
                    _sftpSession = null;
                }
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\SftpClient.NET.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Implementation of the SSH File Transfer Protocol (SFTP) over SSH.
    /// </summary>
    public partial class SftpClient
    {
        #region SynchronizeDirectories

        /// <summary>
        /// Synchronizes the directories.
        /// </summary>
        /// <param name="sourcePath">The source path.</param>
        /// <param name="destinationPath">The destination path.</param>
        /// <param name="searchPattern">The search pattern.</param>
        /// <returns>List of uploaded files.</returns>
        public IEnumerable<FileInfo> SynchronizeDirectories(string sourcePath, string destinationPath, string searchPattern)
        {
            return InternalSynchronizeDirectories(sourcePath, destinationPath, searchPattern, null);
        }

        /// <summary>
        /// Begins the synchronize directories.
        /// </summary>
        /// <param name="sourcePath">The source path.</param>
        /// <param name="destinationPath">The destination path.</param>
        /// <param name="searchPattern">The search pattern.</param>
        /// <param name="asyncCallback">The async callback.</param>
        /// <param name="state">The state.</param>
        /// <returns>
        /// An <see cref="System.IAsyncResult" /> that represents the asynchronous directory synchronization.
        /// </returns>
        /// <exception cref="System.ArgumentNullException"><paramref name="sourcePath"/> is <c>null</c>.</exception>
        /// <exception cref="System.ArgumentException"><paramref name="destinationPath"/> is <c>null</c> or contains only whitespace.</exception>
        public IAsyncResult BeginSynchronizeDirectories(string sourcePath, string destinationPath, string searchPattern, AsyncCallback asyncCallback, object state)
        {
            if (sourcePath == null)
                throw new ArgumentNullException("sourcePath");
            if (destinationPath.IsNullOrWhiteSpace())
                throw new ArgumentException("destDir");

            var asyncResult = new SftpSynchronizeDirectoriesAsyncResult(asyncCallback, state);

            this.ExecuteThread(() =>
            {
                try
                {
                    var result = this.InternalSynchronizeDirectories(sourcePath, destinationPath, searchPattern, asyncResult);

                    asyncResult.SetAsCompleted(result, false);
                }
                catch (Exception exp)
                {
                    asyncResult.SetAsCompleted(exp, false);
                }
            });

            return asyncResult;
        }

        /// <summary>
        /// Ends the synchronize directories.
        /// </summary>
        /// <param name="asyncResult">The async result.</param>
        /// <returns>List of uploaded files.</returns>
        /// <exception cref="System.ArgumentException">Either the IAsyncResult object did not come from the corresponding async method on this type, or EndExecute was called multiple times with the same IAsyncResult.</exception>
        public IEnumerable<FileInfo> EndSynchronizeDirectories(IAsyncResult asyncResult)
        {
            var ar = asyncResult as SftpSynchronizeDirectoriesAsyncResult;

            if (ar == null || ar.EndInvokeCalled)
                throw new ArgumentException("Either the IAsyncResult object did not come from the corresponding async method on this type, or EndExecute was called multiple times with the same IAsyncResult.");

            // Wait for operation to complete, then return result or throw exception
            return ar.EndInvoke();
        }

        private IEnumerable<FileInfo> InternalSynchronizeDirectories(string sourcePath, string destinationPath, string searchPattern, SftpSynchronizeDirectoriesAsyncResult asynchResult)
        {
            if (destinationPath.IsNullOrWhiteSpace())
                throw new ArgumentException("destinationPath");

            if (!Directory.Exists(sourcePath))
                throw new FileNotFoundException(string.Format("Source directory not found: {0}", sourcePath));

            IList<FileInfo> uploadedFiles = new List<FileInfo>();

            DirectoryInfo sourceDirectory = new DirectoryInfo(sourcePath);

#if SILVERLIGHT
            var sourceFiles = sourceDirectory.EnumerateFiles(searchPattern);
#else
            var sourceFiles = sourceDirectory.GetFiles(searchPattern);
#endif

            if (sourceFiles == null || !sourceFiles.Any())
                return uploadedFiles;

            #region Existing Files at The Destination

            var destFiles = InternalListDirectory(destinationPath, null);
            Dictionary<string, SftpFile> destDict = new Dictionary<string, SftpFile>();
            foreach (var destFile in destFiles)
            {
                if (destFile.IsDirectory)
                    continue;
                destDict.Add(destFile.Name, destFile);
            }

            #endregion

            #region Upload the difference

            const Flags uploadFlag = Flags.Write | Flags.Truncate | Flags.CreateNewOrOpen;
            foreach (var localFile in sourceFiles)
            {
                bool isDifferent = !destDict.ContainsKey(localFile.Name);

                if (!isDifferent)
                {
                    SftpFile temp = destDict[localFile.Name];
                    //OneCodeTODO:   Use md5 to detect a difference
                    //ltang: File exists at the destination => Using filesize to detect the difference
                    isDifferent = localFile.Length != temp.Length;
                }

                if (isDifferent)
                {
                    var remoteFileName = string.Format(CultureInfo.InvariantCulture, @"{0}/{1}", destinationPath, localFile.Name);
                    try
                    {
                        using (var file = File.OpenRead(localFile.FullName))
                        {
                            this.InternalUploadFile(file, remoteFileName, uploadFlag, null, null);
                        }

                        uploadedFiles.Add(localFile);

                        if (asynchResult != null)
                        {
                            asynchResult.Update(uploadedFiles.Count);
                        }
                    }
                    catch (Exception ex)
                    {
                        throw new Exception(string.Format("Failed to upload {0} to {1}", localFile.FullName, remoteFileName), ex);
                    }
                }
            }

            #endregion

            return uploadedFiles;
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\SftpClient.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// 
    /// </summary>
    public partial class SftpClient
    {
        /// <summary>
        /// Executes the specified action in a separate thread.
        /// </summary>
        /// <param name="action">The action to execute.</param>
        partial void ExecuteThread(Action action)
        {
            ThreadPool.QueueUserWorkItem(o => action());
        }
    }
}
#endif
// file ...\X\Renci.SshNet\Shell.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Represents instance of the SSH shell object
    /// </summary>
    public partial class Shell : IDisposable
    {
        private readonly ISession _session;

        private IChannelSession _channel;

        private EventWaitHandle _channelClosedWaitHandle;

        private Stream _input;

        private readonly string _terminalName;

        private readonly uint _columns;

        private readonly uint _rows;

        private readonly uint _width;

        private readonly uint _height;

        private readonly IDictionary<TerminalModes, uint> _terminalModes;

        private EventWaitHandle _dataReaderTaskCompleted;

        private readonly Stream _outputStream;

        private readonly Stream _extendedOutputStream;

        private readonly int _bufferSize;

        /// <summary>
        /// Gets a value indicating whether this shell is started.
        /// </summary>
        /// <value>
        /// <c>true</c> if started is started; otherwise, <c>false</c>.
        /// </value>
        public bool IsStarted { get; private set; }

        /// <summary>
        /// Occurs when shell is starting.
        /// </summary>
        public event EventHandler<EventArgs> Starting;

        /// <summary>
        /// Occurs when shell is started.
        /// </summary>
        public event EventHandler<EventArgs> Started;

        /// <summary>
        /// Occurs when shell is stopping.
        /// </summary>
        public event EventHandler<EventArgs> Stopping;

        /// <summary>
        /// Occurs when shell is stopped.
        /// </summary>
        public event EventHandler<EventArgs> Stopped;

        /// <summary>
        /// Occurs when an error occurred.
        /// </summary>
        public event EventHandler<ExceptionEventArgs> ErrorOccurred;

        /// <summary>
        /// Initializes a new instance of the <see cref="Shell"/> class.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="input">The input.</param>
        /// <param name="output">The output.</param>
        /// <param name="extendedOutput">The extended output.</param>
        /// <param name="terminalName">Name of the terminal.</param>
        /// <param name="columns">The columns.</param>
        /// <param name="rows">The rows.</param>
        /// <param name="width">The width.</param>
        /// <param name="height">The height.</param>
        /// <param name="terminalModes">The terminal modes.</param>
        /// <param name="bufferSize">Size of the buffer for output stream.</param>
        internal Shell(ISession session, Stream input, Stream output, Stream extendedOutput, string terminalName, uint columns, uint rows, uint width, uint height, IDictionary<TerminalModes, uint> terminalModes, int bufferSize)
        {
            this._session = session;
            this._input = input;
            this._outputStream = output;
            this._extendedOutputStream = extendedOutput;
            this._terminalName = terminalName;
            this._columns = columns;
            this._rows = rows;
            this._width = width;
            this._height = height;
            this._terminalModes = terminalModes;
            this._bufferSize = bufferSize;
        }

        /// <summary>
        /// Starts this shell.
        /// </summary>
        /// <exception cref="SshException">Shell is started.</exception>
        public void Start()
        {
            if (this.IsStarted)
            {
                throw new SshException("Shell is started.");
            }

            if (this.Starting != null)
            {
                this.Starting(this, new EventArgs());
            }

            this._channel = this._session.CreateChannelSession();
            this._channel.DataReceived += Channel_DataReceived;
            this._channel.ExtendedDataReceived += Channel_ExtendedDataReceived;
            this._channel.Closed += Channel_Closed;
            this._session.Disconnected += Session_Disconnected;
            this._session.ErrorOccured += Session_ErrorOccured;

            this._channel.Open();
            this._channel.SendPseudoTerminalRequest(this._terminalName, this._columns, this._rows, this._width, this._height, this._terminalModes);
            this._channel.SendShellRequest();

            this._channelClosedWaitHandle = new AutoResetEvent(false);

            //  Start input stream listener
            this._dataReaderTaskCompleted = new ManualResetEvent(false);
            this.ExecuteThread(() =>
            {
                try
                {
                    var buffer = new byte[this._bufferSize];

                    while (this._channel.IsOpen)
                    {
                        var asyncResult = this._input.BeginRead(buffer, 0, buffer.Length, delegate(IAsyncResult result)
                        {
                            //  If input stream is closed and disposed already dont finish reading the stream
                            if (this._input == null)
                                return;

                            var read = this._input.EndRead(result);
                            if (read > 0)
                            {
                                this._channel.SendData(buffer.Take(read).ToArray());
                            }

                        }, null);

                        EventWaitHandle.WaitAny(new WaitHandle[] { asyncResult.AsyncWaitHandle, this._channelClosedWaitHandle });

                        if (asyncResult.IsCompleted)
                            continue;
                        break;
                    }
                }
                catch (Exception exp)
                {
                    this.RaiseError(new ExceptionEventArgs(exp));
                }
                finally
                {
                    this._dataReaderTaskCompleted.Set();
                }
            });

            this.IsStarted = true;

            if (this.Started != null)
            {
                this.Started(this, new EventArgs());
            }
        }

        /// <summary>
        /// Stops this shell.
        /// </summary>
        /// <exception cref="SshException">Shell is not started.</exception>
        public void Stop()
        {
            if (!this.IsStarted)
            {
                throw new SshException("Shell is not started.");
            }

            if (this._channel != null)
            {
                this._channel.Close();
            }
        }

        private void Session_ErrorOccured(object sender, ExceptionEventArgs e)
        {
            this.RaiseError(e);
        }

        private void RaiseError(ExceptionEventArgs e)
        {
            var handler = this.ErrorOccurred;
            if (handler != null)
            {
                handler(this, e);
            }
        }

        private void Session_Disconnected(object sender, EventArgs e)
        {
            this.Stop();
        }

        private void Channel_ExtendedDataReceived(object sender, ChannelDataEventArgs e)
        {
            if (this._extendedOutputStream != null)
            {
                this._extendedOutputStream.Write(e.Data, 0, e.Data.Length);
            }
        }

        private void Channel_DataReceived(object sender, ChannelDataEventArgs e)
        {
            if (this._outputStream != null)
            {
                this._outputStream.Write(e.Data, 0, e.Data.Length);
            }
        }

        private void Channel_Closed(object sender, ChannelEventArgs e)
        {
            if (this.Stopping != null)
            {
                //  Handle event on different thread
                this.ExecuteThread(() => this.Stopping(this, new EventArgs()));
            }

            if (this._channel.IsOpen)
            {
                this._channel.Close();
            }

            this._channelClosedWaitHandle.Set();

            this._input.Dispose();
            this._input = null;

            this._dataReaderTaskCompleted.WaitOne(this._session.ConnectionInfo.Timeout);
            this._dataReaderTaskCompleted.Dispose();
            this._dataReaderTaskCompleted = null;

            this._channel.DataReceived -= Channel_DataReceived;
            this._channel.ExtendedDataReceived -= Channel_ExtendedDataReceived;
            this._channel.Closed -= Channel_Closed;
            this._session.Disconnected -= Session_Disconnected;
            this._session.ErrorOccured -= Session_ErrorOccured;

            if (this.Stopped != null)
            {
                //  Handle event on different thread
                this.ExecuteThread(() => this.Stopped(this, new EventArgs()));
            }

            this._channel = null;
        }

        partial void ExecuteThread(Action action);

        #region IDisposable Members

        private bool _disposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged ResourceMessages.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!this._disposed)
            {
                // If disposing equals true, dispose all managed
                // and unmanaged ResourceMessages.
                if (disposing)
                {
                    if (this._channelClosedWaitHandle != null)
                    {
                        this._channelClosedWaitHandle.Dispose();
                        this._channelClosedWaitHandle = null;
                    }

                    if (this._channel != null)
                    {
                        this._channel.Dispose();
                        this._channel = null;
                    }

                    if (this._dataReaderTaskCompleted != null)
                    {
                        this._dataReaderTaskCompleted.Dispose();
                        this._dataReaderTaskCompleted = null;
                    }
                }

                // Note disposing has been done.
                this._disposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="Session"/> is reclaimed by garbage collection.
        /// </summary>
        ~Shell()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion

    }
}

#endif
// file ...\X\Renci.SshNet\Shell.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Represents instance of the SSH shell object
    /// </summary>
    public partial class Shell 
    {
        /// <exception cref="ArgumentNullException"><paramref name=" action"/> is null.</exception>
        partial void ExecuteThread(Action action)
        {
            ThreadPool.QueueUserWorkItem(o => action());
        }
    }
}

#endif
// file ...\X\Renci.SshNet\ShellStream.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Contains operation for working with SSH Shell.
    /// </summary>
    public partial class ShellStream : Stream
    {
        private const string CrLf = "\r\n";
        private const int BufferSize = 1024;

        private readonly ISession _session;
        private readonly Encoding _encoding;
        private readonly Queue<byte> _incoming;
        private readonly Queue<byte> _outgoing;
        private IChannelSession _channel;
        private AutoResetEvent _dataReceived = new AutoResetEvent(false);

        /// <summary>
        /// Occurs when data was received.
        /// </summary>
        public event EventHandler<ShellDataEventArgs> DataReceived;

        /// <summary>
        /// Occurs when an error occurred.
        /// </summary>
        public event EventHandler<ExceptionEventArgs> ErrorOccurred;

        /// <summary>
        /// Gets a value that indicates whether data is available on the <see cref="ShellStream"/> to be read.
        /// </summary>
        /// <value>
        /// <c>true</c> if data is available to be read; otherwise, <c>false</c>.
        /// </value>
        public bool DataAvailable
        {
            get
            {
                lock (_incoming)
                {
                    return _incoming.Count > 0;
                }
            }
        }

        internal ShellStream(ISession session, string terminalName, uint columns, uint rows, uint width, uint height, int maxLines, IDictionary<TerminalModes, uint> terminalModeValues)
        {
            _encoding = session.ConnectionInfo.Encoding;
            _session = session;
            _incoming = new Queue<byte>();
            _outgoing = new Queue<byte>();

            _channel = _session.CreateChannelSession();
            _channel.DataReceived += Channel_DataReceived;
            _channel.Closed += Channel_Closed;
            _session.Disconnected += Session_Disconnected;
            _session.ErrorOccured += Session_ErrorOccured;

            _channel.Open();
            _channel.SendPseudoTerminalRequest(terminalName, columns, rows, width, height, terminalModeValues);
            _channel.SendShellRequest();
        }

        #region Stream overide methods

        /// <summary>
        /// Gets a value indicating whether the current stream supports reading.
        /// </summary>
        /// <returns>
        /// <c>true</c> if the stream supports reading; otherwise, <c>false</c>.
        /// </returns>
        public override bool CanRead
        {
            get { return true; }
        }

        /// <summary>
        /// Gets a value indicating whether the current stream supports seeking.
        /// </summary>
        /// <returns>
        /// <c>true</c> if the stream supports seeking; otherwise, <c>false</c>.
        /// </returns>
        public override bool CanSeek
        {
            get { return false; }
        }

        /// <summary>
        /// Gets a value indicating whether the current stream supports writing.
        /// </summary>
        /// <returns>
        /// <c>true</c> if the stream supports writing; otherwise, <c>false</c>.
        /// </returns>
        public override bool CanWrite
        {
            get { return true; }
        }

        /// <summary>
        /// Clears all buffers for this stream and causes any buffered data to be written to the underlying device.
        /// </summary>
        /// <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        public override void Flush()
        {
            if (_channel == null)
            {
                throw new ObjectDisposedException("ShellStream");
            }
            _channel.SendData(_outgoing.ToArray());
            _outgoing.Clear();
        }

        /// <summary>
        /// Gets the length in bytes of the stream.
        /// </summary>
        /// <returns>A long value representing the length of the stream in bytes.</returns>
        /// <exception cref="T:System.NotSupportedException">A class derived from Stream does not support seeking.</exception>
        /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        public override long Length
        {
            get
            {
                lock (_incoming)
                {
                    return _incoming.Count;
                }
            }
        }

        /// <summary>
        /// Gets or sets the position within the current stream.
        /// </summary>
        /// <returns>
        /// The current position within the stream.
        /// </returns>
        /// <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        /// <exception cref="T:System.NotSupportedException">The stream does not support seeking.</exception>
        /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        public override long Position
        {
            get { return 0; }
            set { throw new NotSupportedException(); }
        }

        /// <summary>
        /// Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
        /// </summary>
        /// <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset"/> and (<paramref name="offset"/> + <paramref name="count"/> - 1) replaced by the bytes read from the current source.</param>
        /// <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin storing the data read from the current stream.</param>
        /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
        /// <returns>
        /// The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
        /// </returns>
        /// <exception cref="T:System.ArgumentException">The sum of <paramref name="offset"/> and <paramref name="count"/> is larger than the buffer length. </exception>
        /// <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
        /// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> or <paramref name="count"/> is negative.</exception>
        /// <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>   
        /// <exception cref="T:System.NotSupportedException">The stream does not support reading.</exception>   
        /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        public override int Read(byte[] buffer, int offset, int count)
        {
            var i = 0;

            lock (_incoming)
            {
                for (; i < count && _incoming.Count > 0; i++)
                {
                    buffer[offset + i] = _incoming.Dequeue();
                }
            }

            return i;
        }

        /// <summary>
        /// This method is not supported.
        /// </summary>
        /// <param name="offset">A byte offset relative to the <paramref name="origin"/> parameter.</param>
        /// <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"/> indicating the reference point used to obtain the new position.</param>
        /// <returns>
        /// The new position within the current stream.
        /// </returns>
        /// <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        /// <exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output.</exception>
        /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException();
        }

        /// <summary>
        /// This method is not supported.
        /// </summary>
        /// <param name="value">The desired length of the current stream in bytes.</param>
        /// <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        /// <exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output.</exception>
        /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        public override void SetLength(long value)
        {
            throw new NotSupportedException();
        }

        /// <summary>
        /// Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies <paramref name="count"/> bytes from <paramref name="buffer"/> to the current stream.</param>
        /// <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin copying bytes to the current stream.</param>
        /// <param name="count">The number of bytes to be written to the current stream.</param>
        /// <exception cref="T:System.ArgumentException">The sum of <paramref name="offset"/> and <paramref name="count"/> is greater than the buffer length.</exception>
        /// <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
        /// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> or <paramref name="count"/> is negative.</exception>
        /// <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        /// <exception cref="T:System.NotSupportedException">The stream does not support writing.</exception>
        /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        public override void Write(byte[] buffer, int offset, int count)
        {
            foreach (var b in buffer.Skip(offset).Take(count).ToArray())
            {
                if (_outgoing.Count < BufferSize)
                {
                    _outgoing.Enqueue(b);
                    continue;
                }

                Flush();
            }
        }

        #endregion

        /// <summary>
        /// Expects the specified expression and performs action when one is found.
        /// </summary>
        /// <param name="expectActions">The expected expressions and actions to perform.</param>
        public void Expect(params ExpectAction[] expectActions)
        {
            Expect(TimeSpan.Zero, expectActions);
        }

        /// <summary>
        /// Expects the specified expression and performs action when one is found.
        /// </summary>
        /// <param name="timeout">Time to wait for input.</param>
        /// <param name="expectActions">The expected expressions and actions to perform, if the specified time elapsed and expected condition have not met, that method will exit without executing any action.</param>
        public void Expect(TimeSpan timeout, params ExpectAction[] expectActions)
        {
            var expectedFound = false;
            var text = string.Empty;

            do
            {
                lock (_incoming)
                {
                    if (_incoming.Count > 0)
                    {
                        text = _encoding.GetString(_incoming.ToArray(), 0, _incoming.Count);
                    }

                    if (text.Length > 0)
                    {
                        foreach (var expectAction in expectActions)
                        {
                            var match = expectAction.Expect.Match(text);

                            if (match.Success)
                            {
                                var result = text.Substring(0, match.Index + match.Length);

                                for (int i = 0; i < match.Index + match.Length && _incoming.Count > 0; i++)
                                {
                                    //  Remove processed items from the queue
                                    _incoming.Dequeue();
                                }

                                expectAction.Action(result);
                                expectedFound = true;
                            }
                        }
                    }
                }

                if (!expectedFound)
                {
                    if (timeout.Ticks > 0)
                    {
                        if (!_dataReceived.WaitOne(timeout))
                        {
                            return;
                        }
                    }
                    else
                    {
                        _dataReceived.WaitOne();
                    }
                }
            }
            while (!expectedFound);
        }

        /// <summary>
        /// Begins the expect.
        /// </summary>
        /// <param name="expectActions">The expect actions.</param>
        /// <returns>
        /// An <see cref="IAsyncResult" /> that references the asynchronous operation.
        /// </returns>
        public IAsyncResult BeginExpect(params ExpectAction[] expectActions)
        {
            return BeginExpect(TimeSpan.Zero, null, null, expectActions);
        }

        /// <summary>
        /// Begins the expect.
        /// </summary>
        /// <param name="callback">The callback.</param>
        /// <param name="expectActions">The expect actions.</param>
        /// <returns>
        /// An <see cref="IAsyncResult" /> that references the asynchronous operation.
        /// </returns>
        public IAsyncResult BeginExpect(AsyncCallback callback, params ExpectAction[] expectActions)
        {
            return BeginExpect(TimeSpan.Zero, callback, null, expectActions);
        }

        /// <summary>
        /// Begins the expect.
        /// </summary>
        /// <param name="callback">The callback.</param>
        /// <param name="state">The state.</param>
        /// <param name="expectActions">The expect actions.</param>
        /// <returns>
        /// An <see cref="IAsyncResult" /> that references the asynchronous operation.
        /// </returns>
        public IAsyncResult BeginExpect(AsyncCallback callback, object state, params ExpectAction[] expectActions)
        {
            return BeginExpect(TimeSpan.Zero, callback, state, expectActions);
        }

        /// <summary>
        /// Begins the expect.
        /// </summary>
        /// <param name="timeout">The timeout.</param>
        /// <param name="callback">The callback.</param>
        /// <param name="state">The state.</param>
        /// <param name="expectActions">The expect actions.</param>
        /// <returns>
        /// An <see cref="IAsyncResult" /> that references the asynchronous operation.
        /// </returns>
        public IAsyncResult BeginExpect(TimeSpan timeout, AsyncCallback callback, object state, params ExpectAction[] expectActions)
        {
            var text = string.Empty;

            //  Create new AsyncResult object
            var asyncResult = new ExpectAsyncResult(callback, state);

            //  Execute callback on different thread
            ExecuteThread(() =>
            {
                string expectActionResult = null;
                try
                {

                    do
                    {
                        lock (_incoming)
                        {

                            if (_incoming.Count > 0)
                            {
                                text = _encoding.GetString(_incoming.ToArray(), 0, _incoming.Count);
                            }

                            if (text.Length > 0)
                            {
                                foreach (var expectAction in expectActions)
                                {
                                    var match = expectAction.Expect.Match(text);

                                    if (match.Success)
                                    {
                                        var result = text.Substring(0, match.Index + match.Length);

                                        for (int i = 0; i < match.Index + match.Length && _incoming.Count > 0; i++)
                                        {
                                            //  Remove processed items from the queue
                                            _incoming.Dequeue();
                                        }

                                        expectAction.Action(result);

                                        if (callback != null)
                                        {
                                            callback(asyncResult);
                                        }
                                        expectActionResult = result;
                                    }
                                }
                            }
                        }

                        if (expectActionResult != null)
                            break;

                        if (timeout.Ticks > 0)
                        {
                            if (!_dataReceived.WaitOne(timeout))
                            {
                                if (callback != null)
                                {
                                    callback(asyncResult);
                                }
                                break;
                            }
                        }
                        else
                        {
                            _dataReceived.WaitOne();
                        }
                    } while (true);

                    asyncResult.SetAsCompleted(expectActionResult, true);
                }
                catch (Exception exp)
                {
                    asyncResult.SetAsCompleted(exp, true);
                }
            });

            return asyncResult;
        }

        /// <summary>
        /// Ends the execute.
        /// </summary>
        /// <param name="asyncResult">The async result.</param>
        /// <exception cref="System.ArgumentException">Either the IAsyncResult object did not come from the corresponding async method on this type, or EndExecute was called multiple times with the same IAsyncResult.</exception>
        public string EndExpect(IAsyncResult asyncResult)
        {
            var ar = asyncResult as ExpectAsyncResult;

            if (ar == null || ar.EndInvokeCalled)
                throw new ArgumentException("Either the IAsyncResult object did not come from the corresponding async method on this type, or EndExecute was called multiple times with the same IAsyncResult.");

            // Wait for operation to complete, then return result or throw exception
            return ar.EndInvoke();
        }

        /// <summary>
        /// Expects the expression specified by text.
        /// </summary>
        /// <param name="text">The text to expect.</param>
        /// <returns>
        /// Text available in the shell that ends with expected text.
        /// </returns>
        public string Expect(string text)
        {
            return Expect(new Regex(Regex.Escape(text)), TimeSpan.FromMilliseconds(-1));
        }

        /// <summary>
        /// Expects the expression specified by text.
        /// </summary>
        /// <param name="text">The text to expect.</param>
        /// <param name="timeout">Time to wait for input.</param>
        /// <returns>
        /// Text available in the shell that ends with expected text, if the specified time elapsed returns null.
        /// </returns>
        public string Expect(string text, TimeSpan timeout)
        {
            return Expect(new Regex(Regex.Escape(text)), timeout);
        }

        /// <summary>
        /// Expects the expression specified by regular expression.
        /// </summary>
        /// <param name="regex">The regular expression to expect.</param>
        /// <returns>Text available in the shell that contains all the text that ends with expected expression.</returns>
        public string Expect(Regex regex)
        {
            return Expect(regex, TimeSpan.Zero);
        }

        /// <summary>
        /// Expects the expression specified by regular expression.
        /// </summary>
        /// <param name="regex">The regular expression to expect.</param>
        /// <param name="timeout">Time to wait for input.</param>
        /// <returns>
        /// Text available in the shell that contains all the text that ends with expected expression, if the specified time elapsed returns null.
        /// </returns>
        public string Expect(Regex regex, TimeSpan timeout)
        {
            var text = string.Empty;

            while (true)
            {
                lock (_incoming)
                {
                    if (_incoming.Count > 0)
                    {
                        text = _encoding.GetString(_incoming.ToArray(), 0, _incoming.Count);
                    }

                    var match = regex.Match(text);

                    if (match.Success)
                    {
                        //  Remove processed items from the queue
                        for (var i = 0; i < match.Index + match.Length && _incoming.Count > 0; i++)
                        {
                            _incoming.Dequeue();
                        }
                        break;
                    }
                }

                if (timeout.Ticks > 0)
                {
                    if (!_dataReceived.WaitOne(timeout))
                    {
                        return null;
                    }
                }
                else
                {
                    _dataReceived.WaitOne();
                }

            }

            return text;
        }

        /// <summary>
        /// Reads the line from the shell. If line is not available it will block the execution and will wait for new line.
        /// </summary>
        /// <returns>
        /// The line read from the shell.
        /// </returns>
        public string ReadLine()
        {
            return ReadLine(TimeSpan.Zero);
        }

        /// <summary>
        /// Reads a line from the shell. If line is not available it will block the execution and will wait for new line.
        /// </summary>
        /// <param name="timeout">Time to wait for input.</param>
        /// <returns>
        /// The line read from the shell, or <c>null</c> when no input is received for the specified timeout.
        /// </returns>
        public string ReadLine(TimeSpan timeout)
        {
            var text = string.Empty;

            while (true)
            {
                lock (_incoming)
                {
                    if (_incoming.Count > 0)
                    {
                        text = _encoding.GetString(_incoming.ToArray(), 0, _incoming.Count);
                    }

                    var index = text.IndexOf(CrLf, StringComparison.Ordinal);

                    if (index >= 0)
                    {
                        text = text.Substring(0, index);

                        // determine how many bytes to remove from buffer
                        var bytesProcessed = _encoding.GetByteCount(text + CrLf);

                        // remove processed bytes from the queue
                        for (var i = 0; i < bytesProcessed; i++)
                            _incoming.Dequeue();

                        break;
                    }
                }

                if (timeout.Ticks > 0)
                {
                    if (!_dataReceived.WaitOne(timeout))
                    {
                        return null;
                    }
                }
                else
                {
                    _dataReceived.WaitOne();
                }

            }

            return text;
        }

        /// <summary>
        /// Reads text available in the shell.
        /// </summary>
        /// <returns>
        /// The text available in the shell.
        /// </returns>
        public string Read()
        {
            string text;

            lock (_incoming)
            {
                text = _encoding.GetString(_incoming.ToArray(), 0, _incoming.Count);
                _incoming.Clear();
            }

            return text;
        }

        /// <summary>
        /// Writes the specified text to the shell.
        /// </summary>
        /// <param name="text">The text to be written to the shell.</param>
        /// <remarks>
        /// If <paramref name="text"/> is <c>null</c>, nothing is written.
        /// </remarks>
        public void Write(string text)
        {
            if (text == null)
                return;

            if (_channel == null)
            {
                throw new ObjectDisposedException("ShellStream");
            }

            var data = _encoding.GetBytes(text);
            _channel.SendData(data);
        }

        /// <summary>
        /// Writes the line to the shell.
        /// </summary>
        /// <param name="line">The line to be written to the shell.</param>
        /// <remarks>
        /// If <paramref name="line"/> is <c>null</c>, only the line terminator is written.
        /// </remarks>
        public void WriteLine(string line)
        {
            var commandText = string.Format("{0}{1}", line, "\r");
            Write(commandText);
        }

        /// <summary>
        /// Releases the unmanaged resources used by the <see cref="T:System.IO.Stream"/> and optionally releases the managed resources.
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);

            if (_session != null)
            {
                _session.Disconnected -= Session_Disconnected;
                _session.ErrorOccured -= Session_ErrorOccured;
            }

            if (_channel != null)
            {
                _channel.DataReceived -= Channel_DataReceived;
                _channel.Closed -= Channel_Closed;
                _channel.Dispose();
                _channel = null;
            }

            if (_dataReceived != null)
            {
                _dataReceived.Dispose();
                _dataReceived = null;
            }
        }

        partial void ExecuteThread(Action action);

        private void Session_ErrorOccured(object sender, ExceptionEventArgs e)
        {
            OnRaiseError(e);
        }

        private void Session_Disconnected(object sender, EventArgs e)
        {
            if (_channel != null)
                _channel.Close();
        }

        private void Channel_Closed(object sender, ChannelEventArgs e)
        {
            //OneCodeTODO:   Do we need to call dispose here ??
            Dispose();
        }

        private void Channel_DataReceived(object sender, ChannelDataEventArgs e)
        {
            lock (_incoming)
            {
                foreach (var b in e.Data)
                    _incoming.Enqueue(b);
            }

            if (_dataReceived != null)
                _dataReceived.Set();

            OnDataReceived(e.Data);
        }

        private void OnRaiseError(ExceptionEventArgs e)
        {
            var handler = ErrorOccurred;
            if (handler != null)
            {
                handler(this, e);
            }
        }

        private void OnDataReceived(byte[] data)
        {
            var handler = DataReceived;
            if (handler != null)
            {
                handler(this, new ShellDataEventArgs(data));
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\ShellStream.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Represents instance of the SSH shell object
    /// </summary>
    public partial class ShellStream
    {
        /// <summary>
        /// Executes the specified action in a separate thread.
        /// </summary>
        /// <param name="action">The action to execute.</param>
        partial void ExecuteThread(Action action)
        {
            ThreadPool.QueueUserWorkItem(o => action());
        }
    }
}

#endif
// file ...\X\Renci.SshNet\SshClient.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Provides client connection to SSH server.
    /// </summary>
    public class SshClient : BaseClient
    {
        /// <summary>
        /// Holds the list of forwarded ports
        /// </summary>
        private readonly List<ForwardedPort> _forwardedPorts;

        /// <summary>
        /// Holds a value indicating whether the current instance is disposed.
        /// </summary>
        /// <value>
        /// <c>true</c> if the current instance is disposed; otherwise, <c>false</c>.
        /// </value>
        private bool _isDisposed;

        private Stream _inputStream;

        /// <summary>
        /// Gets the list of forwarded ports.
        /// </summary>
        public IEnumerable<ForwardedPort> ForwardedPorts
        {
            get
            {
                return _forwardedPorts.AsReadOnly();
            }
        }

        #region Constructors

        /// <summary>
        /// Initializes a new instance of the <see cref="SshClient" /> class.
        /// </summary>
        /// <param name="connectionInfo">The connection info.</param>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\PasswordConnectionInfoTest.cs" region="Example PasswordConnectionInfo" language="C#" title="Connect using PasswordConnectionInfo object" />
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\PasswordConnectionInfoTest.cs" region="Example PasswordConnectionInfo PasswordExpired" language="C#" title="Connect using PasswordConnectionInfo object with passwod change option" />
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\PrivateKeyConnectionInfoTest.cs" region="Example PrivateKeyConnectionInfo PrivateKeyFile" language="C#" title="Connect using PrivateKeyConnectionInfo" />
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshClientTest.cs" region="Example SshClient Connect Timeout" language="C#" title="Specify connection timeout when connecting" />
        /// </example>
        /// <exception cref="ArgumentNullException"><paramref name="connectionInfo"/> is null.</exception>
        public SshClient(ConnectionInfo connectionInfo)
            : this(connectionInfo, false)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshClient"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">Connection port.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="password">Authentication password.</param>
        /// <exception cref="ArgumentNullException"><paramref name="password"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid, or <paramref name="username"/> is null or contains whitespace characters.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="port"/> is not within <see cref="F:System.Net.IPEndPoint.MinPort"/> and <see cref="System.Net.IPEndPoint.MaxPort"/>.</exception>
        [SuppressMessage("Microsoft.Reliability", "C2A000:DisposeObjectsBeforeLosingScope", Justification = "Disposed in Dispose(bool) method.")]
        public SshClient(string host, int port, string username, string password)
            : this(new PasswordConnectionInfo(host, port, username, password), true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshClient"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="password">Authentication password.</param>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshClientTest.cs" region="Example SshClient(host, username) Connect" language="C#" title="Connect using username and password" />
        /// </example>
        /// <exception cref="ArgumentNullException"><paramref name="password"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid, or <paramref name="username"/> is null or contains whitespace characters.</exception>
        public SshClient(string host, string username, string password)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, password)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshClient"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="port">Connection port.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="keyFiles">Authentication private key file(s) .</param>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshClientTest.cs" region="Example SshClient(host, username) Connect PrivateKeyFile" language="C#" title="Connect using username and private key" />
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshClientTest.cs" region="Example SshClient(host, username) Connect PrivateKeyFile PassPhrase" language="C#" title="Connect using username and private key and pass phrase" />
        /// </example>
        /// <exception cref="ArgumentNullException"><paramref name="keyFiles"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid, -or- <paramref name="username"/> is null or contains whitespace characters.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="port"/> is not within <see cref="F:System.Net.IPEndPoint.MinPort"/> and <see cref="System.Net.IPEndPoint.MaxPort"/>.</exception>
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "Disposed in Dispose(bool) method.")]
        public SshClient(string host, int port, string username, params PrivateKeyFile[] keyFiles)
            : this(new PrivateKeyConnectionInfo(host, port, username, keyFiles), true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshClient"/> class.
        /// </summary>
        /// <param name="host">Connection host.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="keyFiles">Authentication private key file(s) .</param>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshClientTest.cs" region="Example SshClient(host, username) Connect PrivateKeyFile" language="C#" title="Connect using private key" />
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshClientTest.cs" region="Example SshClient(host, username) Connect PrivateKeyFile PassPhrase" language="C#" title="Connect using private key and pass phrase" />
        /// </example>
        /// <exception cref="ArgumentNullException"><paramref name="keyFiles"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="host"/> is invalid, -or- <paramref name="username"/> is null or contains whitespace characters.</exception>
        public SshClient(string host, string username, params PrivateKeyFile[] keyFiles)
            : this(host, ConnectionInfo.DEFAULT_PORT, username, keyFiles)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshClient"/> class.
        /// </summary>
        /// <param name="connectionInfo">The connection info.</param>
        /// <param name="ownsConnectionInfo">Specified whether this instance owns the connection info.</param>
        /// <exception cref="ArgumentNullException"><paramref name="connectionInfo"/> is null.</exception>
        /// <remarks>
        /// If <paramref name="ownsConnectionInfo"/> is <c>true</c>, then the
        /// connection info will be disposed when this instance is disposed.
        /// </remarks>
        private SshClient(ConnectionInfo connectionInfo, bool ownsConnectionInfo)
            : this(connectionInfo, ownsConnectionInfo, new ServiceFactory())
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshClient"/> class.
        /// </summary>
        /// <param name="connectionInfo">The connection info.</param>
        /// <param name="ownsConnectionInfo">Specified whether this instance owns the connection info.</param>
        /// <param name="serviceFactory">The factory to use for creating new services.</param>
        /// <exception cref="ArgumentNullException"><paramref name="connectionInfo"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="serviceFactory"/> is null.</exception>
        /// <remarks>
        /// If <paramref name="ownsConnectionInfo"/> is <c>true</c>, then the
        /// connection info will be disposed when this instance is disposed.
        /// </remarks>
        internal SshClient(ConnectionInfo connectionInfo, bool ownsConnectionInfo, IServiceFactory serviceFactory)
            : base(connectionInfo, ownsConnectionInfo, serviceFactory)
        {
            _forwardedPorts = new List<ForwardedPort>();
        }

        #endregion

        /// <summary>
        /// Called when client is disconnecting from the server.
        /// </summary>
        protected override void OnDisconnecting()
        {
            base.OnDisconnecting();

            foreach (var port in _forwardedPorts)
            {
                port.Stop();
            }
        }

        /// <summary>
        /// Adds the forwarded port.
        /// </summary>
        /// <param name="port">The port.</param>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\ForwardedPortRemoteTest.cs" region="Example SshClient AddForwardedPort Start Stop ForwardedPortRemote" language="C#" title="Remote port forwarding" />
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\ForwardedPortLocalTest.cs" region="Example SshClient AddForwardedPort Start Stop ForwardedPortLocal" language="C#" title="Local port forwarding" />
        /// </example>
        /// <exception cref="InvalidOperationException">Forwarded port is already added to a different client.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="port"/> is null.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        public void AddForwardedPort(ForwardedPort port)
        {
            if (port == null)
                throw new ArgumentNullException("port");
            EnsureSessionIsOpen();

            AttachForwardedPort(port);
            _forwardedPorts.Add(port);
        }

        /// <summary>
        /// Stops and removes the forwarded port from the list.
        /// </summary>
        /// <param name="port">Forwarded port.</param>
        /// <exception cref="ArgumentNullException"><paramref name="port"/> is null.</exception>
        public void RemoveForwardedPort(ForwardedPort port)
        {
            if (port == null)
                throw new ArgumentNullException("port");

            //  Stop port forwarding before removing it
            port.Stop();

            DetachForwardedPort(port);
            _forwardedPorts.Remove(port);
        }

        private void AttachForwardedPort(ForwardedPort port)
        {
            if (port.Session != null && port.Session != Session)
                throw new InvalidOperationException("Forwarded port is already added to a different client.");

            port.Session = Session;
        }

        private static void DetachForwardedPort(ForwardedPort port)
        {
            port.Session = null;
        }

        /// <summary>
        /// Creates the command to be executed.
        /// </summary>
        /// <param name="commandText">The command text.</param>
        /// <returns><see cref="SshCommand"/> object.</returns>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        public SshCommand CreateCommand(string commandText)
        {
            return CreateCommand(commandText, ConnectionInfo.Encoding);
        }

        /// <summary>
        /// Creates the command to be executed with specified encoding.
        /// </summary>
        /// <param name="commandText">The command text.</param>
        /// <param name="encoding">The encoding to use for results.</param>
        /// <returns><see cref="SshCommand"/> object which uses specified encoding.</returns>
        /// <remarks>This method will change current default encoding.</remarks>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="commandText"/> or <paramref name="encoding"/> is null.</exception>
        public SshCommand CreateCommand(string commandText, Encoding encoding)
        {
            EnsureSessionIsOpen();

            ConnectionInfo.Encoding = encoding;
            return new SshCommand(Session, commandText, encoding);
        }

        /// <summary>
        /// Creates and executes the command.
        /// </summary>
        /// <param name="commandText">The command text.</param>
        /// <returns>Returns an instance of <see cref="SshCommand"/> with execution results.</returns>
        /// <remarks>This method internally uses asynchronous calls.</remarks>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshCommandTest.cs" region="Example SshCommand RunCommand Result" language="C#" title="Running simple command" />
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshCommandTest.NET40.cs" region="Example SshCommand RunCommand Parallel" language="C#" title="Run many commands in parallel" />
        /// </example>
        /// <exception cref="ArgumentException">CommandText property is empty.</exception>
        /// <exception cref="T:Renci.SshNet.Common.SshException">Invalid Operation - An existing channel was used to execute this command.</exception>
        /// <exception cref="InvalidOperationException">Asynchronous operation is already in progress.</exception>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="commandText"/> is null.</exception>
        public SshCommand RunCommand(string commandText)
        {
            var cmd = CreateCommand(commandText);
            cmd.Execute();
            return cmd;
        }

        /// <summary>
        /// Creates the shell.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <param name="output">The output.</param>
        /// <param name="extendedOutput">The extended output.</param>
        /// <param name="terminalName">Name of the terminal.</param>
        /// <param name="columns">The columns.</param>
        /// <param name="rows">The rows.</param>
        /// <param name="width">The width.</param>
        /// <param name="height">The height.</param>
        /// <param name="terminalModes">The terminal mode.</param>
        /// <param name="bufferSize">Size of the internal read buffer.</param>
        /// <returns>
        /// Returns a representation of a <see cref="Shell" /> object.
        /// </returns>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        public Shell CreateShell(Stream input, Stream output, Stream extendedOutput, string terminalName, uint columns, uint rows, uint width, uint height, IDictionary<TerminalModes, uint> terminalModes, int bufferSize)
        {
            EnsureSessionIsOpen();

            return new Shell(Session, input, output, extendedOutput, terminalName, columns, rows, width, height, terminalModes, bufferSize);
        }

        /// <summary>
        /// Creates the shell.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <param name="output">The output.</param>
        /// <param name="extendedOutput">The extended output.</param>
        /// <param name="terminalName">Name of the terminal.</param>
        /// <param name="columns">The columns.</param>
        /// <param name="rows">The rows.</param>
        /// <param name="width">The width.</param>
        /// <param name="height">The height.</param>
        /// <param name="terminalModes">The terminal mode.</param>
        /// <returns>
        /// Returns a representation of a <see cref="Shell" /> object.
        /// </returns>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        public Shell CreateShell(Stream input, Stream output, Stream extendedOutput, string terminalName, uint columns, uint rows, uint width, uint height, IDictionary<TerminalModes, uint> terminalModes)
        {
            return CreateShell(input, output, extendedOutput, terminalName, columns, rows, width, height, terminalModes, 1024);
        }

        /// <summary>
        /// Creates the shell.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <param name="output">The output.</param>
        /// <param name="extendedOutput">The extended output.</param>
        /// <returns>
        /// Returns a representation of a <see cref="Shell" /> object.
        /// </returns>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        public Shell CreateShell(Stream input, Stream output, Stream extendedOutput)
        {
            return CreateShell(input, output, extendedOutput, string.Empty, 0, 0, 0, 0, null, 1024);
        }

        /// <summary>
        /// Creates the shell.
        /// </summary>
        /// <param name="encoding">The encoding to use to send the input.</param>
        /// <param name="input">The input.</param>
        /// <param name="output">The output.</param>
        /// <param name="extendedOutput">The extended output.</param>
        /// <param name="terminalName">Name of the terminal.</param>
        /// <param name="columns">The columns.</param>
        /// <param name="rows">The rows.</param>
        /// <param name="width">The width.</param>
        /// <param name="height">The height.</param>
        /// <param name="terminalModes">The terminal mode.</param>
        /// <param name="bufferSize">Size of the internal read buffer.</param>
        /// <returns>
        /// Returns a representation of a <see cref="Shell" /> object.
        /// </returns>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        public Shell CreateShell(Encoding encoding, string input, Stream output, Stream extendedOutput, string terminalName, uint columns, uint rows, uint width, uint height, IDictionary<TerminalModes, uint> terminalModes, int bufferSize)
        {
            //OneCodeTODO let shell dispose of input stream when we own the stream!

            _inputStream = new MemoryStream();
            var writer = new StreamWriter(_inputStream, encoding);
            writer.Write(input);
            writer.Flush();
            _inputStream.Seek(0, SeekOrigin.Begin);

            return CreateShell(_inputStream, output, extendedOutput, terminalName, columns, rows, width, height, terminalModes, bufferSize);
        }

        /// <summary>
        /// Creates the shell.
        /// </summary>
        /// <param name="encoding">The encoding.</param>
        /// <param name="input">The input.</param>
        /// <param name="output">The output.</param>
        /// <param name="extendedOutput">The extended output.</param>
        /// <param name="terminalName">Name of the terminal.</param>
        /// <param name="columns">The columns.</param>
        /// <param name="rows">The rows.</param>
        /// <param name="width">The width.</param>
        /// <param name="height">The height.</param>
        /// <param name="terminalModes">The terminal modes.</param>
        /// <returns>
        /// Returns a representation of a <see cref="Shell" /> object.
        /// </returns>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        public Shell CreateShell(Encoding encoding, string input, Stream output, Stream extendedOutput, string terminalName, uint columns, uint rows, uint width, uint height, IDictionary<TerminalModes, uint> terminalModes)
        {
            return CreateShell(encoding, input, output, extendedOutput, terminalName, columns, rows, width, height, terminalModes, 1024);
        }

        /// <summary>
        /// Creates the shell.
        /// </summary>
        /// <param name="encoding">The encoding.</param>
        /// <param name="input">The input.</param>
        /// <param name="output">The output.</param>
        /// <param name="extendedOutput">The extended output.</param>
        /// <returns>
        /// Returns a representation of a <see cref="Shell" /> object.
        /// </returns>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        public Shell CreateShell(Encoding encoding, string input, Stream output, Stream extendedOutput)
        {
            return CreateShell(encoding, input, output, extendedOutput, string.Empty, 0, 0, 0, 0, null, 1024);
        }

        /// <summary>
        /// Creates the shell stream.
        /// </summary>
        /// <param name="terminalName">Name of the terminal.</param>
        /// <param name="columns">The columns.</param>
        /// <param name="rows">The rows.</param>
        /// <param name="width">The width.</param>
        /// <param name="height">The height.</param>
        /// <param name="bufferSize">Size of the buffer.</param>
        /// <returns>
        /// Reference to Created ShellStream object.
        /// </returns>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        public ShellStream CreateShellStream(string terminalName, uint columns, uint rows, uint width, uint height, int bufferSize)
        {
            return CreateShellStream(terminalName, columns, rows, width, height, bufferSize, null);
        }

        /// <summary>
        /// Creates the shell stream.
        /// </summary>
        /// <param name="terminalName">Name of the terminal.</param>
        /// <param name="columns">The columns.</param>
        /// <param name="rows">The rows.</param>
        /// <param name="width">The width.</param>
        /// <param name="height">The height.</param>
        /// <param name="bufferSize">Size of the buffer.</param>
        /// <param name="terminalModeValues">The terminal mode values.</param>
        /// <returns>
        /// Reference to Created ShellStream object.
        /// </returns>
        /// <exception cref="SshConnectionException">Client is not connected.</exception>
        public ShellStream CreateShellStream(string terminalName, uint columns, uint rows, uint width, uint height, int bufferSize, IDictionary<TerminalModes, uint> terminalModeValues)
        {
            EnsureSessionIsOpen();

            return new ShellStream(Session, terminalName, columns, rows, width, height, bufferSize, terminalModeValues);
        }

        /// <summary>
        /// Stops forwarded ports.
        /// </summary>
        protected override void OnDisconnected()
        {
            base.OnDisconnected();

            for (var i = _forwardedPorts.Count - 1; i >= 0; i--)
            {
                var port = _forwardedPorts[i];
                DetachForwardedPort(port);
                _forwardedPorts.RemoveAt(i);
            }
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);

            if (!_isDisposed)
            {
                if (disposing)
                {
                    if (_inputStream != null)
                    {
                        _inputStream.Dispose();
                        _inputStream = null;
                    }
                }
            }

            _isDisposed = true;
        }

        private void EnsureSessionIsOpen()
        {
            if (Session == null)
                throw new SshConnectionException("Client not connected.");
        }
    }
}

#endif
// file ...\X\Renci.SshNet\SshCommand.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Represents SSH command that can be executed.
    /// </summary>
    public partial class SshCommand : IDisposable
    {
        private readonly ISession _session;
        private readonly Encoding _encoding;

        private IChannelSession _channel;

        private CommandAsyncResult _asyncResult;

        private AsyncCallback _callback;

        private EventWaitHandle _sessionErrorOccuredWaitHandle = new AutoResetEvent(false);

        private Exception _exception;

        private bool _hasError;

        private readonly object _endExecuteLock = new object();

        /// <summary>
        /// Gets the command text.
        /// </summary>
        public string CommandText { get; private set; }

        /// <summary>
        /// Gets or sets the command timeout.
        /// </summary>
        /// <value>
        /// The command timeout.
        /// </value>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshCommandTest.cs" region="Example SshCommand CreateCommand Execute CommandTimeout" language="C#" title="Specify command execution timeout" />
        /// </example>
        public TimeSpan CommandTimeout { get; set; }

        /// <summary>
        /// Gets the command exit status.
        /// </summary>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshCommandTest.cs" region="Example SshCommand RunCommand ExitStatus" language="C#" title="Get command execution exit status" />
        /// </example>
        public int ExitStatus { get; private set; }

        /// <summary>
        /// Gets the output stream.
        /// </summary>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshCommandTest.cs" region="Example SshCommand CreateCommand Execute OutputStream" language="C#" title="Use OutputStream to get command execution output" />
        /// </example>
        public Stream OutputStream { get; private set; }

        /// <summary>
        /// Gets the extended output stream.
        /// </summary>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshCommandTest.cs" region="Example SshCommand CreateCommand Execute ExtendedOutputStream" language="C#" title="Use ExtendedOutputStream to get command debug execution output" />
        /// </example>
        public Stream ExtendedOutputStream { get; private set; }

        private StringBuilder _result;
        /// <summary>
        /// Gets the command execution result.
        /// </summary>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshCommandTest.cs" region="Example SshCommand RunCommand Result" language="C#" title="Running simple command" />
        /// </example>
        public string Result
        {
            get
            {
                if (this._result == null)
                {
                    this._result = new StringBuilder();
                }

                if (this.OutputStream != null && this.OutputStream.Length > 0)
                {
                    using (var sr = new StreamReader(this.OutputStream, _encoding))
                    {
                        this._result.Append(sr.ReadToEnd());
                    }
                }

                return this._result.ToString();
            }
        }

        private StringBuilder _error;
        /// <summary>
        /// Gets the command execution error.
        /// </summary>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshCommandTest.cs" region="Example SshCommand CreateCommand Error" language="C#" title="Display command execution error" />
        /// </example>
        public string Error
        {
            get
            {
                if (this._hasError)
                {
                    if (this._error == null)
                    {
                        this._error = new StringBuilder();
                    }

                    if (this.ExtendedOutputStream != null && this.ExtendedOutputStream.Length > 0)
                    {
                        using (var sr = new StreamReader(this.ExtendedOutputStream, _encoding))
                        {
                            this._error.Append(sr.ReadToEnd());
                        }
                    }

                    return this._error.ToString();
                }
                return string.Empty;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshCommand"/> class.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="commandText">The command text.</param>
        /// <param name="encoding">The encoding to use for the results.</param>
        /// <exception cref="ArgumentNullException">Either <paramref name="session"/>, <paramref name="commandText"/> is null.</exception>
        internal SshCommand(ISession session, string commandText, Encoding encoding)
        {
            if (session == null)
                throw new ArgumentNullException("session");
            if (commandText == null)
                throw new ArgumentNullException("commandText");
            if (encoding == null)
                throw new ArgumentNullException("encoding");

            this._session = session;
            this.CommandText = commandText;
            this._encoding = encoding;
            this.CommandTimeout = new TimeSpan(0, 0, 0, 0, -1);

            this._session.Disconnected += Session_Disconnected;
            this._session.ErrorOccured += Session_ErrorOccured;
        }

        /// <summary>
        /// Begins an asynchronous command execution.
        /// </summary>
        /// <returns>
        /// An <see cref="System.IAsyncResult" /> that represents the asynchronous command execution, which could still be pending.
        /// </returns>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshCommandTest.cs" region="Example SshCommand CreateCommand BeginExecute IsCompleted EndExecute" language="C#" title="Asynchronous Command Execution" />
        /// </example>
        /// <exception cref="System.InvalidOperationException">Asynchronous operation is already in progress.</exception>
        /// <exception cref="SshException">Invalid operation.</exception>
        /// <exception cref="System.ArgumentException">CommandText property is empty.</exception>
        /// <exception cref="Renci.SshNet.Common.SshConnectionException">Client is not connected.</exception>
        /// <exception cref="Renci.SshNet.Common.SshOperationTimeoutException">Operation has timed out.</exception>
        /// <exception cref="InvalidOperationException">Asynchronous operation is already in progress.</exception>
        /// <exception cref="ArgumentException">CommandText property is empty.</exception>
        public IAsyncResult BeginExecute()
        {
            return this.BeginExecute(null, null);
        }

        /// <summary>
        /// Begins an asynchronous command execution.
        /// </summary>
        /// <param name="callback">An optional asynchronous callback, to be called when the command execution is complete.</param>
        /// <returns>
        /// An <see cref="System.IAsyncResult" /> that represents the asynchronous command execution, which could still be pending.
        /// </returns>
        /// <exception cref="System.InvalidOperationException">Asynchronous operation is already in progress.</exception>
        /// <exception cref="SshException">Invalid operation.</exception>
        /// <exception cref="System.ArgumentException">CommandText property is empty.</exception>
        /// <exception cref="Renci.SshNet.Common.SshConnectionException">Client is not connected.</exception>
        /// <exception cref="Renci.SshNet.Common.SshOperationTimeoutException">Operation has timed out.</exception>
        /// <exception cref="InvalidOperationException">Asynchronous operation is already in progress.</exception>
        /// <exception cref="ArgumentException">CommandText property is empty.</exception>
        public IAsyncResult BeginExecute(AsyncCallback callback)
        {
            return this.BeginExecute(callback, null);
        }

        /// <summary>
        /// Begins an asynchronous command execution.
        /// </summary>
        /// <param name="callback">An optional asynchronous callback, to be called when the command execution is complete.</param>
        /// <param name="state">A user-provided object that distinguishes this particular asynchronous read request from other requests.</param>
        /// <returns>
        /// An <see cref="System.IAsyncResult" /> that represents the asynchronous command execution, which could still be pending.
        /// </returns>
        /// <exception cref="System.InvalidOperationException">Asynchronous operation is already in progress.</exception>
        /// <exception cref="SshException">Invalid operation.</exception>
        /// <exception cref="System.ArgumentException">CommandText property is empty.</exception>
        /// <exception cref="Renci.SshNet.Common.SshConnectionException">Client is not connected.</exception>
        /// <exception cref="Renci.SshNet.Common.SshOperationTimeoutException">Operation has timed out.</exception>
        /// <exception cref="InvalidOperationException">Asynchronous operation is already in progress.</exception>
        /// <exception cref="ArgumentException">CommandText property is empty.</exception>
        public IAsyncResult BeginExecute(AsyncCallback callback, object state)
        {
            //  Prevent from executing BeginExecute before calling EndExecute
            if (this._asyncResult != null)
            {
                throw new InvalidOperationException("Asynchronous operation is already in progress.");
            }

            //  Create new AsyncResult object
            this._asyncResult = new CommandAsyncResult
            {
                AsyncWaitHandle = new ManualResetEvent(false),
                IsCompleted = false,
                AsyncState = state,
            };

            //  When command re-executed again, create a new channel
            if (this._channel != null)
            {
                throw new SshException("Invalid operation.");
            }

            this.CreateChannel();

            if (string.IsNullOrEmpty(this.CommandText))
                throw new ArgumentException("CommandText property is empty.");

            this._callback = callback;

            this._channel.Open();

            //  Send channel command request
            this._channel.SendExecRequest(this.CommandText);

            return _asyncResult;
        }

        /// <summary>
        /// Begins an asynchronous command execution.
        /// </summary>
        /// <param name="commandText">The command text.</param>
        /// <param name="callback">An optional asynchronous callback, to be called when the command execution is complete.</param>
        /// <param name="state">A user-provided object that distinguishes this particular asynchronous read request from other requests.</param>
        /// <returns>
        /// An <see cref="System.IAsyncResult" /> that represents the asynchronous command execution, which could still be pending.
        /// </returns>
        /// <exception cref="Renci.SshNet.Common.SshConnectionException">Client is not connected.</exception>
        /// <exception cref="Renci.SshNet.Common.SshOperationTimeoutException">Operation has timed out.</exception>
        public IAsyncResult BeginExecute(string commandText, AsyncCallback callback, object state)
        {
            this.CommandText = commandText;

            return BeginExecute(callback, state);
        }

        /// <summary>
        /// Waits for the pending asynchronous command execution to complete.
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous request to finish.</param>
        /// <returns>Command execution result.</returns>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshCommandTest.cs" region="Example SshCommand CreateCommand BeginExecute IsCompleted EndExecute" language="C#" title="Asynchronous Command Execution" />
        /// </example>
        /// <exception cref="ArgumentException">Either the IAsyncResult object did not come from the corresponding async method on this type, or EndExecute was called multiple times with the same IAsyncResult.</exception>
        public string EndExecute(IAsyncResult asyncResult)
        {
            if (this._asyncResult == asyncResult && this._asyncResult != null)
            {
                lock (this._endExecuteLock)
                {
                    if (this._asyncResult != null)
                    {
                        //  Make sure that operation completed if not wait for it to finish
                        this.WaitOnHandle(this._asyncResult.AsyncWaitHandle);

                        if (_channel.IsOpen)
                        {
                            _channel.Close();
                        }

                        UnsubscribeFromEventsAndDisposeChannel();
                        _channel = null;

                        _asyncResult = null;

                        return this.Result;
                    }
                }
            }

            throw new ArgumentException("Either the IAsyncResult object did not come from the corresponding async method on this type, or EndExecute was called multiple times with the same IAsyncResult.");
        }

        /// <summary>
        /// Executes command specified by <see cref="CommandText"/> property.
        /// </summary>
        /// <returns>Command execution result</returns>
        /// <example>
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshCommandTest.cs" region="Example SshCommand CreateCommand Execute" language="C#" title="Simple command execution" />
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshCommandTest.cs" region="Example SshCommand CreateCommand Error" language="C#" title="Display command execution error" />
        ///     <code source="..\..\Renci.SshNet.Tests\Classes\SshCommandTest.cs" region="Example SshCommand CreateCommand Execute CommandTimeout" language="C#" title="Specify command execution timeout" />
        /// </example>
        /// <exception cref="Renci.SshNet.Common.SshConnectionException">Client is not connected.</exception>
        /// <exception cref="Renci.SshNet.Common.SshOperationTimeoutException">Operation has timed out.</exception>
        public string Execute()
        {
            return this.EndExecute(this.BeginExecute(null, null));
        }

        /// <summary>
        /// Cancels command execution in asynchronous scenarios. 
        /// </summary>
        public void CancelAsync()
        {
            if (this._channel != null && this._channel.IsOpen && this._asyncResult != null)
            {
                // TO-DO: check with Oleg if we shouldn't dispose the channel and uninitialize it ?
                this._channel.Close();
            }
        }

        /// <summary>
        /// Executes the specified command text.
        /// </summary>
        /// <param name="commandText">The command text.</param>
        /// <returns>Command execution result</returns>
        /// <exception cref="Renci.SshNet.Common.SshConnectionException">Client is not connected.</exception>
        /// <exception cref="Renci.SshNet.Common.SshOperationTimeoutException">Operation has timed out.</exception>
        public string Execute(string commandText)
        {
            this.CommandText = commandText;

            return this.Execute();
        }

        private void CreateChannel()
        {
            this._channel = this._session.CreateChannelSession();
            this._channel.DataReceived += Channel_DataReceived;
            this._channel.ExtendedDataReceived += Channel_ExtendedDataReceived;
            this._channel.RequestReceived += Channel_RequestReceived;
            this._channel.Closed += Channel_Closed;

            //  Dispose of streams if already exists
            if (this.OutputStream != null)
            {
                this.OutputStream.Dispose();
                this.OutputStream = null;
            }

            if (this.ExtendedOutputStream != null)
            {
                this.ExtendedOutputStream.Dispose();
                this.ExtendedOutputStream = null;
            }

            //  Initialize output streams and StringBuilders
            this.OutputStream = new PipeStream();
            this.ExtendedOutputStream = new PipeStream();

            this._result = null;
            this._error = null;
        }

        private void Session_Disconnected(object sender, EventArgs e)
        {
            //  If objected is disposed or being disposed don't handle this event
            if (this._isDisposed)
                return;

            this._exception = new SshConnectionException("An established connection was aborted by the software in your host machine.", DisconnectReason.ConnectionLost);

            this._sessionErrorOccuredWaitHandle.Set();
        }

        private void Session_ErrorOccured(object sender, ExceptionEventArgs e)
        {
            //  If objected is disposed or being disposed don't handle this event
            if (this._isDisposed)
                return;

            this._exception = e.Exception;

            this._sessionErrorOccuredWaitHandle.Set();
        }

        private void Channel_Closed(object sender, ChannelEventArgs e)
        {
            if (this.OutputStream != null)
            {
                this.OutputStream.Flush();
            }

            if (this.ExtendedOutputStream != null)
            {
                this.ExtendedOutputStream.Flush();
            }

            this._asyncResult.IsCompleted = true;

            if (this._callback != null)
            {
                //  Execute callback on different thread
                this.ExecuteThread(() => this._callback(this._asyncResult));
            }
            ((EventWaitHandle)this._asyncResult.AsyncWaitHandle).Set();
        }

        private void Channel_RequestReceived(object sender, ChannelRequestEventArgs e)
        {
            MessageRenci replyMessage;

            if (e.Info is ExitStatusRequestInfo)
            {
                var exitStatusInfo = e.Info as ExitStatusRequestInfo;

                this.ExitStatus = (int)exitStatusInfo.ExitStatus;

                replyMessage = new ChannelSuccessMessage(this._channel.LocalChannelNumber);
            }
            else
            {
                replyMessage = new ChannelFailureMessage(this._channel.LocalChannelNumber);
            }

            if (e.Info.WantReply)
            {
                this._session.SendMessage(replyMessage);
            }
        }

        private void Channel_ExtendedDataReceived(object sender, ChannelDataEventArgs e)
        {
            if (this.ExtendedOutputStream != null)
            {
                this.ExtendedOutputStream.Write(e.Data, 0, e.Data.Length);
                this.ExtendedOutputStream.Flush();
            }

            if (e.DataTypeCode == 1)
            {
                this._hasError = true;
            }
        }

        private void Channel_DataReceived(object sender, ChannelDataEventArgs e)
        {
            if (this.OutputStream != null)
            {
                this.OutputStream.Write(e.Data, 0, e.Data.Length);
                this.OutputStream.Flush();
            }

            if (this._asyncResult != null)
            {
                lock (this._asyncResult)
                {
                    this._asyncResult.BytesReceived += e.Data.Length;
                }
            }
        }

        /// <exception cref="SshOperationTimeoutException">Command '{0}' has timed out.</exception>
        /// <remarks>The actual command will be included in the exception message.</remarks>
        private void WaitOnHandle(WaitHandle waitHandle)
        {
            var waitHandles = new[]
                {
                    this._sessionErrorOccuredWaitHandle,
                    waitHandle
                };

            switch (WaitHandle.WaitAny(waitHandles, this.CommandTimeout))
            {
                case 0:
                    throw this._exception;
                case WaitHandle.WaitTimeout:
                    throw new SshOperationTimeoutException(string.Format(CultureInfo.CurrentCulture, "Command '{0}' has timed out.", this.CommandText));
            }
        }

        private void UnsubscribeFromEventsAndDisposeChannel()
        {
            // unsubscribe from events as we do not want to be signaled should these get fired
            // during the dispose of the channel
            _channel.DataReceived -= Channel_DataReceived;
            _channel.ExtendedDataReceived -= Channel_ExtendedDataReceived;
            _channel.RequestReceived -= Channel_RequestReceived;
            _channel.Closed -= Channel_Closed;

            // actually dispose the channel
            _channel.Dispose();
        }

        partial void ExecuteThread(Action action);

        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged ResourceMessages.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!this._isDisposed)
            {
                // If disposing equals true, dispose all managed
                // and unmanaged ResourceMessages.
                if (disposing)
                {
                    this._session.Disconnected -= Session_Disconnected;
                    this._session.ErrorOccured -= Session_ErrorOccured;

                    // Dispose managed ResourceMessages.
                    if (this.OutputStream != null)
                    {
                        this.OutputStream.Dispose();
                        this.OutputStream = null;
                    }

                    // Dispose managed ResourceMessages.
                    if (this.ExtendedOutputStream != null)
                    {
                        this.ExtendedOutputStream.Dispose();
                        this.ExtendedOutputStream = null;
                    }

                    // Dispose managed ResourceMessages.
                    if (this._sessionErrorOccuredWaitHandle != null)
                    {
                        this._sessionErrorOccuredWaitHandle.Dispose();
                        this._sessionErrorOccuredWaitHandle = null;
                    }

                    // Dispose managed ResourceMessages.
                    if (this._channel != null)
                    {
                        UnsubscribeFromEventsAndDisposeChannel();
                        this._channel = null;
                    }
                }

                // Note disposing has been done.
                this._isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="SshCommand"/> is reclaimed by garbage collection.
        /// </summary>
        ~SshCommand()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\SshCommand.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Represents SSH command that can be executed.
    /// </summary>
    public partial class SshCommand 
    {
        /// <summary>
        /// Executes the specified action in a separate thread.
        /// </summary>
        /// <param name="action">The action to execute.</param>
        partial void ExecuteThread(Action action)
        {
            ThreadPool.QueueUserWorkItem(o => action());
        }
    }
}

#endif
// file ...\X\Renci.SshNet\SubsystemSession.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Base class for SSH subsystem implementations
    /// </summary>
    public abstract class SubsystemSession : ISubsystemSession
    {
        private ISession _session;
        private readonly string _subsystemName;
        private IChannelSession _channel;
        private Exception _exception;
        private EventWaitHandle _errorOccuredWaitHandle = new ManualResetEvent(false);
        private EventWaitHandle _sessionDisconnectedWaitHandle = new ManualResetEvent(false);
        private EventWaitHandle _channelClosedWaitHandle = new ManualResetEvent(false);

        /// <summary>
        /// Specifies a timeout to wait for operation to complete
        /// </summary>
        protected TimeSpan OperationTimeout { get; private set; }

        /// <summary>
        /// Occurs when an error occurred.
        /// </summary>
        public event EventHandler<ExceptionEventArgs> ErrorOccurred;

        /// <summary>
        /// Occurs when the server has disconnected from the session.
        /// </summary>
        public event EventHandler<EventArgs> Disconnected;

        /// <summary>
        /// Gets the channel associated with this session.
        /// </summary>
        /// <value>
        /// The channel associated with this session.
        /// </value>
        internal IChannelSession Channel
        {
            get
            {
                EnsureNotDisposed();

                return _channel;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this session is open.
        /// </summary>
        /// <value>
        /// <c>true</c> if this session is open; otherwise, <c>false</c>.
        /// </value>
        public bool IsOpen
        {
            get { return _channel != null && _channel.IsOpen; }
        }

        /// <summary>
        /// Gets the character encoding to use.
        /// </summary>
        protected Encoding Encoding { get; private set; }

        /// <summary>
        /// Initializes a new instance of the SubsystemSession class.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="subsystemName">Name of the subsystem.</param>
        /// <param name="operationTimeout">The operation timeout.</param>
        /// <param name="encoding">The character encoding to use.</param>
        /// <exception cref="ArgumentNullException"><paramref name="session" /> or <paramref name="subsystemName" /> or <paramref name="encoding"/>is null.</exception>
        protected SubsystemSession(ISession session, string subsystemName, TimeSpan operationTimeout, Encoding encoding)
        {
            if (session == null)
                throw new ArgumentNullException("session");
            if (subsystemName == null)
                throw new ArgumentNullException("subsystemName");
            if (encoding == null)
                throw new ArgumentNullException("encoding");

            _session = session;
            _subsystemName = subsystemName;
            OperationTimeout = operationTimeout;
            Encoding = encoding;
        }

        /// <summary>
        /// Connects the subsystem using a new SSH channel session.
        /// </summary>
        /// <exception cref="InvalidOperationException">The session is already connected.</exception>
        /// <exception cref="ObjectDisposedException">The method was called after the session was disposed.</exception>
        public void Connect()
        {
            EnsureNotDisposed();

            if (IsOpen)
                throw new InvalidOperationException("The session is already connected.");

            // reset waithandles in case we're reconnecting
            _errorOccuredWaitHandle.Reset();
            _sessionDisconnectedWaitHandle.Reset();
            _sessionDisconnectedWaitHandle.Reset();
            _channelClosedWaitHandle.Reset();

            _session.ErrorOccured += Session_ErrorOccured;
            _session.Disconnected += Session_Disconnected;

            _channel = _session.CreateChannelSession();
            _channel.DataReceived += Channel_DataReceived;
            _channel.Exception += Channel_Exception;
            _channel.Closed += Channel_Closed;
            _channel.Open();
            _channel.SendSubsystemRequest(_subsystemName);

            OnChannelOpen();
        }

        /// <summary>
        /// Disconnects the subsystem channel.
        /// </summary>
        public void Disconnect()
        {
            if (_session != null)
            {
                _session.ErrorOccured -= Session_ErrorOccured;
                _session.Disconnected -= Session_Disconnected;
            }

            if (_channel != null)
            {
                _channel.DataReceived -= Channel_DataReceived;
                _channel.Exception -= Channel_Exception;
                _channel.Closed -= Channel_Closed;
                _channel.Close();
                _channel.Dispose();
                _channel = null;
            }
        }

        /// <summary>
        /// Sends data to the subsystem.
        /// </summary>
        /// <param name="data">The data to be sent.</param>
        public void SendData(byte[] data)
        {
            EnsureNotDisposed();
            EnsureSessionIsOpen();

            _channel.SendData(data);
        }

        /// <summary>
        /// Called when channel is open.
        /// </summary>
        protected abstract void OnChannelOpen();

        /// <summary>
        /// Called when data is received.
        /// </summary>
        /// <param name="dataTypeCode">The data type code.</param>
        /// <param name="data">The data.</param>
        protected abstract void OnDataReceived(uint dataTypeCode, byte[] data);

        /// <summary>
        /// Raises the error.
        /// </summary>
        /// <param name="error">The error.</param>
        protected void RaiseError(Exception error)
        {
            _exception = error;

            var errorOccuredWaitHandle = _errorOccuredWaitHandle;
            if (errorOccuredWaitHandle != null)
                errorOccuredWaitHandle.Set();

            SignalErrorOccurred(error);
        }

        private void Channel_DataReceived(object sender, ChannelDataEventArgs e)
        {
            try
            {
                OnDataReceived(e.DataTypeCode, e.Data);
            }
            catch (Exception ex)
            {
                RaiseError(ex);
            }
        }

        private void Channel_Exception(object sender, ExceptionEventArgs e)
        {
            RaiseError(e.Exception);
        }

        private void Channel_Closed(object sender, ChannelEventArgs e)
        {
            var channelClosedWaitHandle = _channelClosedWaitHandle;
            if (channelClosedWaitHandle != null)
                channelClosedWaitHandle.Set();
        }

        /// <summary>
        /// Waits a specified time for a given <see cref="WaitHandle"/> to get signaled.
        /// </summary>
        /// <param name="waitHandle">The handle to wait for.</param>
        /// <param name="operationTimeout">The time to wait for <paramref name="waitHandle"/> to get signaled.</param>
        /// <exception cref="SshException">The connection was closed by the server.</exception>
        /// <exception cref="SshException">The channel was closed.</exception>
        /// <exception cref="SshOperationTimeoutException">The handle did not get signaled within the specified <paramref name="operationTimeout"/>.</exception>
        public void WaitOnHandle(WaitHandle waitHandle, TimeSpan operationTimeout)
        {
            var waitHandles = new[]
                {
                    _errorOccuredWaitHandle,
                    _sessionDisconnectedWaitHandle,
                    _channelClosedWaitHandle,
                    waitHandle
                };

            switch (WaitHandle.WaitAny(waitHandles, operationTimeout))
            {
                case 0:
                    throw _exception;
                case 1:
                    throw new SshException("Connection was closed by the server.");
                case 2:
                    throw new SshException("Channel was closed.");
                case WaitHandle.WaitTimeout:
                    throw new SshOperationTimeoutException(string.Format(CultureInfo.CurrentCulture, "Operation has timed out."));
            }
        }

        private void Session_Disconnected(object sender, EventArgs e)
        {
            var sessionDisconnectedWaitHandle = _sessionDisconnectedWaitHandle;
            if (sessionDisconnectedWaitHandle != null)
                sessionDisconnectedWaitHandle.Set();

            SignalDisconnected();
        }

        private void Session_ErrorOccured(object sender, ExceptionEventArgs e)
        {
            RaiseError(e.Exception);
        }

        private void SignalErrorOccurred(Exception error)
        {
            var errorOccurred = ErrorOccurred;
            if (errorOccurred != null)
            {
                errorOccurred(this, new ExceptionEventArgs(error));
            }
        }

        private void SignalDisconnected()
        {
            var disconnected = Disconnected;
            if (disconnected != null)
            {
                disconnected(this, new EventArgs());
            }
        }

        private void EnsureSessionIsOpen()
        {
            if (!IsOpen)
                throw new InvalidOperationException("The session is not open.");
        }

        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!_isDisposed)
            {
                if (disposing)
                {
                    Disconnect();

                    _session = null;

                    if (_errorOccuredWaitHandle != null)
                    {
                        _errorOccuredWaitHandle.Dispose();
                        _errorOccuredWaitHandle = null;
                    }

                    if (_sessionDisconnectedWaitHandle != null)
                    {
                        _sessionDisconnectedWaitHandle.Dispose();
                        _sessionDisconnectedWaitHandle = null;
                    }

                    if (_channelClosedWaitHandle != null)
                    {
                        _channelClosedWaitHandle.Dispose();
                        _channelClosedWaitHandle = null;
                    }
                }

                _isDisposed = true;
            }
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="SubsystemSession" /> class.
        /// </summary>
        ~SubsystemSession()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        private void EnsureNotDisposed()
        {
            if (_isDisposed)
                throw new ObjectDisposedException(GetType().FullName);
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\Channels\Channel.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Channels
{
    /// <summary>
    /// Represents base class for SSH channel implementations.
    /// </summary>
    public abstract class Channel : IChannel
    {
        private const int Initial = 0;
        private const int Considered = 1;
        private const int Sent = 2;

        private EventWaitHandle _channelClosedWaitHandle = new ManualResetEvent(false);
        private EventWaitHandle _channelServerWindowAdjustWaitHandle = new ManualResetEvent(false);
        private EventWaitHandle _errorOccuredWaitHandle = new ManualResetEvent(false);
        private readonly object _serverWindowSizeLock = new object();
        private readonly uint _initialWindowSize;
        private uint? _remoteWindowSize;
        private uint? _remoteChannelNumber;
        private uint? _remotePacketSize;
        private ISession _session;

        /// <summary>
        /// Holds a value indicating whether the SSH_MSG_CHANNEL_CLOSE has been sent to the remote party.
        /// </summary>
        /// <value>
        /// <c>0</c> when the SSH_MSG_CHANNEL_CLOSE message has not been sent or considered
        /// <c>1</c> when sending a SSH_MSG_CHANNEL_CLOSE message to the remote party is under consideration
        /// <c>2</c> when this message has been sent to the remote party
        /// </value>
        private int _closeMessageSent;

        /// <summary>
        /// Holds a value indicating whether a SSH_MSG_CHANNEL_CLOSE has been received from the other
        /// party.
        /// </summary>
        /// <value>
        /// <c>true</c> when a SSH_MSG_CHANNEL_CLOSE message has been received from the other party;
        /// otherwise, <c>false</c>.
        /// </value>
        private bool _closeMessageReceived;

        /// <summary>
        /// Holds a value indicating whether the SSH_MSG_CHANNEL_EOF has been received from the other party.
        /// </summary>
        /// <value>
        /// <c>true</c> when a SSH_MSG_CHANNEL_EOF message has been received from the other party;
        /// otherwise, <c>false</c>.
        /// </value>
        private bool _eofMessageReceived;

        /// <summary>
        /// Holds a value indicating whether the SSH_MSG_CHANNEL_EOF has been sent to the remote party.
        /// </summary>
        /// <value>
        /// <c>0</c> when the SSH_MSG_CHANNEL_EOF message has not been sent or considered
        /// <c>1</c> when sending a SSH_MSG_CHANNEL_EOF message to the remote party is under consideration
        /// <c>2</c> when this message has been sent to the remote party
        /// </value>
        private int _eofMessageSent;

        /// <summary>
        /// Occurs when an exception is thrown when processing channel messages.
        /// </summary>
        public event EventHandler<ExceptionEventArgs> Exception;

        /// <summary>
        /// Initializes a new <see cref="Channel"/> instance.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="localChannelNumber">The local channel number.</param>
        /// <param name="localWindowSize">Size of the window.</param>
        /// <param name="localPacketSize">Size of the packet.</param>
        protected Channel(ISession session, uint localChannelNumber, uint localWindowSize, uint localPacketSize)
        {
            _session = session;
            _initialWindowSize = localWindowSize;
            LocalChannelNumber = localChannelNumber;
            LocalPacketSize = localPacketSize;
            LocalWindowSize = localWindowSize;

            _session.ChannelWindowAdjustReceived += OnChannelWindowAdjust;
            _session.ChannelDataReceived += OnChannelData;
            _session.ChannelExtendedDataReceived += OnChannelExtendedData;
            _session.ChannelEofReceived += OnChannelEof;
            _session.ChannelCloseReceived += OnChannelClose;
            _session.ChannelRequestReceived += OnChannelRequest;
            _session.ChannelSuccessReceived += OnChannelSuccess;
            _session.ChannelFailureReceived += OnChannelFailure;
            _session.ErrorOccured += Session_ErrorOccured;
            _session.Disconnected += Session_Disconnected;
        }

        /// <summary>
        /// Gets the session.
        /// </summary>
        /// <value>
        ///  Thhe session.
        /// </value>
        protected ISession Session
        {
            get { return _session; }
        }

        /// <summary>
        /// Gets the type of the channel.
        /// </summary>
        /// <value>
        /// The type of the channel.
        /// </value>
        public abstract ChannelTypes ChannelType { get; }

        /// <summary>
        /// Gets the local channel number.
        /// </summary>
        /// <value>
        /// The local channel number.
        /// </value>
        public uint LocalChannelNumber { get; private set; }

        /// <summary>
        /// Gets the maximum size of a packet.
        /// </summary>
        /// <value>
        /// The maximum size of a packet.
        /// </value>
        public uint LocalPacketSize { get; private set; }

        /// <summary>
        /// Gets the size of the local window.
        /// </summary>
        /// <value>
        /// The size of the local window.
        /// </value>
        public uint LocalWindowSize { get; private set; }

        /// <summary>
        /// Gets the remote channel number.
        /// </summary>
        /// <value>
        /// The remote channel number.
        /// </value>
        public uint RemoteChannelNumber
        {
            get
            {
                if (!_remoteChannelNumber.HasValue)
                    throw CreateRemoteChannelInfoNotAvailableException();
                return _remoteChannelNumber.Value;
            }
            private set
            {
                _remoteChannelNumber = value;
            }
        }

        /// <summary>
        /// Gets the maximum size of a data packet that we can send using the channel.
        /// </summary>
        /// <value>
        /// The maximum size of data that can be sent using a <see cref="ChannelDataMessage"/>
        /// on the current channel.
        /// </value>
        /// <exception cref="InvalidOperationException">The channel has not been opened, or the open has not yet been confirmed.</exception>
        public uint RemotePacketSize
        {
            get
            {
                if (!_remotePacketSize.HasValue)
                    throw CreateRemoteChannelInfoNotAvailableException();
                return _remotePacketSize.Value;
            }
            private set
            {
                _remotePacketSize = value;
            }
        }

        /// <summary>
        /// Gets the window size of the remote server.
        /// </summary>
        /// <value>
        /// The size of the server window.
        /// </value>
        public uint RemoteWindowSize
        {
            get
            {
                if (!_remoteWindowSize.HasValue)
                    throw CreateRemoteChannelInfoNotAvailableException();
                return _remoteWindowSize.Value;
            }
            private set
            {
                _remoteWindowSize = value;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this channel is open.
        /// </summary>
        /// <value>
        /// <c>true</c> if this channel is open; otherwise, <c>false</c>.
        /// </value>
        public bool IsOpen { get; protected set; }

        #region Message events

        /// <summary>
        /// Occurs when <see cref="ChannelDataMessage"/> message received
        /// </summary>
        public event EventHandler<ChannelDataEventArgs> DataReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelExtendedDataMessage"/> message received
        /// </summary>
        public event EventHandler<ChannelDataEventArgs> ExtendedDataReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelEofMessage"/> message received
        /// </summary>
        public event EventHandler<ChannelEventArgs> EndOfData;

        /// <summary>
        /// Occurs when <see cref="ChannelCloseMessage"/> message received
        /// </summary>
        public event EventHandler<ChannelEventArgs> Closed;

        /// <summary>
        /// Occurs when <see cref="ChannelRequestMessage"/> message received
        /// </summary>
        public event EventHandler<ChannelRequestEventArgs> RequestReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelSuccessMessage"/> message received
        /// </summary>
        public event EventHandler<ChannelEventArgs> RequestSucceeded;

        /// <summary>
        /// Occurs when <see cref="ChannelFailureMessage"/> message received
        /// </summary>
        public event EventHandler<ChannelEventArgs> RequestFailed;

        #endregion

        /// <summary>
        /// Gets a value indicating whether the session is connected.
        /// </summary>
        /// <value>
        /// <c>true</c> if the session is connected; otherwise, <c>false</c>.
        /// </value>
        protected bool IsConnected
        {
            get { return _session.IsConnected; }
        }

        /// <summary>
        /// Gets the connection info.
        /// </summary>
        /// <value>The connection info.</value>
        protected IConnectionInfo ConnectionInfo
        {
            get { return _session.ConnectionInfo; }
        }

        /// <summary>
        /// Gets the session semaphore to control number of session channels
        /// </summary>
        /// <value>The session semaphore.</value>
        protected SemaphoreLight SessionSemaphore
        {
            get { return _session.SessionSemaphore; }
        }

        protected void InitializeRemoteInfo(uint remoteChannelNumber, uint remoteWindowSize, uint remotePacketSize)
        {
            RemoteChannelNumber = remoteChannelNumber;
            RemoteWindowSize = remoteWindowSize;
            RemotePacketSize = remotePacketSize;
        }

        /// <summary>
        /// Sends a SSH_MSG_CHANNEL_DATA message with the specified payload.
        /// </summary>
        /// <param name="data">The payload to send.</param>
        public void SendData(byte[] data)
        {
            SendMessage(new ChannelDataMessage(RemoteChannelNumber, data));
        }

        /// <summary>
        /// Closes the channel.
        /// </summary>
        public void Close()
        {
            Close(true);
        }

        #region Channel virtual methods

        /// <summary>
        /// Called when channel window need to be adjust.
        /// </summary>
        /// <param name="bytesToAdd">The bytes to add.</param>
        protected virtual void OnWindowAdjust(uint bytesToAdd)
        {
            lock (_serverWindowSizeLock)
            {
                RemoteWindowSize += bytesToAdd;
            }
            _channelServerWindowAdjustWaitHandle.Set();
        }

        /// <summary>
        /// Called when channel data is received.
        /// </summary>
        /// <param name="data">The data.</param>
        protected virtual void OnData(byte[] data)
        {
            AdjustDataWindow(data);

            var dataReceived = DataReceived;
            if (dataReceived != null)
                dataReceived(this, new ChannelDataEventArgs(LocalChannelNumber, data));
        }

        /// <summary>
        /// Called when channel extended data is received.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <param name="dataTypeCode">The data type code.</param>
        protected virtual void OnExtendedData(byte[] data, uint dataTypeCode)
        {
            AdjustDataWindow(data);

            var extendedDataReceived = ExtendedDataReceived;
            if (extendedDataReceived != null)
                extendedDataReceived(this, new ChannelDataEventArgs(LocalChannelNumber, data, dataTypeCode));
        }

        /// <summary>
        /// Called when channel has no more data to receive.
        /// </summary>
        protected virtual void OnEof()
        {
            _eofMessageReceived = true;

            var endOfData = EndOfData;
            if (endOfData != null)
                endOfData(this, new ChannelEventArgs(LocalChannelNumber));
        }

        /// <summary>
        /// Called when channel is closed by the server.
        /// </summary>
        protected virtual void OnClose()
        {
            _closeMessageReceived = true;

            // close the channel
            Close(false);

            var closed = Closed;
            if (closed != null)
                closed(this, new ChannelEventArgs(LocalChannelNumber));
        }

        /// <summary>
        /// Called when channel request received.
        /// </summary>
        /// <param name="info">Channel request information.</param>
        protected virtual void OnRequest(RequestInfo info)
        {
            var requestReceived = RequestReceived;
            if (requestReceived != null)
                requestReceived(this, new ChannelRequestEventArgs(info));
        }

        /// <summary>
        /// Called when channel request was successful
        /// </summary>
        protected virtual void OnSuccess()
        {
            var requestSuccessed = RequestSucceeded;
            if (requestSuccessed != null)
                requestSuccessed(this, new ChannelEventArgs(LocalChannelNumber));
        }

        /// <summary>
        /// Called when channel request failed.
        /// </summary>
        protected virtual void OnFailure()
        {
            var requestFailed = RequestFailed;
            if (requestFailed != null)
                requestFailed(this, new ChannelEventArgs(LocalChannelNumber));
        }

        #endregion

        /// <summary>
        /// Raises <see cref="Channel.Exception"/> event.
        /// </summary>
        /// <param name="exception">The exception.</param>
        protected void RaiseExceptionEvent(Exception exception)
        {
            var handlers = Exception;
            if (handlers != null)
            {
                handlers(this, new ExceptionEventArgs(exception));
            }
        }

        /// <summary>
        /// Sends a message to the server.
        /// </summary>
        /// <param name="message">The message to send.</param>
        /// <returns>
        /// <c>true</c> if the message was sent to the server; otherwise, <c>false</c>.
        /// </returns>
        /// <exception cref="InvalidOperationException">The size of the packet exceeds the maximum size defined by the protocol.</exception>
        /// <remarks>
        /// This methods returns <c>false</c> when the attempt to send the message results in a
        /// <see cref="SocketException"/> or a <see cref="SshException"/>.
        /// </remarks>
        private bool TrySendMessage(MessageRenci message)
        {
            return _session.TrySendMessage(message);
        }

        /// <summary>
        /// Sends SSH message to the server.
        /// </summary>
        /// <param name="message">The message.</param>
        protected void SendMessage(MessageRenci message)
        {
            // send channel messages only while channel is open
            if (!IsOpen)
                return;

            _session.SendMessage(message);
        }

        /// <summary>
        /// Sends channel data message to the servers.
        /// </summary>
        /// <param name="message">Channel data message.</param>
        /// <remarks>
        /// <para>
        /// When the data of the message exceeds the maximum packet size or the remote window
        /// size does not allow the full message to be sent, then this method will send the
        /// data in multiple chunks and will only wait for the remote window size to be adjusted
        /// when its zero.
        /// </para>
        /// <para>
        /// This is done to support SSH servers will a small window size that do not agressively
        /// increase their window size. We need to take into account that there may be SSH
        /// servers that only increase their window size when it has reached zero.
        /// </para>
        /// </remarks>
        protected void SendMessage(ChannelDataMessage message)
        {
            // send channel messages only while channel is open
            if (!IsOpen)
                return;

            var totalDataLength = message.Data.Length;
            var totalDataSent = 0;

            var totalBytesToSend = totalDataLength;
            while (totalBytesToSend > 0)
            {
                var dataThatCanBeSentInMessage = GetDataLengthThatCanBeSentInMessage(totalBytesToSend);
                if (dataThatCanBeSentInMessage == totalDataLength)
                {
                    // we can send the message in one chunk
                    _session.SendMessage(message);
                }
                else
                {
                    // we need to send the message in multiple chunks
                    var dataToSend = new byte[dataThatCanBeSentInMessage];
                    Array.Copy(message.Data, totalDataSent, dataToSend, 0, dataThatCanBeSentInMessage);
                    _session.SendMessage(new ChannelDataMessage(message.LocalChannelNumber, dataToSend));
                }
                totalDataSent += dataThatCanBeSentInMessage;
                totalBytesToSend -= dataThatCanBeSentInMessage;
            }
        }

        /// <summary>
        /// Sends channel extended data message to the servers.
        /// </summary>
        /// <param name="message">Channel data message.</param>
        /// <remarks>
        /// <para>
        /// When the data of the message exceeds the maximum packet size or the remote window
        /// size does not allow the full message to be sent, then this method will send the
        /// data in multiple chunks and will only wait for the remote window size to be adjusted
        /// when its zero.
        /// </para>
        /// <para>
        /// This is done to support SSH servers will a small window size that do not agressively
        /// increase their window size. We need to take into account that there may be SSH
        /// servers that only increase their window size when it has reached zero.
        /// </para>
        /// </remarks>
        protected void SendMessage(ChannelExtendedDataMessage message)
        {
            // send channel messages only while channel is open
            if (!IsOpen)
                return;

            var totalDataLength = message.Data.Length;
            var totalDataSent = 0;

            var totalBytesToSend = totalDataLength;
            while (totalBytesToSend > 0)
            {
                var dataThatCanBeSentInMessage = GetDataLengthThatCanBeSentInMessage(totalBytesToSend);
                if (dataThatCanBeSentInMessage == totalDataLength)
                {
                    // we can send the message in one chunk
                    _session.SendMessage(message);
                }
                else
                {
                    // we need to send the message in multiple chunks
                    var dataToSend = new byte[dataThatCanBeSentInMessage];
                    Array.Copy(message.Data, totalDataSent, dataToSend, 0, dataThatCanBeSentInMessage);
                    _session.SendMessage(new ChannelExtendedDataMessage(message.LocalChannelNumber,
                        message.DataTypeCode, dataToSend));
                }
                totalDataSent += dataThatCanBeSentInMessage;
                totalBytesToSend -= dataThatCanBeSentInMessage;
            }
        }

        /// <summary>
        /// Waits for the handle to be signaled or for an error to occurs.
        /// </summary>
        /// <param name="waitHandle">The wait handle.</param>
        protected void WaitOnHandle(WaitHandle waitHandle)
        {
            _session.WaitOnHandle(waitHandle);
        }

        /// <summary>
        /// Closes the channel, optionally waiting for the SSH_MSG_CHANNEL_CLOSE message to
        /// be received from the server.
        /// </summary>
        /// <param name="wait"><c>true</c> to wait for the SSH_MSG_CHANNEL_CLOSE message to be received from the server; otherwise, <c>false</c>.</param>
        protected virtual void Close(bool wait)
        {
            // send EOF message first when channel need to be closed, and the remote party has not already sent
            // a SSH_MSG_CHANNEL_EOF or SSH_MSG_CHANNEL_CLOSE message
            //
            // note that we might have had a race condition here when the remote party sends a SSH_MSG_CHANNEL_CLOSE
            // immediately after it has sent a SSH_MSG_CHANNEL_EOF message
            //
            // in that case, we would risk sending a SSH_MSG_CHANNEL_EOF message after the remote party has
            // closed its end of the channel
            //
            // as a solution for this issue we only send a SSH_MSG_CHANNEL_EOF message if we haven't received a
            // SSH_MSG_CHANNEL_EOF or SSH_MSG_CHANNEL_CLOSE message from the remote party
            if (Interlocked.CompareExchange(ref _eofMessageSent, Considered, Initial) == Initial)
            {
                if (!_closeMessageReceived && !_eofMessageReceived && IsOpen && IsConnected)
                {
                    if (TrySendMessage(new ChannelEofMessage(RemoteChannelNumber)))
                        _eofMessageSent = Sent;
                }
            }

            // send message to close the channel on the server
            if (Interlocked.CompareExchange(ref _closeMessageSent, Considered, Initial) == Initial)
            {
                // ignore sending close message when client is not connected or the channel is closed
                if (IsOpen && IsConnected)
                {
                    if (TrySendMessage(new ChannelCloseMessage(RemoteChannelNumber)))
                        _closeMessageSent = Sent;
                }
            }

            // mark the channel closed
            IsOpen = false;

            // wait for channel to be closed if we actually sent a close message (either to initiate closing
            // the channel, or as response to a SSH_MSG_CHANNEL_CLOSE message sent by the server
            if (wait && _closeMessageSent == Sent)
            {
                WaitOnHandle(_channelClosedWaitHandle);
            }

            // reset indicators in case we want to reopen the channel; these are safe to reset
            // since the channel is marked closed by now
            _eofMessageSent = Initial;
            _eofMessageReceived = false;
            _closeMessageReceived = false;
            _closeMessageSent = Initial;
        }

        protected virtual void OnDisconnected()
        {
        }

        protected virtual void OnErrorOccured(Exception exp)
        {
        }

        private void Session_Disconnected(object sender, EventArgs e)
        {
            IsOpen = false;

            try
            {
                OnDisconnected();
            }
            catch (Exception ex)
            {
                OnChannelException(ex);
            }
        }

        /// <summary>
        /// Called when an <see cref="Exception"/> occurs while processing a channel message.
        /// </summary>
        /// <param name="ex">The <see cref="Exception"/>.</param>
        /// <remarks>
        /// This method will in turn invoke <see cref="OnErrorOccured(System.Exception)"/>, and
        /// raise the <see cref="Exception"/> event.
        /// </remarks>
        protected void OnChannelException(Exception ex)
        {
            OnErrorOccured(ex);
            RaiseExceptionEvent(ex);
        }

        private void Session_ErrorOccured(object sender, ExceptionEventArgs e)
        {
            try
            {
                OnErrorOccured(e.Exception);

                var errorOccuredWaitHandle = _errorOccuredWaitHandle;
                if (errorOccuredWaitHandle != null)
                    errorOccuredWaitHandle.Set();
            }
            catch (Exception ex)
            {
                RaiseExceptionEvent(ex);
            }
        }

        #region Channel message event handlers

        private void OnChannelWindowAdjust(object sender, MessageEventArgs<ChannelWindowAdjustMessage> e)
        {
            if (e.Message.LocalChannelNumber == LocalChannelNumber)
            {
                try
                {
                    OnWindowAdjust(e.Message.BytesToAdd);
                }
                catch (Exception ex)
                {
                    OnChannelException(ex);
                }
            }
        }

        private void OnChannelData(object sender, MessageEventArgs<ChannelDataMessage> e)
        {
            if (e.Message.LocalChannelNumber == LocalChannelNumber)
            {
                try
                {
                    OnData(e.Message.Data);
                }
                catch (Exception ex)
                {
                    OnChannelException(ex);
                }
            }
        }

        private void OnChannelExtendedData(object sender, MessageEventArgs<ChannelExtendedDataMessage> e)
        {
            if (e.Message.LocalChannelNumber == LocalChannelNumber)
            {
                try
                {
                    OnExtendedData(e.Message.Data, e.Message.DataTypeCode);
                }
                catch (Exception ex)
                {
                    OnChannelException(ex);
                }
            }
        }

        private void OnChannelEof(object sender, MessageEventArgs<ChannelEofMessage> e)
        {
            if (e.Message.LocalChannelNumber == LocalChannelNumber)
            {
                try
                {
                    OnEof();
                }
                catch (Exception ex)
                {
                    OnChannelException(ex);
                }
            }
        }

        private void OnChannelClose(object sender, MessageEventArgs<ChannelCloseMessage> e)
        {
            if (e.Message.LocalChannelNumber == LocalChannelNumber)
            {
                try
                {
                    OnClose();
                }
                catch (Exception ex)
                {
                    OnChannelException(ex);
                }

                var channelClosedWaitHandle = _channelClosedWaitHandle;
                if (channelClosedWaitHandle != null)
                    channelClosedWaitHandle.Set();
            }
        }

        private void OnChannelRequest(object sender, MessageEventArgs<ChannelRequestMessage> e)
        {
            if (e.Message.LocalChannelNumber == LocalChannelNumber)
            {
                try
                {
                    if (_session.ConnectionInfo.ChannelRequests.ContainsKey(e.Message.RequestName))
                    {
                        //  Get request specific class
                        var requestInfo = _session.ConnectionInfo.ChannelRequests[e.Message.RequestName];

                        //  Load request specific data
                        requestInfo.Load(e.Message.RequestData);

                        //  Raise request specific event
                        OnRequest(requestInfo);
                    }
                    else
                    {
                        //OneCodeTODO: we should also send a SSH_MSG_CHANNEL_FAILURE message
                        throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "Request '{0}' is not supported.", e.Message.RequestName));
                    }
                }
                catch (Exception ex)
                {
                    OnChannelException(ex);
                }
            }
        }

        private void OnChannelSuccess(object sender, MessageEventArgs<ChannelSuccessMessage> e)
        {
            if (e.Message.LocalChannelNumber == LocalChannelNumber)
            {
                try
                {
                    OnSuccess();
                }
                catch (Exception ex)
                {
                    OnChannelException(ex);
                }
            }
        }

        private void OnChannelFailure(object sender, MessageEventArgs<ChannelFailureMessage> e)
        {
            if (e.Message.LocalChannelNumber == LocalChannelNumber)
            {
                try
                {
                    OnFailure();
                }
                catch (Exception ex)
                {
                    OnChannelException(ex);
                }
            }
        }

        #endregion

        private void AdjustDataWindow(byte[] messageData)
        {
            LocalWindowSize -= (uint)messageData.Length;

            //  Adjust window if window size is too low
            if (LocalWindowSize < LocalPacketSize)
            {
                SendMessage(new ChannelWindowAdjustMessage(RemoteChannelNumber, _initialWindowSize - LocalWindowSize));
                LocalWindowSize = _initialWindowSize;
            }
        }

        /// <summary>
        /// Determines the length of data that currently can be sent in a single message.
        /// </summary>
        /// <param name="messageLength">The length of the message that must be sent.</param>
        /// <returns>
        /// The actual data length that currently can be sent.
        /// </returns>
        private int GetDataLengthThatCanBeSentInMessage(int messageLength)
        {
            do
            {
                lock (_serverWindowSizeLock)
                {
                    var serverWindowSize = RemoteWindowSize;
                    if (serverWindowSize == 0)
                    {
                        // allow us to be signal when remote window size is adjusted
                        _channelServerWindowAdjustWaitHandle.Reset();
                    }
                    else
                    {
                        var bytesThatCanBeSent = Math.Min(Math.Min(RemotePacketSize, (uint)messageLength),
                            serverWindowSize);
                        RemoteWindowSize -= bytesThatCanBeSent;
                        return (int)bytesThatCanBeSent;
                    }
                }
                // wait for remote window size to change
                WaitOnHandle(_channelServerWindowAdjustWaitHandle);
            } while (true);
        }

        private InvalidOperationException CreateRemoteChannelInfoNotAvailableException()
        {
            throw new InvalidOperationException("The channel has not been opened, or the open has not yet been confirmed.");
        }

        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (!_isDisposed)
            {
                if (disposing)
                {
                    Close(false);

                    if (_session != null)
                    {
                        _session.ChannelWindowAdjustReceived -= OnChannelWindowAdjust;
                        _session.ChannelDataReceived -= OnChannelData;
                        _session.ChannelExtendedDataReceived -= OnChannelExtendedData;
                        _session.ChannelEofReceived -= OnChannelEof;
                        _session.ChannelCloseReceived -= OnChannelClose;
                        _session.ChannelRequestReceived -= OnChannelRequest;
                        _session.ChannelSuccessReceived -= OnChannelSuccess;
                        _session.ChannelFailureReceived -= OnChannelFailure;
                        _session.ErrorOccured -= Session_ErrorOccured;
                        _session.Disconnected -= Session_Disconnected;
                        _session = null;
                    }

                    if (_channelClosedWaitHandle != null)
                    {
                        _channelClosedWaitHandle.Dispose();
                        _channelClosedWaitHandle = null;
                    }
                    if (_channelServerWindowAdjustWaitHandle != null)
                    {
                        _channelServerWindowAdjustWaitHandle.Dispose();
                        _channelServerWindowAdjustWaitHandle = null;
                    }
                    if (_errorOccuredWaitHandle != null)
                    {
                        _errorOccuredWaitHandle.Dispose();
                        _errorOccuredWaitHandle = null;
                    }
                }

                _isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="Channel"/> is reclaimed by garbage collection.
        /// </summary>
        ~Channel()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\Channels\ChannelDirectTcpip.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Channels
{
    /// <summary>
    /// Implements "direct-tcpip" SSH channel.
    /// </summary>
    public partial class ChannelDirectTcpip : ClientChannel, IChannelDirectTcpip
    {
        private readonly object _socketLock = new object();

        private EventWaitHandle _channelOpen = new AutoResetEvent(false);
        private EventWaitHandle _channelData = new AutoResetEvent(false);
        private IForwardedPort _forwardedPort;
        private Socket _socket;

        /// <summary>
        /// Initializes a new <see cref="ChannelDirectTcpip"/> instance.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="localChannelNumber">The local channel number.</param>
        /// <param name="localWindowSize">Size of the window.</param>
        /// <param name="localPacketSize">Size of the packet.</param>
        public ChannelDirectTcpip(ISession session, uint localChannelNumber, uint localWindowSize, uint localPacketSize)
            : base(session, localChannelNumber, localWindowSize, localPacketSize)
        {
        }

        /// <summary>
        /// Gets the type of the channel.
        /// </summary>
        /// <value>
        /// The type of the channel.
        /// </value>
        public override ChannelTypes ChannelType
        {
            get { return ChannelTypes.DirectTcpip; }
        }

        public void Open(string remoteHost, uint port, IForwardedPort forwardedPort, Socket socket)
        {
            if (IsOpen)
                throw new SshException("Channel is already open.");
            if (!IsConnected)
                throw new SshException("Session is not connected.");

            _socket = socket;
            _forwardedPort = forwardedPort;
            _forwardedPort.Closing += ForwardedPort_Closing;

            var ep = socket.RemoteEndPoint as IPEndPoint;

            // open channel
            SendMessage(new ChannelOpenMessage(LocalChannelNumber, LocalWindowSize, LocalPacketSize,
                new DirectTcpipChannelInfo(remoteHost, port, ep.Address.ToString(), (uint) ep.Port)));

            //  Wait for channel to open
            WaitOnHandle(_channelOpen);
        }

        /// <summary>
        /// Occurs as the forwarded port is being stopped.
        /// </summary>
        private void ForwardedPort_Closing(object sender, EventArgs eventArgs)
        {
            // signal to the client that we will not send anything anymore; this will also interrupt the
            // blocking receive in Bind if the client sends FIN/ACK in time
            //
            // if the FIN/ACK is not sent in time, the socket will be closed in Close(bool)
            ShutdownSocket(SocketShutdown.Send);
        }

        /// <summary>
        /// Binds channel to remote host.
        /// </summary>
        public void Bind()
        {
            //  Cannot bind if channel is not open
            if (!IsOpen)
                return;

            var buffer = new byte[RemotePacketSize];

            while (_socket != null && _socket.Connected)
            {
                try
                {
                    var read = 0;
                    InternalSocketReceive(buffer, ref read);
                    if (read > 0)
                    {
                        SendMessage(new ChannelDataMessage(RemoteChannelNumber, buffer.Take(read).ToArray()));
                    }
                    else
                    {
                        // client shut down the socket (but the server may still send data or an EOF)
                        break;
                    }
                }
                catch (SocketException exp)
                {
                    switch (exp.SocketErrorCode)
                    {
                        case SocketError.WouldBlock:
                        case SocketError.IOPending:
                        case SocketError.NoBufferSpaceAvailable:
                            // socket buffer is probably empty, wait and try again
                            Thread.Sleep(30);
                            break;
                        case SocketError.ConnectionAborted:
                        case SocketError.ConnectionReset:
                            // connection was closed after receiving SSH_MSG_CHANNEL_CLOSE message
                            break;
                        case SocketError.Interrupted:
                            // connection was closed because FIN/ACK was not received in time after
                            // shutting down the (send part of the) socket
                            break;
                        default:
                            throw; // throw any other error
                    }
                }
            }

            // even though the client has disconnected, we still want to properly close the
            // channel
            //
            // we'll do this in in Close(bool) that way we have a single place from which we
            // send an SSH_MSG_CHANNEL_EOF message and wait for the SSH_MSG_CHANNEL_CLOSE
            // message
        }

        /// <summary>
        /// Closes the socket, hereby interrupting the blocking receive in <see cref="Bind()"/>.
        /// </summary>
        private void CloseSocket()
        {
            if (_socket == null)
                return;

            lock (_socketLock)
            {
                if (_socket == null)
                    return;

                // closing a socket actually disposes the socket, so we can safely dereference
                // the field to avoid entering the lock again later
                _socket.Close();
                _socket = null;
            }
        }

        /// <summary>
        /// Shuts down the socket.
        /// </summary>
        /// <param name="how">One of the <see cref="SocketShutdown"/> values that specifies the operation that will no longer be allowed.</param>
        private void ShutdownSocket(SocketShutdown how)
        {
            if (_socket == null)
                return;

            lock (_socketLock)
            {
                if (_socket == null || !_socket.Connected)
                    return;

                _socket.Shutdown(how);
            }
        }

        /// <summary>
        /// Closes the channel, optionally waiting for the SSH_MSG_CHANNEL_CLOSE message to
        /// be received from the server.
        /// </summary>
        /// <param name="wait"><c>true</c> to wait for the SSH_MSG_CHANNEL_CLOSE message to be received from the server; otherwise, <c>false</c>.</param>
        protected override void Close(bool wait)
        {
            if (_forwardedPort != null)
            {
                _forwardedPort.Closing -= ForwardedPort_Closing;
                _forwardedPort = null;
            }

            // signal to the client that we will not send anything anymore; this will also interrupt the
            // blocking receive in Bind if the client sends FIN/ACK in time
            //
            // if the FIN/ACK is not sent in time, the socket will be closed after the channel is closed
            ShutdownSocket(SocketShutdown.Send);

            // close the SSH channel, and mark the channel closed
            base.Close(wait);

            // close the socket
            CloseSocket();
        }

        /// <summary>
        /// Called when channel data is received.
        /// </summary>
        /// <param name="data">The data.</param>
        protected override void OnData(byte[] data)
        {
            base.OnData(data);

            if (_socket != null && _socket.Connected)
            {
                lock (_socketLock)
                {
                    if (_socket != null && _socket.Connected)
                    {
                        InternalSocketSend(data);
                    }
                }
            }
        }

        /// <summary>
        /// Called when channel is opened by the server.
        /// </summary>
        /// <param name="remoteChannelNumber">The remote channel number.</param>
        /// <param name="initialWindowSize">Initial size of the window.</param>
        /// <param name="maximumPacketSize">Maximum size of the packet.</param>
        protected override void OnOpenConfirmation(uint remoteChannelNumber, uint initialWindowSize, uint maximumPacketSize)
        {
            base.OnOpenConfirmation(remoteChannelNumber, initialWindowSize, maximumPacketSize);

            _channelOpen.Set();
        }

        protected override void OnOpenFailure(uint reasonCode, string description, string language)
        {
            base.OnOpenFailure(reasonCode, description, language);

            _channelOpen.Set();
        }

        /// <summary>
        /// Called when channel has no more data to receive.
        /// </summary>
        protected override void OnEof()
        {
            base.OnEof();

            // the channel will send no more data, and hence it does not make sense to receive
            // any more data from the client to send to the remote party (and we surely won't
            // send anything anymore)
            //
            // this will also interrupt the blocking receive in Bind()
            ShutdownSocket(SocketShutdown.Send);
        }

        /// <summary>
        /// Called whenever an unhandled <see cref="Exception"/> occurs in <see cref="Session"/> causing
        /// the message loop to be interrupted, or when an exception occurred processing a channel message.
        /// </summary>
        protected override void OnErrorOccured(Exception exp)
        {
            base.OnErrorOccured(exp);

            // signal to the client that we will not send anything anymore; this will also interrupt the
            // blocking receive in Bind if the client sends FIN/ACK in time
            //
            // if the FIN/ACK is not sent in time, the socket will be closed in Close(bool)
            ShutdownSocket(SocketShutdown.Send);
        }

        /// <summary>
        /// Called when the server wants to terminate the connection immmediately.
        /// </summary>
        /// <remarks>
        /// The sender MUST NOT send or receive any data after this message, and
        /// the recipient MUST NOT accept any data after receiving this message.
        /// </remarks>
        protected override void OnDisconnected()
        {
            base.OnDisconnected();

            // the channel will accept or send no more data, and hence it does not make sense
            // to accept any more data from the client (and we surely won't send anything
            // anymore)
            //
            // 
            // so lets signal to the client that we will not send or receive anything anymore
            // this will also interrupt the blocking receive in Bind()
            ShutdownSocket(SocketShutdown.Both);
        }

        partial void InternalSocketReceive(byte[] buffer, ref int read);

        partial void InternalSocketSend(byte[] data);

        protected override void Dispose(bool disposing)
        {
            // make sure we've unsubscribed from all session events and closed the channel
            // before we starting disposing
            base.Dispose(disposing);

            if (disposing)
            {
                if (_socket != null)
                {
                    lock (_socketLock)
                    {
                        if (_socket != null)
                        {
                            _socket.Dispose();
                            _socket = null;
                        }
                    }
                }

                if (_channelOpen != null)
                {
                    _channelOpen.Dispose();
                    _channelOpen = null;
                }

                if (_channelData != null)
                {
                    _channelData.Dispose();
                    _channelData = null;
                }
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Channels\ChannelDirectTcpip.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Channels
{
    /// <summary>
    /// Implements "direct-tcpip" SSH channel.
    /// </summary>
    public partial class ChannelDirectTcpip 
    {
        partial void InternalSocketReceive(byte[] buffer, ref int read)
        {
            read = this._socket.Receive(buffer);
        }

        partial void InternalSocketSend(byte[] data)
        {
            this._socket.Send(data, 0, data.Length, SocketFlags.None);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Channels\ChannelForwardedTcpip.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Channels
{
    /// <summary>
    /// Implements "forwarded-tcpip" SSH channel.
    /// </summary>
    public partial class ChannelForwardedTcpip : ServerChannel, IChannelForwardedTcpip
    {
        private readonly object _socketShutdownAndCloseLock = new object();
        private Socket _socket;
        private IForwardedPort _forwardedPort;

        /// <summary>
        /// Initializes a new <see cref="ChannelForwardedTcpip"/> instance.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="localChannelNumber">The local channel number.</param>
        /// <param name="localWindowSize">Size of the window.</param>
        /// <param name="localPacketSize">Size of the packet.</param>
        /// <param name="remoteChannelNumber">The remote channel number.</param>
        /// <param name="remoteWindowSize">The window size of the remote party.</param>
        /// <param name="remotePacketSize">The maximum size of a data packet that we can send to the remote party.</param>
        internal ChannelForwardedTcpip(ISession session, uint localChannelNumber, uint localWindowSize, uint localPacketSize, uint remoteChannelNumber, uint remoteWindowSize, uint remotePacketSize)
            : base(session, localChannelNumber, localWindowSize, localPacketSize, remoteChannelNumber, remoteWindowSize, remotePacketSize)
        {
        }

        /// <summary>
        /// Gets the type of the channel.
        /// </summary>
        /// <value>
        /// The type of the channel.
        /// </value>
        public override ChannelTypes ChannelType
        {
            get { return ChannelTypes.ForwardedTcpip; }
        }

        /// <summary>
        /// Binds the channel to the specified endpoint.
        /// </summary>
        /// <param name="remoteEndpoint">The endpoint to connect to.</param>
        /// <param name="forwardedPort">The forwarded port for which the channel is opened.</param>
        public void Bind(IPEndPoint remoteEndpoint, IForwardedPort forwardedPort)
        {
            byte[] buffer;

            if (!IsConnected)
            {
                throw new SshException("Session is not connected.");
            }

            _forwardedPort = forwardedPort;
            _forwardedPort.Closing += ForwardedPort_Closing;

            //  Try to connect to the socket 
            try
            {
                //  Get buffer in memory for data exchange
                buffer = new byte[RemotePacketSize];

                OpenSocket(remoteEndpoint);

                // send channel open confirmation message
                SendMessage(new ChannelOpenConfirmationMessage(RemoteChannelNumber, LocalWindowSize, LocalPacketSize, LocalChannelNumber));
            }
            catch (Exception exp)
            {
                // send channel open failure message
                SendMessage(new ChannelOpenFailureMessage(RemoteChannelNumber, exp.ToString(), ChannelOpenFailureMessage.ConnectFailed, "en"));

                throw;
            }

            //  Start reading data from the port and send to channel
            while (_socket != null && _socket.Connected)
                {
                try
                {
                    var read = 0;
                    InternalSocketReceive(buffer, ref read);

                    if (read > 0)
                    {
                        SendMessage(new ChannelDataMessage(RemoteChannelNumber, buffer.Take(read).ToArray()));
                    }
                    else
                    {
                        // server quit sending
                        break;
                    }
                }
                catch (SocketException exp)
                {
                    if (exp.SocketErrorCode == SocketError.WouldBlock ||
                        exp.SocketErrorCode == SocketError.IOPending ||
                        exp.SocketErrorCode == SocketError.NoBufferSpaceAvailable)
                    {
                        // socket buffer is probably empty, wait and try again
                        Thread.Sleep(30);
                    }
                    else if (exp.SocketErrorCode == SocketError.ConnectionAborted || exp.SocketErrorCode == SocketError.Interrupted)
                    {
                        break;
                    }
                    else
                        throw;  // throw any other error
                }
            }
        }

        protected override void OnErrorOccured(Exception exp)
        {
            base.OnErrorOccured(exp);

            // signal to the server that we will not send anything anymore; this will also interrupt the
            // blocking receive in Bind if the server sends FIN/ACK in time
            //
            // if the FIN/ACK is not sent in time, the socket will be closed in Close(bool)
            ShutdownSocket(SocketShutdown.Send);
        }

        /// <summary>
        /// Occurs as the forwarded port is being stopped.
        /// </summary>
        private void ForwardedPort_Closing(object sender, EventArgs eventArgs)
        {
            // signal to the server that we will not send anything anymore; this will also interrupt the
            // blocking receive in Bind if the server sends FIN/ACK in time
            //
            // if the FIN/ACK is not sent in time, the socket will be closed in Close(bool)
            ShutdownSocket(SocketShutdown.Send);
        }

        partial void OpenSocket(IPEndPoint remoteEndpoint);

        /// <summary>
        /// Shuts down the socket.
        /// </summary>
        /// <param name="how">One of the <see cref="SocketShutdown"/> values that specifies the operation that will no longer be allowed.</param>
        private void ShutdownSocket(SocketShutdown how)
        {
            if (_socket == null || !_socket.Connected)
                return;

            lock (_socketShutdownAndCloseLock)
            {
                if (_socket == null || !_socket.Connected)
                    return;

                _socket.Shutdown(how);
            }
        }

        /// <summary>
        /// Closes the socket, hereby interrupting the blocking receive in <see cref="Bind(IPEndPoint,IForwardedPort)"/>.
        /// </summary>
        private void CloseSocket()
        {
            if (_socket == null)
                return;

            lock (_socketShutdownAndCloseLock)
            {
                if (_socket == null)
                    return;

                // closing a socket actually disposes the socket, so we can safely dereference
                // the field to avoid entering the lock again later
                _socket.Close();
                _socket = null;
            }
        }

        /// <summary>
        /// Closes the channel, optionally waiting for the SSH_MSG_CHANNEL_CLOSE message to
        /// be received from the server.
        /// </summary>
        /// <param name="wait"><c>true</c> to wait for the SSH_MSG_CHANNEL_CLOSE message to be received from the server; otherwise, <c>false</c>.</param>
        protected override void Close(bool wait)
        {
            if (_forwardedPort != null)
            {
                _forwardedPort.Closing -= ForwardedPort_Closing;
                _forwardedPort = null;
            }

            // signal to the server that we will not send anything anymore; this will also interrupt the
            // blocking receive in Bind if the server sends FIN/ACK in time
            //
            // if the FIN/ACK is not sent in time, the socket will be closed after the channel is closed
            ShutdownSocket(SocketShutdown.Send);

            // close the SSH channel, and mark the channel closed
            base.Close(wait);

            // close the socket
            CloseSocket();
        }

        /// <summary>
        /// Called when channel data is received.
        /// </summary>
        /// <param name="data">The data.</param>
        protected override void OnData(byte[] data)
        {
            base.OnData(data);

            if (_socket != null && _socket.Connected)
                InternalSocketSend(data);
        }

        partial void InternalSocketSend(byte[] data);
        
        partial void InternalSocketReceive(byte[] buffer, ref int read);

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected override void Dispose(bool disposing)
        {
            // make sure we've unsubscribed from all session events and closed the channel
            // before we starting disposing
            base.Dispose(disposing);

            if (disposing)
            {
                if (_socket != null)
                {
                    _socket.Dispose();
                    _socket = null;
                }
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Channels\ChannelForwardedTcpip.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Channels
{
    /// <summary>
    /// Implements "forwarded-tcpip" SSH channel.
    /// </summary>
    public partial class ChannelForwardedTcpip
    {
        partial void OpenSocket(IPEndPoint remoteEndpoint)
        {
            this._socket = new Socket(remoteEndpoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
            this._socket.Connect(remoteEndpoint);
            this._socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, 1);
        }

        partial void InternalSocketReceive(byte[] buffer, ref int read)
        {
            read = this._socket.Receive(buffer);
        }

        partial void InternalSocketSend(byte[] data)
        {
            this._socket.Send(data);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Channels\ChannelSession.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Channels
{
    /// <summary>
    /// Implements Session SSH channel.
    /// </summary>
    public class ChannelSession : ClientChannel, IChannelSession
    {
        /// <summary>
        /// Counts failed channel open attempts
        /// </summary>
        private int _failedOpenAttempts;

        /// <summary>
        /// Holds a value indicating whether the session semaphore has been obtained by the current
        /// channel.
        /// </summary>
        /// <value>
        /// <c>0</c> when the session semaphore has not been obtained or has already been released,
        /// and <c>1</c> when the session has been obtained and still needs to be released.
        /// </value>
        private int _sessionSemaphoreObtained;

        /// <summary>
        /// Wait handle to signal when response was received to open the channel
        /// </summary>
        private EventWaitHandle _channelOpenResponseWaitHandle = new AutoResetEvent(false);

        private EventWaitHandle _channelRequestResponse = new ManualResetEvent(false);

        private bool _channelRequestSucces;

        /// <summary>
        /// Initializes a new <see cref="ChannelSession"/> instance.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="localChannelNumber">The local channel number.</param>
        /// <param name="localWindowSize">Size of the window.</param>
        /// <param name="localPacketSize">Size of the packet.</param>
        public ChannelSession(ISession session, uint localChannelNumber, uint localWindowSize, uint localPacketSize)
            : base(session, localChannelNumber, localWindowSize, localPacketSize)
        {
        }

        /// <summary>
        /// Gets the type of the channel.
        /// </summary>
        /// <value>
        /// The type of the channel.
        /// </value>
        public override ChannelTypes ChannelType
        {
            get { return ChannelTypes.Session; }
        }

        /// <summary>
        /// Opens the channel.
        /// </summary>
        public virtual void Open()
        {
            if (!IsOpen)
            {
                //  Try to open channel several times
                while (!IsOpen && _failedOpenAttempts < ConnectionInfo.RetryAttempts)
                {
                    SendChannelOpenMessage();
                    try
                    {
                        WaitOnHandle(_channelOpenResponseWaitHandle);
                    }
                    catch (Exception)
                    {
                        // avoid leaking session semaphore
                        ReleaseSemaphore();
                        throw;
                    }
                }

                if (!IsOpen)
                    throw new SshException(string.Format(CultureInfo.CurrentCulture, "Failed to open a channel after {0} attempts.", _failedOpenAttempts));
            }
        }

        /// <summary>
        /// Called when channel is opened by the server.
        /// </summary>
        /// <param name="remoteChannelNumber">The remote channel number.</param>
        /// <param name="initialWindowSize">Initial size of the window.</param>
        /// <param name="maximumPacketSize">Maximum size of the packet.</param>
        protected override void OnOpenConfirmation(uint remoteChannelNumber, uint initialWindowSize, uint maximumPacketSize)
        {
            base.OnOpenConfirmation(remoteChannelNumber, initialWindowSize, maximumPacketSize);
            _channelOpenResponseWaitHandle.Set();
        }

        /// <summary>
        /// Called when channel failed to open.
        /// </summary>
        /// <param name="reasonCode">The reason code.</param>
        /// <param name="description">The description.</param>
        /// <param name="language">The language.</param>
        protected override void OnOpenFailure(uint reasonCode, string description, string language)
        {
            _failedOpenAttempts++;
            ReleaseSemaphore();
            _channelOpenResponseWaitHandle.Set();
        }

        /// <summary>
        /// Called when channel is closed by the server.
        /// </summary>
        protected override void OnClose()
        {
            base.OnClose();

            //  This timeout needed since when channel is closed it does not immediately becomes available
            //  but it takes time for the server to clean up resource and allow new channels to be created.
            Thread.Sleep(100);
        }

        protected override void Close(bool wait)
        {
            base.Close(wait);

            ReleaseSemaphore();
        }

        /// <summary>
        /// Sends the pseudo terminal request.
        /// </summary>
        /// <param name="environmentVariable">The environment variable.</param>
        /// <param name="columns">The columns.</param>
        /// <param name="rows">The rows.</param>
        /// <param name="width">The width.</param>
        /// <param name="height">The height.</param>
        /// <param name="terminalModeValues">The terminal mode values.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        public bool SendPseudoTerminalRequest(string environmentVariable, uint columns, uint rows, uint width, uint height, IDictionary<TerminalModes, uint> terminalModeValues)
        {
            _channelRequestResponse.Reset();
            SendMessage(new ChannelRequestMessage(RemoteChannelNumber, new PseudoTerminalRequestInfo(environmentVariable, columns, rows, width, height, terminalModeValues)));
            WaitOnHandle(_channelRequestResponse);
            return _channelRequestSucces;
        }

        /// <summary>
        /// Sends the X11 forwarding request.
        /// </summary>
        /// <param name="isSingleConnection">if set to <c>true</c> the it is single connection.</param>
        /// <param name="protocol">The protocol.</param>
        /// <param name="cookie">The cookie.</param>
        /// <param name="screenNumber">The screen number.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        public bool SendX11ForwardingRequest(bool isSingleConnection, string protocol, byte[] cookie, uint screenNumber)
        {
            _channelRequestResponse.Reset();
            SendMessage(new ChannelRequestMessage(RemoteChannelNumber, new X11ForwardingRequestInfo(isSingleConnection, protocol, cookie, screenNumber)));
            WaitOnHandle(_channelRequestResponse);
            return _channelRequestSucces;
        }

        /// <summary>
        /// Sends the environment variable request.
        /// </summary>
        /// <param name="variableName">Name of the variable.</param>
        /// <param name="variableValue">The variable value.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        public bool SendEnvironmentVariableRequest(string variableName, string variableValue)
        {
            _channelRequestResponse.Reset();
            SendMessage(new ChannelRequestMessage(RemoteChannelNumber, new EnvironmentVariableRequestInfo(variableName, variableValue)));
            WaitOnHandle(_channelRequestResponse);
            return _channelRequestSucces;
        }

        /// <summary>
        /// Sends the shell request.
        /// </summary>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        public bool SendShellRequest()
        {
            _channelRequestResponse.Reset();
            SendMessage(new ChannelRequestMessage(RemoteChannelNumber, new ShellRequestInfo()));
            WaitOnHandle(_channelRequestResponse);
            return _channelRequestSucces;
        }

        /// <summary>
        /// Sends the exec request.
        /// </summary>
        /// <param name="command">The command.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        public bool SendExecRequest(string command)
        {
            _channelRequestResponse.Reset();
            SendMessage(new ChannelRequestMessage(RemoteChannelNumber, new ExecRequestInfo(command, ConnectionInfo.Encoding)));
            WaitOnHandle(_channelRequestResponse);
            return _channelRequestSucces;
        }

        /// <summary>
        /// Sends the exec request.
        /// </summary>
        /// <param name="breakLength">Length of the break.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        public bool SendBreakRequest(uint breakLength)
        {
            _channelRequestResponse.Reset();
            SendMessage(new ChannelRequestMessage(RemoteChannelNumber, new BreakRequestInfo(breakLength)));
            WaitOnHandle(_channelRequestResponse);
            return _channelRequestSucces;
        }

        /// <summary>
        /// Sends the subsystem request.
        /// </summary>
        /// <param name="subsystem">The subsystem.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        public bool SendSubsystemRequest(string subsystem)
        {
            _channelRequestResponse.Reset();
            SendMessage(new ChannelRequestMessage(RemoteChannelNumber, new SubsystemRequestInfo(subsystem)));
            WaitOnHandle(_channelRequestResponse);
            return _channelRequestSucces;
        }

        /// <summary>
        /// Sends the window change request.
        /// </summary>
        /// <param name="columns">The columns.</param>
        /// <param name="rows">The rows.</param>
        /// <param name="width">The width.</param>
        /// <param name="height">The height.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        public bool SendWindowChangeRequest(uint columns, uint rows, uint width, uint height)
        {
            SendMessage(new ChannelRequestMessage(RemoteChannelNumber, new WindowChangeRequestInfo(columns, rows, width, height)));
            return true;
        }

        /// <summary>
        /// Sends the local flow request.
        /// </summary>
        /// <param name="clientCanDo">if set to <c>true</c> [client can do].</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        public bool SendLocalFlowRequest(bool clientCanDo)
        {
            SendMessage(new ChannelRequestMessage(RemoteChannelNumber, new XonXoffRequestInfo(clientCanDo)));
            return true;
        }

        /// <summary>
        /// Sends the signal request.
        /// </summary>
        /// <param name="signalName">Name of the signal.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        public bool SendSignalRequest(string signalName)
        {
            SendMessage(new ChannelRequestMessage(RemoteChannelNumber, new SignalRequestInfo(signalName)));
            return true;
        }

        /// <summary>
        /// Sends the exit status request.
        /// </summary>
        /// <param name="exitStatus">The exit status.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        public bool SendExitStatusRequest(uint exitStatus)
        {
            SendMessage(new ChannelRequestMessage(RemoteChannelNumber, new ExitStatusRequestInfo(exitStatus)));
            return true;
        }

        /// <summary>
        /// Sends the exit signal request.
        /// </summary>
        /// <param name="signalName">Name of the signal.</param>
        /// <param name="coreDumped">if set to <c>true</c> [core dumped].</param>
        /// <param name="errorMessage">The error message.</param>
        /// <param name="language">The language.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        public bool SendExitSignalRequest(string signalName, bool coreDumped, string errorMessage, string language)
        {
            SendMessage(new ChannelRequestMessage(RemoteChannelNumber, new ExitSignalRequestInfo(signalName, coreDumped, errorMessage, language)));
            return true;
        }

        /// <summary>
        /// Sends eow@openssh.com request.
        /// </summary>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        public bool SendEndOfWriteRequest()
        {
            _channelRequestResponse.Reset();
            SendMessage(new ChannelRequestMessage(RemoteChannelNumber, new EndOfWriteRequestInfo()));
            WaitOnHandle(_channelRequestResponse);
            return _channelRequestSucces;
        }

        /// <summary>
        /// Sends keepalive@openssh.com request.
        /// </summary>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        public bool SendKeepAliveRequest()
        {
            _channelRequestResponse.Reset();
            SendMessage(new ChannelRequestMessage(RemoteChannelNumber, new KeepAliveRequestInfo()));
            WaitOnHandle(_channelRequestResponse);
            return _channelRequestSucces;
        }

        /// <summary>
        /// Called when channel request was successful
        /// </summary>
        protected override void OnSuccess()
        {
            base.OnSuccess();
            _channelRequestSucces = true;

            var channelRequestResponse = _channelRequestResponse;
            if (channelRequestResponse != null)
                channelRequestResponse.Set();
        }

        /// <summary>
        /// Called when channel request failed.
        /// </summary>
        protected override void OnFailure()
        {
            base.OnFailure();
            _channelRequestSucces = false;

            var channelRequestResponse = _channelRequestResponse;
            if (channelRequestResponse != null)
                channelRequestResponse.Set();
        }

        /// <summary>
        /// Sends the channel open message.
        /// </summary>
        protected void SendChannelOpenMessage()
        {
            // do not allow open to be ChannelOpenMessage to be sent again until we've
            // had a response on the previous attempt for the current channel
            if (Interlocked.CompareExchange(ref _sessionSemaphoreObtained, 1, 0) == 0)
            {
                SessionSemaphore.Wait();
                SendMessage(
                    new ChannelOpenMessage(
                        LocalChannelNumber,
                        LocalWindowSize,
                        LocalPacketSize,
                        new SessionChannelOpenInfo()));
            }
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);

            if (disposing)
            {
                if (_channelOpenResponseWaitHandle != null)
                {
                    _channelOpenResponseWaitHandle.Dispose();
                    _channelOpenResponseWaitHandle = null;
                }

                if (_channelRequestResponse != null)
                {
                    _channelRequestResponse.Dispose();
                    _channelRequestResponse = null;
                }
            }
        }

        /// <summary>
        /// Releases the session semaphore.
        /// </summary>
        /// <remarks>
        /// When the session semaphore has already been released, or was never obtained by
        /// this instance, then this method does nothing.
        /// </remarks>
        private void ReleaseSemaphore()
        {
            if (Interlocked.CompareExchange(ref _sessionSemaphoreObtained, 0, 1) == 1)
                SessionSemaphore.Release();
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Channels\ChannelTypes.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Channels
{
    /// <summary>
    /// Lists channel types as defined by the protocol.
    /// </summary>
    public enum ChannelTypes
    {
        /// <summary>
        /// session
        /// </summary>
        Session,
        /// <summary>
        /// x11
        /// </summary>
        X11,
        /// <summary>
        /// forwarded-tcpip
        /// </summary>
        ForwardedTcpip,
        /// <summary>
        /// direct-tcpip
        /// </summary>
        DirectTcpip,


    }
}

#endif
// file ...\X\Renci.SshNet\Channels\ClientChannel.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Channels
{
    public abstract class ClientChannel : Channel
    {
        /// <summary>
        /// Initializes a new <see cref="ClientChannel"/> instance.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="localChannelNumber">The local channel number.</param>
        /// <param name="localWindowSize">Size of the window.</param>
        /// <param name="localPacketSize">Size of the packet.</param>
        protected ClientChannel(ISession session, uint localChannelNumber, uint localWindowSize, uint localPacketSize)
            : base(session, localChannelNumber, localWindowSize, localPacketSize)
        {
            session.ChannelOpenConfirmationReceived += OnChannelOpenConfirmation;
            session.ChannelOpenFailureReceived += OnChannelOpenFailure;
        }

        /// <summary>
        /// Occurs when <see cref="ChannelOpenConfirmationMessage"/> message is received.
        /// </summary>
        public event EventHandler<ChannelOpenConfirmedEventArgs> OpenConfirmed;

        /// <summary>
        /// Occurs when <see cref="ChannelOpenFailureMessage"/> message received
        /// </summary>
        public event EventHandler<ChannelOpenFailedEventArgs> OpenFailed;

        /// <summary>
        /// Called when channel is opened by the server.
        /// </summary>
        /// <param name="remoteChannelNumber">The remote channel number.</param>
        /// <param name="initialWindowSize">Initial size of the window.</param>
        /// <param name="maximumPacketSize">Maximum size of the packet.</param>
        protected virtual void OnOpenConfirmation(uint remoteChannelNumber, uint initialWindowSize, uint maximumPacketSize)
        {
            InitializeRemoteInfo(remoteChannelNumber, initialWindowSize, maximumPacketSize);

            //  Channel is consider to be open when confirmation message was received
            IsOpen = true;

            var openConfirmed = OpenConfirmed;
            if (openConfirmed != null)
                openConfirmed(this, new ChannelOpenConfirmedEventArgs(remoteChannelNumber, initialWindowSize, maximumPacketSize));
        }

        /// <summary>
        /// Send message to open a channel.
        /// </summary>
        /// <param name="message">Message to send</param>
        protected void SendMessage(ChannelOpenMessage message)
        {
            Session.SendMessage(message);
        }

        /// <summary>
        /// Called when channel failed to open.
        /// </summary>
        /// <param name="reasonCode">The reason code.</param>
        /// <param name="description">The description.</param>
        /// <param name="language">The language.</param>
        protected virtual void OnOpenFailure(uint reasonCode, string description, string language)
        {
            var openFailed = OpenFailed;
            if (openFailed != null)
                openFailed(this, new ChannelOpenFailedEventArgs(LocalChannelNumber, reasonCode, description, language));
        }

        private void OnChannelOpenConfirmation(object sender, MessageEventArgs<ChannelOpenConfirmationMessage> e)
        {
            if (e.Message.LocalChannelNumber == LocalChannelNumber)
            {
                try
                {
                    OnOpenConfirmation(e.Message.RemoteChannelNumber, e.Message.InitialWindowSize,
                        e.Message.MaximumPacketSize);
                }
                catch (Exception ex)
                {
                    OnChannelException(ex);
                }
                
            }
        }

        private void OnChannelOpenFailure(object sender, MessageEventArgs<ChannelOpenFailureMessage> e)
        {
            if (e.Message.LocalChannelNumber == LocalChannelNumber)
            {
                try
                {
                    OnOpenFailure(e.Message.ReasonCode, e.Message.Description, e.Message.Language);
                }
                catch (Exception ex)
                {
                    OnChannelException(ex);
                }
            }
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                var session = Session;
                if (session != null)
                {
                    session.ChannelOpenConfirmationReceived -= OnChannelOpenConfirmation;
                    session.ChannelOpenFailureReceived -= OnChannelOpenFailure;
                }
            }

            base.Dispose(disposing);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Channels\IChannel.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Channels
{
    /// <summary>
    /// Represents SSH channel.
    /// </summary>
    public interface IChannel : IDisposable
    {
        /// <summary>
        /// Occurs when <see cref="ChannelDataMessage"/> message received
        /// </summary>
        event EventHandler<ChannelDataEventArgs> DataReceived;

        /// <summary>
        /// Occurs when an exception is thrown when processing channel messages.
        /// </summary>
        event EventHandler<ExceptionEventArgs> Exception;

        /// <summary>
        /// Occurs when <see cref="ChannelExtendedDataMessage"/> message received
        /// </summary>
        event EventHandler<ChannelDataEventArgs> ExtendedDataReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelRequestMessage"/> message received
        /// </summary>
        event EventHandler<ChannelRequestEventArgs> RequestReceived;

        /// <summary>
        /// Occurs when <see cref="ChannelCloseMessage"/> message received
        /// </summary>
        event EventHandler<ChannelEventArgs> Closed;

        /// <summary>
        /// Gets the local channel number.
        /// </summary>
        /// <value>
        /// The local channel number.
        /// </value>
        uint LocalChannelNumber { get; }

        /// <summary>
        /// Gets the maximum size of a packet.
        /// </summary>
        /// <value>
        /// The maximum size of a packet.
        /// </value>
        uint LocalPacketSize { get; }

        /// <summary>
        /// Gets the maximum size of a data packet that can be sent using the channel.
        /// </summary>
        /// <value>
        /// The maximum size of data that can be sent using a <see cref="ChannelDataMessage"/>
        /// on the current channel.
        /// </value>
        /// <exception cref="InvalidOperationException">The channel has not been opened, or the open has not yet been confirmed.</exception>
        uint RemotePacketSize { get; }

        /// <summary>
        /// Closes the channel.
        /// </summary>
        void Close();

        /// <summary>
        /// Gets a value indicating whether this channel is open.
        /// </summary>
        /// <value>
        /// <c>true</c> if this channel is open; otherwise, <c>false</c>.
        /// </value>
        bool IsOpen { get; }

        /// <summary>
        /// Sends a SSH_MSG_CHANNEL_DATA message with the specified payload.
        /// </summary>
        /// <param name="data">The payload to send.</param>
        void SendData(byte[] data);
    }
}

#endif
// file ...\X\Renci.SshNet\Channels\IChannelDirectTcpip.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Channels
{
    /// <summary>
    /// A "direct-tcpip" SSH channel.
    /// </summary>
    public interface IChannelDirectTcpip : IDisposable
    {
        /// <summary>
        /// Occurs when an exception is thrown while processing channel messages.
        /// </summary>
        event EventHandler<ExceptionEventArgs> Exception;

        /// <summary>
        /// Gets a value indicating whether this channel is open.
        /// </summary>
        /// <value>
        /// <c>true</c> if this channel is open; otherwise, <c>false</c>.
        /// </value>
        bool IsOpen { get; }

        /// <summary>
        /// Gets the local channel number.
        /// </summary>
        /// <value>
        /// The local channel number.
        /// </value>
        uint LocalChannelNumber { get; }

        /// <summary>
        /// Opens a channel for a locally forwarded TCP/IP port.
        /// </summary>
        /// <param name="remoteHost">The name of the remote host to forward to.</param>
        /// <param name="port">The port of the remote hosts to forward to.</param>
        /// <param name="forwardedPort">The forwarded port for which the channel is opened.</param>
        /// <param name="socket">The socket to receive requests from, and send responses from the remote host to.</param>
        void Open(string remoteHost, uint port, IForwardedPort forwardedPort, Socket socket);

        /// <summary>
        /// Binds the channel to the remote host.
        /// </summary>
        void Bind();

        /// <summary>
        /// Closes the channel.
        /// </summary>
        void Close();
    }
}

#endif
// file ...\X\Renci.SshNet\Channels\IChannelForwardedTcpip.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Channels
{
    /// <summary>
    /// A "forwarded-tcpip" SSH channel.
    /// </summary>
    public interface IChannelForwardedTcpip : IDisposable
    {
        /// <summary>
        /// Occurs when an exception is thrown while processing channel messages.
        /// </summary>
        event EventHandler<ExceptionEventArgs> Exception;

        /// <summary>
        /// Binds the channel to the specified endpoint.
        /// </summary>
        /// <param name="remoteEndpoint">The endpoint to connect to.</param>
        /// <param name="forwardedPort">The forwarded port for which the channel is opened.</param>
        void Bind(IPEndPoint remoteEndpoint, IForwardedPort forwardedPort);

        /// <summary>
        /// Closes the channel.
        /// </summary>
        void Close();
    }
}

#endif
// file ...\X\Renci.SshNet\Channels\IChannelSession.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Channels
{
    /// <summary>
    /// Session SSH channel.
    /// </summary>
    public interface IChannelSession : IChannel
    {
        /// <summary>
        /// Opens the channel.
        /// </summary>
        void Open();

        /// <summary>
        /// Sends the pseudo terminal request.
        /// </summary>
        /// <param name="environmentVariable">The environment variable.</param>
        /// <param name="columns">The columns.</param>
        /// <param name="rows">The rows.</param>
        /// <param name="width">The width.</param>
        /// <param name="height">The height.</param>
        /// <param name="terminalModeValues">The terminal mode values.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        bool SendPseudoTerminalRequest(string environmentVariable, uint columns, uint rows, uint width, uint height,
            IDictionary<TerminalModes, uint> terminalModeValues);

        /// <summary>
        /// Sends the X11 forwarding request.
        /// </summary>
        /// <param name="isSingleConnection">if set to <c>true</c> the it is single connection.</param>
        /// <param name="protocol">The protocol.</param>
        /// <param name="cookie">The cookie.</param>
        /// <param name="screenNumber">The screen number.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        bool SendX11ForwardingRequest(bool isSingleConnection, string protocol, byte[] cookie, uint screenNumber);

        /// <summary>
        /// Sends the environment variable request.
        /// </summary>
        /// <param name="variableName">Name of the variable.</param>
        /// <param name="variableValue">The variable value.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        bool SendEnvironmentVariableRequest(string variableName, string variableValue);

        /// <summary>
        /// Sends the shell request.
        /// </summary>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        bool SendShellRequest();

        /// <summary>
        /// Sends the exec request.
        /// </summary>
        /// <param name="command">The command.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        bool SendExecRequest(string command);

        /// <summary>
        /// Sends the exec request.
        /// </summary>
        /// <param name="breakLength">Length of the break.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        bool SendBreakRequest(uint breakLength);

        /// <summary>
        /// Sends the subsystem request.
        /// </summary>
        /// <param name="subsystem">The subsystem.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        bool SendSubsystemRequest(string subsystem);

        /// <summary>
        /// Sends the window change request.
        /// </summary>
        /// <param name="columns">The columns.</param>
        /// <param name="rows">The rows.</param>
        /// <param name="width">The width.</param>
        /// <param name="height">The height.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        bool SendWindowChangeRequest(uint columns, uint rows, uint width, uint height);

        /// <summary>
        /// Sends the local flow request.
        /// </summary>
        /// <param name="clientCanDo">if set to <c>true</c> [client can do].</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        bool SendLocalFlowRequest(bool clientCanDo);

        /// <summary>
        /// Sends the signal request.
        /// </summary>
        /// <param name="signalName">Name of the signal.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        bool SendSignalRequest(string signalName);

        /// <summary>
        /// Sends the exit status request.
        /// </summary>
        /// <param name="exitStatus">The exit status.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        bool SendExitStatusRequest(uint exitStatus);

        /// <summary>
        /// Sends the exit signal request.
        /// </summary>
        /// <param name="signalName">Name of the signal.</param>
        /// <param name="coreDumped">if set to <c>true</c> [core dumped].</param>
        /// <param name="errorMessage">The error message.</param>
        /// <param name="language">The language.</param>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        bool SendExitSignalRequest(string signalName, bool coreDumped, string errorMessage, string language);

        /// <summary>
        /// Sends eow@openssh.com request.
        /// </summary>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        bool SendEndOfWriteRequest();

        /// <summary>
        /// Sends keepalive@openssh.com request.
        /// </summary>
        /// <returns>
        /// <c>true</c> if request was successful; otherwise <c>false</c>.
        /// </returns>
        bool SendKeepAliveRequest();
    }
}

#endif
// file ...\X\Renci.SshNet\Channels\ServerChannel.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Channels
{
    public abstract class ServerChannel : Channel
    {
        /// <summary>
        /// Initializes a new <see cref="ServerChannel"/> instance.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="localChannelNumber">The local channel number.</param>
        /// <param name="localWindowSize">Size of the window.</param>
        /// <param name="localPacketSize">Size of the packet.</param>
        /// <param name="remoteChannelNumber">The remote channel number.</param>
        /// <param name="remoteWindowSize">The window size of the remote party.</param>
        /// <param name="remotePacketSize">The maximum size of a data packet that we can send to the remote party.</param>
        protected ServerChannel(ISession session, uint localChannelNumber, uint localWindowSize, uint localPacketSize, uint remoteChannelNumber, uint remoteWindowSize, uint remotePacketSize)
            : base(session, localChannelNumber, localWindowSize, localPacketSize)
        {
            InitializeRemoteInfo(remoteChannelNumber, remoteWindowSize, remotePacketSize);
        }

        protected void SendMessage(ChannelOpenConfirmationMessage message)
        {
            //  No need to check whether channel is open when trying to open a channel
            Session.SendMessage(message);

            //  When we act as server, consider the channel open when we've sent the
            // confirmation message to the peer
            IsOpen = true;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\ASCIIEncoding.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// Implementation of ASCII Encoding
    /// </summary>
    public class ASCIIEncoding : Encoding
    {
        private readonly char _fallbackChar;

        private static readonly char[] _byteToChar;

        static ASCIIEncoding()
        {
            if (_byteToChar == null)
            {
                _byteToChar = new char[128];
                var ch = '\0';
                for (byte i = 0; i < 128; i++)
                {
                    _byteToChar[i] = ch++;
                }
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ASCIIEncoding"/> class.
        /// </summary>
        public ASCIIEncoding()
        {
            this._fallbackChar = '?';
        }

        /// <summary>
        /// Calculates the number of bytes produced by encoding a set of characters from the specified character array.
        /// </summary>
        /// <param name="chars">The character array containing the set of characters to encode.</param>
        /// <param name="index">The index of the first character to encode.</param>
        /// <param name="count">The number of characters to encode.</param>
        /// <returns>
        /// The number of bytes produced by encoding the specified characters.
        /// </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///   <paramref name="chars"/> is null. </exception>
        ///   
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        ///   <paramref name="index"/> or <paramref name="count"/> is less than zero.-or- <paramref name="index"/> and <paramref name="count"/> do not denote a valid range in <paramref name="chars"/>. </exception>
        ///   
        /// <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation)-and-<see cref="P:System.Text.Encoding.EncoderFallback"/> is set to <see cref="T:System.Text.EncoderExceptionFallback"/>.</exception>
        public override int GetByteCount(char[] chars, int index, int count)
        {
            return count;
        }

        /// <summary>
        /// Encodes a set of characters from the specified character array into the specified byte array.
        /// </summary>
        /// <param name="chars">The character array containing the set of characters to encode.</param>
        /// <param name="charIndex">The index of the first character to encode.</param>
        /// <param name="charCount">The number of characters to encode.</param>
        /// <param name="bytes">The byte array to contain the resulting sequence of bytes.</param>
        /// <param name="byteIndex">The index at which to start writing the resulting sequence of bytes.</param>
        /// <returns>
        /// The actual number of bytes written into <paramref name="bytes"/>.
        /// </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///   <paramref name="chars"/> is null.-or- <paramref name="bytes"/> is null. </exception>
        ///   
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        ///   <paramref name="charIndex"/> or <paramref name="charCount"/> or <paramref name="byteIndex"/> is less than zero.-or- <paramref name="charIndex"/> and <paramref name="charCount"/> do not denote a valid range in <paramref name="chars"/>.-or- <paramref name="byteIndex"/> is not a valid index in <paramref name="bytes"/>. </exception>
        ///   
        /// <exception cref="T:System.ArgumentException">
        ///   <paramref name="bytes"/> does not have enough capacity from <paramref name="byteIndex"/> to the end of the array to accommodate the resulting bytes. </exception>
        ///   
        /// <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation)-and-<see cref="P:System.Text.Encoding.EncoderFallback"/> is set to <see cref="T:System.Text.EncoderExceptionFallback"/>.</exception>
        public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex)
        {
            for (int i = 0; i < charCount && i < chars.Length; i++)
            {
                var b = (byte)chars[i + charIndex];

                if (b > 127)
                    b = (byte)this._fallbackChar;

                bytes[i + byteIndex] = b;
            }
            return charCount;
        }

        /// <summary>
        /// Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.
        /// </summary>
        /// <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        /// <param name="index">The index of the first byte to decode.</param>
        /// <param name="count">The number of bytes to decode.</param>
        /// <returns>
        /// The number of characters produced by decoding the specified sequence of bytes.
        /// </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///   <paramref name="bytes"/> is null. </exception>
        ///   
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        ///   <paramref name="index"/> or <paramref name="count"/> is less than zero.-or- <paramref name="index"/> and <paramref name="count"/> do not denote a valid range in <paramref name="bytes"/>. </exception>
        ///   
        /// <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation)-and-<see cref="P:System.Text.Encoding.DecoderFallback"/> is set to <see cref="T:System.Text.DecoderExceptionFallback"/>.</exception>
        public override int GetCharCount(byte[] bytes, int index, int count)
        {
            return count;
        }

        /// <summary>
        /// Decodes a sequence of bytes from the specified byte array into the specified character array.
        /// </summary>
        /// <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        /// <param name="byteIndex">The index of the first byte to decode.</param>
        /// <param name="byteCount">The number of bytes to decode.</param>
        /// <param name="chars">The character array to contain the resulting set of characters.</param>
        /// <param name="charIndex">The index at which to start writing the resulting set of characters.</param>
        /// <returns>
        /// The actual number of characters written into <paramref name="chars"/>.
        /// </returns>
        /// <exception cref="T:System.ArgumentNullException">
        ///   <paramref name="bytes"/> is null.-or- <paramref name="chars"/> is null. </exception>
        ///   
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        ///   <paramref name="byteIndex"/> or <paramref name="byteCount"/> or <paramref name="charIndex"/> is less than zero.-or- <paramref name="byteIndex"/> and <paramref name="byteCount"/> do not denote a valid range in <paramref name="bytes"/>.-or- <paramref name="charIndex"/> is not a valid index in <paramref name="chars"/>. </exception>
        ///   
        /// <exception cref="T:System.ArgumentException">
        ///   <paramref name="chars"/> does not have enough capacity from <paramref name="charIndex"/> to the end of the array to accommodate the resulting characters. </exception>
        ///   
        /// <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation)-and-<see cref="P:System.Text.Encoding.DecoderFallback"/> is set to <see cref="T:System.Text.DecoderExceptionFallback"/>.</exception>
        public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
        {
            for (int i = 0; i < byteCount; i++)
            {
                var b = bytes[i + byteIndex];
                char ch;

                if (b > 127)
                {
                    ch = this._fallbackChar;
                }
                else 
                {
                    ch = _byteToChar[b];
                }

                chars[i + charIndex] = ch;
            }
            return byteCount;
        }

        /// <summary>
        /// Calculates the maximum number of bytes produced by encoding the specified number of characters.
        /// </summary>
        /// <param name="charCount">The number of characters to encode.</param>
        /// <returns>
        /// The maximum number of bytes produced by encoding the specified number of characters.
        /// </returns>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        ///   <paramref name="charCount"/> is less than zero. </exception>
        ///   
        /// <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation)-and-<see cref="P:System.Text.Encoding.EncoderFallback"/> is set to <see cref="T:System.Text.EncoderExceptionFallback"/>.</exception>
        public override int GetMaxByteCount(int charCount)
        {
            return charCount;
        }

        /// <summary>
        /// Calculates the maximum number of characters produced by decoding the specified number of bytes.
        /// </summary>
        /// <param name="byteCount">The number of bytes to decode.</param>
        /// <returns>
        /// The maximum number of characters produced by decoding the specified number of bytes.
        /// </returns>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        ///   <paramref name="byteCount"/> is less than zero. </exception>
        ///   
        /// <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see Understanding Encodings for complete explanation)-and-<see cref="P:System.Text.Encoding.DecoderFallback"/> is set to <see cref="T:System.Text.DecoderExceptionFallback"/>.</exception>
        public override int GetMaxCharCount(int byteCount)
        {
            return byteCount;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\AsyncResult.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// Base class to encapsulates the results of an asynchronous operation.
    /// </summary>
    public abstract class AsyncResult : IAsyncResult
    {
        // Fields set at construction which never change while operation is pending
        private readonly AsyncCallback _asyncCallback;

        private readonly Object _asyncState;

        // Field set at construction which do change after operation completes
        private const Int32 _statePending = 0;

        private const Int32 _stateCompletedSynchronously = 1;

        private const Int32 _stateCompletedAsynchronously = 2;

        private Int32 _completedState = _statePending;

        // Field that may or may not get set depending on usage
        private ManualResetEvent _asyncWaitHandle;

        // Fields set when operation completes
        private Exception _exception;

        /// <summary>
        /// Gets or sets a value indicating whether EndInvoke has been called on the current AsyncResult.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if EndInvoke has been called on the current AsyncResult; otherwise, <c>false</c>.
        /// </value>
        public bool EndInvokeCalled { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="AsyncResult"/> class.
        /// </summary>
        /// <param name="asyncCallback">The async callback.</param>
        /// <param name="state">The state.</param>
        public AsyncResult(AsyncCallback asyncCallback, Object state)
        {
            this._asyncCallback = asyncCallback;
            this._asyncState = state;
        }

        /// <summary>
        /// Marks asynchronous operation as completed.
        /// </summary>
        /// <param name="exception">The exception.</param>
        /// <param name="completedSynchronously">if set to <c>true</c> [completed synchronously].</param>
        public void SetAsCompleted(Exception exception, Boolean completedSynchronously)
        {
            // Passing null for exception means no error occurred; this is the common case
            this._exception = exception;

            // The m_CompletedState field MUST be set prior calling the callback
            Int32 prevState = Interlocked.Exchange(ref this._completedState,
               completedSynchronously ? _stateCompletedSynchronously : _stateCompletedAsynchronously);
            if (prevState != _statePending)
                throw new InvalidOperationException("You can set a result only once");

            // If the event exists, set it
            if (this._asyncWaitHandle != null)
                this._asyncWaitHandle.Set();

            // If a callback method was set, call it
            if (this._asyncCallback != null)
                this._asyncCallback(this);
        }

        /// <summary>
        /// Waits until the asynchronous operation completes, and then returns. 
        /// </summary>
        public void EndInvoke()
        {
            // This method assumes that only 1 thread calls EndInvoke for this object
            if (!this.IsCompleted)
            {
                // If the operation isn't done, wait for it
                AsyncWaitHandle.WaitOne();
                AsyncWaitHandle.Close();
                this._asyncWaitHandle = null;  // Allow early GC
            }

            this.EndInvokeCalled = true;

            // Operation is done: if an exception occurred, throw it
            if (this._exception != null)
                throw new SshException(this._exception.Message, this._exception);
        }

        #region Implementation of IAsyncResult

        /// <summary>
        /// Gets a user-defined object that qualifies or contains information about an asynchronous operation.
        /// </summary>
        /// <returns>A user-defined object that qualifies or contains information about an asynchronous operation.</returns>
        public Object AsyncState { get { return this._asyncState; } }

        /// <summary>
        /// Gets a value that indicates whether the asynchronous operation completed synchronously.
        /// </summary>
        /// <returns>true if the asynchronous operation completed synchronously; otherwise, false.</returns>
        public Boolean CompletedSynchronously
        {
            get { return this._completedState == _stateCompletedSynchronously; }
        }

        /// <summary>
        /// Gets a <see cref="T:System.Threading.WaitHandle"/> that is used to wait for an asynchronous operation to complete.
        /// </summary>
        /// <returns>A <see cref="T:System.Threading.WaitHandle"/> that is used to wait for an asynchronous operation to complete.</returns>
        public WaitHandle AsyncWaitHandle
        {
            get
            {
                if (this._asyncWaitHandle == null)
                {
                    var done = this.IsCompleted;
                    var mre = new ManualResetEvent(done);
                    if (Interlocked.CompareExchange(ref this._asyncWaitHandle, mre, null) != null)
                    {
                        // Another thread created this object's event; dispose the event we just created
                        mre.Close();
                    }
                    else
                    {
                        if (!done && this.IsCompleted)
                        {
                            // If the operation wasn't done when we created 
                            // the event but now it is done, set the event
                            this._asyncWaitHandle.Set();
                        }
                    }
                }
                return this._asyncWaitHandle;
            }
        }

        /// <summary>
        /// Gets a value that indicates whether the asynchronous operation has completed.
        /// </summary>
        /// <returns>true if the operation is complete; otherwise, false.</returns>
        public Boolean IsCompleted
        {
            get { return this._completedState != _statePending; }
        }
        #endregion
    }

    /// <summary>
    /// Base class to encapsulates the results of an asynchronous operation that returns result.
    /// </summary>
    /// <typeparam name="TResult">The type of the result.</typeparam>
    public abstract class AsyncResult<TResult> : AsyncResult
    {
        // Field set when operation completes
        private TResult _result = default(TResult);

        /// <summary>
        /// Initializes a new instance of the <see cref="AsyncResult&lt;TResult&gt;"/> class.
        /// </summary>
        /// <param name="asyncCallback">The async callback.</param>
        /// <param name="state">The state.</param>
        public AsyncResult(AsyncCallback asyncCallback, Object state)
            : base(asyncCallback, state)
        {
        }

        /// <summary>
        /// Marks asynchronous operation as completed.
        /// </summary>
        /// <param name="result">The result.</param>
        /// <param name="completedSynchronously">if set to <c>true</c> [completed synchronously].</param>
        public void SetAsCompleted(TResult result, Boolean completedSynchronously)
        {
            // Save the asynchronous operation's result
            this._result = result;

            // Tell the base class that the operation completed successfully (no exception)
            base.SetAsCompleted(null, completedSynchronously);
        }

        /// <summary>
        /// Waits until the asynchronous operation completes, and then returns the value generated by the asynchronous operation. 
        /// </summary>
        /// <returns>Invocation result</returns>
        new public TResult EndInvoke()
        {
            base.EndInvoke(); // Wait until operation has completed 
            return _result;  // Return the result (if above didn't throw)
        }
    }
}
#endif
// file ...\X\Renci.SshNet\Common\AuthenticationBannerEventArgs.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Common
{
    /// <summary>
    /// Provides data for <see cref="Renci.SshNet.ConnectionInfo.AuthenticationBanner"/> event.
    /// </summary>
    public class AuthenticationBannerEventArgs : AuthenticationEventArgs
    {
        /// <summary>
        /// Gets banner message.
        /// </summary>
        public string BannerMessage { get; private set; }

        /// <summary>
        /// Gets banner language.
        /// </summary>
        public string Language { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthenticationBannerEventArgs"/> class.
        /// </summary>
        /// <param name="username">The username.</param>
        /// <param name="message">Banner message.</param>
        /// <param name="language">Banner language.</param>
        public AuthenticationBannerEventArgs(string username, string message, string language)
            : base(username)
        {
            this.BannerMessage = message;
            this.Language = language;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\AuthenticationEventArgs.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// Base class for authentication events.
    /// </summary>
    public abstract class AuthenticationEventArgs : EventArgs
    {
        /// <summary>
        /// Gets the username.
        /// </summary>
        public string Username { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthenticationEventArgs"/> class.
        /// </summary>
        /// <param name="username">The username.</param>
        public AuthenticationEventArgs(string username)
        {
            this.Username = username;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\AuthenticationPasswordChangeEventArgs.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Common
{
    /// <summary>
    /// Provides data for <see cref="Renci.SshNet.PasswordConnectionInfo.PasswordExpired"/> event.
    /// </summary>
    public class AuthenticationPasswordChangeEventArgs : AuthenticationEventArgs
    {
        /// <summary>
        /// Gets or sets the new password.
        /// </summary>
        /// <value>
        /// The new password.
        /// </value>
        public byte[] NewPassword { get; set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthenticationPasswordChangeEventArgs"/> class.
        /// </summary>
        /// <param name="username">The username.</param>
        public AuthenticationPasswordChangeEventArgs(string username)
            : base(username)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\AuthenticationPrompt.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Common
{
    /// <summary>
    /// Provides prompt information when <see cref="Renci.SshNet.KeyboardInteractiveConnectionInfo.AuthenticationPrompt"/> is raised
    /// </summary>
    public class AuthenticationPrompt
    {
        /// <summary>
        /// Gets the prompt sequence id.
        /// </summary>
        public int Id { get; private set; }

        /// <summary>
        /// Gets or sets a value indicating whether the user input should be echoed as characters are typed.
        /// </summary>
        /// <value>
        ///   <c>true</c> if the user input should be echoed as characters are typed; otherwise, <c>false</c>.
        /// </value>
        public bool IsEchoed { get; private set; }

        /// <summary>
        /// Gets server information request.
        /// </summary>
        public string Request { get; private set; }

        /// <summary>
        /// Gets or sets server information response.
        /// </summary>
        /// <value>
        /// The response.
        /// </value>
        public string Response { get; set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthenticationPrompt"/> class.
        /// </summary>
        /// <param name="id">The sequence id.</param>
        /// <param name="isEchoed">if set to <c>true</c> the user input should be echoed.</param>
        /// <param name="request">The request.</param>
        public AuthenticationPrompt(int id, bool isEchoed, string request)
        {
            this.Id = id;
            this.IsEchoed = isEchoed;
            this.Request = request;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\AuthenticationPromptEventArgs.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// Provides data for <see cref="Renci.SshNet.KeyboardInteractiveConnectionInfo.AuthenticationPrompt"/> event.
    /// </summary>
    public class AuthenticationPromptEventArgs : AuthenticationEventArgs
    {
        /// <summary>
        /// Gets prompt language.
        /// </summary>
        public string Language { get; private set; }

        /// <summary>
        /// Gets prompt instruction.
        /// </summary>
        public string Instruction { get; private set; }

        /// <summary>
        /// Gets server information request prompts.
        /// </summary>
        public IEnumerable<AuthenticationPrompt> Prompts { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="AuthenticationPromptEventArgs"/> class.
        /// </summary>
        /// <param name="username">The username.</param>
        /// <param name="instruction">The instruction.</param>
        /// <param name="language">The language.</param>
        /// <param name="prompts">The information request prompts.</param>
        public AuthenticationPromptEventArgs(string username, string instruction, string language, IEnumerable<AuthenticationPrompt> prompts)
            : base(username)
        {
            this.Instruction = instruction;
            this.Language = language;
            this.Prompts = prompts;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\BigInteger.cs
#if !MOBILE && !CORE
// vim: noet
// System.Numerics.BigInt
//
// Rodrigo Kumpera (rkumpera@novell.com)

//
// Copyright (C) 2010 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// A big chuck of code comes the DLR (as hosted in http://ironpython.codeplex.com),
// which has the following License:
//
/* ****************************************************************************
*
* Copyright (c) Microsoft Corporation.
*
* This source code is subject to terms and conditions of the Microsoft Public License. A
* copy of the license can be found in the License.html file at the root of this distribution. If
* you cannot locate the Microsoft Public License, please send an email to
* dlr@microsoft.com. By using this source code in any fashion, you are agreeing to be bound
* by the terms of the Microsoft Public License.
*
* You must not remove this notice, or any other, from this software.
*
*
* ***************************************************************************/


/*
Optimization
Have proper popcount function for IsPowerOfTwo
Use unsafe ops to avoid bounds check
CoreAdd could avoid some resizes by checking for equal sized array that top overflow
For bitwise operators, hoist the conditionals out of their main loop
Optimize BitScanBackward
Use a carry variable to make shift opts do half the number of array ops.
Schoolbook multiply is O(n^2), use Karatsuba /Toom-3 for large numbers
*/
namespace Renci.SshNet.Common
{
    /// <summary>
    /// Represents an arbitrarily large signed integer.
    /// </summary>
    public struct BigInteger : IComparable, IFormattable, IComparable<BigInteger>, IEquatable<BigInteger>
    {
        private static readonly RNGCryptoServiceProvider _randomizer = new RNGCryptoServiceProvider();

        private const ulong _BASE = 0x100000000;
        private const Int32 _DECIMALSIGNMASK = unchecked((Int32)0x80000000);
        private const int _BIAS = 1075;

        private static readonly uint[] _zero = new uint[1];
        private static readonly uint[] _one = new uint[] { 1 };

        //LSB on [0]
        private readonly uint[] _data;
        private readonly short _sign;

        /// <summary>
        /// Gets number of bits used by the number.
        /// </summary>
        /// <value>
        /// The number of the bit used.
        /// </value>
        public int BitLength
        {
            get
            {
                if (this._sign == 0)
                    return 0;

                var msbIndex = this._data.Length - 1;

                while (this._data[msbIndex] == 0)
                    msbIndex--;

                var msbBitCount = BitScanBackward(this._data[msbIndex]) + 1;

                return msbIndex * 4 * 8 + msbBitCount + ((this._sign > 0) ? 0 : 1);
            }
        }

        #region Constractors

        /// <summary>
        /// Initializes a new instance of the <see cref="BigInteger"/> struct.
        /// </summary>
        /// <param name="sign">The sign.</param>
        /// <param name="data">The data.</param>
        public BigInteger(short sign, uint[] data)
        {
            this._sign = sign;
            this._data = data;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BigInteger"/> struct.
        /// </summary>
        /// <param name="value">The value.</param>
        public BigInteger(int value)
        {
            if (value == 0)
            {
                this._sign = 0;
                this._data = _zero;
            }
            else if (value > 0)
            {
                this._sign = 1;
                this._data = new uint[] { (uint)value };
            }
            else
            {
                this._sign = -1;
                this._data = new uint[1] { (uint)-value };
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BigInteger"/> struct.
        /// </summary>
        /// <param name="value">The value.</param>
        public BigInteger(uint value)
        {
            if (value == 0)
            {
                this._sign = 0;
                this._data = _zero;
            }
            else
            {
                this._sign = 1;
                this._data = new uint[1] { value };
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BigInteger"/> struct.
        /// </summary>
        /// <param name="value">The value.</param>
        public BigInteger(long value)
        {
            if (value == 0)
            {
                this._sign = 0;
                this._data = _zero;
            }
            else if (value > 0)
            {
                this._sign = 1;
                uint low = (uint)value;
                uint high = (uint)(value >> 32);

                this._data = new uint[high != 0 ? 2 : 1];
                this._data[0] = low;
                if (high != 0)
                    this._data[1] = high;
            }
            else
            {
                this._sign = -1;
                value = -value;
                uint low = (uint)value;
                uint high = (uint)((ulong)value >> 32);

                this._data = new uint[high != 0 ? 2 : 1];
                this._data[0] = low;
                if (high != 0)
                    this._data[1] = high;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BigInteger"/> struct.
        /// </summary>
        /// <param name="value">The value.</param>
        public BigInteger(ulong value)
        {
            if (value == 0)
            {
                this._sign = 0;
                this._data = _zero;
            }
            else
            {
                this._sign = 1;
                uint low = (uint)value;
                uint high = (uint)(value >> 32);

                this._data = new uint[high != 0 ? 2 : 1];
                this._data[0] = low;
                if (high != 0)
                    this._data[1] = high;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BigInteger"/> struct.
        /// </summary>
        /// <param name="value">The value.</param>
        public BigInteger(double value)
        {
            if (double.IsNaN(value) || Double.IsInfinity(value))
                throw new OverflowException();

            byte[] bytes = BitConverter.GetBytes(value);
            ulong mantissa = Mantissa(bytes);
            if (mantissa == 0)
            {
                // 1.0 * 2**exp, we have a power of 2
                int exponent = Exponent(bytes);
                if (exponent == 0)
                {
                    this._sign = 0;
                    this._data = _zero;
                    return;
                }

                BigInteger res = Negative(bytes) ? MinusOne : One;
                res = res << (exponent - 0x3ff);
                this._sign = res._sign;
                this._data = res._data;
            }
            else
            {
                // 1.mantissa * 2**exp
                int exponent = Exponent(bytes);
                mantissa |= 0x10000000000000ul;
                BigInteger res = mantissa;
                res = exponent > _BIAS ? res << (exponent - _BIAS) : res >> (_BIAS - exponent);

                this._sign = (short)(Negative(bytes) ? -1 : 1);
                this._data = res._data;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BigInteger"/> struct.
        /// </summary>
        /// <param name="value">The value.</param>
        public BigInteger(float value)
            : this((double)value)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BigInteger"/> struct.
        /// </summary>
        /// <param name="value">The value.</param>
        public BigInteger(decimal value)
        {
            // First truncate to get scale to 0 and extract bits
            int[] bits = Decimal.GetBits(Decimal.Truncate(value));

            int size = 3;
            while (size > 0 && bits[size - 1] == 0) size--;

            if (size == 0)
            {
                this._sign = 0;
                this._data = _zero;
                return;
            }

            this._sign = (short)((bits[3] & _DECIMALSIGNMASK) != 0 ? -1 : 1);

            this._data = new uint[size];
            this._data[0] = (uint)bits[0];
            if (size > 1)
                this._data[1] = (uint)bits[1];
            if (size > 2)
                this._data[2] = (uint)bits[2];
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BigInteger"/> struct.
        /// </summary>
        /// <param name="value">The value.</param>
        public BigInteger(byte[] value)
        {
            if (value == null)
                throw new ArgumentNullException("value");

            int len = value.Length;

            if (len == 0 || (len == 1 && value[0] == 0))
            {
                this._sign = 0;
                this._data = _zero;
                return;
            }

            if ((value[len - 1] & 0x80) != 0)
                this._sign = -1;
            else
                this._sign = 1;

            if (this._sign == 1)
            {
                while (value[len - 1] == 0)
                    --len;

                int full_words, size;
                full_words = size = len / 4;
                if ((len & 0x3) != 0)
                    ++size;

                this._data = new uint[size];
                int j = 0;
                for (int i = 0; i < full_words; ++i)
                {
                    this._data[i] = (uint)value[j++] |
                    (uint)(value[j++] << 8) |
                    (uint)(value[j++] << 16) |
                    (uint)(value[j++] << 24);
                }
                size = len & 0x3;
                if (size > 0)
                {
                    int idx = this._data.Length - 1;
                    for (int i = 0; i < size; ++i)
                        this._data[idx] |= (uint)(value[j++] << (i * 8));
                }
            }
            else
            {
                int full_words, size;
                full_words = size = len / 4;
                if ((len & 0x3) != 0)
                    ++size;

                this._data = new uint[size];

                uint word, borrow = 1;
                ulong sub = 0;
                int j = 0;

                for (int i = 0; i < full_words; ++i)
                {
                    word = (uint)value[j++] |
                    (uint)(value[j++] << 8) |
                    (uint)(value[j++] << 16) |
                    (uint)(value[j++] << 24);

                    sub = (ulong)word - borrow;
                    word = (uint)sub;
                    borrow = (uint)(sub >> 32) & 0x1u;
                    this._data[i] = ~word;
                }
                size = len & 0x3;

                if (size > 0)
                {
                    word = 0;
                    uint store_mask = 0;
                    for (int i = 0; i < size; ++i)
                    {
                        word |= (uint)(value[j++] << (i * 8));
                        store_mask = (store_mask << 8) | 0xFF;
                    }

                    sub = word - borrow;
                    word = (uint)sub;
                    borrow = (uint)(sub >> 32) & 0x1u;

                    this._data[this._data.Length - 1] = ~word & store_mask;
                }
                if (borrow != 0) //FIXME I believe this can't happen, can someone write a test for it?
                    throw new Exception("non zero final carry");
            }

        }


        #endregion

        #region Operators

        /// <summary>
        /// Defines an explicit conversion of a System.Numerics.BigInteger object to a 32-bit signed integer value.
        /// </summary>
        /// <param name="value">The value to convert to a 32-bit signed integer.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static explicit operator int(BigInteger value)
        {
            int r;
            if (!value.AsInt32(out r))
                throw new OverflowException();
            return r;
        }

        /// <summary>
        /// Defines an explicit conversion of a System.Numerics.BigInteger object to an unsigned 32-bit integer value.
        /// </summary>
        /// <param name="value">The value to convert to an unsigned 32-bit integer.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static explicit operator uint(BigInteger value)
        {
            if (value._data.Length > 1 || value._sign == -1)
                throw new OverflowException();
            return value._data[0];
        }

        /// <summary>
        /// Defines an explicit conversion of a System.Numerics.BigInteger object to a 16-bit signed integer value.
        /// </summary>
        /// <param name="value">The value to convert to a 16-bit signed integer.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static explicit operator short(BigInteger value)
        {
            int val = (int)value;
            if (val < short.MinValue || val > short.MaxValue)
                throw new OverflowException();
            return (short)val;
        }

        /// <summary>
        /// Defines an explicit conversion of a System.Numerics.BigInteger object to an unsigned 16-bit integer value.
        /// </summary>
        /// <param name="value">The value to convert to an unsigned 16-bit integer.</param>
        /// <returns>
        /// An object that contains the value of the value parameter
        /// </returns>
        public static explicit operator ushort(BigInteger value)
        {
            uint val = (uint)value;
            if (val > ushort.MaxValue)
                throw new OverflowException();
            return (ushort)val;
        }

        /// <summary>
        /// Defines an explicit conversion of a System.Numerics.BigInteger object to an unsigned byte value.
        /// </summary>
        /// <param name="value">The value to convert to a System.Byte.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static explicit operator byte(BigInteger value)
        {
            uint val = (uint)value;
            if (val > byte.MaxValue)
                throw new OverflowException();
            return (byte)val;
        }

        /// <summary>
        /// Defines an explicit conversion of a System.Numerics.BigInteger object to a signed 8-bit value.
        /// </summary>
        /// <param name="value">The value to convert to a signed 8-bit value.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static explicit operator sbyte(BigInteger value)
        {
            int val = (int)value;
            if (val < sbyte.MinValue || val > sbyte.MaxValue)
                throw new OverflowException();
            return (sbyte)val;
        }

        /// <summary>
        /// Defines an explicit conversion of a System.Numerics.BigInteger object to a 64-bit signed integer value.
        /// </summary>
        /// <param name="value">The value to convert to a 64-bit signed integer.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static explicit operator long(BigInteger value)
        {
            if (value._sign == 0)
                return 0;

            if (value._data.Length > 2)
                throw new OverflowException();

            uint low = value._data[0];

            if (value._data.Length == 1)
            {
                if (value._sign == 1)
                    return (long)low;
                long res = (long)low;
                return -res;
            }

            uint high = value._data[1];

            if (value._sign == 1)
            {
                if (high >= 0x80000000u)
                    throw new OverflowException();
                return (((long)high) << 32) | low;
            }

            if (high > 0x80000000u)
                throw new OverflowException();

            return -((((long)high) << 32) | (long)low);
        }

        /// <summary>
        /// Defines an explicit conversion of a System.Numerics.BigInteger object to an unsigned 64-bit integer value.
        /// </summary>
        /// <param name="value">The value to convert to an unsigned 64-bit integer.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static explicit operator ulong(BigInteger value)
        {
            if (value._data.Length > 2 || value._sign == -1)
                throw new OverflowException();

            uint low = value._data[0];
            if (value._data.Length == 1)
                return low;

            uint high = value._data[1];
            return (((ulong)high) << 32) | low;
        }

        /// <summary>
        /// Defines an explicit conversion of a System.Numerics.BigInteger object to a <see cref="System.Double"/> value.
        /// </summary>
        /// <param name="value">The value to convert to a <see cref="System.Double"/>.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static explicit operator double(BigInteger value)
        {
            //FIXME
            try
            {
                return double.Parse(value.ToString(),
                     System.Globalization.CultureInfo.InvariantCulture.NumberFormat);
            }
            catch (OverflowException)
            {
                return value._sign == -1 ? double.NegativeInfinity : double.PositiveInfinity;
            }
        }

        /// <summary>
        /// Defines an explicit conversion of a System.Numerics.BigInteger object to a single-precision floating-point value.
        /// </summary>
        /// <param name="value">The value to convert to a single-precision floating-point value.</param>
        /// <returns>
        /// An object that contains the closest possible representation of the value parameter.
        /// </returns>
        public static explicit operator float(BigInteger value)
        {
            //FIXME
            try
            {
                return float.Parse(value.ToString(),
                System.Globalization.CultureInfo.InvariantCulture.NumberFormat);
            }
            catch (OverflowException)
            {
                return value._sign == -1 ? float.NegativeInfinity : float.PositiveInfinity;
            }
        }

        /// <summary>
        /// Defines an explicit conversion of a System.Numerics.BigInteger object to a <see cref="System.Decimal"/> value.
        /// </summary>
        /// <param name="value">The value to convert to a <see cref="System.Decimal"/>.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static explicit operator decimal(BigInteger value)
        {
            if (value._sign == 0)
                return Decimal.Zero;

            uint[] data = value._data;
            if (data.Length > 3)
                throw new OverflowException();

            int lo = 0, mi = 0, hi = 0;
            if (data.Length > 2)
                hi = (Int32)data[2];
            if (data.Length > 1)
                mi = (Int32)data[1];
            if (data.Length > 0)
                lo = (Int32)data[0];

            return new Decimal(lo, mi, hi, value._sign < 0, 0);
        }

        /// <summary>
        /// Defines an implicit conversion of a signed 32-bit integer to a System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="value">The value to convert to a System.Numerics.BigInteger.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static implicit operator BigInteger(int value)
        {
            return new BigInteger(value);
        }

        /// <summary>
        /// Defines an implicit conversion of a 32-bit unsigned integer to a System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="value">The value to convert to a System.Numerics.BigInteger.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static implicit operator BigInteger(uint value)
        {
            return new BigInteger(value);
        }

        /// <summary>
        /// Defines an implicit conversion of a signed 16-bit integer to a System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="value">The value to convert to a System.Numerics.BigInteger.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static implicit operator BigInteger(short value)
        {
            return new BigInteger(value);
        }

        /// <summary>
        /// Defines an implicit conversion of a 16-bit unsigned integer to a System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="value">The value to convert to a System.Numerics.BigInteger.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static implicit operator BigInteger(ushort value)
        {
            return new BigInteger(value);
        }

        /// <summary>
        /// Defines an implicit conversion of an unsigned byte to a System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="value">The value to convert to a System.Numerics.BigInteger.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static implicit operator BigInteger(byte value)
        {
            return new BigInteger(value);
        }

        /// <summary>
        /// Defines an implicit conversion of an 8-bit signed integer to a System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="value">The value to convert to a System.Numerics.BigInteger.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static implicit operator BigInteger(sbyte value)
        {
            return new BigInteger(value);
        }

        /// <summary>
        /// Defines an implicit conversion of a signed 64-bit integer to a System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="value">The value to convert to a System.Numerics.BigInteger.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static implicit operator BigInteger(long value)
        {
            return new BigInteger(value);
        }

        /// <summary>
        /// Defines an implicit conversion of a 64-bit unsigned integer to a System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="value">The value to convert to a System.Numerics.BigInteger.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static implicit operator BigInteger(ulong value)
        {
            return new BigInteger(value);
        }

        /// <summary>
        /// Defines an explicit conversion of a <see cref="System.Double"/> value to a System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="value">The value to convert to a System.Numerics.BigInteger.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static explicit operator BigInteger(double value)
        {
            return new BigInteger(value);
        }

        /// <summary>
        /// Defines an explicit conversion of a <see cref="System.Single"/> object to a System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="value">The value to convert to a System.Numerics.BigInteger.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static explicit operator BigInteger(float value)
        {
            return new BigInteger(value);
        }

        /// <summary>
        /// Defines an explicit conversion of a <see cref="System.Decimal"/> object to a System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="value">The value to convert to a System.Numerics.BigInteger.</param>
        /// <returns>
        /// An object that contains the value of the value parameter.
        /// </returns>
        public static explicit operator BigInteger(decimal value)
        {
            return new BigInteger(value);
        }

        /// <summary>
        /// Adds the values of two specified <see cref="BigInteger"/> objects.
        /// </summary>
        /// <param name="left">The first value to add.</param>
        /// <param name="right">The second value to add.</param>
        /// <returns>
        /// The sum of left and right.
        /// </returns>
        public static BigInteger operator +(BigInteger left, BigInteger right)
        {
            if (left._sign == 0)
                return right;
            if (right._sign == 0)
                return left;

            if (left._sign == right._sign)
                return new BigInteger(left._sign, CoreAdd(left._data, right._data));

            int r = CoreCompare(left._data, right._data);

            if (r == 0)
                return new BigInteger(0, _zero);

            if (r > 0) //left > right
                return new BigInteger(left._sign, CoreSub(left._data, right._data));

            return new BigInteger(right._sign, CoreSub(right._data, left._data));
        }

        /// <summary>
        /// Subtracts a <see cref="BigInteger"/> value from another <see cref="BigInteger"/> value.
        /// </summary>
        /// <param name="left">The value to subtract from (the minuend).</param>
        /// <param name="right">The value to subtract (the subtrahend).</param>
        /// <returns>
        /// The result of subtracting right from left.
        /// </returns>
        public static BigInteger operator -(BigInteger left, BigInteger right)
        {
            if (right._sign == 0)
                return left;
            if (left._sign == 0)
                return new BigInteger((short)-right._sign, right._data);

            if (left._sign == right._sign)
            {
                int r = CoreCompare(left._data, right._data);

                if (r == 0)
                    return new BigInteger(0, _zero);

                if (r > 0) //left > right
                    return new BigInteger(left._sign, CoreSub(left._data, right._data));

                return new BigInteger((short)-right._sign, CoreSub(right._data, left._data));
            }

            return new BigInteger(left._sign, CoreAdd(left._data, right._data));
        }

        /// <summary>
        /// Multiplies two specified <see cref="BigInteger"/> values.
        /// </summary>
        /// <param name="left">The first value to multiply.</param>
        /// <param name="right">The second value to multiply.</param>
        /// <returns>
        /// The product of left and right.
        /// </returns>
        public static BigInteger operator *(BigInteger left, BigInteger right)
        {
            if (left._sign == 0 || right._sign == 0)
                return new BigInteger(0, _zero);

            if (left._data[0] == 1 && left._data.Length == 1)
            {
                if (left._sign == 1)
                    return right;
                return new BigInteger((short)-right._sign, right._data);
            }

            if (right._data[0] == 1 && right._data.Length == 1)
            {
                if (right._sign == 1)
                    return left;
                return new BigInteger((short)-left._sign, left._data);
            }

            uint[] a = left._data;
            uint[] b = right._data;

            uint[] res = new uint[a.Length + b.Length];

            for (int i = 0; i < a.Length; ++i)
            {
                uint ai = a[i];
                int k = i;

                ulong carry = 0;
                for (int j = 0; j < b.Length; ++j)
                {
                    carry = carry + ((ulong)ai) * b[j] + res[k];
                    res[k++] = (uint)carry;
                    carry >>= 32;
                }

                while (carry != 0)
                {
                    carry += res[k];
                    res[k++] = (uint)carry;
                    carry >>= 32;
                }
            }

            int m;
            for (m = res.Length - 1; m >= 0 && res[m] == 0; --m) ;
            if (m < res.Length - 1)
                res = Resize(res, m + 1);

            return new BigInteger((short)(left._sign * right._sign), res);
        }

        /// <summary>
        /// Divides a specified <see cref="BigInteger"/> value by another specified <see cref="BigInteger"/> value by using integer division.
        /// </summary>
        /// <param name="dividend">The value to be divided.</param>
        /// <param name="divisor">The value to divide by.</param>
        /// <returns>
        /// The integral result of the division.
        /// </returns>
        public static BigInteger operator /(BigInteger dividend, BigInteger divisor)
        {
            if (divisor._sign == 0)
                throw new DivideByZeroException();

            if (dividend._sign == 0)
                return dividend;

            uint[] quotient;
            uint[] remainder_value;

            DivModUnsigned(dividend._data, divisor._data, out quotient, out remainder_value);

            int i;
            for (i = quotient.Length - 1; i >= 0 && quotient[i] == 0; --i) ;
            if (i == -1)
                return new BigInteger(0, _zero);
            if (i < quotient.Length - 1)
                quotient = Resize(quotient, i + 1);

            return new BigInteger((short)(dividend._sign * divisor._sign), quotient);
        }

        /// <summary>
        /// Returns the remainder that results from division with two specified <see cref="BigInteger"/> values.
        /// </summary>
        /// <param name="dividend">The value to be divided.</param>
        /// <param name="divisor">The value to divide by.</param>
        /// <returns>
        /// The remainder that results from the division.
        /// </returns>
        public static BigInteger operator %(BigInteger dividend, BigInteger divisor)
        {
            if (divisor._sign == 0)
                throw new DivideByZeroException();

            if (dividend._sign == 0)
                return dividend;

            uint[] quotient;
            uint[] remainder_value;

            DivModUnsigned(dividend._data, divisor._data, out quotient, out remainder_value);

            int i;
            for (i = remainder_value.Length - 1; i >= 0 && remainder_value[i] == 0; --i) ;
            if (i == -1)
                return new BigInteger(0, _zero);

            if (i < remainder_value.Length - 1)
                remainder_value = Resize(remainder_value, i + 1);
            return new BigInteger(dividend._sign, remainder_value);
        }

        /// <summary>
        /// Negates a specified BigInteger value.
        /// </summary>
        /// <param name="value">The value to negate.</param>
        /// <returns>
        /// The result of the value parameter multiplied by negative one (-1).
        /// </returns>
        public static BigInteger operator -(BigInteger value)
        {
            if (value._sign == 0)
                return value;
            return new BigInteger((short)-value._sign, value._data);
        }

        /// <summary>
        /// Returns the value of the <see cref="BigInteger"/> operand. (The sign of the operand is unchanged.)
        /// </summary>
        /// <param name="value">An integer value.</param>
        /// <returns>
        /// The value of the value operand.
        /// </returns>
        public static BigInteger operator +(BigInteger value)
        {
            return value;
        }

        /// <summary>
        /// Increments a <see cref="BigInteger"/> value by 1.
        /// </summary>
        /// <param name="value">The value to increment.</param>
        /// <returns>
        /// The value of the value parameter incremented by 1.
        /// </returns>
        public static BigInteger operator ++(BigInteger value)
        {
            short sign = value._sign;
            uint[] data = value._data;
            if (data.Length == 1)
            {
                if (sign == -1 && data[0] == 1)
                    return new BigInteger(0, _zero);
                if (sign == 0)
                    return new BigInteger(1, _one);
            }

            if (sign == -1)
                data = CoreSub(data, 1);
            else
                data = CoreAdd(data, 1);

            return new BigInteger(sign, data);
        }

        /// <summary>
        /// Decrements a <see cref="BigInteger"/> value by 1.
        /// </summary>
        /// <param name="value">The value to decrement.</param>
        /// <returns>
        /// The value of the value parameter decremented by 1.
        /// </returns>
        public static BigInteger operator --(BigInteger value)
        {
            short sign = value._sign;
            uint[] data = value._data;
            if (data.Length == 1)
            {
                if (sign == 1 && data[0] == 1)
                    return new BigInteger(0, _zero);
                if (sign == 0)
                    return new BigInteger(-1, _one);
            }

            if (sign == -1)
                data = CoreAdd(data, 1);
            else
                data = CoreSub(data, 1);

            return new BigInteger(sign, data);
        }

        /// <summary>
        /// Performs a bitwise And operation on two <see cref="BigInteger"/> values.
        /// </summary>
        /// <param name="left">The first value.</param>
        /// <param name="right">The second value.</param>
        /// <returns>
        /// The result of the bitwise And operation.
        /// </returns>
        public static BigInteger operator &(BigInteger left, BigInteger right)
        {
            if (left._sign == 0)
                return left;

            if (right._sign == 0)
                return right;

            uint[] a = left._data;
            uint[] b = right._data;
            int ls = left._sign;
            int rs = right._sign;

            bool neg_res = (ls == rs) && (ls == -1);

            uint[] result = new uint[Math.Max(a.Length, b.Length)];

            ulong ac = 1, bc = 1, borrow = 1;

            int i;
            for (i = 0; i < result.Length; ++i)
            {
                uint va = 0;
                if (i < a.Length)
                    va = a[i];
                if (ls == -1)
                {
                    ac = ~va + ac;
                    va = (uint)ac;
                    ac = (uint)(ac >> 32);
                }

                uint vb = 0;
                if (i < b.Length)
                    vb = b[i];
                if (rs == -1)
                {
                    bc = ~vb + bc;
                    vb = (uint)bc;
                    bc = (uint)(bc >> 32);
                }

                uint word = va & vb;

                if (neg_res)
                {
                    borrow = word - borrow;
                    word = ~(uint)borrow;
                    borrow = (uint)(borrow >> 32) & 0x1u;
                }

                result[i] = word;
            }

            for (i = result.Length - 1; i >= 0 && result[i] == 0; --i) ;
            if (i == -1)
                return new BigInteger(0, _zero);

            if (i < result.Length - 1)
                result = Resize(result, i + 1);

            return new BigInteger(neg_res ? (short)-1 : (short)1, result);
        }

        /// <summary>
        /// Performs a bitwise Or operation on two <see cref="BigInteger"/> values.
        /// </summary>
        /// <param name="left">The first value.</param>
        /// <param name="right">The second value.</param>
        /// <returns>
        /// The result of the bitwise Or operation.
        /// </returns>
        public static BigInteger operator |(BigInteger left, BigInteger right)
        {
            if (left._sign == 0)
                return right;

            if (right._sign == 0)
                return left;

            uint[] a = left._data;
            uint[] b = right._data;
            int ls = left._sign;
            int rs = right._sign;

            bool neg_res = (ls == -1) || (rs == -1);

            uint[] result = new uint[Math.Max(a.Length, b.Length)];

            ulong ac = 1, bc = 1, borrow = 1;

            int i;
            for (i = 0; i < result.Length; ++i)
            {
                uint va = 0;
                if (i < a.Length)
                    va = a[i];
                if (ls == -1)
                {
                    ac = ~va + ac;
                    va = (uint)ac;
                    ac = (uint)(ac >> 32);
                }

                uint vb = 0;
                if (i < b.Length)
                    vb = b[i];
                if (rs == -1)
                {
                    bc = ~vb + bc;
                    vb = (uint)bc;
                    bc = (uint)(bc >> 32);
                }

                uint word = va | vb;

                if (neg_res)
                {
                    borrow = word - borrow;
                    word = ~(uint)borrow;
                    borrow = (uint)(borrow >> 32) & 0x1u;
                }

                result[i] = word;
            }

            for (i = result.Length - 1; i >= 0 && result[i] == 0; --i) ;
            if (i == -1)
                return new BigInteger(0, _zero);

            if (i < result.Length - 1)
                result = Resize(result, i + 1);

            return new BigInteger(neg_res ? (short)-1 : (short)1, result);
        }

        /// <summary>
        /// Performs a bitwise exclusive Or (XOr) operation on two <see cref="BigInteger"/> values.
        /// </summary>
        /// <param name="left">The first value.</param>
        /// <param name="right">The second value.</param>
        /// <returns>
        /// The result of the bitwise Or operation.
        /// </returns>
        public static BigInteger operator ^(BigInteger left, BigInteger right)
        {
            if (left._sign == 0)
                return right;

            if (right._sign == 0)
                return left;

            uint[] a = left._data;
            uint[] b = right._data;
            int ls = left._sign;
            int rs = right._sign;

            bool neg_res = (ls == -1) ^ (rs == -1);

            uint[] result = new uint[Math.Max(a.Length, b.Length)];

            ulong ac = 1, bc = 1, borrow = 1;

            int i;
            for (i = 0; i < result.Length; ++i)
            {
                uint va = 0;
                if (i < a.Length)
                    va = a[i];
                if (ls == -1)
                {
                    ac = ~va + ac;
                    va = (uint)ac;
                    ac = (uint)(ac >> 32);
                }

                uint vb = 0;
                if (i < b.Length)
                    vb = b[i];
                if (rs == -1)
                {
                    bc = ~vb + bc;
                    vb = (uint)bc;
                    bc = (uint)(bc >> 32);
                }

                uint word = va ^ vb;

                if (neg_res)
                {
                    borrow = word - borrow;
                    word = ~(uint)borrow;
                    borrow = (uint)(borrow >> 32) & 0x1u;
                }

                result[i] = word;
            }

            for (i = result.Length - 1; i >= 0 && result[i] == 0; --i) ;
            if (i == -1)
                return new BigInteger(0, _zero);

            if (i < result.Length - 1)
                result = Resize(result, i + 1);

            return new BigInteger(neg_res ? (short)-1 : (short)1, result);
        }

        /// <summary>
        /// Returns the bitwise one's complement of a <see cref="BigInteger"/> value.
        /// </summary>
        /// <param name="value">An integer value.</param>
        /// <returns>
        /// The bitwise one's complement of value.
        /// </returns>
        public static BigInteger operator ~(BigInteger value)
        {
            if (value._sign == 0)
                return new BigInteger(-1, _one);

            uint[] data = value._data;
            int sign = value._sign;

            bool neg_res = sign == 1;

            uint[] result = new uint[data.Length];

            ulong carry = 1, borrow = 1;

            int i;
            for (i = 0; i < result.Length; ++i)
            {
                uint word = data[i];
                if (sign == -1)
                {
                    carry = ~word + carry;
                    word = (uint)carry;
                    carry = (uint)(carry >> 32);
                }

                word = ~word;

                if (neg_res)
                {
                    borrow = word - borrow;
                    word = ~(uint)borrow;
                    borrow = (uint)(borrow >> 32) & 0x1u;
                }

                result[i] = word;
            }

            for (i = result.Length - 1; i >= 0 && result[i] == 0; --i) ;
            if (i == -1)
                return new BigInteger(0, _zero);

            if (i < result.Length - 1)
                result = Resize(result, i + 1);

            return new BigInteger(neg_res ? (short)-1 : (short)1, result);
        }

        /// <summary>
        /// Shifts a <see cref="BigInteger"/> value a specified number of bits to the left.
        /// </summary>
        /// <param name="value">The value whose bits are to be shifted.</param>
        /// <param name="shift">The number of bits to shift value to the left.</param>
        /// <returns>
        /// A value that has been shifted to the left by the specified number of bits.
        /// </returns>
        public static BigInteger operator <<(BigInteger value, int shift)
        {
            if (shift == 0 || value._sign == 0)
                return value;
            if (shift < 0)
                return value >> -shift;

            uint[] data = value._data;
            int sign = value._sign;

            int topMostIdx = BitScanBackward(data[data.Length - 1]);
            int bits = shift - (31 - topMostIdx);
            int extra_words = (bits >> 5) + ((bits & 0x1F) != 0 ? 1 : 0);

            uint[] res = new uint[data.Length + extra_words];

            int idx_shift = shift >> 5;
            int bit_shift = shift & 0x1F;
            int carry_shift = 32 - bit_shift;

            for (int i = 0; i < data.Length; ++i)
            {
                uint word = data[i];
                res[i + idx_shift] |= word << bit_shift;
                if (i + idx_shift + 1 < res.Length)
                    res[i + idx_shift + 1] = word >> carry_shift;
            }

            return new BigInteger((short)sign, res);
        }

        /// <summary>
        /// Shifts a System.Numerics.BigInteger value a specified number of bits to the right.
        /// </summary>
        /// <param name="value">The value whose bits are to be shifted.</param>
        /// <param name="shift">The number of bits to shift value to the right.</param>
        /// <returns>
        /// A value that has been shifted to the right by the specified number of bits.
        /// </returns>
        public static BigInteger operator >>(BigInteger value, int shift)
        {
            if (shift == 0 || value._sign == 0)
                return value;
            if (shift < 0)
                return value << -shift;

            uint[] data = value._data;
            int sign = value._sign;

            int topMostIdx = BitScanBackward(data[data.Length - 1]);
            int idx_shift = shift >> 5;
            int bit_shift = shift & 0x1F;

            int extra_words = idx_shift;
            if (bit_shift > topMostIdx)
                ++extra_words;
            int size = data.Length - extra_words;

            if (size <= 0)
            {
                if (sign == 1)
                    return new BigInteger(0, _zero);
                return new BigInteger(-1, _one);
            }

            uint[] res = new uint[size];
            int carry_shift = 32 - bit_shift;

            for (int i = data.Length - 1; i >= idx_shift; --i)
            {
                uint word = data[i];

                if (i - idx_shift < res.Length)
                    res[i - idx_shift] |= word >> bit_shift;
                if (i - idx_shift - 1 >= 0)
                    res[i - idx_shift - 1] = word << carry_shift;
            }

            //Round down instead of toward zero
            if (sign == -1)
            {
                for (int i = 0; i < idx_shift; i++)
                {
                    if (data[i] != 0u)
                    {
                        var tmp = new BigInteger((short)sign, res);
                        --tmp;
                        return tmp;
                    }
                }
                if (bit_shift > 0 && (data[idx_shift] << carry_shift) != 0u)
                {
                    var tmp = new BigInteger((short)sign, res);
                    --tmp;
                    return tmp;
                }
            }
            return new BigInteger((short)sign, res);
        }

        /// <summary>
        /// Returns a value that indicates whether a <see cref="BigInteger"/> value is less than another <see cref="BigInteger"/> value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is less than right; otherwise, false.
        /// </returns>
        public static bool operator <(BigInteger left, BigInteger right)
        {
            return Compare(left, right) < 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a <see cref="BigInteger"/> value is less than a 64-bit signed integer.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is less than right; otherwise, false.
        /// </returns>
        public static bool operator <(BigInteger left, long right)
        {
            return left.CompareTo(right) < 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a 64-bit signed integer is less than a <see cref="BigInteger"/> value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is less than right; otherwise, false.
        /// </returns>
        public static bool operator <(long left, BigInteger right)
        {
            return right.CompareTo(left) > 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a <see cref="BigInteger"/> value is less than a 64-bit unsigned integer.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is less than right; otherwise, false.
        /// </returns>
        public static bool operator <(BigInteger left, ulong right)
        {
            return left.CompareTo(right) < 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a 64-bit unsigned integer is less than a <see cref="BigInteger"/> value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is less than right; otherwise, false.
        /// </returns>
        public static bool operator <(ulong left, BigInteger right)
        {
            return right.CompareTo(left) > 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a System.Numerics.BigInteger value is less than or equal to another System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is less than or equal to right; otherwise, false.
        /// </returns>
        public static bool operator <=(BigInteger left, BigInteger right)
        {
            return Compare(left, right) <= 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a System.Numerics.BigInteger value is less than or equal to a 64-bit signed integer.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is less than or equal to right; otherwise, false.
        /// </returns>
        public static bool operator <=(BigInteger left, long right)
        {
            return left.CompareTo(right) <= 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a 64-bit signed integer is less than or equal to a System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is less than or equal to right; otherwise, false.
        /// </returns>
        public static bool operator <=(long left, BigInteger right)
        {
            return right.CompareTo(left) >= 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a System.Numerics.BigInteger value is less than or equal to a 64-bit unsigned integer.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is less than or equal to right; otherwise, false.
        /// </returns>
        public static bool operator <=(BigInteger left, ulong right)
        {
            return left.CompareTo(right) <= 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a 64-bit unsigned integer is less than or equal to a System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is less than or equal to right; otherwise, false.
        /// </returns>
        public static bool operator <=(ulong left, BigInteger right)
        {
            return right.CompareTo(left) >= 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a System.Numerics.BigInteger value is greater than another System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is greater than right; otherwise, false.
        /// </returns>
        public static bool operator >(BigInteger left, BigInteger right)
        {
            return Compare(left, right) > 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a System.Numerics.BigInteger is greater than a 64-bit signed integer value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is greater than right; otherwise, false.
        /// </returns>
        public static bool operator >(BigInteger left, long right)
        {
            return left.CompareTo(right) > 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a 64-bit signed integer is greater than a System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is greater than right; otherwise, false.
        /// </returns>
        public static bool operator >(long left, BigInteger right)
        {
            return right.CompareTo(left) < 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a System.Numerics.BigInteger value is greater than a 64-bit unsigned integer.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is greater than right; otherwise, false.
        /// </returns>
        public static bool operator >(BigInteger left, ulong right)
        {
            return left.CompareTo(right) > 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a System.Numerics.BigInteger value is greater than a 64-bit unsigned integer.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is greater than right; otherwise, false.
        /// </returns>
        public static bool operator >(ulong left, BigInteger right)
        {
            return right.CompareTo(left) < 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a System.Numerics.BigInteger value is greater than or equal to another System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is greater than or equal  right; otherwise, false.
        /// </returns>
        public static bool operator >=(BigInteger left, BigInteger right)
        {
            return Compare(left, right) >= 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a System.Numerics.BigInteger value is greater than or equal to a 64-bit signed integer value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is greater than or equal right; otherwise, false.
        /// </returns>
        public static bool operator >=(BigInteger left, long right)
        {
            return left.CompareTo(right) >= 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a 64-bit signed integer is greater than or equal to a System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is greater than or equal right; otherwise, false.
        /// </returns>
        public static bool operator >=(long left, BigInteger right)
        {
            return right.CompareTo(left) <= 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a System.Numerics.BigInteger value is greater than or equal to a 64-bit unsigned integer value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is greater than or equal right; otherwise, false.
        /// </returns>
        public static bool operator >=(BigInteger left, ulong right)
        {
            return left.CompareTo(right) >= 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a 64-bit unsigned integer is greater than or equal to a System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left is greater than or equal right; otherwise, false.
        /// </returns>
        public static bool operator >=(ulong left, BigInteger right)
        {
            return right.CompareTo(left) <= 0;
        }

        /// <summary>
        /// Returns a value that indicates whether the values of two System.Numerics.BigInteger objects are equal.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if the left and right parameters have the same value; otherwise, false.
        /// </returns>
        public static bool operator ==(BigInteger left, BigInteger right)
        {
            return Compare(left, right) == 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a System.Numerics.BigInteger value and a signed long integer value are equal.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if the left and right parameters have the same value; otherwise, false.
        /// </returns>
        public static bool operator ==(BigInteger left, long right)
        {
            return left.CompareTo(right) == 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a signed long integer value and a System.Numerics.BigInteger value are equal.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if the left and right parameters have the same value; otherwise, false.
        /// </returns>
        public static bool operator ==(long left, BigInteger right)
        {
            return right.CompareTo(left) == 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a System.Numerics.BigInteger value and an unsigned long integer value are equal.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if the left and right parameters have the same value; otherwise, false.
        /// </returns>
        public static bool operator ==(BigInteger left, ulong right)
        {
            return left.CompareTo(right) == 0;
        }

        /// <summary>
        /// Returns a value that indicates whether an unsigned long integer value and a System.Numerics.BigInteger value are equal.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if the left and right parameters have the same value; otherwise, false.
        /// </returns>
        public static bool operator ==(ulong left, BigInteger right)
        {
            return right.CompareTo(left) == 0;
        }

        /// <summary>
        /// Returns a value that indicates whether two <see cref="BigInteger"/> objects have different values.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left and right are not equal; otherwise, false.
        /// </returns>
        public static bool operator !=(BigInteger left, BigInteger right)
        {
            return Compare(left, right) != 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a <see cref="BigInteger"/> value and a 64-bit signed integer are not equal.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left and right are not equal; otherwise, false.
        /// </returns>
        public static bool operator !=(BigInteger left, long right)
        {
            return left.CompareTo(right) != 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a 64-bit signed integer and a <see cref="BigInteger"/> value are not equal.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left and right are not equal; otherwise, false.
        /// </returns>
        public static bool operator !=(long left, BigInteger right)
        {
            return right.CompareTo(left) != 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a <see cref="BigInteger"/> value and a 64-bit unsigned integer are not equal.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left and right are not equal; otherwise, false.
        /// </returns>
        public static bool operator !=(BigInteger left, ulong right)
        {
            return left.CompareTo(right) != 0;
        }

        /// <summary>
        /// Returns a value that indicates whether a 64-bit unsigned integer and a <see cref="BigInteger"/> value are not equal.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if left and right are not equal; otherwise, false.
        /// </returns>
        public static bool operator !=(ulong left, BigInteger right)
        {
            return right.CompareTo(left) != 0;
        }

        #endregion

        /// <summary>
        /// Indicates whether the value of the current System.Numerics.BigInteger object is an even number.
        /// </summary>
        /// <value>
        ///   <c>true</c> if the value of the System.Numerics.BigInteger object is an even number; otherwise, <c>false</c>.
        /// </value>
        public bool IsEven
        {
            get { return (this._data[0] & 0x1) == 0; }
        }

        /// <summary>
        /// Indicates whether the value of the current System.Numerics.BigInteger object is System.Numerics.BigInteger.One.
        /// </summary>
        /// <value>
        ///   <c>true</c> if the value of the System.Numerics.BigInteger object is System.Numerics.BigInteger.One; otherwise, <c>false</c>.
        /// </value>
        public bool IsOne
        {
            get { return this._sign == 1 && this._data.Length == 1 && this._data[0] == 1; }
        }

        /// <summary>
        /// Indicates whether the value of the current System.Numerics.BigInteger object is a power of two.
        /// </summary>
        /// <value>
        ///     <c>true</c> if the value of the System.Numerics.BigInteger object is a power of two; otherwise, <c>false</c>.
        /// </value>
        public bool IsPowerOfTwo
        {
            get
            {
                bool foundBit = false;
                if (this._sign != 1)
                    return false;
                //This function is pop count == 1 for positive numbers
                for (int i = 0; i < this._data.Length; ++i)
                {
                    int p = PopulationCount(this._data[i]);
                    if (p > 0)
                    {
                        if (p > 1 || foundBit)
                            return false;
                        foundBit = true;
                    }
                }
                return foundBit;
            }
        }

        /// <summary>
        /// Indicates whether the value of the current System.Numerics.BigInteger object is System.Numerics.BigInteger.Zero.
        /// </summary>
        /// <value>
        ///   <c>true</c> if the value of the System.Numerics.BigInteger object is System.Numerics.BigInteger.Zero; otherwise, <c>false</c>.
        /// </value>
        public bool IsZero
        {
            get { return this._sign == 0; }
        }

        /// <summary>
        /// Gets a value that represents the number negative one (-1).
        /// </summary>
        public static BigInteger MinusOne
        {
            get { return new BigInteger(-1, _one); }
        }

        /// <summary>
        /// Gets a value that represents the number one (1).
        /// </summary>
        public static BigInteger One
        {
            get { return new BigInteger(1, _one); }
        }

        /// <summary>
        /// Gets a number that indicates the sign (negative, positive, or zero) of the current System.Numerics.BigInteger object.
        /// </summary>
        public int Sign
        {
            get { return this._sign; }
        }

        /// <summary>
        /// Gets a value that represents the number 0 (zero).
        /// </summary>
        public static BigInteger Zero
        {
            get { return new BigInteger(0, _zero); }
        }

        /// <summary>
        /// Gets the absolute value of a System.Numerics.BigInteger object.
        /// </summary>
        /// <param name="value">A number.</param>
        /// <returns>The absolute value of value.</returns>
        public static BigInteger Abs(BigInteger value)
        {
            return new BigInteger((short)Math.Abs(value._sign), value._data);
        }

        /// <summary>
        /// Adds two System.Numerics.BigInteger values and returns the result.
        /// </summary>
        /// <param name="left">The first value to add.</param>
        /// <param name="right">The second value to add.</param>
        /// <returns>The sum of left and right.</returns>
        public static BigInteger Add(BigInteger left, BigInteger right)
        {
            return left + right;
        }

        /// <summary>
        /// Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
        /// </summary>
        /// <param name="obj">An object to compare with this instance.</param>
        /// <returns>
        /// A value that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance is less than <paramref name="obj"/>. Zero This instance is equal to <paramref name="obj"/>. Greater than zero This instance is greater than <paramref name="obj"/>.
        /// </returns>
        /// <exception cref="T:System.ArgumentException">
        ///   <paramref name="obj"/> is not the same type as this instance. </exception>
        public int CompareTo(object obj)
        {
            if (obj == null)
                return 1;

            if (!(obj is BigInteger))
                return -1;

            return Compare(this, (BigInteger)obj);
        }

        /// <summary>
        /// Compares this instance to a second System.Numerics.BigInteger and returns 
        /// an integer that indicates whether the value of this instance is less than, 
        /// equal to, or greater than the value of the specified object.
        /// </summary>
        /// <param name="other">The object to compare.</param>
        /// <returns>
        /// A signed integer value that indicates the relationship of this instance to 
        /// other, as shown in the following table.Return valueDescriptionLess than zeroThe 
        /// current instance is less than other.ZeroThe current instance equals other.Greater 
        /// than zeroThe current instance is greater than other.
        /// </returns>
        public int CompareTo(BigInteger other)
        {
            return Compare(this, other);
        }

        /// <summary>
        /// Compares this instance to an unsigned 64-bit integer and returns an integer 
        /// that indicates whether the value of this instance is less than, equal to, 
        /// or greater than the value of the unsigned 64-bit integer.
        /// </summary>
        /// <param name="other">The unsigned 64-bit integer to compare.</param>
        /// <returns>A signed integer that indicates the relative value of this instance and other, 
        /// as shown in the following table.Return valueDescriptionLess than zeroThe 
        /// current instance is less than other.ZeroThe current instance equals other.Greater
        /// than zeroThe current instance is greater than other.</returns>
        public int CompareTo(ulong other)
        {
            if (this._sign < 0)
                return -1;
            if (this._sign == 0)
                return other == 0 ? 0 : -1;

            if (this._data.Length > 2)
                return 1;

            uint high = (uint)(other >> 32);
            uint low = (uint)other;

            return LongCompare(low, high);
        }

        /// <summary>
        /// Generates random BigInteger number
        /// </summary>
        /// <param name="bitLength">Length of random number in bits.</param>
        /// <returns>Big random number.</returns>
        public static BigInteger Random(int bitLength)
        {
            var bytesArray = new byte[bitLength / 8 + (((bitLength % 8) > 0) ? 1 : 0)];
            _randomizer.GetBytes(bytesArray);
            bytesArray[bytesArray.Length - 1] = (byte)(bytesArray[bytesArray.Length - 1] & 0x7F);   //  Ensure not a negative value
            return new BigInteger(bytesArray.ToArray());
        }

        /// <summary>
        /// Divides one System.Numerics.BigInteger value by another and returns the result.
        /// </summary>
        /// <param name="dividend">The value to be divided.</param>
        /// <param name="divisor">The value to divide by.</param>
        /// <returns>The quotient of the division.</returns>
        public static BigInteger Divide(BigInteger dividend, BigInteger divisor)
        {
            return dividend / divisor;
        }

        /// <summary>
        /// Divides one System.Numerics.BigInteger value by another, returns the result, and returns the remainder in an output parameter.
        /// </summary>
        /// <param name="dividend">The value to be divided.</param>
        /// <param name="divisor">The value to divide by.</param>
        /// <param name="remainder">When this method returns, contains a System.Numerics.BigInteger value that 
        /// represents the remainder from the division. This parameter is passed uninitialized.</param>
        /// <returns>The quotient of the division.</returns>
        public static BigInteger DivRem(BigInteger dividend, BigInteger divisor, out BigInteger remainder)
        {
            if (divisor._sign == 0)
                throw new DivideByZeroException();

            if (dividend._sign == 0)
            {
                remainder = dividend;
                return dividend;
            }

            uint[] quotient;
            uint[] remainder_value;

            DivModUnsigned(dividend._data, divisor._data, out quotient, out remainder_value);

            int i;
            for (i = remainder_value.Length - 1; i >= 0 && remainder_value[i] == 0; --i) ;
            if (i == -1)
            {
                remainder = new BigInteger(0, _zero);
            }
            else
            {
                if (i < remainder_value.Length - 1)
                    remainder_value = Resize(remainder_value, i + 1);
                remainder = new BigInteger(dividend._sign, remainder_value);
            }

            for (i = quotient.Length - 1; i >= 0 && quotient[i] == 0; --i) ;
            if (i == -1)
                return new BigInteger(0, _zero);
            if (i < quotient.Length - 1)
                quotient = Resize(quotient, i + 1);

            return new BigInteger((short)(dividend._sign * divisor._sign), quotient);
        }

        /// <summary>
        /// Returns a value that indicates whether the current instance and a specified System.Numerics.BigInteger object have the same value.
        /// </summary>
        /// <param name="other">The object to compare.</param>
        /// <returns>
        /// true if this System.Numerics.BigInteger object and other have the same value; otherwise, false.
        /// </returns>
        public bool Equals(BigInteger other)
        {
            if (this._sign != other._sign)
                return false;
            if (this._data.Length != other._data.Length)
                return false;
            for (int i = 0; i < this._data.Length; ++i)
            {
                if (this._data[i] != other._data[i])
                    return false;
            }
            return true;
        }

        /// <summary>
        /// Returns a value that indicates whether the current instance and a signed 64-bit integer have the same value.
        /// </summary>
        /// <param name="other">The signed 64-bit integer value to compare.</param>
        /// <returns>true if the signed 64-bit integer and the current instance have the same value; otherwise, false.</returns>
        public bool Equals(long other)
        {
            return CompareTo(other) == 0;
        }

        /// <summary>
        /// Returns a value that indicates whether the current instance and a specified object have the same value.
        /// </summary>
        /// <param name="obj">The object to compare.</param>
        /// <returns>
        ///   <c>true</c> if the obj parameter is a System.Numerics.BigInteger object or a type
        ///   capable of implicit conversion to a System.Numerics.BigInteger value, and
        ///   its value is equal to the value of the current System.Numerics.BigInteger
        ///   object; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(object obj)
        {
            if (!(obj is BigInteger))
                return false;
            return Equals((BigInteger)obj);
        }

        /// <summary>
        /// Returns a value that indicates whether the current instance and an unsigned 64-bit integer have the same value.
        /// </summary>
        /// <param name="other">The unsigned 64-bit integer to compare.</param>
        /// <returns>true if the current instance and the unsigned 64-bit integer have the same value; otherwise, false.</returns>
        public bool Equals(ulong other)
        {
            return CompareTo(other) == 0;
        }

        /// <summary>
        /// Returns the hash code for the current System.Numerics.BigInteger object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode()
        {
            uint hash = (uint)(this._sign * 0x01010101u);

            for (int i = 0; i < this._data.Length; ++i)
                hash ^= this._data[i];
            return (int)hash;
        }

        /// <summary>
        /// Finds the greatest common divisor of two System.Numerics.BigInteger values.
        /// </summary>
        /// <param name="left">The first value.</param>
        /// <param name="right">The second value.</param>
        /// <returns>The greatest common divisor of left and right.</returns>
        public static BigInteger GreatestCommonDivisor(BigInteger left, BigInteger right)
        {
            if (left._data.Length == 1 && left._data[0] == 1)
                return new BigInteger(1, _one);
            if (right._data.Length == 1 && right._data[0] == 1)
                return new BigInteger(1, _one);
            if (left.IsZero)
                return right;
            if (right.IsZero)
                return left;

            BigInteger x = new BigInteger(1, left._data);
            BigInteger y = new BigInteger(1, right._data);

            BigInteger g = y;

            while (x._data.Length > 1)
            {
                g = x;
                x = y % x;
                y = g;

            }
            if (x.IsZero) return g;

            //OneCodeTODO: should we have something here if we can convert to long?

            //
            // Now we can just do it with single precision. I am using the binary gcd method,
            // as it should be faster.
            //

            uint yy = x._data[0];
            uint xx = (uint)(y % yy);

            int t = 0;

            while (((xx | yy) & 1) == 0)
            {
                xx >>= 1; yy >>= 1; t++;
            }
            while (xx != 0)
            {
                while ((xx & 1) == 0) xx >>= 1;
                while ((yy & 1) == 0) yy >>= 1;
                if (xx >= yy)
                    xx = (xx - yy) >> 1;
                else
                    yy = (yy - xx) >> 1;
            }

            return yy << t;
        }

        /// <summary>
        /// Returns the logarithm of a specified number in a specified base.
        /// </summary>
        /// <param name="value">A number whose logarithm is to be found.</param>
        /// <param name="baseValue">The base of the logarithm.</param>
        /// <returns>The base baseValue logarithm of value, as shown in the table in the Remarks section.</returns>
        public static double Log(BigInteger value, Double baseValue)
        {
            //  LAMESPEC Log doesn't specify to how many ulp is has to be precise 
            //  We are equilavent to MS with about 2 ULP

            if (value._sign == -1 || baseValue == 1.0d || baseValue == -1.0d ||
            baseValue == Double.NegativeInfinity || double.IsNaN(baseValue))
                return double.NaN;

            if (baseValue == 0.0d || baseValue == Double.PositiveInfinity)
                return value.IsOne ? 0 : double.NaN;

            if (value._sign == 0)
                return double.NegativeInfinity;

            int length = value._data.Length - 1;
            int bitCount = -1;
            for (int curBit = 31; curBit >= 0; curBit--)
            {
                if ((value._data[length] & (1 << curBit)) != 0)
                {
                    bitCount = curBit + length * 32;
                    break;
                }
            }

            long bitlen = bitCount;
            Double c = 0, d = 1;

            BigInteger testBit = One;
            long tempBitlen = bitlen;
            while (tempBitlen > Int32.MaxValue)
            {
                testBit = testBit << Int32.MaxValue;
                tempBitlen -= Int32.MaxValue;
            }
            testBit = testBit << (int)tempBitlen;

            for (long curbit = bitlen; curbit >= 0; --curbit)
            {
                if ((value & testBit)._sign != 0)
                    c += d;
                d *= 0.5;
                testBit = testBit >> 1;
            }
            return (System.Math.Log(c) + System.Math.Log(2) * bitlen) / System.Math.Log(baseValue);
        }

        /// <summary>
        /// Returns the natural (base e) logarithm of a specified number.
        /// </summary>
        /// <param name="value">The number whose logarithm is to be found.</param>
        /// <returns>The natural (base e) logarithm of value, as shown in the table in the Remarks section.</returns>
        public static double Log(BigInteger value)
        {
            return Log(value, Math.E);
        }

        /// <summary>
        /// Returns the base 10 logarithm of a specified number.
        /// </summary>
        /// <param name="value">A number whose logarithm is to be found.</param>
        /// <returns>The base 10 logarithm of value, as shown in the table in the Remarks section.</returns>
        public static double Log10(BigInteger value)
        {
            return Log(value, 10);
        }

        /// <summary>
        /// Returns the larger of two System.Numerics.BigInteger values.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>The left or right parameter, whichever is larger.</returns>
        public static BigInteger Max(BigInteger left, BigInteger right)
        {
            int ls = left._sign;
            int rs = right._sign;

            if (ls > rs)
                return left;
            if (rs > ls)
                return right;

            int r = CoreCompare(left._data, right._data);
            if (ls == -1)
                r = -r;

            if (r >= 0)
                return left;
            return right;
        }

        /// <summary>
        /// Returns the smaller of two System.Numerics.BigInteger values.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>The left or right parameter, whichever is smaller.</returns>
        public static BigInteger Min(BigInteger left, BigInteger right)
        {
            int ls = left._sign;
            int rs = right._sign;

            if (ls < rs)
                return left;
            if (rs < ls)
                return right;

            int r = CoreCompare(left._data, right._data);
            if (ls == -1)
                r = -r;

            if (r <= 0)
                return left;
            return right;
        }

        /// <summary>
        /// Performs modulus division on a number raised to the power of another number.
        /// </summary>
        /// <param name="value">The number to raise to the exponent power.</param>
        /// <param name="exponent">The exponent to raise value by.</param>
        /// <param name="modulus">The value to divide valueexponent by.</param>
        /// <returns>The remainder after dividing valueexponent by modulus.</returns>
        public static BigInteger ModPow(BigInteger value, BigInteger exponent, BigInteger modulus)
        {
            if (exponent._sign == -1)
                throw new ArgumentOutOfRangeException("exponent", "power must be >= 0");
            if (modulus._sign == 0)
                throw new DivideByZeroException();

            BigInteger result = One % modulus;
            while (exponent._sign != 0)
            {
                if (!exponent.IsEven)
                {
                    result = result * value;
                    result = result % modulus;
                }

                if (exponent.IsOne)
                    break;

                value = value * value;
                value = value % modulus;
                exponent >>= 1;
            }
            return result;
        }

        /// <summary>
        /// Mods the inverse.
        /// </summary>
        /// <param name="bi">The bi.</param>
        /// <param name="modulus">The modulus.</param>
        /// <returns>Modulus inverted number.</returns>
        public static BigInteger ModInverse(BigInteger bi, BigInteger modulus)
        {
            BigInteger a = modulus, b = bi % modulus;
            BigInteger p0 = 0, p1 = 1;

            while (!b.IsZero)
            {
                if (b.IsOne)
                    return p1;

                p0 += (a / b) * p1;
                a %= b;

                if (a.IsZero)
                    break;

                if (a.IsOne)
                    return modulus - p0;

                p1 += (b / a) * p0;
                b %= a;

            }
            return 0;
        }

        /// <summary>
        /// Returns positive remainder that results from division with two specified <see cref="BigInteger"/> values.
        /// </summary>
        /// <param name="dividend">The value to be divided.</param>
        /// <param name="divisor">The value to divide by.</param>
        /// <returns>
        /// Positive remainder that results from the division.
        /// </returns>
        public static BigInteger PositiveMod(BigInteger dividend, BigInteger divisor)
        {
            var result = dividend % divisor;
            if (result < 0)
                result += divisor;

            return result;
        }

        /// <summary>
        /// Returns the product of two System.Numerics.BigInteger values.
        /// </summary>
        /// <param name="left">The first number to multiply.</param>
        /// <param name="right">The second number to multiply.</param>
        /// <returns>The product of the left and right parameters.</returns>
        public static BigInteger Multiply(BigInteger left, BigInteger right)
        {
            return left * right;
        }

        /// <summary>
        /// Negates a specified System.Numerics.BigInteger value.
        /// </summary>
        /// <param name="value">The value to negate.</param>
        /// <returns>The result of the value parameter multiplied by negative one (-1).</returns>
        public static BigInteger Negate(BigInteger value)
        {
            return -value;
        }

        /// <summary>
        /// Converts the string representation of a number in a specified style and culture-specific format to its <see cref="BigInteger"/> equivalent.
        /// </summary>
        /// <param name="value">A string that contains a number to convert.</param>
        /// <param name="style">A bitwise combination of the enumeration values that specify the permitted format of value.</param>
        /// <param name="provider">An object that provides culture-specific formatting information about value.</param>
        /// <returns>Parsed <see cref="BigInteger"/> number</returns>
        public static BigInteger Parse(string value, System.Globalization.NumberStyles style, IFormatProvider provider)
        {
            Exception ex;
            BigInteger result;

            if (!Parse(value, false, style, provider, out result, out ex))
                throw ex;
            return result;
        }

        /// <summary>
        /// Converts the string representation of a number in a specified culture-specific format to its System.Numerics.BigInteger equivalent.
        /// </summary>
        /// <param name="value">A string that contains a number to convert.</param>
        /// <param name="provider">An object that provides culture-specific formatting information about value.</param>
        /// <returns>A value that is equivalent to the number specified in the value parameter.</returns>
        public static BigInteger Parse(string value, IFormatProvider provider)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Converts the string representation of a number in a specified style to its System.Numerics.BigInteger equivalent.
        /// </summary>
        /// <param name="value">A string that contains a number to convert.</param>
        /// <param name="style">A bitwise combination of the enumeration values that specify the permitted format of value.</param>
        /// <returns>A value that is equivalent to the number specified in the value parameter.</returns>
        public static BigInteger Parse(string value, NumberStyles style)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Raises a System.Numerics.BigInteger value to the power of a specified value.
        /// </summary>
        /// <param name="value">The number to raise to the exponent power.</param>
        /// <param name="exponent">The exponent to raise value by.</param>
        /// <returns>The result of raising value to the exponent power.</returns>
        public static BigInteger Pow(BigInteger value, int exponent)
        {
            if (exponent < 0)
                throw new ArgumentOutOfRangeException("exponent", "exp must be >= 0");
            if (exponent == 0)
                return One;
            if (exponent == 1)
                return value;

            BigInteger result = One;
            while (exponent != 0)
            {
                if ((exponent & 1) != 0)
                    result = result * value;
                if (exponent == 1)
                    break;

                value = value * value;
                exponent >>= 1;
            }
            return result;
        }

        /// <summary>
        /// Performs integer division on two System.Numerics.BigInteger values and returns the remainder.
        /// </summary>
        /// <param name="dividend">The value to be divided.</param>
        /// <param name="divisor">The value to divide by.</param>
        /// <returns>The remainder after dividing dividend by divisor.</returns>
        public static BigInteger Remainder(BigInteger dividend, BigInteger divisor)
        {
            return dividend % divisor;
        }

        /// <summary>
        /// Subtracts one System.Numerics.BigInteger value from another and returns the result.
        /// </summary>
        /// <param name="left">The value to subtract from (the minuend).</param>
        /// <param name="right">The value to subtract (the subtrahend).</param>
        /// <returns>The result of subtracting right from left.</returns>
        public static BigInteger Subtract(BigInteger left, BigInteger right)
        {
            return left - right;
        }

        /// <summary>
        /// Converts a System.Numerics.BigInteger value to a byte array.
        /// </summary>
        /// <returns>The value of the current System.Numerics.BigInteger object converted to an array of bytes.</returns>
        public byte[] ToByteArray()
        {
            if (this._sign == 0)
                return new byte[1];

            //number of bytes not counting upper word
            int bytes = (this._data.Length - 1) * 4;
            bool needExtraZero = false;

            uint topWord = this._data[this._data.Length - 1];
            int extra;

            //if the topmost bit is set we need an extra
            if (this._sign == 1)
            {
                extra = TopByte(topWord);
                uint mask = 0x80u << ((extra - 1) * 8);
                if ((topWord & mask) != 0)
                {
                    needExtraZero = true;
                }
            }
            else
            {
                extra = TopByte(topWord);
            }

            byte[] res = new byte[bytes + extra + (needExtraZero ? 1 : 0)];
            if (this._sign == 1)
            {
                int j = 0;
                int end = this._data.Length - 1;
                for (int i = 0; i < end; ++i)
                {
                    uint word = this._data[i];

                    res[j++] = (byte)word;
                    res[j++] = (byte)(word >> 8);
                    res[j++] = (byte)(word >> 16);
                    res[j++] = (byte)(word >> 24);
                }
                while (extra-- > 0)
                {
                    res[j++] = (byte)topWord;
                    topWord >>= 8;
                }
            }
            else
            {
                int j = 0;
                int end = this._data.Length - 1;

                uint carry = 1, word;
                ulong add;
                for (int i = 0; i < end; ++i)
                {
                    word = this._data[i];
                    add = (ulong)~word + carry;
                    word = (uint)add;
                    carry = (uint)(add >> 32);

                    res[j++] = (byte)word;
                    res[j++] = (byte)(word >> 8);
                    res[j++] = (byte)(word >> 16);
                    res[j++] = (byte)(word >> 24);
                }

                add = (ulong)~topWord + (carry);
                word = (uint)add;
                carry = (uint)(add >> 32);
                if (carry == 0)
                {
                    int ex = FirstNonFFByte(word);
                    bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;
                    int to = ex + (needExtra ? 1 : 0);

                    if (to != extra)
                        res = Resize(res, bytes + to);

                    while (ex-- > 0)
                    {
                        res[j++] = (byte)word;
                        word >>= 8;
                    }
                    if (needExtra)
                        res[j++] = 0xFF;
                }
                else
                {
                    res = Resize(res, bytes + 5);
                    res[j++] = (byte)word;
                    res[j++] = (byte)(word >> 8);
                    res[j++] = (byte)(word >> 16);
                    res[j++] = (byte)(word >> 24);
                    res[j++] = 0xFF;
                }
            }

            return res;
        }

        /// <summary>
        /// Converts the numeric value of the current System.Numerics.BigInteger object to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// The string representation of the current System.Numerics.BigInteger value.
        /// </returns>
        public override string ToString()
        {
            return ToString(10, null);
        }

        /// <summary>
        /// Converts the numeric value of the current System.Numerics.BigInteger object 
        /// to its equivalent string representation by using the specified culture-specific 
        /// formatting information.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the current System.Numerics.BigInteger value 
        /// in the format specified by the provider parameter.
        /// </returns>
        public string ToString(IFormatProvider provider)
        {
            return ToString(null, provider);
        }

        /// <summary>
        /// Converts the numeric value of the current System.Numerics.BigInteger object
        /// to its equivalent string representation by using the specified format.
        /// </summary>
        /// <param name="format">A standard or custom numeric format string.</param>
        /// <returns>
        /// The string representation of the current System.Numerics.BigInteger value
        /// in the format specified by the format parameter.
        /// </returns>
        public string ToString(string format)
        {
            return ToString(format, null);
        }

        /// <summary>
        /// Converts the numeric value of the current System.Numerics.BigInteger object
        /// to its equivalent string representation by using the specified format and
        /// culture-specific format information.
        /// </summary>
        /// <param name="format">A standard or custom numeric format string.</param>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the current System.Numerics.BigInteger value 
        /// as specified by the format and provider parameters.
        /// </returns>
        public string ToString(string format, IFormatProvider provider)
        {
            if (string.IsNullOrEmpty(format))
                return ToString(10, provider);

            switch (format[0])
            {
                case 'd':
                case 'D':
                case 'g':
                case 'G':
                case 'r':
                case 'R':
                    return ToStringWithPadding(format, 10, provider);
                case 'x':
                case 'X':
                    return ToStringWithPadding(format, 16, null);
                default:
                    throw new FormatException(string.Format("format '{0}' not implemented", format));
            }
        }

        /// <summary>
        /// Tries to convert the string representation of a number in a specified style
        /// and culture-specific format to its System.Numerics.BigInteger equivalent,
        /// and returns a value that indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="value">The string representation of a number. The string is interpreted using the style specified by style.</param>
        /// <param name="style">A bitwise combination of enumeration values that indicates the style elements
        /// that can be present in value. A typical value to specify is System.Globalization.NumberStyles.Integer.</param>
        /// <param name="cultureInfo">An object that supplies culture-specific formatting information about value.</param>
        /// <param name="result">When this method returns, contains the System.Numerics.BigInteger equivalent
        /// to the number that is contained in value, or System.Numerics.BigInteger.Zero
        /// if the conversion failed. The conversion fails if the value parameter is
        /// null or is not in a format that is compliant with style. This parameter is
        /// passed uninitialized.</param>
        /// <returns>true if the value parameter was converted successfully; otherwise, false.</returns>
        public static bool TryParse(string value, NumberStyles style, CultureInfo cultureInfo, out BigInteger result)
        {
            Exception ex;
            return Parse(value, true, style, cultureInfo, out result, out ex);
        }

        /// <summary>
        /// Tries to convert the string representation of a number to its System.Numerics.BigInteger
        /// equivalent, and returns a value that indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="value">The string representation of a number.</param>
        /// <param name="result">When this method returns, contains the System.Numerics.BigInteger equivalent
        /// to the number that is contained in value, or zero (0) if the conversion fails.
        /// The conversion fails if the value parameter is null or is not of the correct
        /// format. This parameter is passed uninitialized.</param>
        /// <returns>true if value was converted successfully; otherwise, false.</returns>
        public static bool TryParse(string value, out BigInteger result)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Compares this instance to a signed 64-bit integer and returns an integer 
        /// that indicates whether the value of this instance is less than, equal to, 
        /// or greater than the value of the signed 64-bit integer.
        /// </summary>
        /// <param name="other">The signed 64-bit integer to compare.</param>
        /// <returns>A signed integer value that indicates the relationship of this instance to 
        /// other, as shown in the following table.Return valueDescriptionLess than zeroThe 
        /// current instance is less than other.ZeroThe current instance equals other.Greater 
        /// than zero.The current instance is greater than other.</returns>
        public int CompareTo(long other)
        {
            int ls = this._sign;
            int rs = Math.Sign(other);

            if (ls != rs)
                return ls > rs ? 1 : -1;

            if (ls == 0)
                return 0;

            if (this._data.Length > 2)
                return this._sign;

            if (other < 0)
                other = -other;
            uint low = (uint)other;
            uint high = (uint)((ulong)other >> 32);

            int r = LongCompare(low, high);
            if (ls == -1)
                r = -r;

            return r;
        }

        /// <summary>
        /// Compares two System.Numerics.BigInteger values and returns an integer that 
        /// indicates whether the first value is less than, equal to, or greater than the second value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>A signed integer that indicates the relative values of left and right, 
        /// as shown in the following table.ValueConditionLess than zeroleft is less than right.Zeroleft 
        /// equals right.Greater than zeroleft is greater than right.</returns>
        public static int Compare(BigInteger left, BigInteger right)
        {
            int ls = left._sign;
            int rs = right._sign;

            if (ls != rs)
                return ls > rs ? 1 : -1;

            int r = CoreCompare(left._data, right._data);
            if (ls < 0)
                r = -r;
            return r;
        }

        private static bool Negative(byte[] v)
        {
            return ((v[7] & 0x80) != 0);
        }

        private static ushort Exponent(byte[] v)
        {
            return (ushort)((((ushort)(v[7] & 0x7F)) << (ushort)4) | (((ushort)(v[6] & 0xF0)) >> 4));
        }

        private static ulong Mantissa(byte[] v)
        {
            uint i1 = ((uint)v[0] | ((uint)v[1] << 8) | ((uint)v[2] << 16) | ((uint)v[3] << 24));
            uint i2 = ((uint)v[4] | ((uint)v[5] << 8) | ((uint)(v[6] & 0xF) << 16));

            return (ulong)((ulong)i1 | ((ulong)i2 << 32));
        }

        /// <summary>
        /// Populations the count.
        /// </summary>
        /// <param name="x">The x.</param>
        /// <returns>Returns the number of bits set in x</returns>
        private static int PopulationCount(uint x)
        {
            x = x - ((x >> 1) & 0x55555555);
            x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
            x = (x + (x >> 4)) & 0x0F0F0F0F;
            x = x + (x >> 8);
            x = x + (x >> 16);
            return (int)(x & 0x0000003F);
        }

        private string ToStringWithPadding(string format, uint radix, IFormatProvider provider)
        {
            if (format.Length > 1)
            {
                int precision = Convert.ToInt32(format.Substring(1), CultureInfo.InvariantCulture.NumberFormat);
                string baseStr = ToString(radix, provider);
                if (baseStr.Length < precision)
                {
                    string additional = new String('0', precision - baseStr.Length);
                    if (baseStr[0] != '-')
                    {
                        return additional + baseStr;
                    }
                    else
                    {
                        return "-" + additional + baseStr.Substring(1);
                    }
                }
                return baseStr;
            }
            return ToString(radix, provider);
        }

        private static uint[] MakeTwoComplement(uint[] v)
        {
            uint[] res = new uint[v.Length];

            ulong carry = 1;
            for (int i = 0; i < v.Length; ++i)
            {
                uint word = v[i];
                carry = (ulong)~word + carry;
                word = (uint)carry;
                carry = (uint)(carry >> 32);
                res[i] = word;
            }

            uint last = res[res.Length - 1];
            int idx = FirstNonFFByte(last);
            uint mask = 0xFF;
            for (int i = 1; i < idx; ++i)
                mask = (mask << 8) | 0xFF;

            res[res.Length - 1] = last & mask;
            return res;
        }

        private string ToString(uint radix, IFormatProvider provider)
        {
            const string characterSet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

            if (characterSet.Length < radix)
                throw new ArgumentException("charSet length less than radix", "characterSet");
            if (radix == 1)
                throw new ArgumentException("There is no such thing as radix one notation", "radix");

            if (this._sign == 0)
                return "0";
            if (this._data.Length == 1 && this._data[0] == 1)
                return this._sign == 1 ? "1" : "-1";

            List<char> digits = new List<char>(1 + this._data.Length * 3 / 10);

            BigInteger a;
            if (this._sign == 1)
                a = this;
            else
            {
                uint[] dt = this._data;
                if (radix > 10)
                    dt = MakeTwoComplement(dt);
                a = new BigInteger(1, dt);
            }

            while (a != 0)
            {
                BigInteger rem;
                a = DivRem(a, radix, out rem);
                digits.Add(characterSet[(int)rem]);
            }

            if (this._sign == -1 && radix == 10)
            {
                NumberFormatInfo info = null;
                if (provider != null)
                    info = provider.GetFormat(typeof(NumberFormatInfo)) as NumberFormatInfo;
                if (info != null)
                {
                    string str = info.NegativeSign;
                    for (int i = str.Length - 1; i >= 0; --i)
                        digits.Add(str[i]);
                }
                else
                {
                    digits.Add('-');
                }
            }

            char last = digits[digits.Count - 1];
            if (this._sign == 1 && radix > 10 && (last < '0' || last > '9'))
                digits.Add('0');

            digits.Reverse();

            return new String(digits.ToArray());
        }

        private static Exception GetFormatException()
        {
            return new FormatException("Input string was not in the correct format");
        }

        private static bool ProcessTrailingWhitespace(bool tryParse, string s, int position, ref Exception exc)
        {
            int len = s.Length;

            for (int i = position; i < len; i++)
            {
                char c = s[i];

                if (c != 0 && !Char.IsWhiteSpace(c))
                {
                    if (!tryParse)
                        exc = GetFormatException();
                    return false;
                }
            }
            return true;
        }

        private static bool Parse(string s, bool tryParse, System.Globalization.NumberStyles style, IFormatProvider provider, out BigInteger result, out Exception exc)
        {
            int len;
            int i, sign = 1;
            bool digits_seen = false;

            var baseNumber = 10;
            switch (style)
            {
                case NumberStyles.None:
                    break;
                case NumberStyles.HexNumber:
                case NumberStyles.AllowHexSpecifier:
                    baseNumber = 16;
                    break;
                case NumberStyles.AllowCurrencySymbol:
                case NumberStyles.AllowDecimalPoint:
                case NumberStyles.AllowExponent:
                case NumberStyles.AllowLeadingSign:
                case NumberStyles.AllowLeadingWhite:
                case NumberStyles.AllowParentheses:
                case NumberStyles.AllowThousands:
                case NumberStyles.AllowTrailingSign:
                case NumberStyles.AllowTrailingWhite:
                case NumberStyles.Any:
                case NumberStyles.Currency:
                case NumberStyles.Float:
                case NumberStyles.Integer:
                case NumberStyles.Number:
                default:
                    throw new NotSupportedException(string.Format("Style '{0}' is not supported.", style));
            }

            result = Zero;
            exc = null;

            if (s == null)
            {
                if (!tryParse)
                    exc = new ArgumentNullException("value");
                return false;
            }

            len = s.Length;

            char c;
            for (i = 0; i < len; i++)
            {
                c = s[i];
                if (!Char.IsWhiteSpace(c))
                    break;
            }

            if (i == len)
            {
                if (!tryParse)
                    exc = GetFormatException();
                return false;
            }

            var info = provider.GetFormat(typeof(NumberFormatInfo)) as NumberFormatInfo;

            string negative = info.NegativeSign;
            string positive = info.PositiveSign;

            if (string.CompareOrdinal(s, i, positive, 0, positive.Length) == 0)
                i += positive.Length;
            else if (string.CompareOrdinal(s, i, negative, 0, negative.Length) == 0)
            {
                sign = -1;
                i += negative.Length;
            }

            BigInteger val = Zero;
            for (; i < len; i++)
            {
                c = s[i];

                if (c == '\0')
                {
                    i = len;
                    continue;
                }

                if (c >= '0' && c <= '9')
                {
                    byte d = (byte)(c - '0');

                    val = val * baseNumber + d;

                    digits_seen = true;
                }
                else if (c >= 'A' && c <= 'F')
                {
                    byte d = (byte)(c - 'A' + 10);

                    val = val * baseNumber + d;

                    digits_seen = true;
                }
                else if (!ProcessTrailingWhitespace(tryParse, s, i, ref exc))
                    return false;
            }

            if (!digits_seen)
            {
                if (!tryParse)
                    exc = GetFormatException();
                return false;
            }

            if (val._sign == 0)
                result = val;
            else if (sign == -1)
                result = new BigInteger(-1, val._data);
            else
                result = new BigInteger(1, val._data);

            return true;
        }

        private int LongCompare(uint low, uint high)
        {
            uint h = 0;
            if (this._data.Length > 1)
                h = this._data[1];

            if (h > high)
                return 1;
            if (h < high)
                return -1;

            uint l = this._data[0];

            if (l > low)
                return 1;
            if (l < low)
                return -1;

            return 0;
        }

        private bool AsUInt64(out ulong val)
        {
            val = 0;
            if (this._data.Length > 2 || this._sign == -1)
                return false;

            val = this._data[0];
            if (this._data.Length == 1)
                return true;

            uint high = this._data[1];
            val |= (((ulong)high) << 32);
            return true;
        }

        private bool AsInt32(out int val)
        {
            val = 0;
            if (this._data.Length > 1) return false;
            uint d = this._data[0];

            if (this._sign == 1)
            {
                if (d > (uint)int.MaxValue)
                    return false;
                val = (int)d;
            }
            else if (this._sign == -1)
            {
                if (d > 0x80000000u)
                    return false;
                val = -(int)d;
            }
            return true;
        }

        /// <summary>
        /// Returns the 0-based index of the most significant set bit
        /// </summary>
        /// <param name="word">The word.</param>
        /// <returns>0 if no bit is set</returns>
        private static int BitScanBackward(uint word)
        {
            for (int i = 31; i >= 0; --i)
            {
                uint mask = 1u << i;
                if ((word & mask) == mask)
                    return i;
            }
            return 0;
        }

        private static int TopByte(uint x)
        {
            if ((x & 0xFFFF0000u) != 0)
            {
                if ((x & 0xFF000000u) != 0)
                    return 4;
                return 3;
            }
            if ((x & 0xFF00u) != 0)
                return 2;
            return 1;
        }

        private static int FirstNonFFByte(uint word)
        {
            if ((word & 0xFF000000u) != 0xFF000000u)
                return 4;
            else if ((word & 0xFF0000u) != 0xFF0000u)
                return 3;
            else if ((word & 0xFF00u) != 0xFF00u)
                return 2;
            return 1;
        }

        private static byte[] Resize(byte[] v, int len)
        {
            byte[] res = new byte[len];
            Buffer.BlockCopy(v, 0, res, 0, Math.Min(v.Length, len));
            Array.Copy(v, res, Math.Min(v.Length, len));
            return res;
        }

        private static uint[] Resize(uint[] v, int len)
        {
            uint[] res = new uint[len];
            Buffer.BlockCopy(v, 0, res, 0, Math.Min(v.Length, len) * sizeof(uint));
            return res;
        }

        private static uint[] CoreAdd(uint[] a, uint[] b)
        {
            if (a.Length < b.Length)
            {
                uint[] tmp = a;
                a = b;
                b = tmp;
            }

            int bl = a.Length;
            int sl = b.Length;

            uint[] res = new uint[bl];

            ulong sum = 0;

            int i = 0;
            for (; i < sl; i++)
            {
                sum = sum + a[i] + b[i];
                res[i] = (uint)sum;
                sum >>= 32;
            }

            for (; i < bl; i++)
            {
                sum = sum + a[i];
                res[i] = (uint)sum;
                sum >>= 32;
            }

            if (sum != 0)
            {
                res = Resize(res, bl + 1);
                res[i] = (uint)sum;
            }

            return res;
        }

        /*invariant a > b*/
        private static uint[] CoreSub(uint[] a, uint[] b)
        {
            int bl = a.Length;
            int sl = b.Length;

            uint[] res = new uint[bl];

            ulong borrow = 0;
            int i;
            for (i = 0; i < sl; ++i)
            {
                borrow = (ulong)a[i] - b[i] - borrow;

                res[i] = (uint)borrow;
                borrow = (borrow >> 32) & 0x1;
            }

            for (; i < bl; i++)
            {
                borrow = (ulong)a[i] - borrow;
                res[i] = (uint)borrow;
                borrow = (borrow >> 32) & 0x1;
            }

            //remove extra zeroes
            for (i = bl - 1; i >= 0 && res[i] == 0; --i) ;
            if (i < bl - 1)
                res = Resize(res, i + 1);

            return res;
        }

        private static uint[] CoreAdd(uint[] a, uint b)
        {
            int len = a.Length;
            uint[] res = new uint[len];

            ulong sum = b;
            int i;
            for (i = 0; i < len; i++)
            {
                sum = sum + a[i];
                res[i] = (uint)sum;
                sum >>= 32;
            }

            if (sum != 0)
            {
                res = Resize(res, len + 1);
                res[i] = (uint)sum;
            }

            return res;
        }

        private static uint[] CoreSub(uint[] a, uint b)
        {
            int len = a.Length;
            uint[] res = new uint[len];

            ulong borrow = b;
            int i;
            for (i = 0; i < len; i++)
            {
                borrow = (ulong)a[i] - borrow;
                res[i] = (uint)borrow;
                borrow = (borrow >> 32) & 0x1;
            }

            //remove extra zeroes
            for (i = len - 1; i >= 0 && res[i] == 0; --i) ;
            if (i < len - 1)
                res = Resize(res, i + 1);

            return res;
        }

        private static int CoreCompare(uint[] a, uint[] b)
        {
            int al = a.Length;
            int bl = b.Length;

            if (al > bl)
                return 1;
            if (bl > al)
                return -1;

            for (int i = al - 1; i >= 0; --i)
            {
                uint ai = a[i];
                uint bi = b[i];
                if (ai > bi)
                    return 1;
                if (ai < bi)
                    return -1;
            }
            return 0;
        }

        private static int GetNormalizeShift(uint value)
        {
            int shift = 0;

            if ((value & 0xFFFF0000) == 0) { value <<= 16; shift += 16; }
            if ((value & 0xFF000000) == 0) { value <<= 8; shift += 8; }
            if ((value & 0xF0000000) == 0) { value <<= 4; shift += 4; }
            if ((value & 0xC0000000) == 0) { value <<= 2; shift += 2; }
            if ((value & 0x80000000) == 0) { value <<= 1; shift += 1; }

            return shift;
        }

        private static void Normalize(uint[] u, int l, uint[] un, int shift)
        {
            uint carry = 0;
            int i;
            if (shift > 0)
            {
                int rshift = 32 - shift;
                for (i = 0; i < l; i++)
                {
                    uint ui = u[i];
                    un[i] = (ui << shift) | carry;
                    carry = ui >> rshift;
                }
            }
            else
            {
                for (i = 0; i < l; i++)
                {
                    un[i] = u[i];
                }
            }

            while (i < un.Length)
            {
                un[i++] = 0;
            }

            if (carry != 0)
            {
                un[l] = carry;
            }
        }

        private static void Unnormalize(uint[] un, out uint[] r, int shift)
        {
            int length = un.Length;
            r = new uint[length];

            if (shift > 0)
            {
                int lshift = 32 - shift;
                uint carry = 0;
                for (int i = length - 1; i >= 0; i--)
                {
                    uint uni = un[i];
                    r[i] = (uni >> shift) | carry;
                    carry = (uni << lshift);
                }
            }
            else
            {
                for (int i = 0; i < length; i++)
                {
                    r[i] = un[i];
                }
            }
        }

        private static void DivModUnsigned(uint[] u, uint[] v, out uint[] q, out uint[] r)
        {
            int m = u.Length;
            int n = v.Length;

            if (n <= 1)
            {
                // Divide by single digit
                //
                ulong rem = 0;
                uint v0 = v[0];
                q = new uint[m];
                r = new uint[1];

                for (int j = m - 1; j >= 0; j--)
                {
                    rem *= _BASE;
                    rem += u[j];

                    ulong div = rem / v0;
                    rem -= div * v0;
                    q[j] = (uint)div;
                }
                r[0] = (uint)rem;
            }
            else if (m >= n)
            {
                int shift = GetNormalizeShift(v[n - 1]);

                uint[] un = new uint[m + 1];
                uint[] vn = new uint[n];

                Normalize(u, m, un, shift);
                Normalize(v, n, vn, shift);

                q = new uint[m - n + 1];
                r = null;

                // Main division loop
                //
                for (int j = m - n; j >= 0; j--)
                {
                    ulong rr, qq;
                    int i;

                    rr = _BASE * un[j + n] + un[j + n - 1];
                    qq = rr / vn[n - 1];
                    rr -= qq * vn[n - 1];

                    for (;;)
                    {
                        // Estimate too big ?
                        //
                        if ((qq >= _BASE) || (qq * vn[n - 2] > (rr * _BASE + un[j + n - 2])))
                        {
                            qq--;
                            rr += (ulong)vn[n - 1];
                            if (rr < _BASE)
                                continue;
                        }
                        break;
                    }


                    // Multiply and subtract
                    //
                    long b = 0;
                    long t = 0;
                    for (i = 0; i < n; i++)
                    {
                        ulong p = vn[i] * qq;
                        t = (long)un[i + j] - (long)(uint)p - b;
                        un[i + j] = (uint)t;
                        p >>= 32;
                        t >>= 32;
                        b = (long)p - t;
                    }
                    t = (long)un[j + n] - b;
                    un[j + n] = (uint)t;

                    // Store the calculated value
                    //
                    q[j] = (uint)qq;

                    // Add back vn[0..n] to un[j..j+n]
                    //
                    if (t < 0)
                    {
                        q[j]--;
                        ulong c = 0;
                        for (i = 0; i < n; i++)
                        {
                            c = (ulong)vn[i] + un[j + i] + c;
                            un[j + i] = (uint)c;
                            c >>= 32;
                        }
                        c += (ulong)un[j + n];
                        un[j + n] = (uint)c;
                    }
                }

                Unnormalize(un, out r, shift);
            }
            else
            {
                q = new uint[] { 0 };
                r = u;
            }
        }
    }
}
#endif
// file ...\X\Renci.SshNet\Common\ChannelDataEventArgs.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Common
{
    /// <summary>
    /// Provides data for <see cref="Renci.SshNet.Channels.Channel.DataReceived"/> event and <see cref="Renci.SshNet.Channels.Channel.ExtendedDataReceived"/> events.
    /// </summary>
    public class ChannelDataEventArgs : ChannelEventArgs
    {
        /// <summary>
        /// Gets channel data.
        /// </summary>
        public byte[] Data { get; private set; }

        /// <summary>
        /// Gets the data type code.
        /// </summary>
        public uint DataTypeCode { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelDataEventArgs"/> class.
        /// </summary>
        /// <param name="channelNumber">Channel number.</param>
        /// <param name="data">Channel data.</param>
        public ChannelDataEventArgs(uint channelNumber, byte[] data)
            : base(channelNumber)
        {
            this.Data = data;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelDataEventArgs"/> class.
        /// </summary>
        /// <param name="channelNumber">Channel number.</param>
        /// <param name="data">Channel data.</param>
        /// <param name="dataTypeCode">Channel data type code.</param>
        public ChannelDataEventArgs(uint channelNumber, byte[] data, uint dataTypeCode)
            : this(channelNumber, data)
        {
            this.DataTypeCode = dataTypeCode;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\ChannelEventArgs.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// Base class for all channel related events.
    /// </summary>
    public class ChannelEventArgs : EventArgs
    {
        /// <summary>
        /// Gets the channel number.
        /// </summary>
        public uint ChannelNumber { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelEventArgs"/> class.
        /// </summary>
        /// <param name="channelNumber">The channel number.</param>
        public ChannelEventArgs(uint channelNumber)
        {
            this.ChannelNumber = channelNumber;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\ChannelOpenConfirmedEventArgs.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Common
{
    /// <summary>
    /// Provides data for <see cref="Renci.SshNet.Channels.ClientChannel.OpenConfirmed"/> event.
    /// </summary>
    public class ChannelOpenConfirmedEventArgs : ChannelEventArgs
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelOpenConfirmedEventArgs"/> class.
        /// </summary>
        /// <param name="remoteChannelNumber">The remote channel number.</param>
        /// <param name="initialWindowSize">The initial window size.</param>
        /// <param name="maximumPacketSize">The maximum packet size.</param>
        public ChannelOpenConfirmedEventArgs(uint remoteChannelNumber, uint initialWindowSize, uint maximumPacketSize)
            : base(remoteChannelNumber)
        {
            InitialWindowSize = initialWindowSize;
            MaximumPacketSize = maximumPacketSize;
        }

        /// <summary>
        /// Gets the initial size of the window.
        /// </summary>
        /// <value>
        /// The initial size of the window.
        /// </value>
        public uint InitialWindowSize { get; private set; }

        /// <summary>
        /// Gets the maximum size of the packet.
        /// </summary>
        /// <value>
        /// The maximum size of the packet.
        /// </value>
        public uint MaximumPacketSize { get; private set; }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\ChannelOpenFailedEventArgs.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Common
{
    /// <summary>
    /// Provides data for <see cref="Renci.SshNet.Channels.ClientChannel.OpenFailed"/> event.
    /// </summary>
    public class ChannelOpenFailedEventArgs : ChannelEventArgs
    {
        /// <summary>
        /// Gets failure reason code.
        /// </summary>
        public uint ReasonCode { get; private set; }

        /// <summary>
        /// Gets failure description.
        /// </summary>
        public string Description { get; private set; }

        /// <summary>
        /// Gets failure language.
        /// </summary>
        public string Language { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelOpenFailedEventArgs"/> class.
        /// </summary>
        /// <param name="channelNumber">Channel number.</param>
        /// <param name="reasonCode">Failure reason code.</param>
        /// <param name="description">Failure description.</param>
        /// <param name="language">Failure language.</param>
        public ChannelOpenFailedEventArgs(uint channelNumber, uint reasonCode, string description, string language)
            : base(channelNumber)
        {
            this.ReasonCode = reasonCode;
            this.Description = description;
            this.Language = language;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\ChannelRequestEventArgs.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// Provides data for <see cref="Renci.SshNet.Channels.Channel.RequestReceived"/> event.
    /// </summary>
    public class ChannelRequestEventArgs : EventArgs
    {
        /// <summary>
        /// Gets request information.
        /// </summary>
        public RequestInfo Info { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelRequestEventArgs"/> class.
        /// </summary>
        /// <param name="info">Request information.</param>
        public ChannelRequestEventArgs(RequestInfo info)
        {
            this.Info = info;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\DerData.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// Base class for DER encoded data.
    /// </summary>
    public class DerData
    {
        private const byte CONSTRUCTED = 0x20;

        private const byte BOOLEAN = 0x01;
        private const byte INTEGER = 0x02;
        //private const byte BITSTRING = 0x03;
        private const byte OCTETSTRING = 0x04;
        private const byte NULL = 0x05;
        private const byte OBJECTIDENTIFIER = 0x06;
        //private const byte EXTERNAL = 0x08;
        //private const byte ENUMERATED = 0x0a;
        private const byte SEQUENCE = 0x10;
        //private const byte SEQUENCEOF = 0x10; // for completeness
        //private const byte SET = 0x11;
        //private const byte SETOF = 0x11; // for completeness

        //private const byte NUMERICSTRING = 0x12;
        //private const byte PRINTABLESTRING = 0x13;
        //private const byte T61STRING = 0x14;
        //private const byte VIDEOTEXSTRING = 0x15;
        //private const byte IA5STRING = 0x16;
        //private const byte UTCTIME = 0x17;
        //private const byte GENERALIZEDTIME = 0x18;
        //private const byte GRAPHICSTRING = 0x19;
        //private const byte VISIBLESTRING = 0x1a;
        //private const byte GENERALSTRING = 0x1b;
        //private const byte UNIVERSALSTRING = 0x1c;
        //private const byte BMPSTRING = 0x1e;
        //private const byte UTF8STRING = 0x0c;
        //private const byte APPLICATION = 0x40;
        //private const byte TAGGED = 0x80;

        private readonly List<byte> _data;

        private int _readerIndex;
        private readonly int _lastIndex;

        /// <summary>
        /// Gets a value indicating whether end of data is reached.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if end of data is reached; otherwise, <c>false</c>.
        /// </value>
        public bool IsEndOfData
        {
            get
            {
                return this._readerIndex >= this._lastIndex;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DerData"/> class.
        /// </summary>
        public DerData()
        {
            this._data = new List<byte>();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DerData"/> class.
        /// </summary>
        /// <param name="data">DER encoded data.</param>
        public DerData(byte[] data)
        {
            this._data = new List<byte>(data);
            var dataType = this.ReadByte();
            var length = this.ReadLength();
            this._lastIndex = this._readerIndex + length;
        }

        /// <summary>
        /// Encodes written data as DER byte array.
        /// </summary>
        /// <returns>DER Encoded array.</returns>
        public byte[] Encode()
        {
            var length = this._data.Count();
            var lengthBytes = this.GetLength(length);

            this._data.InsertRange(0, lengthBytes);
            this._data.Insert(0, CONSTRUCTED | SEQUENCE);

            return this._data.ToArray();
        }

        /// <summary>
        /// Reads next mpint data type from internal buffer.
        /// </summary>
        /// <returns>mpint read.</returns>
        public BigInteger ReadBigInteger()
        {
            var type = this.ReadByte();
            if (type != INTEGER)
                throw new InvalidOperationException("Invalid data type, INTEGER(02) is expected.");

            var length = this.ReadLength();

            var data = this.ReadBytes(length);

            return new BigInteger(data.Reverse().ToArray());
        }

        /// <summary>
        /// Reads next int data type from internal buffer.
        /// </summary>
        /// <returns>int read.</returns>
        public int ReadInteger()
        {
            var type = this.ReadByte();
            if (type != INTEGER)
                throw new InvalidOperationException("Invalid data type, INTEGER(02) is expected.");

            var length = this.ReadLength();

            var data = this.ReadBytes(length);

            if (length > 4)
                throw new InvalidOperationException("Integer type cannot occupy more then 4 bytes");

            var result = 0;
            var shift = (length - 1) * 8;
            for (int i = 0; i < length; i++)
            {
                result |= data[i] << shift;
                shift -= 8;
            }

            //return (int)(data[0] << 56 | data[1] << 48 | data[2] << 40 | data[3] << 32 | data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);

            return result;
        }

        /// <summary>
        /// Writes BOOLEAN data into internal buffer.
        /// </summary>
        /// <param name="data">UInt32 data to write.</param>
        public void Write(bool data)
        {
            this._data.Add(BOOLEAN);
            this._data.Add(1);
            this._data.Add((byte)(data ? 1 : 0));
        }

        /// <summary>
        /// Writes UInt32 data into internal buffer.
        /// </summary>
        /// <param name="data">UInt32 data to write.</param>
        public void Write(UInt32 data)
        {
            var bytes = data.GetBytes();
            this._data.Add(INTEGER);
            var length = this.GetLength(bytes.Length);
            this.WriteBytes(length);
            this.WriteBytes(bytes);
        }

        /// <summary>
        /// Writes INTEGER data into internal buffer.
        /// </summary>
        /// <param name="data">BigInteger data to write.</param>
        public void Write(BigInteger data)
        {
            var bytes = data.ToByteArray().Reverse().ToList();
            this._data.Add(INTEGER);
            var length = this.GetLength(bytes.Count);
            this.WriteBytes(length);
            this.WriteBytes(bytes);
        }

        /// <summary>
        /// Writes OCTETSTRING data into internal buffer.
        /// </summary>
        /// <param name="data">The data.</param>
        public void Write(byte[] data)
        {
            this._data.Add(OCTETSTRING);
            var length = this.GetLength(data.Length);
            this.WriteBytes(length);
            this.WriteBytes(data);
        }

        /// <summary>
        /// Writes OBJECTIDENTIFIER data into internal buffer.
        /// </summary>
        /// <param name="identifier">The identifier.</param>
        public void Write(ObjectIdentifier identifier)
        {
            var temp = new ulong[identifier.Identifiers.Length - 1];
            temp[0] = identifier.Identifiers[0] * 40 + identifier.Identifiers[1];
            Buffer.BlockCopy(identifier.Identifiers, 2 * sizeof(ulong), temp, 1 * sizeof(ulong), (identifier.Identifiers.Length - 2) * sizeof(ulong));
            //Array.Copy(identifier.Identifiers, 2, temp, 1, identifier.Identifiers.Length - 2);
            var bytes = new List<byte>();
            foreach (var subidentifier in temp)
            {
                var item = subidentifier;
                var buffer = new byte[8];
                var bufferIndex = buffer.Length - 1;

                var current = (byte)(item & 0x7F);
                do
                {
                    buffer[bufferIndex] = current;
                    if (bufferIndex < buffer.Length - 1)
                        buffer[bufferIndex] |= (byte)0x80;
                    item >>= 7;
                    current = (byte)(item & 0x7F);
                    bufferIndex--;
                }
                while (current > 0);

                for (int i = bufferIndex + 1; i < buffer.Length; i++)
                {
                    bytes.Add(buffer[i]);
                }
            }

            this._data.Add(OBJECTIDENTIFIER);
            var length = this.GetLength(bytes.Count);
            this.WriteBytes(length);
            this.WriteBytes(bytes);
        }

        /// <summary>
        /// Writes NULL data into internal buffer.
        /// </summary>
        public void WriteNull()
        {
            this._data.Add(NULL);
            this._data.Add(0);
        }

        /// <summary>
        /// Writes DerData data into internal buffer.
        /// </summary>
        /// <param name="data">DerData data to write.</param>
        public void Write(DerData data)
        {
            var bytes = data.Encode();
            this._data.AddRange(bytes);
        }

        private byte[] GetLength(int length)
        {
            if (length > 127)
            {
                int size = 1;
                int val = length;

                while ((val >>= 8) != 0)
                    size++;

                var data = new byte[size];
                data[0] = (byte)(size | 0x80);

                for (int i = (size - 1) * 8, j = 1; i >= 0; i -= 8, j++)
                {
                    data[j] = (byte)(length >> i);
                }

                return data;
            }
            return new byte[] { (byte)length };
        }

        private int ReadLength()
        {
            int length = this.ReadByte();

            if (length == 0x80)
            {
                throw new NotSupportedException("Indefinite-length encoding is not supported.");
            }

            if (length > 127)
            {
                int size = length & 0x7f;

                // Note: The invalid long form "0xff" (see X.690 8.1.3.5c) will be caught here
                if (size > 4)
                    throw new InvalidOperationException(string.Format("DER length is '{0}' and cannot be more than 4 bytes.", size));

                length = 0;
                for (int i = 0; i < size; i++)
                {
                    int next = this.ReadByte();

                    length = (length << 8) + next;
                }

                if (length < 0)
                    throw new InvalidOperationException("Corrupted data - negative length found");

                //if (length >= limit)   // after all we must have read at least 1 byte
                //    throw new IOException("Corrupted stream - out of bounds length found");
            }

            return length;
        }

        private void WriteBytes(IEnumerable<byte> data)
        {
            this._data.AddRange(data);
        }

        private byte ReadByte()
        {
            if (this._readerIndex > this._data.Count)
                throw new InvalidOperationException("Read out of boundaries.");

            return this._data[this._readerIndex++];
        }

        private byte[] ReadBytes(int length)
        {
            if (this._readerIndex + length > this._data.Count)
                throw new InvalidOperationException("Read out of boundaries.");

            var result = new byte[length];
            this._data.CopyTo(this._readerIndex, result, 0, length);
            this._readerIndex += length;
            return result;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\ExceptionEventArgs.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// Provides data for the ErrorOccured events.
    /// </summary>
    public class ExceptionEventArgs : EventArgs
    {
        /// <summary>
        /// Gets the System.Exception that represents the error that occurred.
        /// </summary>
        public Exception Exception { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExceptionEventArgs"/> class.
        /// </summary>
        /// <param name="exception">An System.Exception that represents the error that occurred.</param>
        public ExceptionEventArgs(Exception exception)
        {
            this.Exception = exception;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\Extensions.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Collection of different extension method
    /// </summary>
    public static partial class Extensions
    {
        /// <summary>
        /// Checks whether a collection is the same as another collection
        /// </summary>
        /// <param name="value">The current instance object</param>
        /// <param name="compareList">The collection to compare with</param>
        /// <param name="comparer">The comparer object to use to compare each item in the collection.  If null uses EqualityComparer(T).Default</param>
        /// <returns>True if the two collections contain all the same items in the same order</returns>
        internal static bool IsEqualTo<TSource>(this IEnumerable<TSource> value, IEnumerable<TSource> compareList, IEqualityComparer<TSource> comparer)
        {
            if (value == compareList)
                return true;
            if (value == null || compareList == null)
                return false;

            if (comparer == null)
            {
                comparer = EqualityComparer<TSource>.Default;
            }

            var enumerator1 = value.GetEnumerator();
            var enumerator2 = compareList.GetEnumerator();

            bool enum1HasValue = enumerator1.MoveNext();
            bool enum2HasValue = enumerator2.MoveNext();

            try
            {
                while (enum1HasValue && enum2HasValue)
                {
                    if (!comparer.Equals(enumerator1.Current, enumerator2.Current))
                    {
                        return false;
                    }

                    enum1HasValue = enumerator1.MoveNext();
                    enum2HasValue = enumerator2.MoveNext();
                }

                return !(enum1HasValue || enum2HasValue);
            }
            finally
            {
                enumerator1.Dispose();
                enumerator2.Dispose();
            }
        }

        /// <summary>
        /// Checks whether a collection is the same as another collection
        /// </summary>
        /// <param name="value">The current instance object</param>
        /// <param name="compareList">The collection to compare with</param>
        /// <returns>True if the two collections contain all the same items in the same order</returns>
        internal static bool IsEqualTo<TSource>(this IEnumerable<TSource> value, IEnumerable<TSource> compareList)
        {
            return IsEqualTo(value, compareList, null);
        }

#if SILVERLIGHT
#else

        /// <summary>
        /// Prints out 
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        internal static void DebugPrint(this IEnumerable<byte> bytes)
        {
            foreach (var b in bytes)
            {
                Debug.Write(string.Format(CultureInfo.CurrentCulture, "0x{0:x2}, ", b));
            }
            Debug.WriteLine(string.Empty);
        }
#endif

        /// <summary>
        /// Trims the leading zero from bytes array.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <returns>Data without leading zeros.</returns>
        internal static IEnumerable<byte> TrimLeadingZero(this IEnumerable<byte> data)
        {
            bool leadingZero = true;
            foreach (var item in data)
            {
                if (item == 0 & leadingZero)
                {
                    continue;
                }
                leadingZero = false;

                yield return item;
            }
        }

        /// <summary>
        /// Creates an instance of the specified type using that type's default constructor.
        /// </summary>
        /// <typeparam name="T">The type to create.</typeparam>
        /// <param name="type">Type of the instance to create.</param>
        /// <returns>A reference to the newly created object.</returns>
        public static T CreateInstance<T>(this Type type) where T : class
        {
            if (type == null)
                return null;
            return Activator.CreateInstance(type) as T;
        }

        /// <summary>
        /// Returns the specified 16-bit unsigned integer value as an array of bytes.
        /// </summary>
        /// <param name="value">The number to convert.</param>
        /// <returns>An array of bytes with length 2.</returns>
        internal static byte[] GetBytes(this UInt16 value)
        {
            return new byte[] { (byte)(value >> 8), (byte)(value & 0xFF) };
        }

        /// <summary>
        /// Returns the specified 32-bit unsigned integer value as an array of bytes.
        /// </summary>
        /// <param name="value">The number to convert.</param>
        /// <returns>An array of bytes with length 4.</returns>
        internal static byte[] GetBytes(this UInt32 value)
        {
            return new byte[] { (byte)(value >> 24), (byte)(value >> 16), (byte)(value >> 8), (byte)(value & 0xFF) };
        }

        /// <summary>
        /// Returns the specified 64-bit unsigned integer value as an array of bytes.
        /// </summary>
        /// <param name="value">The number to convert.</param>
        /// <returns>An array of bytes with length 8.</returns>
        internal static byte[] GetBytes(this UInt64 value)
        {
            return new byte[] { (byte)(value >> 56), (byte)(value >> 48), (byte)(value >> 40), (byte)(value >> 32), (byte)(value >> 24), (byte)(value >> 16), (byte)(value >> 8), (byte)(value & 0xFF) };
        }

        /// <summary>
        /// Returns the specified 64-bit signed integer value as an array of bytes.
        /// </summary>
        /// <param name="value">The number to convert.</param>
        /// <returns>An array of bytes with length 8.</returns>
        internal static byte[] GetBytes(this Int64 value)
        {
            return new byte[] { (byte)(value >> 56), (byte)(value >> 48), (byte)(value >> 40), (byte)(value >> 32), (byte)(value >> 24), (byte)(value >> 16), (byte)(value >> 8), (byte)(value & 0xFF) };
        }

        internal static void ValidatePort(this uint value, string argument)
        {
            if (value > IPEndPoint.MaxPort)
                throw new ArgumentOutOfRangeException(argument,
                    string.Format(CultureInfo.InvariantCulture, "Specified value cannot be greater than {0}.",
                        IPEndPoint.MaxPort));
        }

        internal static void ValidatePort(this int value, string argument)
        {
            if (value < IPEndPoint.MinPort)
                throw new ArgumentOutOfRangeException(argument,
                    string.Format(CultureInfo.InvariantCulture, "Specified value cannot be less than {0}.",
                        IPEndPoint.MinPort));

            if (value > IPEndPoint.MaxPort)
                throw new ArgumentOutOfRangeException(argument,
                    string.Format(CultureInfo.InvariantCulture, "Specified value cannot be greater than {0}.",
                        IPEndPoint.MaxPort));
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\Extensions.NET.cs
#if !MOBILE && !CORE

namespace Renci.SshNet
{
    /// <summary>
    /// Collection of different extension method specific for .NET 4.0
    /// </summary>
    public static partial class Extensions
    {
        /// <summary>
        /// Determines whether [is null or white space] [the specified value].
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        ///   <c>true</c> if [is null or white space] [the specified value]; otherwise, <c>false</c>.
        /// </returns>
        internal static bool IsNullOrWhiteSpace(this string value)
        {
            if (string.IsNullOrEmpty(value)) return true;

            return value.All(char.IsWhiteSpace);
        }
        
        internal static bool CanRead(this Socket socket)
        {
            return socket.Connected && socket.Poll(-1, SelectMode.SelectRead) && socket.Available > 0;
        }

        internal static bool CanWrite(this Socket socket)
        {
            return socket.Connected && socket.Poll(-1, SelectMode.SelectWrite);
        }

        internal static IPAddress GetIPAddress(this string host)
        {
            IPAddress ipAddress;
            if (!IPAddress.TryParse(host, out ipAddress))
                ipAddress = Dns.GetHostAddresses(host).First();

            return ipAddress;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\HostKeyEventArgs.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// Provides data for the HostKeyReceived event.
    /// </summary>
    public class HostKeyEventArgs : EventArgs
    {
        /// <summary>
        /// Gets or sets a value indicating whether host key can be trusted.
        /// </summary>
        /// <value>
        ///   <c>true</c> if host key can be trusted; otherwise, <c>false</c>.
        /// </value>
        public bool CanTrust { get; set; }

        /// <summary>
        /// Gets the host key.
        /// </summary>
        public byte[] HostKey { get; private set; }

        /// <summary>
        /// Gets the host key name.
        /// </summary>
        public string HostKeyName{ get; private set; }

        /// <summary>
        /// Gets the finger print.
        /// </summary>
        public byte[] FingerPrint { get; private set; }

        /// <summary>
        /// Gets the length of the key in bits.
        /// </summary>
        /// <value>
        /// The length of the key in bits.
        /// </value>
        public int KeyLength { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="HostKeyEventArgs"/> class.
        /// </summary>
        /// <param name="host">The host.</param>
        public HostKeyEventArgs(KeyHostAlgorithm host)
        {
            this.CanTrust = true;   //  Set default value

            this.HostKey = host.Data;

            this.HostKeyName = host.Name;

            this.KeyLength = host.Key.KeyLength;

            using (var md5 = new MD5Hash())
            {
                this.FingerPrint = md5.ComputeHash(host.Data);
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\NetConfServerException.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// The exception that is thrown when there is something wrong with the server capabilities.
    /// </summary>
    public partial class NetConfServerException : SshException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="NetConfServerException"/> class.
        /// </summary>
        public NetConfServerException()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NetConfServerException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        public NetConfServerException(string message)
            : base(message)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NetConfServerException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        /// <param name="innerException">The inner exception.</param>
        public NetConfServerException(string message, Exception innerException) :
            base(message, innerException)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\NetConfServerException.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// The exception that is thrown when there is something wrong with the server capabilities.
    /// </summary>
    [Serializable]
    public partial class NetConfServerException : SshException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SshAuthenticationException"/> class.
        /// </summary>
        /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        /// <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
        /// <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
        protected NetConfServerException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\ObjectIdentifier.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// Describes object identifier for DER encoding
    /// </summary>
    public struct ObjectIdentifier
    {
        /// <summary>
        /// Gets the object identifier.
        /// </summary>
        public ulong[] Identifiers { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectIdentifier"/> class.
        /// </summary>
        /// <param name="identifiers">The identifiers.</param>
        public ObjectIdentifier(params ulong[] identifiers)
            : this()
        {
            if (identifiers.Length < 2)
                throw new ArgumentException("identifiers");

            this.Identifiers = identifiers;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\PipeStream.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Common
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Threading;
    using System.Globalization;

    /// <summary>
    /// PipeStream is a thread-safe read/write data stream for use between two threads in a 
    /// single-producer/single-consumer type problem.
    /// </summary>
    /// <version>2006/10/13 1.0</version>
    /// <remarks>Update on 2008/10/9 1.1 - uses Monitor instead of Manual Reset events for more elegant synchronicity.</remarks>
    /// <license>
    ///	Copyright (c) 2006 James Kolpack (james dot kolpack at google mail)
    ///	
    ///	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and 
    ///	associated documentation files (the "Software"), to deal in the Software without restriction, 
    ///	including without limitation the rights to use, copy, modify, merge, publish, distribute, 
    ///	sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is 
    ///	furnished to do so, subject to the following conditions:
    ///	
    ///	The above copyright notice and this permission notice shall be included in all copies or 
    ///	substantial portions of the Software.
    ///	
    ///	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
    ///	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
    ///	PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
    ///	LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT 
    ///	OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
    ///	OTHER DEALINGS IN THE SOFTWARE.
    /// </license>
    public class PipeStream : Stream
    {
        #region Private members

        /// <summary>
        /// Queue of bytes provides the datastructure for transmitting from an
        /// input stream to an output stream.
        /// </summary>
        /// <remarks>Possible more effecient ways to accomplish this.</remarks>
        private readonly Queue<byte> _buffer = new Queue<byte>();

        /// <summary>
        /// Indicates that the input stream has been flushed and that
        /// all remaining data should be written to the output stream.
        /// </summary>
        private bool _isFlushed;

        /// <summary>
        /// Maximum number of bytes to store in the buffer.
        /// </summary>
        private long _maxBufferLength = 200 * 1024 * 1024;

        /// <summary>
        /// Setting this to true will cause Read() to block if it appears
        /// that it will run out of data.
        /// </summary>
        private bool _canBlockLastRead;

        #endregion

        #region Public properties

        /// <summary>
        /// Gets or sets the maximum number of bytes to store in the buffer.
        /// </summary>
        /// <value>The length of the max buffer.</value>
        public long MaxBufferLength
        {
            get { return this._maxBufferLength; }
            set { this._maxBufferLength = value; }
        }

        /// <summary>
        /// Gets or sets a value indicating whether to block last read method before the buffer is empty.
        /// When true, Read() will block until it can fill the passed in buffer and count.
        /// When false, Read() will not block, returning all the available buffer data.
        /// </summary>
        /// <remarks>
        /// Setting to true will remove the possibility of ending a stream reader prematurely.
        /// </remarks>
        /// <value>
        /// 	<c>true</c> if block last read method before the buffer is empty; otherwise, <c>false</c>.
        /// </value>
        public bool BlockLastReadBuffer
        {
            get { return this._canBlockLastRead; }
            set
            {
                this._canBlockLastRead = value;

                // when turning off the block last read, signal Read() that it may now read the rest of the buffer.
                if (!this._canBlockLastRead)
                    lock (this._buffer)
                        Monitor.Pulse(this._buffer);
            }
        }

        #endregion

        #region Stream overide methods

        ///<summary>
        ///When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.
        ///</summary>
        ///
        ///<exception cref="T:System.IO.IOException">An I/O error occurs. </exception><filterpriority>2</filterpriority>
        public override void Flush()
        {
            this._isFlushed = true;
            lock (this._buffer)
                Monitor.Pulse(this._buffer);
        }

        ///<summary>
        ///When overridden in a derived class, sets the position within the current stream.
        ///</summary>
        ///<returns>
        ///The new position within the current stream.
        ///</returns>
        ///<param name="offset">A byte offset relative to the origin parameter. </param>
        ///<param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"></see> indicating the reference point used to obtain the new position. </param>
        ///<exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        ///<exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output. </exception>
        ///<exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException();
        }

        ///<summary>
        ///When overridden in a derived class, sets the length of the current stream.
        ///</summary>
        ///<param name="value">The desired length of the current stream in bytes. </param>
        ///<exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output. </exception>
        ///<exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        ///<exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>2</filterpriority>
        public override void SetLength(long value)
        {
            throw new NotSupportedException();
        }

        ///<summary>
        ///When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
        ///</summary>
        ///<returns>
        ///The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
        ///</returns>
        ///<param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream. </param>
        ///<param name="count">The maximum number of bytes to be read from the current stream. </param>
        ///<param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between offset and (offset + count - 1) replaced by the bytes read from the current source. </param>
        ///<exception cref="T:System.ArgumentException">The sum of offset and count is larger than the buffer length. </exception>
        ///<exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
        ///<exception cref="T:System.NotSupportedException">The stream does not support reading. </exception>
        ///<exception cref="T:System.ArgumentNullException">buffer is null. </exception>
        ///<exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        ///<exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative. </exception><filterpriority>1</filterpriority>
        public override int Read(byte[] buffer, int offset, int count)
        {
            if (offset != 0)
                throw new NotSupportedException("Offsets with value of non-zero are not supported");
            if (buffer == null)
                throw new ArgumentNullException("buffer");
            if (offset + count > buffer.Length)
                throw new ArgumentException("The sum of offset and count is greater than the buffer length. ");
            if (offset < 0 || count < 0)
                throw new ArgumentOutOfRangeException("offset", "offset or count is negative.");
            if (BlockLastReadBuffer && count >= _maxBufferLength)
                throw new ArgumentException(String.Format(CultureInfo.CurrentCulture, "count({0}) > mMaxBufferLength({1})", count, _maxBufferLength));

            if (count == 0)
                return 0;

            int readLength = 0;

            lock (this._buffer)
            {
                while (!this.ReadAvailable(count))
                    Monitor.Wait(this._buffer);

                // fill the read buffer
                for (; readLength < count && Length > 0 && this._buffer.Count > 0; readLength++)
                {
                    buffer[readLength] = this._buffer.Dequeue();
                }

                Monitor.Pulse(this._buffer);
            }
            return readLength;
        }

        /// <summary>
        /// Returns true if there are
        /// </summary>
        /// <param name="count">The count.</param>
        /// <returns><c>True</c> if data available; otherwise<c>false</c>.</returns>
        private bool ReadAvailable(int count)
        {
            return (this.Length >= count || this._isFlushed) &&
                   (this.Length >= (count + 1) || !this.BlockLastReadBuffer);
        }

        ///<summary>
        ///When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
        ///</summary>
        ///<param name="offset">The zero-based byte offset in buffer at which to begin copying bytes to the current stream. </param>
        ///<param name="count">The number of bytes to be written to the current stream. </param>
        ///<param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream. </param>
        ///<exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        ///<exception cref="T:System.NotSupportedException">The stream does not support writing. </exception>
        ///<exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
        ///<exception cref="T:System.ArgumentNullException">buffer is null. </exception>
        ///<exception cref="T:System.ArgumentException">The sum of offset and count is greater than the buffer length. </exception>
        ///<exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative. </exception><filterpriority>1</filterpriority>
        public override void Write(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
                throw new ArgumentNullException("buffer");
            if (offset + count > buffer.Length)
                throw new ArgumentException("The sum of offset and count is greater than the buffer length. ");
            if (offset < 0 || count < 0)
                throw new ArgumentOutOfRangeException("offset", "offset or count is negative.");
            if (count == 0)
                return;

            lock (this._buffer)
            {
                // wait until the buffer isn't full
                while (this.Length >= this._maxBufferLength)
                    Monitor.Wait(this._buffer);

                this._isFlushed = false; // if it were flushed before, it soon will not be.

                // queue up the buffer data
                for (int i = offset; i < offset + count; i++)
                {
                    this._buffer.Enqueue(buffer[i]);
                }

                Monitor.Pulse(this._buffer); // signal that write has occurred
            }
        }

        ///<summary>
        ///When overridden in a derived class, gets a value indicating whether the current stream supports reading.
        ///</summary>
        ///<returns>
        ///true if the stream supports reading; otherwise, false.
        ///</returns>
        ///<filterpriority>1</filterpriority>
        public override bool CanRead
        {
            get { return true; }
        }

        ///<summary>
        ///When overridden in a derived class, gets a value indicating whether the current stream supports seeking.
        ///</summary>
        ///<returns>
        ///true if the stream supports seeking; otherwise, false.
        ///</returns>
        ///<filterpriority>1</filterpriority>
        public override bool CanSeek
        {
            get { return false; }
        }

        ///<summary>
        ///When overridden in a derived class, gets a value indicating whether the current stream supports writing.
        ///</summary>
        ///<returns>
        ///true if the stream supports writing; otherwise, false.
        ///</returns>
        ///<filterpriority>1</filterpriority>
        public override bool CanWrite
        {
            get { return true; }
        }

        ///<summary>
        ///When overridden in a derived class, gets the length in bytes of the stream.
        ///</summary>
        ///<returns>
        ///A long value representing the length of the stream in bytes.
        ///</returns>
        ///
        ///<exception cref="T:System.NotSupportedException">A class derived from Stream does not support seeking. </exception>
        ///<exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        public override long Length
        {
            get { return this._buffer.Count; }
        }

        ///<summary>
        ///When overridden in a derived class, gets or sets the position within the current stream.
        ///</summary>
        ///<returns>
        ///The current position within the stream.
        ///</returns>
        ///<exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        ///<exception cref="T:System.NotSupportedException">The stream does not support seeking. </exception>
        ///<exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        public override long Position
        {
            get { return 0; }
            set { throw new NotSupportedException(); }
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\Common\PortForwardEventArgs.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// Provides data for <see cref="Renci.SshNet.ForwardedPort.RequestReceived"/> event.
    /// </summary>
    public class PortForwardEventArgs : EventArgs
    {
        /// <summary>
        /// Gets request originator host.
        /// </summary>
        public string OriginatorHost { get; private set; }

        /// <summary>
        /// Gets request originator port.
        /// </summary>
        public uint OriginatorPort { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="PortForwardEventArgs"/> class.
        /// </summary>
        /// <param name="host">The host.</param>
        /// <param name="port">The port.</param>
        /// <exception cref="ArgumentNullException"><paramref name="host"/> is <c>null</c>.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="port" /> is not within <see cref="F:System.Net.IPEndPoint.MinPort" /> and <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        internal PortForwardEventArgs(string host, uint port)
        {
            if (host == null)
                throw new ArgumentNullException("host");
            port.ValidatePort("port");

            OriginatorHost = host;
            OriginatorPort = port;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\ProxyException.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// The exception that is thrown when SCP error occurred.
    /// </summary>
    public partial class ProxyException : SshException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ScpException"/> class.
        /// </summary>
        public ProxyException()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ScpException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        public ProxyException(string message)
            : base(message)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ScpException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        /// <param name="innerException">The inner exception.</param>
        public ProxyException(string message, Exception innerException) :
            base(message, innerException)
        {
        }
    }

}

#endif
// file ...\X\Renci.SshNet\Common\ProxyException.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    [Serializable]
    public partial class ProxyException : SshException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ProxyException"/> class.
        /// </summary>
        /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        /// <exception cref="ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
        /// <exception cref="SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
        protected ProxyException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }

}

#endif
// file ...\X\Renci.SshNet\Common\ScpDownloadEventArgs.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// Provides data for the Downloading event.
    /// </summary>
    public class ScpDownloadEventArgs : EventArgs
    {
        /// <summary>
        /// Gets the downloaded filename.
        /// </summary>
        public string Filename { get; private set; }

        /// <summary>
        /// Gets the downloaded file size.
        /// </summary>
        public long Size { get; private set; }

        /// <summary>
        /// Gets number of downloaded bytes so far.
        /// </summary>
        public long Downloaded { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ScpDownloadEventArgs"/> class.
        /// </summary>
        /// <param name="filename">The downloaded filename.</param>
        /// <param name="size">The downloaded file size.</param>
        /// <param name="downloaded">The number of downloaded bytes so far.</param>
        public ScpDownloadEventArgs(string filename, long size, long downloaded)
        {
            this.Filename = filename;
            this.Size = size;
            this.Downloaded = downloaded;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\ScpException.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// The exception that is thrown when SCP error occurred.
    /// </summary>
    public partial class ScpException : SshException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ScpException"/> class.
        /// </summary>
        public ScpException()
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ScpException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        public ScpException(string message)
            : base(message)
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ScpException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        /// <param name="innerException">The inner exception.</param>
        public ScpException(string message, Exception innerException) :
            base(message, innerException)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\ScpException.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    [Serializable]
    public partial class ScpException : SshException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ScpException"/> class.
        /// </summary>
        /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        /// <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
        /// <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
        protected ScpException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\ScpUploadEventArgs.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// Provides data for the Uploading event.
    /// </summary>
    public class ScpUploadEventArgs : EventArgs
    {
        /// <summary>
        /// Gets the uploaded filename.
        /// </summary>
        public string Filename { get; private set; }

        /// <summary>
        /// Gets the uploaded file size.
        /// </summary>
        public long Size { get; private set; }

        /// <summary>
        /// Gets number of uploaded bytes so far.
        /// </summary>
        public long Uploaded { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ScpUploadEventArgs"/> class.
        /// </summary>
        /// <param name="filename">The uploaded filename.</param>
        /// <param name="size">The the uploaded file size.</param>
        /// <param name="uploaded">The number of uploaded bytes so far.</param>
        public ScpUploadEventArgs(string filename, long size, long uploaded)
        {
            this.Filename = filename;
            this.Size = size;
            this.Uploaded = uploaded;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\SemaphoreLight.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// Light implementation of SemaphoreSlim.
    /// </summary>
    public class SemaphoreLight
    {
        private readonly object _lock = new object();

        private int _currentCount;

        /// <summary>
        /// Initializes a new instance of the <see cref="SemaphoreLight"/> class, specifying 
        /// the initial number of requests that can be granted concurrently.
        /// </summary>
        /// <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently.</param>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="initialCount"/> is a negative number.</exception>
        public SemaphoreLight(int initialCount)
        {
            if (initialCount < 0 )
                throw new ArgumentOutOfRangeException("initialCount", "The value cannot be negative.");

            this._currentCount = initialCount;
        }

        /// <summary>
        /// Gets the current count of the <see cref="SemaphoreLight"/>.
        /// </summary>
        public int CurrentCount { get { return this._currentCount; } }

        /// <summary>
        /// Exits the <see cref="SemaphoreLight"/> once.
        /// </summary>
        /// <returns>The previous count of the <see cref="SemaphoreLight"/>.</returns>
        public int Release()
        {
            return this.Release(1);
        }

        /// <summary>
        /// Exits the <see cref="SemaphoreLight"/> a specified number of times.
        /// </summary>
        /// <param name="releaseCount">The number of times to exit the semaphore.</param>
        /// <returns>The previous count of the <see cref="SemaphoreLight"/>.</returns>
        public int Release(int releaseCount)
        {
            var oldCount = this._currentCount;

            lock (this._lock)
            {
                this._currentCount += releaseCount;

                Monitor.Pulse(this._lock);
            }

            return oldCount;
        }

        /// <summary>
        /// Blocks the current thread until it can enter the <see cref="SemaphoreLight"/>.
        /// </summary>
        public void Wait()
        {

            lock (this._lock)
            {
                while (this._currentCount < 1)
                {
                    Monitor.Wait(this._lock);
                }

                this._currentCount--;

                Monitor.Pulse(this._lock);
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\SftpPathNotFoundException.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// The exception that is thrown when file or directory is not found.
    /// </summary>
    public partial class SftpPathNotFoundException : SshException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SftpPathNotFoundException"/> class.
        /// </summary>
        public SftpPathNotFoundException()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpPathNotFoundException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        public SftpPathNotFoundException(string message)
            : base(message)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpPathNotFoundException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        /// <param name="innerException">The inner exception.</param>
        public SftpPathNotFoundException(string message, Exception innerException) :
            base(message, innerException)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\SftpPathNotFoundException.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// The exception that is thrown when file or directory is not found.
    /// </summary>
    [Serializable]
    public partial class SftpPathNotFoundException : SshException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SftpPathNotFoundException"/> class.
        /// </summary>
        /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        /// <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
        /// <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
        protected SftpPathNotFoundException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\SftpPermissionDeniedException.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// The exception that is thrown when operation permission is denied.
    /// </summary>
    public partial class SftpPermissionDeniedException : SshException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SftpPermissionDeniedException"/> class.
        /// </summary>
        public SftpPermissionDeniedException()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpPermissionDeniedException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        public SftpPermissionDeniedException(string message)
            : base(message)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpPermissionDeniedException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        /// <param name="innerException">The inner exception.</param>
        public SftpPermissionDeniedException(string message, Exception innerException) :
            base(message, innerException)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\SftpPermissionDeniedException.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// The exception that is thrown when operation permission is denied.
    /// </summary>
    [Serializable]
    public partial class SftpPermissionDeniedException : SshException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SftpPermissionDeniedException"/> class.
        /// </summary>
        /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        /// <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
        /// <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
        protected SftpPermissionDeniedException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\ShellDataEventArgs.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// Provides data for Shell DataReceived event
    /// </summary>
    public class ShellDataEventArgs : EventArgs
    {
        /// <summary>
        /// Gets the data.
        /// </summary>
        public byte[] Data { get; private set; }

        /// <summary>
        /// Gets the line data.
        /// </summary>
        public string Line { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ShellDataEventArgs"/> class.
        /// </summary>
        /// <param name="data">The data.</param>
        public ShellDataEventArgs(byte[] data)
        {
            this.Data = data;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ShellDataEventArgs"/> class.
        /// </summary>
        /// <param name="line">The line.</param>
        public ShellDataEventArgs(string line)
        {
            this.Line = line;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\SshAuthenticationException.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// The exception that is thrown when authentication failed.
    /// </summary>
    public partial class SshAuthenticationException : SshException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SshAuthenticationException"/> class.
        /// </summary>
        public SshAuthenticationException()
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshAuthenticationException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        public SshAuthenticationException(string message)
            : base(message)
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshAuthenticationException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        /// <param name="innerException">The inner exception.</param>
        public SshAuthenticationException(string message, Exception innerException) :
            base(message, innerException)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\SshAuthenticationException.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// The exception that is thrown when authentication failed.
    /// </summary>
    [Serializable]
    public partial class SshAuthenticationException : SshException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SshAuthenticationException"/> class.
        /// </summary>
        /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        /// <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
        /// <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
        protected SshAuthenticationException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\SshConnectionException.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// The exception that is thrown when connection was terminated.
    /// </summary>
    public partial class SshConnectionException : SshException
    {
        /// <summary>
        /// Gets the disconnect reason if provided by the server or client. Otherwise None.
        /// </summary>
        public DisconnectReason DisconnectReason { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshConnectionException"/> class.
        /// </summary>
        public SshConnectionException()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshConnectionException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        public SshConnectionException(string message)
            : base(message)
        {
            this.DisconnectReason = DisconnectReason.None;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshConnectionException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        /// <param name="disconnectReasonCode">The disconnect reason code.</param>
        public SshConnectionException(string message, DisconnectReason disconnectReasonCode)
            : base(message)
        {
            this.DisconnectReason = disconnectReasonCode;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshConnectionException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        /// <param name="disconnectReasonCode">The disconnect reason code.</param>
        /// <param name="inner">The inner.</param>
        public SshConnectionException(string message, DisconnectReason disconnectReasonCode, Exception inner)
            : base(message, inner)
        {
            this.DisconnectReason = disconnectReasonCode;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshConnectionException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        /// <param name="innerException">The inner exception.</param>
        public SshConnectionException(string message, Exception innerException) :
            base(message, innerException)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\SshConnectionException.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// The exception that is thrown when connection was terminated.
    /// </summary>
    [Serializable]
    public partial class SshConnectionException : SshException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SshConnectionException"/> class.
        /// </summary>
        /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        /// <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
        /// <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
        protected SshConnectionException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\SshData.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// Base ssh data serialization type
    /// </summary>
    public abstract class SshData
    {
        private static readonly Encoding _ascii = new Renci.SshNet.Common.ASCIIEncoding();

#if SILVERLIGHT
        private static readonly Encoding _utf8 = Encoding.UTF8;
#else
        private static readonly Encoding _utf8 = Encoding.Default;
#endif

        /// <summary>
        /// Data byte array that hold message unencrypted data
        /// </summary>
        private List<byte> _data;

        private int _readerIndex;

        /// <summary>
        /// Gets a value indicating whether all data from the buffer has been read.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if this instance is end of data; otherwise, <c>false</c>.
        /// </value>
        public bool IsEndOfData
        {
            get
            {
                return this._readerIndex >= this._data.Count();
            }
        }

        private byte[] _loadedData;

        /// <summary>
        /// Gets the index that represents zero in current data type.
        /// </summary>
        /// <value>
        /// The index of the zero reader.
        /// </value>
        protected virtual int ZeroReaderIndex
        {
            get
            {
                return 0;
            }
        }

        /// <summary>
        /// Gets data bytes array
        /// </summary>
        /// <returns>Byte array representation of data structure.</returns>
        public virtual byte[] GetBytes()
        {
            this._data = new List<byte>();

            this.SaveData();

            return this._data.ToArray();
        }

        internal T OfType<T>() where T : SshData, new()
        {
            var result = new T();
            result.LoadBytes(this._loadedData);
            result.LoadData();
            return result;
        }

        /// <summary>
        /// Loads data from specified bytes.
        /// </summary>
        /// <param name="value">Bytes array.</param>
        /// <exception cref="ArgumentNullException"><paramref name="value"/> is null.</exception>
        public void Load(byte[] value)
        {
            if (value == null)
                throw new ArgumentNullException("value");

            this.LoadBytes(value);
            this.LoadData();
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected abstract void LoadData();

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected abstract void SaveData();

        /// <summary>
        /// Loads data bytes into internal buffer.
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        /// <exception cref="ArgumentNullException"><paramref name="bytes"/> is null.</exception>
        protected void LoadBytes(byte[] bytes)
        {
            // Note about why I check for null here, and in Load(byte[]) in this class.
            // This method is called by several other classes, such as SshNet.Messages.Message, SshNet.Sftp.SftpMessage.
            if (bytes == null)
                throw new ArgumentNullException("bytes");

            this.ResetReader();
            this._loadedData = bytes;
            this._data = new List<byte>(bytes);
        }

        /// <summary>
        /// Resets internal data reader index.
        /// </summary>
        protected void ResetReader()
        {
            this._readerIndex = this.ZeroReaderIndex;  //  Set to 1 to skip first byte which specifies message type
        }

        /// <summary>
        /// Reads all data left in internal buffer at current position.
        /// </summary>
        /// <returns>An array of bytes containing the remaining data in the internal buffer.</returns>
        protected byte[] ReadBytes()
        {
            var data = new byte[this._data.Count - this._readerIndex];
            this._data.CopyTo(this._readerIndex, data, 0, data.Length);
            return data;
        }

        /// <summary>
        /// Reads next specified number of bytes data type from internal buffer.
        /// </summary>
        /// <param name="length">Number of bytes to read.</param>
        /// <returns>An array of bytes that was read from the internal buffer.</returns>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="length"/> is greater than the internal buffer size.</exception>
        protected byte[] ReadBytes(int length)
        {
            // Note that this also prevents allocating non-relevant lengths, such as if length is greater than _data.Count but less than int.MaxValue.
            // For the nerds, the condition translates to: if (length > data.Count && length < int.MaxValue)
            // Which probably would cause all sorts of exception, most notably OutOfMemoryException.
            if (length > this._data.Count)
                throw new ArgumentOutOfRangeException("length");

            var result = new byte[length];
            this._data.CopyTo(this._readerIndex, result, 0, length);
            this._readerIndex += length;
            return result;
        }

        /// <summary>
        /// Reads next byte data type from internal buffer.
        /// </summary>
        /// <returns>Byte read.</returns>
        protected byte ReadByte()
        {
            return this.ReadBytes(1).FirstOrDefault();
        }

        /// <summary>
        /// Reads next boolean data type from internal buffer.
        /// </summary>
        /// <returns>Boolean read.</returns>
        protected bool ReadBoolean()
        {
            return this.ReadByte() == 0 ? false : true;
        }

        /// <summary>
        /// Reads next uint16 data type from internal buffer.
        /// </summary>
        /// <returns>uint16 read</returns>
        protected UInt16 ReadUInt16()
        {
            var data = this.ReadBytes(2);
            return (ushort)(data[0] << 8 | data[1]);
        }

        /// <summary>
        /// Reads next uint32 data type from internal buffer.
        /// </summary>
        /// <returns>uint32 read</returns>
        protected UInt32 ReadUInt32()
        {
            var data = this.ReadBytes(4);
            return (uint)(data[0] << 24 | data[1] << 16 | data[2] << 8 | data[3]);
        }

        /// <summary>
        /// Reads next uint64 data type from internal buffer.
        /// </summary>
        /// <returns>uint64 read</returns>
        protected UInt64 ReadUInt64()
        {
            var data = this.ReadBytes(8);
            return ((ulong)data[0] << 56 | (ulong)data[1] << 48 | (ulong)data[2] << 40 | (ulong)data[3] << 32 | (ulong)data[4] << 24 | (ulong)data[5] << 16 | (ulong)data[6] << 8 | data[7]);
        }

        /// <summary>
        /// Reads next int64 data type from internal buffer.
        /// </summary>
        /// <returns>int64 read</returns>
        protected Int64 ReadInt64()
        {
            var data = this.ReadBytes(8);
            return (int)(data[0] << 56 | data[1] << 48 | data[2] << 40 | data[3] << 32 | data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);
        }

        /// <summary>
        /// Reads next string data type from internal buffer.
        /// </summary>
        /// <returns>string read</returns>
        protected string ReadAsciiString()
        {
            var length = this.ReadUInt32();

            if (length > (uint)int.MaxValue)
            {
                throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "Strings longer than {0} is not supported.", int.MaxValue));
            }
            return _ascii.GetString(this.ReadBytes((int)length), 0, (int)length);
        }

        /// <summary>
        /// Reads next string data type from internal buffer.
        /// </summary>
        /// <returns>string read</returns>
        protected string ReadString()
        {
            return this.ReadString(SshData._utf8);
        }

        /// <summary>
        /// Reads next string data type from internal buffer.
        /// </summary>
        /// <returns>string read</returns>
        protected string ReadString(Encoding encoding)
        {
            var length = this.ReadUInt32();

            if (length > (uint)int.MaxValue)
            {
                throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "Strings longer than {0} is not supported.", int.MaxValue));
            }
            return encoding.GetString(this.ReadBytes((int)length), 0, (int)length);
        }


        /// <summary>
        /// Reads next string data type from internal buffer.
        /// </summary>
        /// <returns>string read</returns>
        protected byte[] ReadBinaryString()
        {
            var length = this.ReadUInt32();

            if (length > (uint)int.MaxValue)
            {
                throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "Strings longer than {0} is not supported.", int.MaxValue));
            }

            return this.ReadBytes((int)length);
        }

        /// <summary>
        /// Reads next mpint data type from internal buffer.
        /// </summary>
        /// <returns>mpint read.</returns>
        protected BigInteger ReadBigInt()
        {
            var length = this.ReadUInt32();

            var data = this.ReadBytes((int)length);

            return new BigInteger(data.Reverse().ToArray());
        }

        /// <summary>
        /// Reads next name-list data type from internal buffer.
        /// </summary>
        /// <returns>String array or read data..</returns>
        protected string[] ReadNamesList()
        {
            var namesList = this.ReadString();
            return namesList.Split(',');
        }

        /// <summary>
        /// Reads next extension-pair data type from internal buffer.
        /// </summary>
        /// <returns>Extensions pair dictionary.</returns>
        protected IDictionary<string, string> ReadExtensionPair()
        {
            Dictionary<string, string> result = new Dictionary<string, string>();
            while (this._readerIndex < this._data.Count)
            {
                var extensionName = this.ReadString();
                var extensionData = this.ReadString();
                result.Add(extensionName, extensionData);
            }
            return result;
        }

        /// <summary>
        /// Writes bytes array data into internal buffer.
        /// </summary>
        /// <param name="data">Byte array data to write.</param>
        /// <exception cref="ArgumentNullException"><paramref name="data"/> is null.</exception>
        protected void Write(IEnumerable<byte> data)
        {
            this._data.AddRange(data);
        }

        /// <summary>
        /// Writes byte data into internal buffer.
        /// </summary>
        /// <param name="data">Byte data to write.</param>
        protected void Write(byte data)
        {
            this._data.Add(data);
        }

        /// <summary>
        /// Writes boolean data into internal buffer.
        /// </summary>
        /// <param name="data">Boolean data to write.</param>
        protected void Write(bool data)
        {
            if (data)
            {
                this.Write(1);
            }
            else
            {
                this.Write(0);
            }
        }

        /// <summary>
        /// Writes uint16 data into internal buffer.
        /// </summary>
        /// <param name="data">uint16 data to write.</param>
        protected void Write(UInt16 data)
        {
            this.Write(data.GetBytes());
        }

        /// <summary>
        /// Writes uint32 data into internal buffer.
        /// </summary>
        /// <param name="data">uint32 data to write.</param>
        protected void Write(UInt32 data)
        {
            this.Write(data.GetBytes());
        }

        /// <summary>
        /// Writes uint64 data into internal buffer.
        /// </summary>
        /// <param name="data">uint64 data to write.</param>
        protected void Write(UInt64 data)
        {
            this.Write(data.GetBytes());
        }

        /// <summary>
        /// Writes int64 data into internal buffer.
        /// </summary>
        /// <param name="data">int64 data to write.</param>
        protected void Write(Int64 data)
        {
            this.Write(data.GetBytes());
        }


        /// <summary>
        /// Writes string data into internal buffer as ASCII.
        /// </summary>
        /// <param name="data">string data to write.</param>
        protected void WriteAscii(string data)
        {
            this.Write(data, SshData._ascii);
        }

        /// <summary>
        /// Writes string data into internal buffer using default encoding.
        /// </summary>
        /// <param name="data">string data to write.</param>
        /// <exception cref="ArgumentNullException"><paramref name="data"/> is null.</exception>
        protected void Write(string data)
        {
            this.Write(data, SshData._utf8);
        }

        /// <summary>
        /// Writes string data into internal buffer using the specified encoding.
        /// </summary>
        /// <param name="data">string data to write.</param>
        /// <param name="encoding">The character encoding to use.</param>
        /// <exception cref="ArgumentNullException"><paramref name="data"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="encoding"/> is null.</exception>
        protected void Write(string data, Encoding encoding)
        {
            if (data == null)
                throw new ArgumentNullException("data");
            if (encoding == null)
                throw new ArgumentNullException("encoding");

            var bytes = encoding.GetBytes(data);
            this.Write((uint)bytes.Length);
            this.Write(bytes);
        }

        /// <summary>
        /// Writes string data into internal buffer.
        /// </summary>
        /// <param name="data">string data to write.</param>
        /// <exception cref="ArgumentNullException"><paramref name="data"/> is null.</exception>
        protected void WriteBinaryString(byte[] data)
        {
            if (data == null)
                throw new ArgumentNullException("data");

            this.Write((uint)data.Length);
            this._data.AddRange(data);
        }

        /// <summary>
        /// Writes mpint data into internal buffer.
        /// </summary>
        /// <param name="data">mpint data to write.</param>
        protected void Write(BigInteger data)
        {
            var bytes = data.ToByteArray().Reverse().ToList();
            this.Write((uint)bytes.Count);
            this.Write(bytes);
        }

        /// <summary>
        /// Writes name-list data into internal buffer.
        /// </summary>
        /// <param name="data">name-list data to write.</param>
        protected void Write(string[] data)
        {
            this.WriteAscii(string.Join(",", data));
        }

        /// <summary>
        /// Writes extension-pair data into internal buffer.
        /// </summary>
        /// <param name="data">extension-pair data to write.</param>
        protected void Write(IDictionary<string, string> data)
        {
            foreach (var item in data)
            {
                this.WriteAscii(item.Key);
                this.WriteAscii(item.Value);
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\SshException.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// The exception that is thrown when SSH exception occurs.
    /// </summary>
    public partial class SshException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SshException"/> class.
        /// </summary>
        public SshException()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        public SshException(string message)
            : base(message)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        /// <param name="inner">The inner.</param>
        public SshException(string message, Exception inner)
            : base(message, inner)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\SshException.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// The exception that is thrown when SSH exception occurs.
    /// </summary>
    [Serializable]
    public partial class SshException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SshException"/> class.
        /// </summary>
        /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        /// <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
        ///   
        /// <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
        protected SshException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\SshOperationTimeoutException.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// The exception that is thrown when operation is timed out.
    /// </summary>
    public partial class SshOperationTimeoutException : SshException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SshOperationTimeoutException"/> class.
        /// </summary>
        public SshOperationTimeoutException()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshOperationTimeoutException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        public SshOperationTimeoutException(string message)
            : base(message)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshOperationTimeoutException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        /// <param name="innerException">The inner exception.</param>
        public SshOperationTimeoutException(string message, Exception innerException) :
            base(message, innerException)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\SshOperationTimeoutException.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    [Serializable]
    public partial class SshOperationTimeoutException : SshException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SshOperationTimeoutException"/> class.
        /// </summary>
        /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        /// <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
        /// <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
        protected SshOperationTimeoutException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\SshPassPhraseNullOrEmptyException.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// The exception that is thrown when pass phrase for key file is empty or null
    /// </summary>
    public partial class SshPassPhraseNullOrEmptyException : SshException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SshPassPhraseNullOrEmptyException"/> class.
        /// </summary>
        public SshPassPhraseNullOrEmptyException()
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshPassPhraseNullOrEmptyException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        public SshPassPhraseNullOrEmptyException(string message)
            : base(message)
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SshPassPhraseNullOrEmptyException"/> class.
        /// </summary>
        /// <param name="message">The message.</param>
        /// <param name="innerException">The inner exception.</param>
        public SshPassPhraseNullOrEmptyException(string message, Exception innerException) :
            base(message, innerException)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\SshPassPhraseNullOrEmptyException.NET40.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Common
{
    /// <summary>
    /// The exception that is thrown when pass phrase for key file is empty or null
    /// </summary>
    [Serializable]
    public partial class SshPassPhraseNullOrEmptyException : SshException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SshPassPhraseNullOrEmptyException"/> class.
        /// </summary>
        /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        /// <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
        /// <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
        protected SshPassPhraseNullOrEmptyException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Common\TerminalModes.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Common
{
    /// <summary>
    /// Specifies the initial assignments of the opcode values that are used in the 'encoded terminal modes' valu
    /// </summary>
    public enum TerminalModes : byte
    {
        /// <summary>
        /// Indicates end of options.
        /// </summary> 
        TTY_OP_END = 0,
        
        /// <summary>
        /// Interrupt character; 255 if none.  Similarly for the other characters.  Not all of these characters are supported on all systems.
        /// </summary> 
        VINTR = 1,

        /// <summary>
        /// The quit character (sends SIGQUIT signal on POSIX systems).
        /// </summary> 
        VQUIT = 2,
        
        /// <summary>
        /// Erase the character to left of the cursor. 
        /// </summary>
        VERASE = 3,

        /// <summary>
        /// Kill the current input line.
        /// </summary>
        VKILL = 4,

        /// <summary>
        /// End-of-file character (sends EOF from the terminal).
        /// </summary>
        VEOF = 5,
        
        /// <summary>
        /// End-of-line character in addition to carriage return and/or linefeed.
        /// </summary>
        VEOL = 6,
        
        /// <summary>
        /// Additional end-of-line character.
        /// </summary>
        VEOL2 = 7,
        
        /// <summary>
        /// Continues paused output (normally control-Q).
        /// </summary>
        VSTART = 8,
        
        /// <summary>
        /// Pauses output (normally control-S).
        /// </summary>
        VSTOP = 9,
        
        /// <summary>
        /// Suspends the current program.
        /// </summary>
        VSUSP = 10,
        
        /// <summary>
        /// Another suspend character.
        /// </summary>
        VDSUSP = 11,

        /// <summary>
        /// Reprints the current input line.
        /// </summary>
        VREPRINT = 12,

        /// <summary>
        /// Erases a word left of cursor.
        /// </summary>
        VWERASE = 13,

        /// <summary>
        /// Enter the next character typed literally, even if it is a special character
        /// </summary>
        VLNEXT = 14,

        /// <summary>
        /// Character to flush output.
        /// </summary>
        VFLUSH = 15,

        /// <summary>
        /// Switch to a different shell layer.
        /// </summary>
        VSWTCH = 16,

        /// <summary>
        /// Prints system status line (load, command, pid, etc).
        /// </summary>
        VSTATUS = 17,

        /// <summary>
        /// Toggles the flushing of terminal output.
        /// </summary>
        VDISCARD = 18,

        /// <summary>
        /// The ignore parity flag.  The parameter SHOULD be 0 if this flag is FALSE, and 1 if it is TRUE.
        /// </summary>
        IGNPAR = 30,

        /// <summary>
        /// Mark parity and framing errors.
        /// </summary>
        PARMRK = 31,

        /// <summary>
        /// Enable checking of parity errors.
        /// </summary>
        INPCK = 32,

        /// <summary>
        /// Strip 8th bit off characters.
        /// </summary>
        ISTRIP = 33,

        /// <summary>
        /// Map NL into CR on input.
        /// </summary>
        INLCR = 34,

        /// <summary>
        /// Ignore CR on input.
        /// </summary>
        IGNCR = 35,

        /// <summary>
        /// Map CR to NL on input.
        /// </summary>
        ICRNL = 36,

        /// <summary>
        /// Translate uppercase characters to lowercase.
        /// </summary>
        IUCLC = 37,

        /// <summary>
        /// Enable output flow control.
        /// </summary>
        IXON = 38,

        /// <summary>
        /// Any char will restart after stop.
        /// </summary>
        IXANY = 39,

        /// <summary>
        /// Enable input flow control.
        /// </summary>
        IXOFF = 40,

        /// <summary>
        /// Ring bell on input queue full.
        /// </summary>
        IMAXBEL = 41,

        /// <summary>
        /// Enable signals INTR, QUIT, [D]SUSP.
        /// </summary>
        ISIG = 50,

        /// <summary>
        /// Canonicalize input lines.
        /// </summary>
        ICANON = 51,

        /// <summary>
        /// Enable input and output of uppercase characters by preceding their lowercase equivalents with "\".
        /// </summary>
        XCASE = 52,

        /// <summary>
        /// Enable echoing.
        /// </summary>
        ECHO = 53,

        /// <summary>
        /// Visually erase chars.
        /// </summary>
        ECHOE = 54,

        /// <summary>
        /// Kill character discards current line.
        /// </summary>
        ECHOK = 55,

        /// <summary>
        /// Echo NL even if ECHO is off.
        /// </summary>
        ECHONL = 56,

        /// <summary>
        /// Don't flush after interrupt.
        /// </summary>
        NOFLSH = 57,

        /// <summary>
        /// Stop background jobs from output.
        /// </summary>
        TOSTOP = 58,

        /// <summary>
        /// Enable extensions.
        /// </summary>
        IEXTEN = 59,

        /// <summary>
        /// Echo control characters as ^(Char).
        /// </summary>
        ECHOCTL = 60,

        /// <summary>
        /// Visual erase for line kill.
        /// </summary>
        ECHOKE = 61,

        /// <summary>
        /// Retype pending input.
        /// </summary>
        PENDIN = 62,

        /// <summary>
        /// Enable output processing.
        /// </summary>
        OPOST = 70,

        /// <summary>
        /// Convert lowercase to uppercase.
        /// </summary>
        OLCUC = 71,

        /// <summary>
        /// Map NL to CR-NL.
        /// </summary>
        ONLCR = 72,

        /// <summary>
        /// Translate carriage return to newline (output).
        /// </summary>
        OCRNL = 73,

        /// <summary>
        /// Translate newline to carriage return-newline (output).
        /// </summary>
        ONOCR = 74,

        /// <summary>
        /// Newline performs a carriage return (output).
        /// </summary>
        ONLRET = 75,

        /// <summary>
        /// 7 bit mode.
        /// </summary>
        CS7 = 90,

        /// <summary>
        /// 8 bit mode.
        /// </summary>
        CS8 = 91,

        /// <summary>
        /// Parity enable.
        /// </summary>
        PARENB = 92,

        /// <summary>
        /// Odd parity, else even.
        /// </summary>
        PARODD = 93,

        /// <summary>
        /// Specifies the input baud rate in bits per second.
        /// </summary>
        TTY_OP_ISPEED = 128,

        /// <summary>
        /// Specifies the output baud rate in bits per second.
        /// </summary>
        TTY_OP_OSPEED = 129,
    }
}

#endif
// file ...\X\Renci.SshNet\Compression\CompressionMode.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Compression
{
    /// <summary>
    /// Specifies compression modes
    /// </summary>
    public enum CompressionMode
    {
        /// <summary>
        /// Specifies that content should be compressed.
        /// </summary>
        Compress = 0,

        /// <summary>
        /// Specifies that content should be decompressed.
        /// </summary>
        Decompress = 1,
    }
}

#endif
// file ...\X\Renci.SshNet\Compression\Compressor.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Compression
{
    /// <summary>
    /// Represents base class for compression algorithm implementation
    /// </summary>
    public abstract class Compressor : Algorithm, IDisposable
    {
        private readonly ZlibStream _compressor;
        private readonly ZlibStream _decompressor;

        private MemoryStream _compressorStream;
        private MemoryStream _decompressorStream;

        /// <summary>
        /// Gets or sets a value indicating whether compression is active.
        /// </summary>
        /// <value>
        ///   <c>true</c> if compression is active; otherwise, <c>false</c>.
        /// </value>
        protected bool IsActive { get; set; }

        /// <summary>
        /// Gets the session.
        /// </summary>
        protected Session Session { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="Compressor"/> class.
        /// </summary>
        public Compressor()
        {
            this._compressorStream = new MemoryStream();
            this._decompressorStream = new MemoryStream();

            this._compressor = new ZlibStream(this._compressorStream, CompressionMode.Compress);
            this._decompressor = new ZlibStream(this._decompressorStream, CompressionMode.Decompress);
        }

        /// <summary>
        /// Initializes the algorithm
        /// </summary>
        /// <param name="session">The session.</param>
        public virtual void Init(Session session)
        {
            this.Session = session;
        }

        /// <summary>
        /// Compresses the specified data.
        /// </summary>
        /// <param name="data">Data to compress.</param>
        /// <returns>Compressed data</returns>
        public virtual byte[] Compress(byte[] data)
        {
            if (!this.IsActive)
            {
                return data;
            }

            this._compressorStream.SetLength(0);

            this._compressor.Write(data, 0, data.Length);

            return this._compressorStream.ToArray();
        }

        /// <summary>
        /// Decompresses the specified data.
        /// </summary>
        /// <param name="data">Compressed data.</param>
        /// <returns>Decompressed data.</returns>
        public virtual byte[] Decompress(byte[] data)
        {
            if (!this.IsActive)
            {
                return data;
            }

            this._decompressorStream.SetLength(0);

            this._decompressor.Write(data, 0, data.Length);

            return this._decompressorStream.ToArray();
        }

        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged ResourceMessages.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!this._isDisposed)
            {
                // If disposing equals true, dispose all managed
                // and unmanaged ResourceMessages.
                if (disposing)
                {
                    // Dispose managed ResourceMessages.
                    if (this._compressorStream != null)
                    {
                        this._compressorStream.Dispose();
                        this._compressorStream = null;
                    }

                    if (this._decompressorStream != null)
                    {
                        this._decompressorStream.Dispose();
                        this._decompressorStream = null;
                    }
                }

                // Note disposing has been done.
                this._isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="SshCommand"/> is reclaimed by garbage collection.
        /// </summary>
        ~Compressor()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\Compression\Zlib.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Compression
{
    /// <summary>
    /// Represents "zlib" compression implementation
    /// </summary>
    public class Zlib : Compressor
    {
        /// <summary>
        /// Gets algorithm name.
        /// </summary>
        public override string Name
        {
            get { return "zlib"; }
        }

        /// <summary>
        /// Initializes the algorithm
        /// </summary>
        /// <param name="session">The session.</param>
        public override void Init(Session session)
        {
            base.Init(session);
            this.IsActive = true;
        }
    }
}
#endif
// file ...\X\Renci.SshNet\Compression\ZlibOpenSsh.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Compression
{
    /// <summary>
    /// Represents "zlib@openssh.org" compression implementation
    /// </summary>
    public class ZlibOpenSsh : Compressor
    {
        /// <summary>
        /// Gets algorithm name.
        /// </summary>
        public override string Name
        {
            get { return "zlib@openssh.org"; }
        }

        /// <summary>
        /// Initializes the algorithm
        /// </summary>
        /// <param name="session">The session.</param>
        public override void Init(Session session)
        {
            base.Init(session);

            session.UserAuthenticationSuccessReceived += Session_UserAuthenticationSuccessReceived;
        }

        private void Session_UserAuthenticationSuccessReceived(object sender, MessageEventArgs<Messages.Authentication.SuccessMessage> e)
        {
            this.IsActive = true;
            this.Session.UserAuthenticationSuccessReceived -= Session_UserAuthenticationSuccessReceived;
        }
    }
}
#endif
// file ...\X\Renci.SshNet\Compression\ZlibStream.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Compression
{
    /// <summary>
    /// Implements Zlib compression algorithm.
    /// </summary>
    public class ZlibStream
    {
        //private readonly Ionic.Zlib.ZlibStream _baseStream;

        /// <summary>
        /// Initializes a new instance of the <see cref="ZlibStream" /> class.
        /// </summary>
        /// <param name="stream">The stream.</param>
        /// <param name="mode">The mode.</param>
        public ZlibStream(Stream stream, CompressionMode mode)
        {
            //switch (mode)
            //{
            //    case CompressionMode.Compress:
            //        this._baseStream = new Ionic.Zlib.ZlibStream(stream, Ionic.Zlib.CompressionMode.Compress, Ionic.Zlib.CompressionLevel.Default);
            //        break;
            //    case CompressionMode.Decompress:
            //        this._baseStream = new Ionic.Zlib.ZlibStream(stream, Ionic.Zlib.CompressionMode.Decompress, Ionic.Zlib.CompressionLevel.Default);
            //        break;
            //    default:
            //        break;
            //}

            //this._baseStream.FlushMode = Ionic.Zlib.FlushType.Partial;
        }

        /// <summary>
        /// Writes the specified buffer.
        /// </summary>
        /// <param name="buffer">The buffer.</param>
        /// <param name="offset">The offset.</param>
        /// <param name="count">The count.</param>
        public void Write(byte[] buffer, int offset, int count)
        {
            //this._baseStream.Write(buffer, offset, count);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Message.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages
{
    /// <summary>
    /// Base class for all SSH protocol messages
    /// </summary>
    public abstract class MessageRenci : SshData
    {
        /// <summary>
        /// Gets the index that represents zero in current data type.
        /// </summary>
        /// <value>
        /// The index of the zero reader.
        /// </value>
        protected override int ZeroReaderIndex
        {
            get
            {
                return 1;
            }
        }

        /// <summary>
        /// Gets data bytes array
        /// </summary>
        /// <returns>Byte array representation of the message</returns>
        public override byte[] GetBytes()
        {
            var messageAttribute = this.GetType().GetCustomAttributes(typeof(MessageAttribute), true).SingleOrDefault() as MessageAttribute;

            if (messageAttribute == null)
                throw new SshException(string.Format(CultureInfo.CurrentCulture, "Type '{0}' is not a valid message type.", this.GetType().AssemblyQualifiedName));

            var data = new List<byte>(base.GetBytes());

            data.Insert(0, messageAttribute.Number);

            return data.ToArray();
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            var messageAttribute = this.GetType().GetCustomAttributes(typeof(MessageAttribute), true).SingleOrDefault() as MessageAttribute;

            if (messageAttribute == null)
                return string.Format(CultureInfo.CurrentCulture, "'{0}' without Message attribute.", this.GetType().FullName);

            return messageAttribute.Name;
        }
    }
}
#endif
// file ...\X\Renci.SshNet\Messages\MessageAttribute.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages
{

    /// <summary>
    /// Indicates that a class represents SSH message. This class cannot be inherited.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited = true, AllowMultiple = false)]
    public sealed class MessageAttribute : Attribute
    {
        /// <summary>
        /// Gets or sets message name as defined in RFC 4250.
        /// </summary>
        /// <value>
        /// The name.
        /// </value>
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets message number as defined in RFC 4250.
        /// </summary>
        /// <value>
        /// The number.
        /// </value>
        public byte Number { get; set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessageAttribute"/> class.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <param name="number">The number.</param>
        public MessageAttribute(string name, byte number)
        {
            this.Name = name;
            this.Number = number;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\ServiceName.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages
{
    /// <summary>
    /// Specifies list of supported services
    /// </summary>
    public enum ServiceName
    {
        /// <summary>
        /// ssh-userauth
        /// </summary>
        UserAuthentication,

        /// <summary>
        /// ssh-connection
        /// </summary>
        Connection
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Authentication\BannerMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Authentication
{
    /// <summary>
    /// Represents SSH_MSG_USERAUTH_BANNER message.
    /// </summary>
    [Message("SSH_MSG_USERAUTH_BANNER", 53)]
    public class BannerMessage : MessageRenci
    {
        /// <summary>
        /// Gets banner message.
        /// </summary>
        public string Message { get; private set; }

        /// <summary>
        /// Gets banner language.
        /// </summary>
        public string Language { get; private set; }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.Message = this.ReadString();
            this.Language = this.ReadString();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.Write(this.Message);
            this.Write(this.Language);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Authentication\FailureMessage.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Authentication
{
    /// <summary>
    /// Represents SSH_MSG_USERAUTH_FAILURE message.
    /// </summary>
    [Message("SSH_MSG_USERAUTH_FAILURE", 51)]
    public class FailureMessage : MessageRenci
    {
        /// <summary>
        /// Gets or sets the allowed authentications if available.
        /// </summary>
        /// <value>
        /// The allowed authentications.
        /// </value>
        public string[] AllowedAuthentications { get; set; }

        /// <summary>
        /// Gets failure message.
        /// </summary>
        public string Message { get; private set; }

        /// <summary>
        /// Gets a value indicating whether authentication is partially successful.
        /// </summary>
        /// <value>
        ///   <c>true</c> if partially successful; otherwise, <c>false</c>.
        /// </value>
        public bool PartialSuccess { get; private set; }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.AllowedAuthentications = this.ReadNamesList();
            this.PartialSuccess = this.ReadBoolean();
            if (this.PartialSuccess)
            {
                this.Message = string.Join(",", this.AllowedAuthentications);
            }
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            throw new NotImplementedException();
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Authentication\InformationRequestMessage.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Authentication
{
    /// <summary>
    /// Represents SSH_MSG_USERAUTH_INFO_REQUEST message.
    /// </summary>
    [Message("SSH_MSG_USERAUTH_INFO_REQUEST", 60)]
    public class InformationRequestMessage : MessageRenci
    {
        /// <summary>
        /// Gets information request name.
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        /// Gets information request instruction.
        /// </summary>
        public string Instruction { get; private set; }

        /// <summary>
        /// Gets information request language.
        /// </summary>
        public string Language { get; private set; }

        /// <summary>
        /// Gets information request prompts.
        /// </summary>
        public IEnumerable<AuthenticationPrompt> Prompts { get; private set; }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.Name = this.ReadString();
            this.Instruction = this.ReadString();
            this.Language = this.ReadString();

            var numOfPrompts = this.ReadUInt32();
            var prompts = new List<AuthenticationPrompt>();

            for (int i = 0; i < numOfPrompts; i++)
            {
                var prompt = this.ReadString();
                var echo = this.ReadBoolean();
                prompts.Add(new AuthenticationPrompt(i, echo, prompt));
            }

            this.Prompts = prompts;
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            throw new NotImplementedException();
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Authentication\InformationResponseMessage.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Authentication
{
    /// <summary>
    /// Represents SSH_MSG_USERAUTH_INFO_RESPONSE message.
    /// </summary>
    [Message("SSH_MSG_USERAUTH_INFO_RESPONSE", 61)]
    public class InformationResponseMessage : MessageRenci
    {
        /// <summary>
        /// Gets authentication responses.
        /// </summary>
        public IList<string> Responses { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="InformationResponseMessage"/> class.
        /// </summary>
        public InformationResponseMessage()
        {
            this.Responses = new List<string>();
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.Write((UInt32)this.Responses.Count);
            foreach (var response in this.Responses)
            {
                this.Write(response);
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Authentication\PasswordChangeRequiredMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Authentication
{
    /// <summary>
    /// Represents SSH_MSG_USERAUTH_PASSWD_CHANGEREQ message.
    /// </summary>
    [Message("SSH_MSG_USERAUTH_PASSWD_CHANGEREQ", 60)]
    public class PasswordChangeRequiredMessage : MessageRenci
    {
        /// <summary>
        /// Gets password change request message.
        /// </summary>
        public string Message { get; private set; }

        /// <summary>
        /// Gets message language.
        /// </summary>
        public string Language { get; private set; }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.Message = this.ReadString();
            this.Language = this.ReadString();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.Write(this.Message);
            this.Write(this.Language);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Authentication\PublicKeyMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Authentication
{
    /// <summary>
    /// Represents SSH_MSG_USERAUTH_PK_OK message.
    /// </summary>
    [Message("SSH_MSG_USERAUTH_PK_OK", 60)]
    public class PublicKeyMessage : MessageRenci
    {
        /// <summary>
        /// Gets the name of the public key algorithm.
        /// </summary>
        /// <value>
        /// The name of the public key algorithm.
        /// </value>
        public string PublicKeyAlgorithmName { get; private set; }

        /// <summary>
        /// Gets the public key data.
        /// </summary>
        public byte[] PublicKeyData { get; private set; }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.PublicKeyAlgorithmName = this.ReadAsciiString();
            this.PublicKeyData = this.ReadBinaryString();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.WriteAscii(this.PublicKeyAlgorithmName);
            this.WriteBinaryString(this.PublicKeyData);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Authentication\RequestMessage.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Authentication
{
    /// <summary>
    /// Represents SSH_MSG_USERAUTH_REQUEST message. Server as a base message for other user authentication requests.
    /// </summary>
    [Message("SSH_MSG_USERAUTH_REQUEST", 50)]
    public class RequestMessage : MessageRenci
    {
        /// <summary>
        /// Gets authentication username.
        /// </summary>
        public string Username { get; private set; }

        /// <summary>
        /// Gets the name of the service.
        /// </summary>
        /// <value>
        /// The name of the service.
        /// </value>
        public ServiceName ServiceName { get; private set; }

        /// <summary>
        /// Gets the name of the authentication method.
        /// </summary>
        /// <value>
        /// The name of the method.
        /// </value>
        public virtual string MethodName { get { return "none"; } }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestMessage"/> class.
        /// </summary>
        /// <param name="serviceName">Name of the service.</param>
        /// <param name="username">Authentication username.</param>
        public RequestMessage(ServiceName serviceName, string username)
        {
            this.ServiceName = serviceName;
            this.Username = username;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            throw new InvalidOperationException("Load data is not supported.");
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.Write(this.Username);
            switch (this.ServiceName)
            {
                case ServiceName.UserAuthentication:
                    this.WriteAscii("ssh-userauth");
                    break;
                case ServiceName.Connection:
                    this.WriteAscii("ssh-connection");
                    break;
                default:
                    throw new NotSupportedException("Not supported service name");
            }
            this.WriteAscii(this.MethodName);
        }
    }
}


#endif
// file ...\X\Renci.SshNet\Messages\Authentication\RequestMessageHost.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Authentication
{
    /// <summary>
    /// Represents "hostbased" SSH_MSG_USERAUTH_REQUEST message.
    /// </summary>
    public class RequestMessageHost : RequestMessage
    {
        /// <summary>
        /// Gets the name of the authentication method.
        /// </summary>
        /// <value>
        /// The name of the method.
        /// </value>
        public override string MethodName
        {
            get
            {
                return "hostbased";
            }
        }

        /// <summary>
        /// Gets the public key algorithm for host key
        /// </summary>
        public string PublicKeyAlgorithm { get; private set; }

        /// <summary>
        /// Gets or sets the public host key and certificates for client host.
        /// </summary>
        /// <value>
        /// The public host key.
        /// </value>
        public byte[] PublicHostKey { get; private set; }

        /// <summary>
        /// Gets or sets the name of the client host.
        /// </summary>
        /// <value>
        /// The name of the client host.
        /// </value>
        public string ClientHostName { get; private set; }

        /// <summary>
        /// Gets or sets the client username on the client host
        /// </summary>
        /// <value>
        /// The client username.
        /// </value>
        public string ClientUsername { get; private set; }

        /// <summary>
        /// Gets or sets the signature.
        /// </summary>
        /// <value>
        /// The signature.
        /// </value>
        public byte[] Signature { get; set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestMessageHost"/> class.
        /// </summary>
        /// <param name="serviceName">Name of the service.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="publicKeyAlgorithm">The public key algorithm.</param>
        /// <param name="publicHostKey">The public host key.</param>
        /// <param name="clientHostName">Name of the client host.</param>
        /// <param name="clientUsername">The client username.</param>
        public RequestMessageHost(ServiceName serviceName, string username, string publicKeyAlgorithm, byte[] publicHostKey, string clientHostName, string clientUsername)
            : base(serviceName, username)
        {
            this.PublicKeyAlgorithm = publicKeyAlgorithm;
            this.PublicHostKey = publicHostKey;
            this.ClientHostName = clientHostName;
            this.ClientUsername = clientUsername;
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.WriteAscii(this.PublicKeyAlgorithm);
            this.WriteBinaryString(this.PublicHostKey);
            this.Write(this.ClientHostName);
            this.Write(this.ClientUsername);

            if (this.Signature != null)
                this.WriteBinaryString(this.Signature);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Authentication\RequestMessageKeyboardInteractive.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Authentication
{
    /// <summary>
    /// Represents "keyboard-interactive" SSH_MSG_USERAUTH_REQUEST message.
    /// </summary>
    public class RequestMessageKeyboardInteractive : RequestMessage
    {
        /// <summary>
        /// Gets the name of the authentication method.
        /// </summary>
        /// <value>
        /// The name of the method.
        /// </value>
        public override string MethodName
        {
            get
            {
                return "keyboard-interactive";
            }
        }

        /// <summary>
        /// Gets message language.
        /// </summary>
        public string Language { get; private set; }

        /// <summary>
        /// Gets authentication sub methods.
        /// </summary>
        public string SubMethods { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestMessageKeyboardInteractive"/> class.
        /// </summary>
        /// <param name="serviceName">Name of the service.</param>
        /// <param name="username">Authentication username.</param>
        public RequestMessageKeyboardInteractive(ServiceName serviceName, string username)
            : base(serviceName, username)
        {
            this.Language = string.Empty;
            this.SubMethods = string.Empty;
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.Write(this.Language);

            this.Write(this.SubMethods);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Authentication\RequestMessageNone.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Authentication
{
    /// <summary>
    /// Represents "none" SSH_MSG_USERAUTH_REQUEST message.
    /// </summary>
    public class RequestMessageNone : RequestMessage
    {
        /// <summary>
        /// Gets the name of the authentication method.
        /// </summary>
        /// <value>
        /// The name of the method.
        /// </value>
        public override string MethodName
        {
            get
            {
                return "none";
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestMessagePassword"/> class.
        /// </summary>
        /// <param name="serviceName">Name of the service.</param>
        /// <param name="username">Authentication username.</param>
        public RequestMessageNone(ServiceName serviceName, string username)
            : base(serviceName, username)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Authentication\RequestMessagePassword.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Authentication
{
    /// <summary>
    /// Represents "password" SSH_MSG_USERAUTH_REQUEST message.
    /// </summary>
    public class RequestMessagePassword : RequestMessage
    {
        /// <summary>
        /// Gets the name of the authentication method.
        /// </summary>
        /// <value>
        /// The name of the method.
        /// </value>
        public override string MethodName
        {
            get
            {
                return "password";
            }
        }

        /// <summary>
        /// Gets authentication password.
        /// </summary>
        public byte[] Password { get; private set; }

        /// <summary>
        /// Gets new authentication password.
        /// </summary>
        public byte[] NewPassword { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestMessagePassword"/> class.
        /// </summary>
        /// <param name="serviceName">Name of the service.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="password">Authentication password.</param>
        public RequestMessagePassword(ServiceName serviceName, string username, byte[] password)
            : base(serviceName, username)
        {
            this.Password = password;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestMessagePassword"/> class.
        /// </summary>
        /// <param name="serviceName">Name of the service.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="password">Authentication password.</param>
        /// <param name="newPassword">New authentication password.</param>
        public RequestMessagePassword(ServiceName serviceName, string username, byte[] password, byte[] newPassword)
            : this(serviceName, username, password)
        {
            this.NewPassword = newPassword;
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.Write(this.NewPassword != null);

            this.Write((uint)this.Password.Length);
            this.Write(this.Password);

            if (this.NewPassword != null)
            {
                this.Write((uint)this.NewPassword.Length);
                this.Write(this.NewPassword);
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Authentication\RequestMessagePublicKey.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Authentication
{
    /// <summary>
    /// Represents "publickey" SSH_MSG_USERAUTH_REQUEST message.
    /// </summary>
    public class RequestMessagePublicKey : RequestMessage
    {
        /// <summary>
        /// Gets the name of the authentication method.
        /// </summary>
        /// <value>
        /// The name of the method.
        /// </value>
        public override string MethodName
        {
            get
            {
                return "publickey";
            }
        }

        /// <summary>
        /// Gets the name of the public key algorithm.
        /// </summary>
        /// <value>
        /// The name of the public key algorithm.
        /// </value>
        public string PublicKeyAlgorithmName { get; private set; }

        /// <summary>
        /// Gets the public key data.
        /// </summary>
        public byte[] PublicKeyData { get; private set; }

        /// <summary>
        /// Gets or sets public key signature.
        /// </summary>
        /// <value>
        /// The signature.
        /// </value>
        public byte[] Signature { get; set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestMessagePublicKey"/> class.
        /// </summary>
        /// <param name="serviceName">Name of the service.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="keyAlgorithmName">Name of private key algorithm.</param>
        /// <param name="keyData">Private key data.</param>
        public RequestMessagePublicKey(ServiceName serviceName, string username, string keyAlgorithmName, byte[] keyData)
            : base(serviceName, username)
        {
            this.PublicKeyAlgorithmName = keyAlgorithmName;
            this.PublicKeyData = keyData;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestMessagePublicKey"/> class.
        /// </summary>
        /// <param name="serviceName">Name of the service.</param>
        /// <param name="username">Authentication username.</param>
        /// <param name="keyAlgorithmName">Name of private key algorithm.</param>
        /// <param name="keyData">Private key data.</param>
        /// <param name="signature">Private key signature.</param>
        public RequestMessagePublicKey(ServiceName serviceName, string username, string keyAlgorithmName, byte[] keyData, byte[] signature)
            : this(serviceName, username, keyAlgorithmName, keyData)
        {
            this.Signature = signature;
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            if (this.Signature == null)
            {
                this.Write(false);
            }
            else
            {
                this.Write(true);
            }
            this.WriteAscii(this.PublicKeyAlgorithmName);
            this.WriteBinaryString(this.PublicKeyData);
            if (this.Signature != null)
                this.WriteBinaryString(this.Signature);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Authentication\SuccessMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Authentication
{
    /// <summary>
    /// Represents SSH_MSG_USERAUTH_SUCCESS message.
    /// </summary>
    [Message("SSH_MSG_USERAUTH_SUCCESS", 52)]
    public class SuccessMessage : MessageRenci
    {
        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelCloseMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents SSH_MSG_CHANNEL_CLOSE message.
    /// </summary>
    [Message("SSH_MSG_CHANNEL_CLOSE", 97)]
    public class ChannelCloseMessage : ChannelMessage
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelCloseMessage"/> class.
        /// </summary>
        public ChannelCloseMessage()
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelCloseMessage"/> class.
        /// </summary>
        /// <param name="localChannelNumber">The local channel number.</param>
        public ChannelCloseMessage(uint localChannelNumber)
        {
            LocalChannelNumber = localChannelNumber;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelDataMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents SSH_MSG_CHANNEL_DATA message.
    /// </summary>
    [Message("SSH_MSG_CHANNEL_DATA", 94)]
    public class ChannelDataMessage : ChannelMessage
    {
        /// <summary>
        /// Gets or sets message data.
        /// </summary>
        /// <value>
        /// The data.
        /// </value>
        public byte[] Data { get; protected set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelDataMessage"/> class.
        /// </summary>
        public ChannelDataMessage()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelDataMessage"/> class.
        /// </summary>
        /// <param name="localChannelNumber">The local channel number.</param>
        /// <param name="data">Message data.</param>
        public ChannelDataMessage(uint localChannelNumber, byte[] data)
        {
            this.LocalChannelNumber = localChannelNumber;
            this.Data = data;
        }

        /// <summary>
        /// Loads the data.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();
            this.Data = this.ReadBinaryString();
        }

        /// <summary>
        /// Saves the data.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();
            this.WriteBinaryString(this.Data);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelEofMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents SSH_MSG_CHANNEL_EOF message.
    /// </summary>
    [Message("SSH_MSG_CHANNEL_EOF", 96)]
    public class ChannelEofMessage : ChannelMessage
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelEofMessage"/> class.
        /// </summary>
        public ChannelEofMessage()
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelEofMessage"/> class.
        /// </summary>
        /// <param name="localChannelNumber">The local channel number.</param>
        public ChannelEofMessage(uint localChannelNumber)
        {
            this.LocalChannelNumber = localChannelNumber;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelExtendedDataMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents SSH_MSG_CHANNEL_EXTENDED_DATA message.
    /// </summary>
    [Message("SSH_MSG_CHANNEL_EXTENDED_DATA", 95)]
    public class ChannelExtendedDataMessage : ChannelMessage
    {
        /// <summary>
        /// Gets message data type code.
        /// </summary>
        public uint DataTypeCode { get; private set; }

        /// <summary>
        /// Gets message data.
        /// </summary>
        public byte[] Data { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelExtendedDataMessage"/> class.
        /// </summary>
        public ChannelExtendedDataMessage()
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelExtendedDataMessage"/> class.
        /// </summary>
        /// <param name="localChannelNumber">The local channel number.</param>
        /// <param name="dataTypeCode">The message data type code.</param>
        /// <param name="data">The message data.</param>
        public ChannelExtendedDataMessage(uint localChannelNumber, uint dataTypeCode, byte[] data)
        {
            this.LocalChannelNumber = localChannelNumber;
            this.DataTypeCode = dataTypeCode;
            this.Data = data;
        }

        /// <summary>
        /// Loads the data.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();
            this.DataTypeCode = this.ReadUInt32();
            this.Data = this.ReadBinaryString();
        }

        /// <summary>
        /// Saves the data.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.DataTypeCode);
            this.WriteBinaryString(this.Data);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelFailureMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents SSH_MSG_CHANNEL_FAILURE message.
    /// </summary>
    [Message("SSH_MSG_CHANNEL_FAILURE", 100)]
    public class ChannelFailureMessage : ChannelMessage
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelFailureMessage"/> class.
        /// </summary>
        public ChannelFailureMessage()
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelFailureMessage"/> class.
        /// </summary>
        /// <param name="localChannelNumber">The local channel number.</param>
        public ChannelFailureMessage(uint localChannelNumber)
        {
            this.LocalChannelNumber = localChannelNumber;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Base class for all channel specific SSH messages.
    /// </summary>
    public abstract class ChannelMessage : MessageRenci
    {
        /// <summary>
        /// Gets or sets the local channel number.
        /// </summary>
        /// <value>
        /// The local channel number.
        /// </value>
        public uint LocalChannelNumber { get; protected set; }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.LocalChannelNumber = this.ReadUInt32();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.Write(this.LocalChannelNumber);
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return string.Format(CultureInfo.CurrentCulture, "{0} : #{1}", base.ToString(), this.LocalChannelNumber);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelOpenConfirmationMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents SSH_MSG_CHANNEL_OPEN_CONFIRMATION message.
    /// </summary>
    [Message("SSH_MSG_CHANNEL_OPEN_CONFIRMATION", 91)]
    public class ChannelOpenConfirmationMessage : ChannelMessage
    {
        /// <summary>
        /// Gets the remote channel number.
        /// </summary>
        public uint RemoteChannelNumber { get; private set; }

        /// <summary>
        /// Gets the initial size of the window.
        /// </summary>
        /// <value>
        /// The initial size of the window.
        /// </value>
        public uint InitialWindowSize { get; private set; }

        /// <summary>
        /// Gets the maximum size of the packet.
        /// </summary>
        /// <value>
        /// The maximum size of the packet.
        /// </value>
        public uint MaximumPacketSize { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelOpenConfirmationMessage"/> class.
        /// </summary>
        public ChannelOpenConfirmationMessage()
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelOpenConfirmationMessage"/> class.
        /// </summary>
        /// <param name="localChannelNumber">The local channel number.</param>
        /// <param name="initialWindowSize">Initial size of the window.</param>
        /// <param name="maximumPacketSize">Maximum size of the packet.</param>
        /// <param name="remoteChannelNumber">The remote channel number.</param>
        public ChannelOpenConfirmationMessage(uint localChannelNumber, uint initialWindowSize, uint maximumPacketSize, uint remoteChannelNumber)
        {
            this.LocalChannelNumber = localChannelNumber;
            this.InitialWindowSize = initialWindowSize;
            this.MaximumPacketSize = maximumPacketSize;
            this.RemoteChannelNumber = remoteChannelNumber;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();
            this.RemoteChannelNumber = this.ReadUInt32();
            this.InitialWindowSize = this.ReadUInt32();
            this.MaximumPacketSize = this.ReadUInt32();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.RemoteChannelNumber);
            this.Write(this.InitialWindowSize);
            this.Write(this.MaximumPacketSize);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelOpenFailureMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents SSH_MSG_CHANNEL_OPEN_FAILURE message.
    /// </summary>
    [Message("SSH_MSG_CHANNEL_OPEN_FAILURE", 92)]
    public class ChannelOpenFailureMessage : ChannelMessage
    {
        internal const uint AdministrativelyProhibited = 1;
        internal const uint ConnectFailed = 2;
        internal const uint UnknownChannelType = 3;
        internal const uint ResourceShortage = 4;

        /// <summary>
        /// Gets failure reason code.
        /// </summary>
        public uint ReasonCode { get; private set; }

        /// <summary>
        /// Gets description for failure.
        /// </summary>
        public string Description { get; private set; }

        /// <summary>
        /// Gets message language.
        /// </summary>
        public string Language { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelOpenFailureMessage"/> class.
        /// </summary>
        public ChannelOpenFailureMessage()
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelOpenFailureMessage"/> class.
        /// </summary>
        /// <param name="localChannelNumber">The local channel number.</param>
        /// <param name="description">The description.</param>
        /// <param name="reasonCode">The reason code.</param>
        public ChannelOpenFailureMessage(uint localChannelNumber, string description, uint reasonCode)
        {
            this.LocalChannelNumber = localChannelNumber;
            this.Description = description;
            this.ReasonCode = reasonCode;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelOpenFailureMessage"/> class.
        /// </summary>
        /// <param name="localChannelNumber">The local channel number.</param>
        /// <param name="description">The description.</param>
        /// <param name="reasonCode">The reason code.</param>
        /// <param name="language">The language (RFC3066).</param>
        public ChannelOpenFailureMessage(uint localChannelNumber, string description, uint reasonCode, string language)
        {
            LocalChannelNumber = localChannelNumber;
            Description = description;
            ReasonCode = reasonCode;
            Language = language;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();
            this.ReasonCode = this.ReadUInt32();
            this.Description = this.ReadString();
            this.Language = this.ReadString();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.ReasonCode);
            this.Write(this.Description ?? string.Empty);
            this.Write(this.Language ?? "en");
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelOpenFailureReasons.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// List channel open failure reasons defined by the protocol.
    /// </summary>
    public enum ChannelOpenFailureReasons : uint
    {
        /// <summary>
        /// SSH_OPEN_ADMINISTRATIVELY_PROHIBITED
        /// </summary>
        AdministativelyProhibited = 1,
        /// <summary>
        /// SSH_OPEN_CONNECT_FAILED
        /// </summary>
        ConnectFailed = 2,
        /// <summary>
        /// SSH_OPEN_UNKNOWN_CHANNEL_TYPE
        /// </summary>
        UnknownChannelType = 3,
        /// <summary>
        /// SSH_OPEN_RESOURCE_SHORTAGE
        /// </summary>
        ResourceShortage = 4
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelSuccessMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents SSH_MSG_CHANNEL_SUCCESS message.
    /// </summary>
    [Message("SSH_MSG_CHANNEL_SUCCESS", 99)]
    public class ChannelSuccessMessage : ChannelMessage
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelSuccessMessage"/> class.
        /// </summary>
        public ChannelSuccessMessage()
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelSuccessMessage"/> class.
        /// </summary>
        /// <param name="localChannelNumber">The local channel number.</param>
        public ChannelSuccessMessage(uint localChannelNumber)
        {
            this.LocalChannelNumber = localChannelNumber;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelWindowAdjustMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents SSH_MSG_CHANNEL_SUCCESS message.
    /// </summary>
    [Message("SSH_MSG_CHANNEL_WINDOW_ADJUST", 93)]
    public class ChannelWindowAdjustMessage : ChannelMessage
    {
        /// <summary>
        /// Gets number of bytes to add to the window.
        /// </summary>
        public uint BytesToAdd { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelWindowAdjustMessage"/> class.
        /// </summary>
        public ChannelWindowAdjustMessage()
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelWindowAdjustMessage"/> class.
        /// </summary>
        /// <param name="localChannelNumber">The local channel number.</param>
        /// <param name="bytesToAdd">The bytes to add.</param>
        public ChannelWindowAdjustMessage(uint localChannelNumber, uint bytesToAdd)
        {
            this.LocalChannelNumber = localChannelNumber;
            this.BytesToAdd = bytesToAdd;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();
            this.BytesToAdd = this.ReadUInt32();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.BytesToAdd);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\GlobalRequestMessage.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents SSH_MSG_GLOBAL_REQUEST message.
    /// </summary>
    [Message("SSH_MSG_GLOBAL_REQUEST", 80)]
    public class GlobalRequestMessage : MessageRenci
    {
        /// <summary>
        /// Gets the name of the request.
        /// </summary>
        /// <value>
        /// The name of the request.
        /// </value>
        public GlobalRequestName RequestName { get; private set; }

        /// <summary>
        /// Gets a value indicating whether message reply should be sent..
        /// </summary>
        /// <value>
        ///   <c>true</c> if message reply should be sent; otherwise, <c>false</c>.
        /// </value>
        public bool WantReply { get; private set; }

        /// <summary>
        /// Gets the address to bind to.
        /// </summary>
        public string AddressToBind { get; private set; }
        //OneCodeTODO:   Extract AddressToBind property to be in different class and GlobalREquestMessage to be a base class fo it.

        /// <summary>
        /// Gets port number to bind to.
        /// </summary>
        public UInt32 PortToBind { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="GlobalRequestMessage"/> class.
        /// </summary>
        public GlobalRequestMessage()
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GlobalRequestMessage"/> class.
        /// </summary>
        /// <param name="requestName">Name of the request.</param>
        /// <param name="wantReply">if set to <c>true</c> [want reply].</param>
        public GlobalRequestMessage(GlobalRequestName requestName, bool wantReply)
        {
            this.RequestName = requestName;
            this.WantReply = wantReply;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GlobalRequestMessage"/> class.
        /// </summary>
        /// <param name="requestName">Name of the request.</param>
        /// <param name="wantReply">if set to <c>true</c> [want reply].</param>
        /// <param name="addressToBind">The address to bind.</param>
        /// <param name="portToBind">The port to bind.</param>
        public GlobalRequestMessage(GlobalRequestName requestName, bool wantReply, string addressToBind, uint portToBind)
            : this(requestName, wantReply)
        {
            this.AddressToBind = addressToBind;
            this.PortToBind = portToBind;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            var requestName = this.ReadAsciiString();

            this.WantReply = this.ReadBoolean();

            switch (requestName)
            {
                case "tcpip-forward":
                    this.RequestName = GlobalRequestName.TcpIpForward;
                    this.AddressToBind = this.ReadString();
                    this.PortToBind = this.ReadUInt32();
                    break;
                case "cancel-tcpip-forward":
                    this.RequestName = GlobalRequestName.CancelTcpIpForward;
                    this.AddressToBind = this.ReadString();
                    this.PortToBind = this.ReadUInt32();
                    break;
            }
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            switch (this.RequestName)
            {
                case GlobalRequestName.TcpIpForward:
                    this.WriteAscii("tcpip-forward");
                    break;
                case GlobalRequestName.CancelTcpIpForward:
                    this.WriteAscii("cancel-tcpip-forward");
                    break;
            }

            this.Write(this.WantReply);

            switch (this.RequestName)
            {
                case GlobalRequestName.TcpIpForward:
                case GlobalRequestName.CancelTcpIpForward:
                    this.Write(this.AddressToBind);
                    this.Write(this.PortToBind);
                    break;
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\GlobalRequestName.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Specifies supported request names.
    /// </summary>
    public enum GlobalRequestName
    {
        /// <summary>
        /// tcpip-forward
        /// </summary>
        TcpIpForward,
        /// <summary>
        /// cancel-tcpip-forward
        /// </summary>
        CancelTcpIpForward,
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\RequestFailureMessage.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents SSH_MSG_REQUEST_FAILURE message.
    /// </summary>
    [Message("SSH_MSG_REQUEST_FAILURE", 82)]
    public class RequestFailureMessage : MessageRenci
    {
        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\RequestSuccessMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents SSH_MSG_REQUEST_SUCCESS message.
    /// </summary>
    [Message("SSH_MSG_REQUEST_SUCCESS", 81)]
    public class RequestSuccessMessage : MessageRenci
    {
        /// <summary>
        /// Gets the bound port.
        /// </summary>
        public uint? BoundPort { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestSuccessMessage"/> class.
        /// </summary>
        public RequestSuccessMessage()
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestSuccessMessage"/> class.
        /// </summary>
        /// <param name="boundPort">The bound port.</param>
        public RequestSuccessMessage(uint boundPort)
        {
            this.BoundPort = boundPort;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            if (!this.IsEndOfData)
                this.BoundPort = this.ReadUInt32();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            if (this.BoundPort != null)
                this.Write(this.BoundPort.Value);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelOpen\ChannelOpenInfo.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Base class for open channel messages
    /// </summary>
    public abstract class ChannelOpenInfo : SshData
    {
        /// <summary>
        /// Gets the type of the channel to open.
        /// </summary>
        /// <value>
        /// The type of the channel to open.
        /// </value>
        public abstract string ChannelType { get; }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelOpen\ChannelOpenMessage.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents SSH_MSG_CHANNEL_OPEN message.
    /// </summary>
    [Message("SSH_MSG_CHANNEL_OPEN", 90)]
    public class ChannelOpenMessage : ChannelMessage
    {
        /// <summary>
        /// Gets the type of the channel.
        /// </summary>
        /// <value>
        /// The type of the channel.
        /// </value>
        public string ChannelType
        {
            get
            {
                return this.Info.ChannelType;
            }
        }

        /// <summary>
        /// Gets the initial size of the window.
        /// </summary>
        /// <value>
        /// The initial size of the window.
        /// </value>
        public uint InitialWindowSize { get; private set; }

        /// <summary>
        /// Gets the maximum size of the packet.
        /// </summary>
        /// <value>
        /// The maximum size of the packet.
        /// </value>
        public uint MaximumPacketSize { get; private set; }

        /// <summary>
        /// Gets channel specific open information.
        /// </summary>
        public ChannelOpenInfo Info { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelOpenMessage"/> class.
        /// </summary>
        public ChannelOpenMessage()
        {
            //  Required for dynamicly loading request type when it comes from the server
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelOpenMessage"/> class.
        /// </summary>
        /// <param name="channelNumber">The channel number.</param>
        /// <param name="initialWindowSize">Initial size of the window.</param>
        /// <param name="maximumPacketSize">Maximum size of the packet.</param>
        /// <param name="info">The info.</param>
        public ChannelOpenMessage(uint channelNumber, uint initialWindowSize, uint maximumPacketSize, ChannelOpenInfo info)
        {
            this.LocalChannelNumber = channelNumber;
            this.InitialWindowSize = initialWindowSize;
            this.MaximumPacketSize = maximumPacketSize;
            this.Info = info;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            var channelName = this.ReadAsciiString();
            this.LocalChannelNumber = this.ReadUInt32();
            this.InitialWindowSize = this.ReadUInt32();
            this.MaximumPacketSize = this.ReadUInt32();
            var bytes = this.ReadBytes();

            if (channelName == SessionChannelOpenInfo.NAME)
            {
                this.Info = new SessionChannelOpenInfo();
            }
            else if (channelName == X11ChannelOpenInfo.NAME)
            {
                this.Info = new X11ChannelOpenInfo();
            }
            else if (channelName == DirectTcpipChannelInfo.NAME)
            {
                this.Info = new DirectTcpipChannelInfo();
            }
            else if (channelName == ForwardedTcpipChannelInfo.NAME)
            {
                this.Info = new ForwardedTcpipChannelInfo();
            }
            else
            {
                throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "Channel type '{0}' is not supported.", channelName));
            }

            this.Info.Load(bytes);

        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.WriteAscii(this.ChannelType);
            this.Write(this.LocalChannelNumber);
            this.Write(this.InitialWindowSize);
            this.Write(this.MaximumPacketSize);
            this.Write(this.Info.GetBytes());
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelOpen\DirectTcpipChannelInfo.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Used to open "direct-tcpip" channel type
    /// </summary>
    public class DirectTcpipChannelInfo : ChannelOpenInfo
    {
        /// <summary>
        /// Specifies channel open type
        /// </summary>
        public const string NAME = "direct-tcpip";

        /// <summary>
        /// Gets the type of the channel to open.
        /// </summary>
        /// <value>
        /// The type of the channel to open.
        /// </value>
        public override string ChannelType
        {
            get { return NAME; }
        }

        /// <summary>
        /// Gets the host to connect.
        /// </summary>
        public string HostToConnect { get; private set; }

        /// <summary>
        /// Gets the port to connect.
        /// </summary>
        public uint PortToConnect { get; private set; }

        /// <summary>
        /// Gets the originator address.
        /// </summary>
        public string OriginatorAddress { get; private set; }

        /// <summary>
        /// Gets the originator port.
        /// </summary>
        public uint OriginatorPort { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="DirectTcpipChannelInfo"/> class.
        /// </summary>
        public DirectTcpipChannelInfo()
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DirectTcpipChannelInfo"/> class.
        /// </summary>
        /// <param name="hostToConnect">The host to connect.</param>
        /// <param name="portToConnect">The port to connect.</param>
        /// <param name="originatorAddress">The originator address.</param>
        /// <param name="originatorPort">The originator port.</param>
        public DirectTcpipChannelInfo(string hostToConnect, uint portToConnect, string originatorAddress, uint originatorPort)
        {
            this.HostToConnect = hostToConnect;
            this.PortToConnect = portToConnect;
            this.OriginatorAddress = originatorAddress;
            this.OriginatorPort = originatorPort;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();

            this.HostToConnect = this.ReadString();
            this.PortToConnect = this.ReadUInt32();
            this.OriginatorAddress = this.ReadString();
            this.OriginatorPort = this.ReadUInt32();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.Write(this.HostToConnect);
            this.Write(this.PortToConnect);
            this.Write(this.OriginatorAddress);
            this.Write(this.OriginatorPort);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelOpen\ForwardedTcpipChannelInfo.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Used to open "forwarded-tcpip" channel type
    /// </summary>
    public class ForwardedTcpipChannelInfo : ChannelOpenInfo
    {
        /// <summary>
        /// Initializes a new <see cref="ForwardedTcpipChannelInfo"/> instance.
        /// </summary>
        public ForwardedTcpipChannelInfo()
        {
        }

        /// <summary>
        /// Initializes a new <see cref="ForwardedTcpipChannelInfo"/> instance with the specified connector
        /// address and port, and originator address and port.
        /// </summary>
        public ForwardedTcpipChannelInfo(string connectedAddress, uint connectedPort, string originatorAddress, uint originatorPort)
        {
            ConnectedAddress = connectedAddress;
            ConnectedPort = connectedPort;
            OriginatorAddress = originatorAddress;
            OriginatorPort = originatorPort;
        }

        /// <summary>
        /// Specifies channel open type
        /// </summary>
        public const string NAME = "forwarded-tcpip";

        /// <summary>
        /// Gets the type of the channel to open.
        /// </summary>
        /// <value>
        /// The type of the channel to open.
        /// </value>
        public override string ChannelType
        {
            get { return NAME; }
        }

        /// <summary>
        /// Gets the connected address.
        /// </summary>
        public string ConnectedAddress { get; private set; }

        /// <summary>
        /// Gets the connected port.
        /// </summary>
        public uint ConnectedPort { get; private set; }

        /// <summary>
        /// Gets the originator address.
        /// </summary>
        public string OriginatorAddress { get; private set; }

        /// <summary>
        /// Gets the originator port.
        /// </summary>
        public uint OriginatorPort { get; private set; }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();

            this.ConnectedAddress = this.ReadString();
            this.ConnectedPort = this.ReadUInt32();
            this.OriginatorAddress = this.ReadString();
            this.OriginatorPort = this.ReadUInt32();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.Write(this.ConnectedAddress);
            this.Write(this.ConnectedPort);
            this.Write(this.OriginatorAddress);
            this.Write(this.OriginatorPort);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelOpen\SessionChannelOpenInfo.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Used to open "session" channel type
    /// </summary>
    public class SessionChannelOpenInfo : ChannelOpenInfo
    {
        /// <summary>
        /// Specifies channel open type
        /// </summary>
        public const string NAME = "session";

        /// <summary>
        /// Gets the type of the channel to open.
        /// </summary>
        /// <value>
        /// The type of the channel to open.
        /// </value>
        public override string ChannelType
        {
            get { return NAME; }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelOpen\X11ChannelOpenInfo.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Used to open "x11" channel type
    /// </summary>
    public class X11ChannelOpenInfo : ChannelOpenInfo
    {
        /// <summary>
        /// Specifies channel open type
        /// </summary>
        public const string NAME = "x11";

        /// <summary>
        /// Gets the type of the channel to open.
        /// </summary>
        /// <value>
        /// The type of the channel to open.
        /// </value>
        public override string ChannelType
        {
            get { return NAME; }
        }

        /// <summary>
        /// Gets the originator address.
        /// </summary>
        public string OriginatorAddress { get; private set; }

        /// <summary>
        /// Gets the originator port.
        /// </summary>
        public uint OriginatorPort { get; private set; }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();

            this.OriginatorAddress = this.ReadString();
            this.OriginatorPort = this.ReadUInt32();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.Write(this.OriginatorAddress);
            this.Write(this.OriginatorPort);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelRequest\BreakRequestInfo.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents "break" type channel request information
    /// </summary>
    public class BreakRequestInfo : RequestInfo
    {
        /// <summary>
        /// Channel request name
        /// </summary>
        public const string NAME = "break";

        /// <summary>
        /// Gets the name of the request.
        /// </summary>
        /// <value>
        /// The name of the request.
        /// </value>
        public override string RequestName
        {
            get { return NAME; }
        }

        /// <summary>
        /// Gets break length in milliseconds.
        /// </summary>
        public UInt32 BreakLength { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExecRequestInfo"/> class.
        /// </summary>
        public BreakRequestInfo()
        {
            this.WantReply = true;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExecRequestInfo"/> class.
        /// </summary>
        /// <param name="breakLength">Length of the break.</param>
        public BreakRequestInfo(UInt32 breakLength)
            : this()
        {
            this.BreakLength = breakLength;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();

            this.BreakLength = this.ReadUInt32();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.Write(this.BreakLength);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelRequest\ChannelRequestMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents SSH_MSG_CHANNEL_REQUEST message.
    /// </summary>
    [Message("SSH_MSG_CHANNEL_REQUEST", 98)]
    public class ChannelRequestMessage : ChannelMessage
    {
        /// <summary>
        /// Gets the name of the request.
        /// </summary>
        /// <value>
        /// The name of the request.
        /// </value>
        public string RequestName { get; private set; }

        /// <summary>
        /// Gets channel request data.
        /// </summary>
        public byte[] RequestData { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelRequestMessage"/> class.
        /// </summary>
        public ChannelRequestMessage()
        {
            //  Required for dynamically loading request type when it comes from the server
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelRequestMessage"/> class.
        /// </summary>
        /// <param name="localChannelName">Name of the local channel.</param>
        /// <param name="info">The info.</param>
        public ChannelRequestMessage(uint localChannelName, RequestInfo info)
        {
            this.LocalChannelNumber = localChannelName;
            this.RequestName = info.RequestName;
            this.RequestData = info.GetBytes();
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();

            this.RequestName = this.ReadAsciiString();
            this.RequestData = this.ReadBytes();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.WriteAscii(this.RequestName);
            this.Write(this.RequestData);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelRequest\EndOfWriteRequestInfo.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents "eow@openssh.com" type channel request information
    /// </summary>
    public class EndOfWriteRequestInfo : RequestInfo
    {
        /// <summary>
        /// Channel request name
        /// </summary>
        public const string NAME = "eow@openssh.com";

        /// <summary>
        /// Gets the name of the request.
        /// </summary>
        /// <value>
        /// The name of the request.
        /// </value>
        public override string RequestName
        {
            get { return NAME; }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EndOfWriteRequestInfo"/> class.
        /// </summary>
        public EndOfWriteRequestInfo()
        {
            this.WantReply = false;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelRequest\EnvironmentVariableRequestInfo.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents "env" type channel request information
    /// </summary>
    public class EnvironmentVariableRequestInfo : RequestInfo
    {
        /// <summary>
        /// Channel request name
        /// </summary>
        public const string NAME = "env";

        /// <summary>
        /// Gets the name of the request.
        /// </summary>
        /// <value>
        /// The name of the request.
        /// </value>
        public override string RequestName
        {
            get { return NAME; }
        }

        /// <summary>
        /// Gets or sets the name of the variable.
        /// </summary>
        /// <value>
        /// The name of the variable.
        /// </value>
        public string VariableName { get; set; }

        /// <summary>
        /// Gets or sets the variable value.
        /// </summary>
        /// <value>
        /// The variable value.
        /// </value>
        public string VariableValue { get; set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="EnvironmentVariableRequestInfo"/> class.
        /// </summary>
        public EnvironmentVariableRequestInfo()
        {
            this.WantReply = true;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EnvironmentVariableRequestInfo"/> class.
        /// </summary>
        /// <param name="variableName">Name of the variable.</param>
        /// <param name="variableValue">The variable value.</param>
        public EnvironmentVariableRequestInfo(string variableName, string variableValue)
            : this()
        {
            this.VariableName = variableName;
            this.VariableValue = variableValue;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();

            this.VariableName = this.ReadString();
            this.VariableValue = this.ReadString();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.Write(this.VariableName);
            this.Write(this.VariableValue);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelRequest\ExecRequestInfo.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents "exec" type channel request information
    /// </summary>
    public class ExecRequestInfo : RequestInfo
    {
        /// <summary>
        /// Channel request name
        /// </summary>
        public const string NAME = "exec";

        /// <summary>
        /// Gets the name of the request.
        /// </summary>
        /// <value>
        /// The name of the request.
        /// </value>
        public override string RequestName
        {
            get { return NAME; }
        }

        /// <summary>
        /// Gets command to execute.
        /// </summary>
        /// <value>
        /// The command.
        /// </value>
        public string Command { get; private set; }

        /// <summary>
        /// Gets the encoding.
        /// </summary>
        /// <value>
        /// The encoding.
        /// </value>
        public Encoding Encoding { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExecRequestInfo"/> class.
        /// </summary>
        public ExecRequestInfo()
        {
            this.WantReply = true;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExecRequestInfo"/> class.
        /// </summary>
        /// <param name="command">The command.</param>
        /// <param name="encoding">The character encoding to use.</param>
        /// <exception cref="System.ArgumentNullException"><paramref name="command"/> or <paramref name="encoding"/> is null.</exception>
        public ExecRequestInfo(string command, Encoding encoding)
            : this()
        {
            if (command == null)
                throw new System.ArgumentNullException("command");
            if (encoding == null)
                throw new System.ArgumentNullException("encoding");

            this.Command = command;
            this.Encoding = encoding;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();

            this.Command = this.ReadString();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.Write(this.Command, this.Encoding);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelRequest\ExitSignalRequestInfo.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents "exit-signal" type channel request information
    /// </summary>
    public class ExitSignalRequestInfo : RequestInfo
    {
        /// <summary>
        /// Channel request name
        /// </summary>
        public const string NAME = "exit-signal";

        /// <summary>
        /// Gets the name of the request.
        /// </summary>
        /// <value>
        /// The name of the request.
        /// </value>
        public override string RequestName
        {
            get { return NAME; }
        }

        /// <summary>
        /// Gets the name of the signal.
        /// </summary>
        /// <value>
        /// The name of the signal.
        /// </value>
        public string SignalName { get; private set; }

        /// <summary>
        /// Gets a value indicating whether core is dumped.
        /// </summary>
        /// <value>
        ///   <c>true</c> if core is dumped; otherwise, <c>false</c>.
        /// </value>
        public bool CoreDumped { get; private set; }

        /// <summary>
        /// Gets the error message.
        /// </summary>
        public string ErrorMessage { get; private set; }

        /// <summary>
        /// Gets message language.
        /// </summary>
        public string Language { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExitSignalRequestInfo"/> class.
        /// </summary>
        public ExitSignalRequestInfo()
        {
            this.WantReply = false;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExitSignalRequestInfo"/> class.
        /// </summary>
        /// <param name="signalName">Name of the signal.</param>
        /// <param name="coreDumped">if set to <c>true</c> then core is dumped.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <param name="language">The language.</param>
        public ExitSignalRequestInfo(string signalName, bool coreDumped, string errorMessage, string language)
            : this()
        {
            this.SignalName = signalName;
            this.CoreDumped = coreDumped;
            this.ErrorMessage = errorMessage;
            this.Language = language;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();

            this.SignalName = this.ReadAsciiString();
            this.CoreDumped = this.ReadBoolean();
            this.ErrorMessage = this.ReadString();
            this.Language = this.ReadString();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.WriteAscii(this.SignalName);
            this.Write(this.CoreDumped);
            this.Write(this.ErrorMessage);
            this.Write(this.Language);
        }

    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelRequest\ExitStatusRequestInfo.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents "exit-status" type channel request information
    /// </summary>
    public class ExitStatusRequestInfo : RequestInfo
    {
        /// <summary>
        /// Channel request name.
        /// </summary>
        public const string NAME = "exit-status";

        /// <summary>
        /// Gets the name of the request.
        /// </summary>
        /// <value>
        /// The name of the request.
        /// </value>
        public override string RequestName
        {
            get { return NAME; }
        }

        /// <summary>
        /// Gets the exit status number.
        /// </summary>
        public uint ExitStatus { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExitStatusRequestInfo"/> class.
        /// </summary>
        public ExitStatusRequestInfo()
        {
            this.WantReply = false;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExitStatusRequestInfo"/> class.
        /// </summary>
        /// <param name="exitStatus">The exit status number.</param>
        public ExitStatusRequestInfo(uint exitStatus)
            : this()
        {
            this.ExitStatus = exitStatus;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();

            this.ExitStatus = this.ReadUInt32();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.Write(this.ExitStatus);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelRequest\KeepAliveRequestInfo.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents "keepalive@openssh.com" type channel request information
    /// </summary>
    public class KeepAliveRequestInfo : RequestInfo
    {
        /// <summary>
        /// Channel request name
        /// </summary>
        public const string NAME = "keepalive@openssh.com";

        /// <summary>
        /// Gets the name of the request.
        /// </summary>
        /// <value>
        /// The name of the request.
        /// </value>
        public override string RequestName
        {
            get { return NAME; }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EndOfWriteRequestInfo"/> class.
        /// </summary>
        public KeepAliveRequestInfo()
        {
            this.WantReply = false;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelRequest\PseudoTerminalInfo.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents "pty-req" type channel request information
    /// </summary>
    public class PseudoTerminalRequestInfo : RequestInfo
    {
        /// <summary>
        /// Channel request name
        /// </summary>
        public const string NAME = "pty-req";

        /// <summary>
        /// Gets the name of the request.
        /// </summary>
        /// <value>
        /// The name of the request.
        /// </value>
        public override string RequestName
        {
            get { return NAME; }
        }

        /// <summary>
        /// Gets or sets the environment variable (e.g., vt100).
        /// </summary>
        /// <value>
        /// The environment variable.
        /// </value>
        public string EnvironmentVariable { get; set; }

        /// <summary>
        /// Gets or sets the terminal width in columns (e.g., 80).
        /// </summary>
        /// <value>
        /// The terminal width in columns.
        /// </value>
        public uint Columns { get; set; }

        /// <summary>
        /// Gets or sets the terminal width in rows (e.g., 24).
        /// </summary>
        /// <value>
        /// The terminal width in rows.
        /// </value>
        public uint Rows { get; set; }

        /// <summary>
        /// Gets or sets the terminal width in pixels (e.g., 640).
        /// </summary>
        /// <value>
        /// The terminal width in pixels.
        /// </value>
        public uint PixelWidth { get; set; }

        /// <summary>
        /// Gets or sets the terminal height in pixels (e.g., 480).
        /// </summary>
        /// <value>
        /// The terminal height in pixels.
        /// </value>
        public uint PixelHeight { get; set; }

        /// <summary>
        /// Gets or sets the terminal mode.
        /// </summary>
        /// <value>
        /// The terminal mode.
        /// </value>
        public IDictionary<TerminalModes, uint> TerminalModeValues { get; set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="PseudoTerminalRequestInfo"/> class.
        /// </summary>
        public PseudoTerminalRequestInfo()
        {
            this.WantReply = true;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PseudoTerminalRequestInfo"/> class.
        /// </summary>
        /// <param name="environmentVariable">The environment variable.</param>
        /// <param name="columns">The columns.</param>
        /// <param name="rows">The rows.</param>
        /// <param name="width">The width.</param>
        /// <param name="height">The height.</param>
        /// <param name="terminalModeValues">The terminal mode values.</param>
        public PseudoTerminalRequestInfo(string environmentVariable, uint columns, uint rows, uint width, uint height, IDictionary<TerminalModes, uint> terminalModeValues)
            : this()
        {
            this.EnvironmentVariable = environmentVariable;
            this.Columns = columns;
            this.Rows = rows;
            this.PixelWidth = width;
            this.PixelHeight = height;
            this.TerminalModeValues = terminalModeValues;
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.Write(this.EnvironmentVariable);
            this.Write(this.Columns);
            this.Write(this.Rows);
            this.Write(this.Rows);
            this.Write(this.PixelHeight);

            if (this.TerminalModeValues != null)
            {
                this.Write((uint)this.TerminalModeValues.Count * (1 + 4) + 1);

                foreach (var item in this.TerminalModeValues)
                {
                    this.Write((byte)item.Key);
                    this.Write(item.Value);
                }
                this.Write((byte)0);
            }
            else
            {
                this.Write((uint)0);
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelRequest\RequestInfo.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents type specific information for channel request.
    /// </summary>
    public abstract class RequestInfo : SshData
    {
        /// <summary>
        /// Gets the name of the request.
        /// </summary>
        /// <value>
        /// The name of the request.
        /// </value>
        public abstract string RequestName { get; }

        /// <summary>
        /// Gets or sets a value indicating whether reply message is needed.
        /// </summary>
        /// <value>
        ///   <c>true</c> if reply message is needed; otherwise, <c>false</c>.
        /// </value>
        public bool WantReply { get; protected set; }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.WantReply = this.ReadBoolean();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.Write(this.WantReply);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelRequest\ShellRequestInfo.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents "shell" type channel request information
    /// </summary>
    public class ShellRequestInfo : RequestInfo
    {
        /// <summary>
        /// Channel request name
        /// </summary>
        public const string NAME = "shell";

        /// <summary>
        /// Gets the name of the request.
        /// </summary>
        /// <value>
        /// The name of the request.
        /// </value>
        public override string RequestName
        {
            get { return NAME; }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ShellRequestInfo"/> class.
        /// </summary>
        public ShellRequestInfo()
        {
            this.WantReply = true;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelRequest\SignalRequestInfo.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents "signal" type channel request information
    /// </summary>
    public class SignalRequestInfo : RequestInfo
    {
        /// <summary>
        /// Channel request name.
        /// </summary>
        public const string NAME = "signal";

        /// <summary>
        /// Gets the name of the request.
        /// </summary>
        /// <value>
        /// The name of the request.
        /// </value>
        public override string RequestName
        {
            get { return NAME; }
        }

        /// <summary>
        /// Gets the name of the signal.
        /// </summary>
        /// <value>
        /// The name of the signal.
        /// </value>
        public string SignalName { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SignalRequestInfo"/> class.
        /// </summary>
        public SignalRequestInfo()
        {
            this.WantReply = false;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SignalRequestInfo"/> class.
        /// </summary>
        /// <param name="signalName">Name of the signal.</param>
        public SignalRequestInfo(string signalName)
            : this()
        {
            this.SignalName = signalName;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();

            this.SignalName = this.ReadAsciiString();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.WriteAscii(this.SignalName);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelRequest\SubsystemRequestInfo.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents "subsystem" type channel request information
    /// </summary>
    public class SubsystemRequestInfo : RequestInfo
    {
        /// <summary>
        /// Channel request name
        /// </summary>
        public const string NAME = "subsystem";

        /// <summary>
        /// Gets the name of the request.
        /// </summary>
        /// <value>
        /// The name of the request.
        /// </value>
        public override string RequestName
        {
            get { return NAME; }
        }

        /// <summary>
        /// Gets the name of the subsystem.
        /// </summary>
        /// <value>
        /// The name of the subsystem.
        /// </value>
        public string SubsystemName { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SubsystemRequestInfo"/> class.
        /// </summary>
        public SubsystemRequestInfo()
        {
            this.WantReply = true;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SubsystemRequestInfo"/> class.
        /// </summary>
        /// <param name="subsystem">The subsystem.</param>
        public SubsystemRequestInfo(string subsystem)
            : this()
        {
            this.SubsystemName = subsystem;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();

            this.SubsystemName = this.ReadAsciiString();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.WriteAscii(this.SubsystemName);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelRequest\WindowChangeRequestInfo.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents "window-change" type channel request information
    /// </summary>
    public class WindowChangeRequestInfo : RequestInfo
    {
        /// <summary>
        /// Channe request name
        /// </summary>
        public const string NAME = "window-change";

        /// <summary>
        /// Gets the name of the request.
        /// </summary>
        /// <value>
        /// The name of the request.
        /// </value>
        public override string RequestName
        {
            get { return NAME; }
        }

        /// <summary>
        /// Gets the columns.
        /// </summary>
        public uint Columns { get; private set; }

        /// <summary>
        /// Gets the rows.
        /// </summary>
        public uint Rows { get; private set; }

        /// <summary>
        /// Gets the width.
        /// </summary>
        public uint Width { get; private set; }

        /// <summary>
        /// Gets the height.
        /// </summary>
        public uint Height { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="WindowChangeRequestInfo"/> class.
        /// </summary>
        public WindowChangeRequestInfo()
        {
            this.WantReply = false;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="WindowChangeRequestInfo"/> class.
        /// </summary>
        /// <param name="columns">The columns.</param>
        /// <param name="rows">The rows.</param>
        /// <param name="width">The width.</param>
        /// <param name="height">The height.</param>
        public WindowChangeRequestInfo(uint columns, uint rows, uint width, uint height)
            : this()
        {
            this.Columns = columns;
            this.Rows = rows;
            this.Width = width;
            this.Height = height;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();

            this.Columns = this.ReadUInt32();
            this.Rows = this.ReadUInt32();
            this.Width = this.ReadUInt32();
            this.Height = this.ReadUInt32();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.Write(this.Columns);
            this.Write(this.Rows);
            this.Write(this.Width);
            this.Write(this.Height);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelRequest\X11ForwardingRequestInfo.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents "x11-req" type channel request information
    /// </summary>
    public class X11ForwardingRequestInfo : RequestInfo
    {
        /// <summary>
        /// Channel request name
        /// </summary>
        public const string NAME = "x11-req";

        /// <summary>
        /// Gets the name of the request.
        /// </summary>
        /// <value>
        /// The name of the request.
        /// </value>
        public override string RequestName
        {
            get { return NAME; }
        }

        /// <summary>
        /// Gets or sets a value indicating whether it is a single connection.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if it is a single connection; otherwise, <c>false</c>.
        /// </value>
        public bool IsSingleConnection { get; set; }

        /// <summary>
        /// Gets or sets the authentication protocol.
        /// </summary>
        /// <value>
        /// The authentication protocol.
        /// </value>
        public string AuthenticationProtocol { get; set; }

        /// <summary>
        /// Gets or sets the authentication cookie.
        /// </summary>
        /// <value>
        /// The authentication cookie.
        /// </value>
        public byte[] AuthenticationCookie { get; set; }

        /// <summary>
        /// Gets or sets the screen number.
        /// </summary>
        /// <value>
        /// The screen number.
        /// </value>
        public uint ScreenNumber { get; set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="X11ForwardingRequestInfo"/> class.
        /// </summary>
        public X11ForwardingRequestInfo()
        {
            this.WantReply = true;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="X11ForwardingRequestInfo"/> class.
        /// </summary>
        /// <param name="isSingleConnection">if set to <c>true</c> it is a single connection.</param>
        /// <param name="protocol">The protocol.</param>
        /// <param name="cookie">The cookie.</param>
        /// <param name="screenNumber">The screen number.</param>
        public X11ForwardingRequestInfo(bool isSingleConnection, string protocol, byte[] cookie, uint screenNumber)
            : this()
        {
            this.IsSingleConnection = isSingleConnection;
            this.AuthenticationProtocol = protocol;
            this.AuthenticationCookie = cookie;
            this.ScreenNumber = screenNumber;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();

            this.IsSingleConnection = this.ReadBoolean();
            this.AuthenticationProtocol = this.ReadAsciiString();
            this.AuthenticationCookie = this.ReadBinaryString();
            this.ScreenNumber = this.ReadUInt32();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.Write(this.IsSingleConnection);
            this.WriteAscii(this.AuthenticationProtocol);
            this.WriteBinaryString(this.AuthenticationCookie);
            this.Write(this.ScreenNumber);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Connection\ChannelRequest\XonXoffRequestInfo.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Connection
{
    /// <summary>
    /// Represents "xon-xoff" type channel request information
    /// </summary>
    public class XonXoffRequestInfo : RequestInfo
    {
        /// <summary>
        /// Channel request type
        /// </summary>
        public const string NAME = "xon-xoff";

        /// <summary>
        /// Gets the name of the request.
        /// </summary>
        /// <value>
        /// The name of the request.
        /// </value>
        public override string RequestName
        {
            get { return NAME; }
        }

        /// <summary>
        /// Gets or sets a value indicating whether client can do.
        /// </summary>
        /// <value>
        ///   <c>true</c> if client can do; otherwise, <c>false</c>.
        /// </value>
        public bool ClientCanDo { get; set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="XonXoffRequestInfo"/> class.
        /// </summary>
        public XonXoffRequestInfo()
        {
            this.WantReply = false;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="XonXoffRequestInfo"/> class.
        /// </summary>
        /// <param name="clientCanDo">if set to <c>true</c> [client can do].</param>
        public XonXoffRequestInfo(bool clientCanDo)
            : this()
        {
            this.ClientCanDo = clientCanDo;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            base.LoadData();

            this.ClientCanDo = this.ReadBoolean();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            base.SaveData();

            this.Write(this.ClientCanDo);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\DebugMessage.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Represents SSH_MSG_DEBUG message.
    /// </summary>
    [Message("SSH_MSG_DEBUG", 4)]
    public class DebugMessage : MessageRenci
    {
        /// <summary>
        /// Gets a value indicating whether the message to be always displayed.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if the message always to be displayed; otherwise, <c>false</c>.
        /// </value>
        public bool IsAlwaysDisplay { get; private set; }

        /// <summary>
        /// Gets debug message.
        /// </summary>
        public string Message { get; private set; }

        /// <summary>
        /// Gets message language.
        /// </summary>
        public string Language { get; private set; }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.IsAlwaysDisplay = this.ReadBoolean();
            this.Message = this.ReadString();
            this.Language = this.ReadString();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.Write(this.IsAlwaysDisplay);
            this.Write(this.Message);
            this.Write(this.Language);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\DisconnectMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Represents SSH_MSG_DISCONNECT message.
    /// </summary>
    [Message("SSH_MSG_DISCONNECT", 1)]
    public class DisconnectMessage : MessageRenci, IKeyExchangedAllowed
    {
        /// <summary>
        /// Gets disconnect reason code.
        /// </summary>
        public DisconnectReason ReasonCode { get; private set; }

        /// <summary>
        /// Gets disconnect description.
        /// </summary>
        public string Description { get; private set; }

        /// <summary>
        /// Gets message language.
        /// </summary>
        public string Language { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="DisconnectMessage"/> class.
        /// </summary>
        public DisconnectMessage()
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DisconnectMessage"/> class.
        /// </summary>
        /// <param name="reasonCode">The reason code.</param>
        /// <param name="message">The message.</param>
        public DisconnectMessage(DisconnectReason reasonCode, string message)
        {
            this.ReasonCode = reasonCode;
            this.Description = message;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.ReasonCode = (DisconnectReason)this.ReadUInt32();
            this.Description = this.ReadString();
            this.Language = this.ReadString();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.Write((uint)this.ReasonCode);
            this.Write(this.Description);
            this.Write(this.Language ?? "en");
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\DisconnectReason.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Provides list of disconnect reason as specified by the protocol.
    /// </summary>
    public enum DisconnectReason
    {
        /// <summary>
        /// Disconnect reason is not provided.
        /// </summary>
        None = 0,
        /// <summary>
        /// SSH_DISCONNECT_HOST_NOT_ALLOWED_TO_CONNECT
        /// </summary>
        HostNotAllowedToConnect = 1,
        /// <summary>
        /// SSH_DISCONNECT_PROTOCOL_ERROR
        /// </summary>
        ProtocolError = 2,
        /// <summary>
        /// SSH_DISCONNECT_KEY_EXCHANGE_FAILED
        /// </summary>
        KeyExchangeFailed = 3,
        /// <summary>
        /// SSH_DISCONNECT_RESERVED
        /// </summary>
        Reserved = 4,
        /// <summary>
        /// SSH_DISCONNECT_MAC_ERROR
        /// </summary>
        MacError = 5,
        /// <summary>
        /// SSH_DISCONNECT_COMPRESSION_ERROR
        /// </summary>
        CompressionError = 6,
        /// <summary>
        /// SSH_DISCONNECT_SERVICE_NOT_AVAILABLE
        /// </summary>
        ServiceNotAvailable = 7,
        /// <summary>
        /// SSH_DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED
        /// </summary>
        ProtocolVersionNotSupported = 8,
        /// <summary>
        /// SSH_DISCONNECT_HOST_KEY_NOT_VERIFIABLE
        /// </summary>
        HostKeyNotVerifiable = 9,
        /// <summary>
        /// SSH_DISCONNECT_CONNECTION_LOST
        /// </summary>
        ConnectionLost = 10,
        /// <summary>
        /// SSH_DISCONNECT_BY_APPLICATION
        /// </summary>
        ByApplication = 11,
        /// <summary>
        /// SSH_DISCONNECT_TOO_MANY_CONNECTIONS
        /// </summary>
        TooManyConnections = 12,
        /// <summary>
        /// SSH_DISCONNECT_AUTH_CANCELLED_BY_USER
        /// </summary>
        AuthenticationCanceledByUser = 13,
        /// <summary>
        /// SSH_DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE
        /// </summary>
        NoMoreAuthenticationMethodsAvailable = 14,
        /// <summary>
        /// SSH_DISCONNECT_ILLEGAL_USER_NAME
        /// </summary>
        IllegalUserName = 15,
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\IgnoreMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Represents SSH_MSG_IGNORE message.
    /// </summary>
    [Message("SSH_MSG_IGNORE", 2)]
    public class IgnoreMessage : MessageRenci
    {
        /// <summary>
        /// Gets ignore message data if any.
        /// </summary>
        public byte[] Data { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="IgnoreMessage"/> class.
        /// </summary>
        public IgnoreMessage()
        {
            this.Data = new byte[] { };
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="IgnoreMessage"/> class.
        /// </summary>
        /// <param name="data">The data.</param>
        public IgnoreMessage(byte[] data)
        {
            this.Data = data;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.Data = this.ReadBinaryString();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.WriteBinaryString(this.Data);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\IKeyExchangedAllowed.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Indicates that message that implement this interface is allowed during key exchange phase
    /// </summary>
    public interface IKeyExchangedAllowed
    {
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\KeyExchangeDhGroupExchangeGroup.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Represents SSH_MSG_KEX_DH_GEX_GROUP message.
    /// </summary>
    [Message("SSH_MSG_KEX_DH_GEX_GROUP", 31)]
    public class KeyExchangeDhGroupExchangeGroup : MessageRenci
    {
        /// <summary>
        /// Gets or sets the safe prime.
        /// </summary>
        /// <value>
        /// The safe prime.
        /// </value>
        public BigInteger SafePrime { get; private set; }

        /// <summary>
        /// Gets or sets the generator for subgroup in GF(p).
        /// </summary>
        /// <value>
        /// The sub group.
        /// </value>
        public BigInteger SubGroup { get; private set; }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.SafePrime = this.ReadBigInt();
            this.SubGroup = this.ReadBigInt();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.Write(this.SafePrime);
            this.Write(this.SubGroup);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\KeyExchangeDhGroupExchangeInit.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Represents SSH_MSG_KEX_DH_GEX_INIT message.
    /// </summary>
    [Message("SSH_MSG_KEX_DH_GEX_INIT", 32)]
    public class KeyExchangeDhGroupExchangeInit : MessageRenci, IKeyExchangedAllowed
    {
        /// <summary>
        /// Gets the E value.
        /// </summary>
        public BigInteger E { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="KeyExchangeDhGroupExchangeInit"/> class.
        /// </summary>
        /// <param name="clientExchangeValue">The client exchange value.</param>
        public KeyExchangeDhGroupExchangeInit(BigInteger clientExchangeValue)
        {
            this.E = clientExchangeValue;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.E = this.ReadBigInt();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.Write(this.E);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\KeyExchangeDhGroupExchangeReply.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Represents SSH_MSG_KEX_DH_GEX_REPLY message.
    /// </summary>
    [Message("SSH_MSG_KEX_DH_GEX_REPLY", 33)]
    public class KeyExchangeDhGroupExchangeReply : MessageRenci
    {
        /// <summary>
        /// Gets server public host key and certificates
        /// </summary>
        /// <value>The host key.</value>
        public byte[] HostKey { get; private set; }

        /// <summary>
        /// Gets the F value.
        /// </summary>
        public BigInteger F { get; private set; }

        /// <summary>
        /// Gets the signature of H.
        /// </summary>
        /// <value>The signature.</value>
        public byte[] Signature { get; private set; }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.HostKey = this.ReadBinaryString();
            this.F = this.ReadBigInt();
            this.Signature = this.ReadBinaryString();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.WriteBinaryString(this.HostKey);
            this.Write(this.F);
            this.WriteBinaryString(this.Signature);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\KeyExchangeDhGroupExchangeRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Represents SSH_MSG_KEX_DH_GEX_REQUEST message.
    /// </summary>
    [Message("SSH_MSG_KEX_DH_GEX_REQUEST", 34)]
    public class KeyExchangeDhGroupExchangeRequest : MessageRenci, IKeyExchangedAllowed
    {
        /// <summary>
        /// Gets or sets the minimal size in bits of an acceptable group.
        /// </summary>
        /// <value>
        /// The minimum.
        /// </value>
        public UInt32 Minimum { get; private set; }

        /// <summary>
        /// Gets or sets the preferred size in bits of the group the server will send.
        /// </summary>
        /// <value>
        /// The preferred.
        /// </value>
        public UInt32 Preferred { get; private set; }

        /// <summary>
        /// Gets or sets the maximal size in bits of an acceptable group.
        /// </summary>
        /// <value>
        /// The maximum.
        /// </value>
        public UInt32 Maximum { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="KeyExchangeDhGroupExchangeRequest"/> class.
        /// </summary>
        /// <param name="minimum">The minimum.</param>
        /// <param name="preferred">The preferred.</param>
        /// <param name="maximum">The maximum.</param>
        public KeyExchangeDhGroupExchangeRequest(uint minimum, uint preferred, uint maximum)
        {
            this.Minimum = minimum;
            this.Preferred = preferred;
            this.Maximum = maximum;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.Minimum = this.ReadUInt32();
            this.Preferred = this.ReadUInt32();
            this.Maximum = this.ReadUInt32();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.Write(this.Minimum);
            this.Write(this.Preferred);
            this.Write(this.Maximum);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\KeyExchangeDhInitMessage.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Represents SSH_MSG_KEXDH_INIT message.
    /// </summary>
    [Message("SSH_MSG_KEXDH_INIT", 30)]
    public class KeyExchangeDhInitMessage : MessageRenci, IKeyExchangedAllowed
    {
        /// <summary>
        /// Gets the E value.
        /// </summary>
        public BigInteger E { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="KeyExchangeDhInitMessage"/> class.
        /// </summary>
        /// <param name="clientExchangeValue">The client exchange value.</param>
        public KeyExchangeDhInitMessage(BigInteger clientExchangeValue)
        {
            this.E = clientExchangeValue;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.ResetReader();
            this.E = this.ReadBigInt();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.Write(this.E);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\KeyExchangeDhReplyMessage.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Represents SSH_MSG_KEXDH_REPLY message.
    /// </summary>
    [Message("SSH_MSG_KEXDH_REPLY", 31)]
    public class KeyExchangeDhReplyMessage : MessageRenci
    {
        /// <summary>
        /// Gets server public host key and certificates
        /// </summary>
        /// <value>The host key.</value>
        public byte[] HostKey { get; private set; }

        /// <summary>
        /// Gets the F value.
        /// </summary>
        public BigInteger F { get; private set; }

        /// <summary>
        /// Gets the signature of H.
        /// </summary>
        /// <value>The signature.</value>
        public byte[] Signature { get; private set; }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.ResetReader();
            this.HostKey = this.ReadBinaryString();
            this.F = this.ReadBigInt();
            this.Signature = this.ReadBinaryString();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.WriteBinaryString(this.HostKey);
            this.Write(this.F);
            this.WriteBinaryString(this.Signature);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\KeyExchangeEcdhInitMessage.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Represents SSH_MSG_KEXECDH_INIT message.
    /// </summary>
    [Message("SSH_MSG_KEXECDH_INIT", 30)]
    public class KeyExchangeEcdhInitMessage : MessageRenci, IKeyExchangedAllowed
    {
        /// <summary>
        /// Gets the client's ephemeral contribution to the ECDH exchange, encoded as an octet string
        /// </summary>
        public byte[] QC { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="KeyExchangeEcdhInitMessage"/> class.
        /// </summary>
        public KeyExchangeEcdhInitMessage(BigInteger d, BigInteger q)
        {
            var data = new List<byte>();
            data.Add(0x04);
            data.AddRange(d.ToByteArray().Reverse());
            data.AddRange(q.ToByteArray().Reverse());
            this.QC = data.ToArray();
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.ResetReader();
            this.QC = this.ReadBinaryString();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.WriteBinaryString(this.QC);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\KeyExchangeEcdhReplyMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Represents SSH_MSG_KEXECDH_REPLY message.
    /// </summary>
    [Message("SSH_MSG_KEXECDH_REPLY", 31)]
    public class KeyExchangeEcdhReplyMessage : MessageRenci
    {
        /// <summary>
        /// Gets a string encoding an X.509v3 certificate containing the server's ECDSA public host key
        /// </summary>
        /// <value>The host key.</value>
        public byte[] KS { get; private set; }

        /// <summary>
        /// Gets the the server's ephemeral contribution to the ECDH exchange, encoded as an octet string.
        /// </summary>
        public byte[] QS { get; private set; }

        /// <summary>
        /// Gets the an octet string containing the server's signature of the newly established exchange hash value.
        /// </summary>
        /// <value>The signature.</value>
        public byte[] Signature { get; private set; }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.ResetReader();
            this.KS = this.ReadBinaryString();
            this.QS = this.ReadBinaryString();
            this.Signature = this.ReadBinaryString();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.WriteBinaryString(this.KS);
            this.WriteBinaryString(this.QS);
            this.WriteBinaryString(this.Signature);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\KeyExchangeInitMessage.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Represents SSH_MSG_KEXINIT message.
    /// </summary>
    [Message("SSH_MSG_KEXINIT", 20)]
    public class KeyExchangeInitMessage : MessageRenci, IKeyExchangedAllowed
    {
        private static readonly RNGCryptoServiceProvider _randomizer = new RNGCryptoServiceProvider();

        /// <summary>
        /// Initializes a new instance of the <see cref="KeyExchangeInitMessage"/> class.
        /// </summary>
        public KeyExchangeInitMessage()
        {
            var cookie = new byte[16];
            _randomizer.GetBytes(cookie);
            this.Cookie = cookie;
        }

        #region Message Properties

        /// <summary>
        /// Gets session cookie.
        /// </summary>
        public byte[] Cookie { get; private set; }

        /// <summary>
        /// Gets or sets supported key exchange algorithms.
        /// </summary>
        /// <value>
        /// Supported key exchange algorithms.
        /// </value>
        public string[] KeyExchangeAlgorithms { get; set; }

        /// <summary>
        /// Gets or sets supported server host key algorithms.
        /// </summary>
        /// <value>
        /// Supported server host key algorithms.
        /// </value>
        public string[] ServerHostKeyAlgorithms { get; set; }

        /// <summary>
        /// Gets or sets supported encryption algorithms client to server.
        /// </summary>
        /// <value>
        /// Supported encryption algorithms client to server.
        /// </value>
        public string[] EncryptionAlgorithmsClientToServer { get; set; }

        /// <summary>
        /// Gets or sets supported encryption algorithms server to client.
        /// </summary>
        /// <value>
        /// Supported encryption algorithms server to client.
        /// </value>
        public string[] EncryptionAlgorithmsServerToClient { get; set; }

        /// <summary>
        /// Gets or sets supported hash algorithms client to server.
        /// </summary>
        /// <value>
        /// Supported hash algorithms client to server.
        /// </value>
        public string[] MacAlgorithmsClientToServer { get; set; }

        /// <summary>
        /// Gets or sets supported hash algorithms server to client.
        /// </summary>
        /// <value>
        /// Supported hash algorithms server to client.
        /// </value>
        public string[] MacAlgorithmsServerToClient { get; set; }

        /// <summary>
        /// Gets or sets supported compression algorithms client to server.
        /// </summary>
        /// <value>
        /// Supported compression algorithms client to server.
        /// </value>
        public string[] CompressionAlgorithmsClientToServer { get; set; }

        /// <summary>
        /// Gets or sets supported compression algorithms server to client.
        /// </summary>
        /// <value>
        /// Supported compression algorithms server to client.
        /// </value>
        public string[] CompressionAlgorithmsServerToClient { get; set; }

        /// <summary>
        /// Gets or sets supported languages client to server.
        /// </summary>
        /// <value>
        /// Supported languages client to server.
        /// </value>
        public string[] LanguagesClientToServer { get; set; }

        /// <summary>
        /// Gets or sets supported languages server to client.
        /// </summary>
        /// <value>
        /// The languages server to client.
        /// </value>
        public string[] LanguagesServerToClient { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether first key exchange packet follows.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if first key exchange packet follows; otherwise, <c>false</c>.
        /// </value>
        public bool FirstKexPacketFollows { get; set; }

        /// <summary>
        /// Gets or sets the reserved value.
        /// </summary>
        /// <value>
        /// The reserved value.
        /// </value>
        public UInt32 Reserved { get; set; }

        #endregion

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            this.ResetReader();

            this.Cookie = this.ReadBytes(16);
            this.KeyExchangeAlgorithms = this.ReadNamesList();
            this.ServerHostKeyAlgorithms = this.ReadNamesList();
            this.EncryptionAlgorithmsClientToServer = this.ReadNamesList();
            this.EncryptionAlgorithmsServerToClient = this.ReadNamesList();
            this.MacAlgorithmsClientToServer = this.ReadNamesList();
            this.MacAlgorithmsServerToClient = this.ReadNamesList();
            this.CompressionAlgorithmsClientToServer = this.ReadNamesList();
            this.CompressionAlgorithmsServerToClient = this.ReadNamesList();
            this.LanguagesClientToServer = this.ReadNamesList();
            this.LanguagesServerToClient = this.ReadNamesList();
            this.FirstKexPacketFollows = this.ReadBoolean();
            this.Reserved = this.ReadUInt32();
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            this.Write(this.Cookie);
            this.Write(this.KeyExchangeAlgorithms);
            this.Write(this.ServerHostKeyAlgorithms);
            this.Write(this.EncryptionAlgorithmsClientToServer);
            this.Write(this.EncryptionAlgorithmsServerToClient);
            this.Write(this.MacAlgorithmsClientToServer);
            this.Write(this.MacAlgorithmsServerToClient);
            this.Write(this.CompressionAlgorithmsClientToServer);
            this.Write(this.CompressionAlgorithmsServerToClient);
            this.Write(this.LanguagesClientToServer);
            this.Write(this.LanguagesServerToClient);
            this.Write(this.FirstKexPacketFollows);
            this.Write(this.Reserved);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\NewKeysMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Represents SSH_MSG_KEXINIT message.
    /// </summary>
    [Message("SSH_MSG_NEWKEYS", 21)]
    public class NewKeysMessage : MessageRenci, IKeyExchangedAllowed
    {
        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\ServiceAcceptMessage.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Represents SSH_MSG_SERVICE_ACCEPT message.
    /// </summary>
    [Message("SSH_MSG_SERVICE_ACCEPT", 6)]
    public class ServiceAcceptMessage : MessageRenci
    {
        /// <summary>
        /// Gets the name of the service.
        /// </summary>
        /// <value>
        /// The name of the service.
        /// </value>
        public ServiceName ServiceName { get; private set; }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            var serviceName = this.ReadAsciiString();
            switch (serviceName)
            {
                case "ssh-userauth":
                    this.ServiceName = ServiceName.UserAuthentication;
                    break;
                case "ssh-connection":
                    this.ServiceName = ServiceName.Connection;
                    break;
            }
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            throw new InvalidOperationException("Save data is not supported.");
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\ServiceRequestMessage.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Represents SSH_MSG_SERVICE_REQUEST message.
    /// </summary>
    [Message("SSH_MSG_SERVICE_REQUEST", 5)]
    public class ServiceRequestMessage : MessageRenci
    {
        /// <summary>
        /// Gets the name of the service.
        /// </summary>
        /// <value>
        /// The name of the service.
        /// </value>
        public ServiceName ServiceName { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ServiceRequestMessage"/> class.
        /// </summary>
        /// <param name="serviceName">Name of the service.</param>
        public ServiceRequestMessage(ServiceName serviceName)
        {
            this.ServiceName = serviceName;
        }

        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
            throw new InvalidOperationException("Load data is not supported.");
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
            switch (this.ServiceName)
            {
                case ServiceName.UserAuthentication:
                    this.WriteAscii("ssh-userauth");
                    break;
                case ServiceName.Connection:
                    this.WriteAscii("ssh-connection");
                    break;
                default:
                    throw new NotSupportedException("Not supported service name");
            }

        }
    }
}

#endif
// file ...\X\Renci.SshNet\Messages\Transport\UnimplementedMessage.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Messages.Transport
{
    /// <summary>
    /// Represents SSH_MSG_UNIMPLEMENTED message.
    /// </summary>
    [Message("SSH_MSG_UNIMPLEMENTED", 3)]
    public class UnimplementedMessage : MessageRenci
    {
        /// <summary>
        /// Called when type specific data need to be loaded.
        /// </summary>
        protected override void LoadData()
        {
        }

        /// <summary>
        /// Called when type specific data need to be saved.
        /// </summary>
        protected override void SaveData()
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Netconf\INetConfSession.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.NetConf
{
    public interface INetConfSession : ISubsystemSession
    {
        /// <summary>
        /// Gets the NetConf server capabilities.
        /// </summary>
        /// <value>
        /// The NetConf server capabilities.
        /// </value>
        XmlDocument ServerCapabilities { get; }

        /// <summary>
        /// Gets the NetConf client capabilities.
        /// </summary>
        /// <value>
        /// The NetConf client capabilities.
        /// </value>
        XmlDocument ClientCapabilities { get; }

        XmlDocument SendReceiveRpc(XmlDocument rpc, bool automaticMessageIdHandling);
    }
}

#endif
// file ...\X\Renci.SshNet\Netconf\NetConfSession.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.NetConf
{
    public class NetConfSession : SubsystemSession, INetConfSession
    {
        private const string Prompt = "]]>]]>";

        private readonly StringBuilder _data = new StringBuilder();
        private bool _usingFramingProtocol;
        private EventWaitHandle _serverCapabilitiesConfirmed = new AutoResetEvent(false);
        private EventWaitHandle _rpcReplyReceived = new AutoResetEvent(false);
        private StringBuilder _rpcReply = new StringBuilder();
        private int _messageId;

        /// <summary>
        /// Gets NetConf server capabilities.
        /// </summary>
        public XmlDocument ServerCapabilities { get; private set; }

        /// <summary>
        /// Gets NetConf client capabilities.
        /// </summary>
        public XmlDocument ClientCapabilities { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="NetConfSession"/> class.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="operationTimeout">The operation timeout.</param>
        public NetConfSession(ISession session, TimeSpan operationTimeout)
            : base(session, "netconf", operationTimeout, Encoding.UTF8)
        {
            ClientCapabilities = new XmlDocument();
            ClientCapabilities.LoadXml("<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                                                "<hello xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">" +
                                                    "<capabilities>" +
                                                        "<capability>" +
                                                            "urn:ietf:params:netconf:base:1.0" +
                                                        "</capability>" +
                                                    "</capabilities>" +
                                                "</hello>");

        }

        public XmlDocument SendReceiveRpc(XmlDocument rpc, bool automaticMessageIdHandling)
        {
            _data.Clear();

            XmlNamespaceManager nsMgr = null;
            if (automaticMessageIdHandling)
            {
                _messageId++;
                nsMgr = new XmlNamespaceManager(rpc.NameTable);
                nsMgr.AddNamespace("nc", "urn:ietf:params:xml:ns:netconf:base:1.0");
                rpc.SelectSingleNode("/nc:rpc/@message-id", nsMgr).Value = _messageId.ToString(CultureInfo.InvariantCulture);
            }
            _rpcReply = new StringBuilder();
            _rpcReplyReceived.Reset();
            var reply = new XmlDocument();
            if (_usingFramingProtocol)
            {
                var command = new StringBuilder(rpc.InnerXml.Length + 10);
                command.AppendFormat("\n#{0}\n", rpc.InnerXml.Length);
                command.Append(rpc.InnerXml);
                command.Append("\n##\n");
                SendData(Encoding.UTF8.GetBytes(command.ToString()));

                WaitOnHandle(_rpcReplyReceived, OperationTimeout);
                reply.LoadXml(_rpcReply.ToString());
            }
            else
            {
                SendData(Encoding.UTF8.GetBytes(rpc.InnerXml + Prompt));
                WaitOnHandle(_rpcReplyReceived, OperationTimeout);
                reply.LoadXml(_rpcReply.ToString());
            }
            if (automaticMessageIdHandling)
            {
                var replyId = rpc.SelectSingleNode("/nc:rpc/@message-id", nsMgr).Value;
                if (replyId != _messageId.ToString(CultureInfo.InvariantCulture))
                {
                    throw new NetConfServerException("The rpc message id does not match the rpc-reply message id.");
                }
            }
            return reply;
        }

        protected override void OnChannelOpen()
        {
            _data.Clear();

            var message = string.Format("{0}{1}", ClientCapabilities.InnerXml, Prompt);

            SendData(Encoding.UTF8.GetBytes(message));

            WaitOnHandle(_serverCapabilitiesConfirmed, OperationTimeout);
        }

        protected override void OnDataReceived(uint dataTypeCode, byte[] data)
        {
            var chunk = Encoding.UTF8.GetString(data);

            if (ServerCapabilities == null)   // This must be server capabilities, old protocol
            {
                _data.Append(chunk);  

                if (!chunk.Contains(Prompt))
                {
                    return;
                }
                try
                {
                    chunk = _data.ToString(); 
                    _data.Clear();

                    ServerCapabilities = new XmlDocument();
                    ServerCapabilities.LoadXml(chunk.Replace(Prompt, ""));
                }
                catch (XmlException e)
                {
                    throw new NetConfServerException("Server capabilities received are not well formed XML", e);
                }

                var nsMgr = new XmlNamespaceManager(ServerCapabilities.NameTable);
                nsMgr.AddNamespace("nc", "urn:ietf:params:xml:ns:netconf:base:1.0");

                _usingFramingProtocol = (ServerCapabilities.SelectSingleNode("/nc:hello/nc:capabilities/nc:capability[text()='urn:ietf:params:netconf:base:1.1']", nsMgr) != null);

                _serverCapabilitiesConfirmed.Set();
            }
            else if (_usingFramingProtocol)
            {
                int position = 0;

                for (; ; )
                {
                    var match = Regex.Match(chunk.Substring(position), @"\n#(?<length>\d+)\n");
                    if (!match.Success)
                    {
                        break;
                    }
                    var fractionLength = Convert.ToInt32(match.Groups["length"].Value);
                    _rpcReply.Append(chunk, position + match.Index + match.Length, fractionLength);
                    position += match.Index + match.Length + fractionLength;
                }
                if (Regex.IsMatch(chunk.Substring(position), @"\n##\n"))
                {
                    _rpcReplyReceived.Set();
                }
            }
            else  // Old protocol
            {
                _data.Append(chunk);

                if (!chunk.Contains(Prompt))
                {
                    return;
                    //throw new NetConfServerException("Server XML message does not end with the prompt " + _prompt);
                }
                
                chunk = _data.ToString();
                _data.Clear();

                _rpcReply.Append(chunk.Replace(Prompt, ""));
                _rpcReplyReceived.Set();
            }
        }

        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);

            if (disposing)
            {
                if (_serverCapabilitiesConfirmed != null)
                {
                    _serverCapabilitiesConfirmed.Dispose();
                    _serverCapabilitiesConfirmed = null;
                }

                if (_rpcReplyReceived != null)
                {
                    _rpcReplyReceived.Dispose();
                    _rpcReplyReceived = null;
                }
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Algorithm.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Security
{
    /// <summary>
    /// Represents the abstract base class from which all implementations of algorithms must inherit.
    /// </summary>
    public abstract class Algorithm
    {
        /// <summary>
        /// Gets algorithm name.
        /// </summary>
        public abstract string Name { get; }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\CertificateHostAlgorithm.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security
{
    /// <summary>
    /// Implements certificate support for host algorithm.
    /// </summary>
    public class CertificateHostAlgorithm : HostAlgorithm
    {
        /// <summary>
        /// Gets the host key data.
        /// </summary>
        public override byte[] Data
        {
            get { throw new NotImplementedException(); }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CertificateHostAlgorithm"/> class.
        /// </summary>
        /// <param name="name">The host key name.</param>
        public CertificateHostAlgorithm(string name)
            : base(name)
        {
        }

        /// <summary>
        /// Signs the specified data.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <returns>Signed data.</returns>
        /// <exception cref="System.NotImplementedException"></exception>
        public override byte[] Sign(byte[] data)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Verifies the signature.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <param name="signature">The signature.</param>
        /// <returns><c>True</c> if signature was successfully verified; otherwise <c>false</c>.</returns>
        /// <exception cref="System.NotImplementedException"></exception>
        public override bool VerifySignature(byte[] data, byte[] signature)
        {
            throw new NotImplementedException();
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\GroupExchangeHashData.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security
{
    public class GroupExchangeHashData : SshData
    {
        public string ServerVersion { get; set; }

        public string ClientVersion { get; set; }

        public byte[] ClientPayload { get; set; }

        public byte[] ServerPayload { get; set; }

        public byte[] HostKey { get; set; }

        public UInt32 MinimumGroupSize { get; set; }

        public UInt32 PreferredGroupSize { get; set; }

        public UInt32 MaximumGroupSize { get; set; }

        public BigInteger Prime { get; set; }

        public BigInteger SubGroup { get; set; }

        public BigInteger ClientExchangeValue { get; set; }

        public BigInteger ServerExchangeValue { get; set; }

        public BigInteger SharedKey { get; set; }

        protected override void LoadData()
        {
            throw new NotImplementedException();
        }

        protected override void SaveData()
        {
            this.Write(this.ClientVersion);
            this.Write(this.ServerVersion);
            this.WriteBinaryString(this.ClientPayload);
            this.WriteBinaryString(this.ServerPayload);
            this.WriteBinaryString(this.HostKey);
            this.Write(this.MinimumGroupSize);
            this.Write(this.PreferredGroupSize);
            this.Write(this.MaximumGroupSize);
            this.Write(this.Prime);
            this.Write(this.SubGroup);
            this.Write(this.ClientExchangeValue);
            this.Write(this.ServerExchangeValue);
            this.Write(this.SharedKey);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\HostAlgorithm.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Security
{
    /// <summary>
    /// Base class for SSH host algorithms.
    /// </summary>
    public abstract class HostAlgorithm
    {
        /// <summary>
        /// Gets the host key name.
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        /// Gets the host key data.
        /// </summary>
        public abstract byte[] Data { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="HostAlgorithm"/> class.
        /// </summary>
        /// <param name="name">The host key name.</param>
        public HostAlgorithm(string name)
        {
            this.Name = name;
        }

        /// <summary>
        /// Signs the specified data.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <returns>Signed data.</returns>
        public abstract byte[] Sign(byte[] data);

        /// <summary>
        /// Verifies the signature.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <param name="signature">The signature.</param>
        /// <returns><c>True</c> is signature was successfully verifies; otherwise <c>false</c>.</returns>
        public abstract bool VerifySignature(byte[] data, byte[] signature);
    }
}

#endif
// file ...\X\Renci.SshNet\Security\KeyExchange.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security
{
    /// <summary>
    /// Represents base class for different key exchange algorithm implementations
    /// </summary>
    public abstract class KeyExchange : Algorithm, IDisposable
    {
        private CipherInfo _clientCipherInfo;

        private CipherInfo _serverCipherInfo;

        private HashInfo _clientHashInfo;

        private HashInfo _serverHashInfo;

        private Type _compressionType;

        private Type _decompressionType;

        /// <summary>
        /// Gets or sets the session.
        /// </summary>
        /// <value>
        /// The session.
        /// </value>
        protected Session Session { get; private set; }

        /// <summary>
        /// Gets or sets key exchange shared key.
        /// </summary>
        /// <value>
        /// The shared key.
        /// </value>
        public BigInteger SharedKey { get; protected set; }

        private byte[] _exchangeHash;
        /// <summary>
        /// Gets the exchange hash.
        /// </summary>
        /// <value>The exchange hash.</value>
        public byte[] ExchangeHash
        {
            get
            {
                if (this._exchangeHash == null)
                {
                    this._exchangeHash = this.CalculateHash();
                }
                return this._exchangeHash;
            }
        }

        /// <summary>
        /// Occurs when host key received.
        /// </summary>
        public event EventHandler<HostKeyEventArgs> HostKeyReceived;

        /// <summary>
        /// Starts key exchange algorithm
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="message">Key exchange init message.</param>
        public virtual void Start(Session session, KeyExchangeInitMessage message)
        {
            this.Session = session;

            this.SendMessage(session.ClientInitMessage);

            //  Determine encryption algorithm
            var clientEncryptionAlgorithmName = (from b in session.ConnectionInfo.Encryptions.Keys
                                                 from a in message.EncryptionAlgorithmsClientToServer
                                                 where a == b
                                                 select a).FirstOrDefault();

            if (string.IsNullOrEmpty(clientEncryptionAlgorithmName))
            {
                throw new SshConnectionException("Client encryption algorithm not found", DisconnectReason.KeyExchangeFailed);
            }

            session.ConnectionInfo.CurrentClientEncryption = clientEncryptionAlgorithmName;

            //  Determine encryption algorithm
            var serverDecryptionAlgorithmName = (from b in session.ConnectionInfo.Encryptions.Keys
                                                 from a in message.EncryptionAlgorithmsServerToClient
                                                 where a == b
                                                 select a).FirstOrDefault();
            if (string.IsNullOrEmpty(serverDecryptionAlgorithmName))
            {
                throw new SshConnectionException("Server decryption algorithm not found", DisconnectReason.KeyExchangeFailed);
            }

            session.ConnectionInfo.CurrentServerEncryption = serverDecryptionAlgorithmName;

            //  Determine client hmac algorithm
            var clientHmacAlgorithmName = (from b in session.ConnectionInfo.HmacAlgorithms.Keys
                                           from a in message.MacAlgorithmsClientToServer
                                           where a == b
                                           select a).FirstOrDefault();
            if (string.IsNullOrEmpty(clientHmacAlgorithmName))
            {
                throw new SshConnectionException("Server HMAC algorithm not found", DisconnectReason.KeyExchangeFailed);
            }

            session.ConnectionInfo.CurrentClientHmacAlgorithm = clientHmacAlgorithmName;

            //  Determine server hmac algorithm
            var serverHmacAlgorithmName = (from b in session.ConnectionInfo.HmacAlgorithms.Keys
                                           from a in message.MacAlgorithmsServerToClient
                                           where a == b
                                           select a).FirstOrDefault();
            if (string.IsNullOrEmpty(serverHmacAlgorithmName))
            {
                throw new SshConnectionException("Server HMAC algorithm not found", DisconnectReason.KeyExchangeFailed);
            }

            session.ConnectionInfo.CurrentServerHmacAlgorithm = serverHmacAlgorithmName;

            //  Determine compression algorithm
            var compressionAlgorithmName = (from b in session.ConnectionInfo.CompressionAlgorithms.Keys
                                            from a in message.CompressionAlgorithmsClientToServer
                                            where a == b
                                            select a).LastOrDefault();
            if (string.IsNullOrEmpty(compressionAlgorithmName))
            {
                throw new SshConnectionException("Compression algorithm not found", DisconnectReason.KeyExchangeFailed);
            }

            session.ConnectionInfo.CurrentClientCompressionAlgorithm = compressionAlgorithmName;

            //  Determine decompression algorithm
            var decompressionAlgorithmName = (from b in session.ConnectionInfo.CompressionAlgorithms.Keys
                                              from a in message.CompressionAlgorithmsServerToClient
                                              where a == b
                                              select a).LastOrDefault();
            if (string.IsNullOrEmpty(decompressionAlgorithmName))
            {
                throw new SshConnectionException("Decompression algorithm not found", DisconnectReason.KeyExchangeFailed);
            }

            session.ConnectionInfo.CurrentServerCompressionAlgorithm = decompressionAlgorithmName;

            this._clientCipherInfo = session.ConnectionInfo.Encryptions[clientEncryptionAlgorithmName];
            this._serverCipherInfo = session.ConnectionInfo.Encryptions[serverDecryptionAlgorithmName];
            this._clientHashInfo = session.ConnectionInfo.HmacAlgorithms[clientHmacAlgorithmName];
            this._serverHashInfo = session.ConnectionInfo.HmacAlgorithms[serverHmacAlgorithmName];
            this._compressionType = session.ConnectionInfo.CompressionAlgorithms[compressionAlgorithmName];
            this._decompressionType = session.ConnectionInfo.CompressionAlgorithms[decompressionAlgorithmName];
        }

        /// <summary>
        /// Finishes key exchange algorithm.
        /// </summary>
        public virtual void Finish()
        {
            //  Validate hash
            if (this.ValidateExchangeHash())
            {
                this.SendMessage(new NewKeysMessage());
            }
            else
            {
                throw new SshConnectionException("Key exchange negotiation failed.", DisconnectReason.KeyExchangeFailed);
            }
        }

        /// <summary>
        /// Creates the server side cipher to use.
        /// </summary>
        /// <returns>Server cipher.</returns>
        public Cipher CreateServerCipher()
        {
            //  Resolve Session ID
            var sessionId = this.Session.SessionId ?? this.ExchangeHash;

            //  Calculate server to client initial IV
            var serverVector = this.Hash(this.GenerateSessionKey(this.SharedKey, this.ExchangeHash, 'B', sessionId));

            //  Calculate server to client encryption
            var serverKey = this.Hash(this.GenerateSessionKey(this.SharedKey, this.ExchangeHash, 'D', sessionId));

            serverKey = this.GenerateSessionKey(this.SharedKey, this.ExchangeHash, serverKey, this._serverCipherInfo.KeySize / 8);
            
            //  Create server cipher
            return this._serverCipherInfo.Cipher(serverKey, serverVector);
        }

        /// <summary>
        /// Creates the client side cipher to use.
        /// </summary>
        /// <returns>Client cipher.</returns>
        public Cipher CreateClientCipher()
        {
            //  Resolve Session ID
            var sessionId = this.Session.SessionId ?? this.ExchangeHash;

            //  Calculate client to server initial IV
            var clientVector = this.Hash(this.GenerateSessionKey(this.SharedKey, this.ExchangeHash, 'A', sessionId));

            //  Calculate client to server encryption
            var clientKey = this.Hash(this.GenerateSessionKey(this.SharedKey, this.ExchangeHash, 'C', sessionId));

            clientKey = this.GenerateSessionKey(this.SharedKey, this.ExchangeHash, clientKey, this._clientCipherInfo.KeySize / 8);

            //  Create client cipher
            return this._clientCipherInfo.Cipher(clientKey, clientVector);
        }

        /// <summary>
        /// Creates the server side hash algorithm to use.
        /// </summary>
        /// <returns>Hash algorithm</returns>
        public HashAlgorithm CreateServerHash()
        {
            //  Resolve Session ID
            var sessionId = this.Session.SessionId ?? this.ExchangeHash;

            var serverKey = this.Hash(this.GenerateSessionKey(this.SharedKey, this.ExchangeHash, 'F', sessionId));

            serverKey = this.GenerateSessionKey(this.SharedKey, this.ExchangeHash, serverKey, this._serverHashInfo.KeySize / 8);

            //return serverHMac;
            return this._serverHashInfo.HashAlgorithm(serverKey);
        }

        /// <summary>
        /// Creates the client side hash algorithm to use.
        /// </summary>
        /// <returns>Hash algorithm</returns>
        public HashAlgorithm CreateClientHash()
        {
            //  Resolve Session ID
            var sessionId = this.Session.SessionId ?? this.ExchangeHash;

            var clientKey = this.Hash(this.GenerateSessionKey(this.SharedKey, this.ExchangeHash, 'E', sessionId));
            
            clientKey = this.GenerateSessionKey(this.SharedKey, this.ExchangeHash, clientKey, this._clientHashInfo.KeySize / 8);

            //return clientHMac;
            return this._clientHashInfo.HashAlgorithm(clientKey);
        }

        /// <summary>
        /// Creates the compression algorithm to use to deflate data.
        /// </summary>
        /// <returns>Compression method.</returns>
        public Compressor CreateCompressor()
        {
            if (this._compressionType == null)
                return null;

            var compressor = this._compressionType.CreateInstance<Compressor>();

            compressor.Init(this.Session);

            return compressor;
        }

        /// <summary>
        /// Creates the compression algorithm to use to inflate data.
        /// </summary>
        /// <returns>Compression method.</returns>
        public Compressor CreateDecompressor()
        {
            if (this._compressionType == null)
                return null;

            var decompressor = this._decompressionType.CreateInstance<Compressor>();

            decompressor.Init(this.Session);

            return decompressor;
        }

        /// <summary>
        /// Determines whether the specified host key can be trusted.
        /// </summary>
        /// <param name="host">The host algorithm.</param>
        /// <returns>
        ///   <c>true</c> if the specified host can be trusted; otherwise, <c>false</c>.
        /// </returns>
        protected bool CanTrustHostKey(KeyHostAlgorithm host)
        {
            var handlers = HostKeyReceived;
            if (handlers != null)
            {
                var args = new HostKeyEventArgs(host);
                handlers(this, args);
                return args.CanTrust;
            }

            return true;
        }

        /// <summary>
        /// Validates the exchange hash.
        /// </summary>
        /// <returns>true if exchange hash is valid; otherwise false.</returns>
        protected abstract bool ValidateExchangeHash();

        /// <summary>
        /// Calculates key exchange hash value.
        /// </summary>
        /// <returns>Key exchange hash.</returns>
        protected abstract byte[] CalculateHash();

        /// <summary>
        /// Hashes the specified data bytes.
        /// </summary>
        /// <param name="hashData">The hash data.</param>
        /// <returns>
        /// Hashed bytes
        /// </returns>
        protected virtual byte[] Hash(byte[] hashData)
        {
            using (var sha1 = new SHA1Hash())
            {
                return sha1.ComputeHash(hashData, 0, hashData.Length);
            }
        }

        /// <summary>
        /// Sends SSH message to the server
        /// </summary>
        /// <param name="message">The message.</param>
        protected void SendMessage(MessageRenci message)
        {
            this.Session.SendMessage(message);
        }

        /// <summary>
        /// Generates the session key.
        /// </summary>
        /// <param name="sharedKey">The shared key.</param>
        /// <param name="exchangeHash">The exchange hash.</param>
        /// <param name="key">The key.</param>
        /// <param name="size">The size.</param>
        /// <returns></returns>
        private byte[] GenerateSessionKey(BigInteger sharedKey, byte[] exchangeHash, byte[] key, int size)
        {
            var result = new List<byte>(key);
            while (size > result.Count)
            {
                result.AddRange(this.Hash(new _SessionKeyAdjustment
                {
                    SharedKey = sharedKey,
                    ExcahngeHash = exchangeHash,
                    Key = key,
                }.GetBytes()));
            }

            return result.ToArray();
        }

        /// <summary>
        /// Generates the session key.
        /// </summary>
        /// <param name="sharedKey">The shared key.</param>
        /// <param name="exchangeHash">The exchange hash.</param>
        /// <param name="p">The p.</param>
        /// <param name="sessionId">The session id.</param>
        /// <returns></returns>
        private byte[] GenerateSessionKey(BigInteger sharedKey, byte[] exchangeHash, char p, byte[] sessionId)
        {
            return new _SessionKeyGeneration
            {
                SharedKey = sharedKey,
                ExchangeHash = exchangeHash,
                Char = p,
                SessionId = sessionId,
            }.GetBytes();
        }

        private class _SessionKeyGeneration : SshData
        {
            public BigInteger SharedKey { get; set; }
            public byte[] ExchangeHash { get; set; }
            public char Char { get; set; }
            public byte[] SessionId { get; set; }

            protected override void LoadData()
            {
                throw new NotImplementedException();
            }

            protected override void SaveData()
            {
                this.Write(this.SharedKey);
                this.Write(this.ExchangeHash);
                this.Write((byte)this.Char);
                this.Write(this.SessionId);
            }
        }

        private class _SessionKeyAdjustment : SshData
        {
            public BigInteger SharedKey { get; set; }
            public byte[] ExcahngeHash { get; set; }
            public byte[] Key { get; set; }

            protected override void LoadData()
            {
                throw new NotImplementedException();
            }

            protected override void SaveData()
            {
                this.Write(this.SharedKey);
                this.Write(this.ExcahngeHash);
                this.Write(this.Key);
            }
        }

        #region IDisposable Members

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged ResourceMessages.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected virtual void Dispose(bool disposing)
        {
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="KeyExchange"/> is reclaimed by garbage collection.
        /// </summary>
        ~KeyExchange()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\Security\KeyExchangeDiffieHellman.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security
{
    /// <summary>
    /// Represents base class for Diffie Hellman key exchange algorithm
    /// </summary>
    public abstract class KeyExchangeDiffieHellman : KeyExchange
    {
        /// <summary>
        /// Specifies key exchange group number.
        /// </summary>
        protected BigInteger _group;

        /// <summary>
        /// Specifies key exchange prime number.
        /// </summary>
        protected BigInteger _prime;

        /// <summary>
        /// Specifies client payload
        /// </summary>
        protected byte[] _clientPayload;

        /// <summary>
        /// Specifies server payload
        /// </summary>
        protected byte[] _serverPayload;

        /// <summary>
        /// Specifies client exchange number.
        /// </summary>
        protected BigInteger _clientExchangeValue;

        /// <summary>
        /// Specifies server exchange number.
        /// </summary>
        protected BigInteger _serverExchangeValue;

        /// <summary>
        /// Specifies random generated number.
        /// </summary>
        protected BigInteger _randomValue;

        /// <summary>
        /// Specifies host key data.
        /// </summary>
        protected byte[] _hostKey;

        /// <summary>
        /// Specifies signature data.
        /// </summary>
        protected byte[] _signature;

        /// <summary>
        /// Validates the exchange hash.
        /// </summary>
        /// <returns>
        /// true if exchange hash is valid; otherwise false.
        /// </returns>
        protected override bool ValidateExchangeHash()
        {
            var exchangeHash = this.CalculateHash();

            var length = (uint)(this._hostKey[0] << 24 | this._hostKey[1] << 16 | this._hostKey[2] << 8 | this._hostKey[3]);

            var algorithmName = Encoding.UTF8.GetString(this._hostKey, 4, (int)length);

            var key = this.Session.ConnectionInfo.HostKeyAlgorithms[algorithmName](this._hostKey);

            this.Session.ConnectionInfo.CurrentHostKeyAlgorithm = algorithmName;

            if (this.CanTrustHostKey(key))
            {

                return key.VerifySignature(exchangeHash, this._signature);
            }
            return false;
        }

        /// <summary>
        /// Starts key exchange algorithm
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="message">Key exchange init message.</param>
        public override void Start(Session session, KeyExchangeInitMessage message)
        {
            base.Start(session, message);

            this._serverPayload = message.GetBytes().ToArray();
            this._clientPayload = this.Session.ClientInitMessage.GetBytes().ToArray();
        }

        /// <summary>
        /// Populates the client exchange value.
        /// </summary>
        protected void PopulateClientExchangeValue()
        {
            if (this._group.IsZero)
                throw new ArgumentNullException("_group");

            if (this._prime.IsZero)
                throw new ArgumentNullException("_prime");

            var bitLength = this._prime.BitLength;

            do
            {
                this._randomValue = BigInteger.Random(bitLength);

                this._clientExchangeValue = BigInteger.ModPow(this._group, this._randomValue, this._prime);

            } while (this._clientExchangeValue < 1 || this._clientExchangeValue > ((this._prime - 1)));
        }

        /// <summary>
        /// Handles the server DH reply message.
        /// </summary>
        /// <param name="hostKey">The host key.</param>
        /// <param name="serverExchangeValue">The server exchange value.</param>
        /// <param name="signature">The signature.</param>
        protected virtual void HandleServerDhReply(byte[] hostKey, BigInteger serverExchangeValue, byte[] signature)
        {
            this._serverExchangeValue = serverExchangeValue;
            this._hostKey = hostKey;
            this.SharedKey = BigInteger.ModPow(serverExchangeValue, this._randomValue, this._prime);
            this._signature = signature;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\KeyExchangeDiffieHellmanGroup14Sha1.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security
{
    /// <summary>
    /// Represents "diffie-hellman-group14-sha1" algorithm implementation.
    /// </summary>
    public class KeyExchangeDiffieHellmanGroup14Sha1 : KeyExchangeDiffieHellmanGroupSha1
    {
        private const string SecondOkleyGroup = "00FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF";

        /// <summary>
        /// Gets algorithm name.
        /// </summary>
        public override string Name
        {
            get { return "diffie-hellman-group14-sha1"; }
        }

        /// <summary>
        /// Gets the group prime.
        /// </summary>
        /// <value>
        /// The group prime.
        /// </value>
        public override BigInteger GroupPrime
        {
            get
            {
                BigInteger prime;
                BigInteger.TryParse(SecondOkleyGroup, NumberStyles.AllowHexSpecifier, CultureInfo.CurrentCulture, out prime);
                return prime;
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\KeyExchangeDiffieHellmanGroup1Sha1.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security
{
    /// <summary>
    /// Represents "diffie-hellman-group1-sha1" algorithm implementation.
    /// </summary>
    public class KeyExchangeDiffieHellmanGroup1Sha1 : KeyExchangeDiffieHellmanGroupSha1
    {
        private const string SecondOkleyGroup = @"00FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF";

        /// <summary>
        /// Gets algorithm name.
        /// </summary>
        public override string Name
        {
            get { return "diffie-hellman-group1-sha1"; }
        }

        /// <summary>
        /// Gets the group prime.
        /// </summary>
        /// <value>
        /// The group prime.
        /// </value>
        public override BigInteger GroupPrime
        {
            get
            {
                BigInteger prime;
                BigInteger.TryParse(SecondOkleyGroup, NumberStyles.AllowHexSpecifier, CultureInfo.CurrentCulture, out prime);
                return prime;
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\KeyExchangeDiffieHellmanGroupExchangeSha1.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Security
{
    /// <summary>
    /// Represents "diffie-hellman-group-exchange-sha1" algorithm implementation.
    /// </summary>
    public class KeyExchangeDiffieHellmanGroupExchangeSha1 : KeyExchangeDiffieHellmanGroupExchangeShaBase
    {
        /// <summary>
        /// Gets algorithm name.
        /// </summary>
        public override string Name
        {
            get { return "diffie-hellman-group-exchange-sha1"; }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\KeyExchangeDiffieHellmanGroupExchangeSha256.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security
{
    /// <summary>
    /// Represents "diffie-hellman-group-exchange-sha256" algorithm implementation.
    /// </summary>
    public class KeyExchangeDiffieHellmanGroupExchangeSha256 : KeyExchangeDiffieHellmanGroupExchangeShaBase
    {
        /// <summary>
        /// Gets algorithm name.
        /// </summary>
        public override string Name
        {
            get { return "diffie-hellman-group-exchange-sha256"; }
        }

        /// <summary>
        /// Hashes the specified data bytes.
        /// </summary>
        /// <param name="hashBytes">Data to hash.</param>
        /// <returns>
        /// Hashed bytes
        /// </returns>
        protected override byte[] Hash(byte[] hashBytes)
        {
            using (var md = new SHA256Hash())
            {
                return md.ComputeHash(hashBytes);
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\KeyExchangeDiffieHellmanGroupExchangeShaBase.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security
{
    public abstract class KeyExchangeDiffieHellmanGroupExchangeShaBase : KeyExchangeDiffieHellman
    {
        private const int MinimumGroupSize = 1024;
        private const int PreferredGroupSize = 1024;
        private const int MaximumProupSize = 8192;

        /// <summary>
        /// Calculates key exchange hash value.
        /// </summary>
        /// <returns>
        /// Key exchange hash.
        /// </returns>
        protected override byte[] CalculateHash()
        {
            var hashData = new GroupExchangeHashData
                {
                    ClientVersion = Session.ClientVersion,
                    ServerVersion = Session.ServerVersion,
                    ClientPayload = _clientPayload,
                    ServerPayload = _serverPayload,
                    HostKey = _hostKey,
                    MinimumGroupSize = MinimumGroupSize,
                    PreferredGroupSize = PreferredGroupSize,
                    MaximumGroupSize = MaximumProupSize,
                    Prime = _prime,
                    SubGroup = _group,
                    ClientExchangeValue = _clientExchangeValue,
                    ServerExchangeValue = _serverExchangeValue,
                    SharedKey = SharedKey,
                }.GetBytes();

            return this.Hash(hashData);
        }

        /// <summary>
        /// Starts key exchange algorithm
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="message">Key exchange init message.</param>
        public override void Start(Session session, KeyExchangeInitMessage message)
        {
            base.Start(session, message);

            Session.RegisterMessage("SSH_MSG_KEX_DH_GEX_GROUP");
            Session.RegisterMessage("SSH_MSG_KEX_DH_GEX_REPLY");

            Session.MessageReceived += Session_MessageReceived;

            //  1. send SSH_MSG_KEY_DH_GEX_REQUEST
            SendMessage(new KeyExchangeDhGroupExchangeRequest(MinimumGroupSize, PreferredGroupSize,
                MaximumProupSize));
        }

        /// <summary>
        /// Finishes key exchange algorithm.
        /// </summary>
        public override void Finish()
        {
            base.Finish();

            Session.MessageReceived -= Session_MessageReceived;
        }

        private void Session_MessageReceived(object sender, MessageEventArgs<MessageRenci> e)
        {
            var groupMessage = e.Message as KeyExchangeDhGroupExchangeGroup;
            if (groupMessage != null)
            {
                //  Unregister message once received
                Session.UnRegisterMessage("SSH_MSG_KEX_DH_GEX_GROUP");

                //  2. Receive SSH_MSG_KEX_DH_GEX_GROUP
                _prime = groupMessage.SafePrime;
                _group = groupMessage.SubGroup;

                PopulateClientExchangeValue();

                //  3. Send SSH_MSG_KEX_DH_GEX_INIT
                SendMessage(new KeyExchangeDhGroupExchangeInit(_clientExchangeValue));
            }
            else
            {
                var replyMessage = e.Message as KeyExchangeDhGroupExchangeReply;
                if (replyMessage != null)
                {
                    //  Unregister message once received
                    Session.UnRegisterMessage("SSH_MSG_KEX_DH_GEX_REPLY");

                    HandleServerDhReply(replyMessage.HostKey, replyMessage.F, replyMessage.Signature);

                    //  When SSH_MSG_KEX_DH_GEX_REPLY received key exchange is completed
                    Finish();
                }
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\KeyExchangeDiffieHellmanGroupSha1.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security
{
    /// <summary>
    /// Represents "diffie-hellman-group1-sha1" algorithm implementation.
    /// </summary>
    public abstract class KeyExchangeDiffieHellmanGroupSha1 : KeyExchangeDiffieHellman
    {
        /// <summary>
        /// Gets the group prime.
        /// </summary>
        /// <value>
        /// The group prime.
        /// </value>
        public abstract BigInteger GroupPrime { get; }

        /// <summary>
        /// Calculates key exchange hash value.
        /// </summary>
        /// <returns>
        /// Key exchange hash.
        /// </returns>
        protected override byte[] CalculateHash()
        {
            var hashData = new _ExchangeHashData
            {
                ClientVersion = this.Session.ClientVersion,
                ServerVersion = this.Session.ServerVersion,
                ClientPayload = this._clientPayload,
                ServerPayload = this._serverPayload,
                HostKey = this._hostKey,
                ClientExchangeValue = this._clientExchangeValue,
                ServerExchangeValue = this._serverExchangeValue,
                SharedKey = this.SharedKey,
            }.GetBytes();

            return this.Hash(hashData);
        }

        /// <summary>
        /// Starts key exchange algorithm
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="message">Key exchange init message.</param>
        public override void Start(Session session, KeyExchangeInitMessage message)
        {
            base.Start(session, message);

            this.Session.RegisterMessage("SSH_MSG_KEXDH_REPLY");

            this.Session.MessageReceived += Session_MessageReceived;

            this._prime = this.GroupPrime;

            this._group = new BigInteger(new byte[] { 2 });

            this.PopulateClientExchangeValue();

            this.SendMessage(new KeyExchangeDhInitMessage(this._clientExchangeValue));

        }

        /// <summary>
        /// Finishes key exchange algorithm.
        /// </summary>
        public override void Finish()
        {
            base.Finish();

            this.Session.MessageReceived -= Session_MessageReceived;
        }

        private void Session_MessageReceived(object sender, MessageEventArgs<MessageRenci> e)
        {
            var message = e.Message as KeyExchangeDhReplyMessage;
            if (message != null)
            {
                //  Unregister message once received
                this.Session.UnRegisterMessage("SSH_MSG_KEXDH_REPLY");

                this.HandleServerDhReply(message.HostKey, message.F, message.Signature);

                //  When SSH_MSG_KEXDH_REPLY received key exchange is completed
                this.Finish();
            }
        }

        private class _ExchangeHashData : SshData
        {
            public string ServerVersion { get; set; }

            public string ClientVersion { get; set; }

            public byte[] ClientPayload { get; set; }

            public byte[] ServerPayload { get; set; }

            public byte[] HostKey { get; set; }

            public BigInteger ClientExchangeValue { get; set; }

            public BigInteger ServerExchangeValue { get; set; }

            public BigInteger SharedKey { get; set; }

            protected override void LoadData()
            {
                throw new System.NotImplementedException();
            }

            protected override void SaveData()
            {
                this.Write(this.ClientVersion);
                this.Write(this.ServerVersion);
                this.WriteBinaryString(this.ClientPayload);
                this.WriteBinaryString(this.ServerPayload);
                this.WriteBinaryString(this.HostKey);
                this.Write(this.ClientExchangeValue);
                this.Write(this.ServerExchangeValue);
                this.Write(this.SharedKey);
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\KeyExchangeEllipticCurveDiffieHellman.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security
{
    /// <summary>
    /// Represents base class for Diffie Hellman key exchange algorithm
    /// </summary>
    public class KeyExchangeEllipticCurveDiffieHellman : KeyExchange
    {
        /// <summary>
        /// Specifies client payload
        /// </summary>
        protected byte[] _clientPayload;

        /// <summary>
        /// Specifies server payload
        /// </summary>
        protected byte[] _serverPayload;

        /// <summary>
        /// Specifies client exchange number.
        /// </summary>
        protected BigInteger _clientExchangeValue;

        /// <summary>
        /// Specifies server exchange number.
        /// </summary>
        protected BigInteger _serverExchangeValue;

        /// <summary>
        /// Specifies random generated number.
        /// </summary>
        protected BigInteger _randomValue;

        /// <summary>
        /// Specifies host key data.
        /// </summary>
        protected byte[] _hostKey;

        /// <summary>
        /// Specifies signature data.
        /// </summary>
        protected byte[] _signature;

        ////  256
        //p = FFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFF
        //a = FFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFC
        //b = 5AC635D8 AA3A93E7 B3EBBD55 769886BC 651D06B0 CC53B0F6 3BCE3C3E 27D2604B
        //S = C49D3608 86E70493 6A6678E1 139D26B7 819F7E90
        //The base point G in compressed form is:
        //G = 03 6B17D1F2 E12C4247 F8BCE6E5 63A440F2 77037D81 2DEB33A0 F4A13945 D898C296
        //and in uncompressed form is:
        //G = 04 6B17D1F2 E12C4247 F8BCE6E5 63A440F2 77037D81 2DEB33A0 F4A13945 D898C296 4FE342E2 FE1A7F9B 8EE7EB4A 7C0F9E16 2BCE3357 6B315ECE CBB64068 37BF51F5
        //n = FFFFFFFF 00000000 FFFFFFFF FFFFFFFF BCE6FAAD A7179E84 F3B9CAC2 FC632551
        //h = 01

        ////  384
        //p = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFFFF 00000000 00000000 FFFFFFFF
        //a = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFFFF 00000000 00000000 FFFFFFFC
        //b = B3312FA7 E23EE7E4 988E056B E3F82D19 181D9C6E FE814112 0314088F 5013875A C656398D 8A2ED19D 2A85C8ED D3EC2AEF
        //S = A335926A A319A27A 1D00896A 6773A482 7ACDAC73
        //The base point G in compressed form is:
        //G = 03 AA87CA22 BE8B0537 8EB1C71E F320AD74 6E1D3B62 8BA79B98 59F741E0 82542A38 5502F25D BF55296C 3A545E38 72760AB7
        //and in uncompressed form is:
        //G = 04 AA87CA22 BE8B0537 8EB1C71E F320AD74 6E1D3B62 8BA79B98 59F741E0 82542A38 5502F25D BF55296C 3A545E38 72760AB7 3617DE4A 96262C6F 5D9E98BF 9292DC29 F8F41DBD 289A147C E9DA3113 B5F0B8C0 0A60B1CE 1D7E819D 7A431D7C 90EA0E5F
        //n = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF C7634D81 F4372DDF 581A0DB2 48B0A77A ECEC196A CCC52973
        //h = 01

        public override string Name
        {
            get { return "ecdh-sha2-nistp256"; }
        }

        /// <summary>
        /// Starts key exchange algorithm
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="message">Key exchange init message.</param>
        public override void Start(Session session, KeyExchangeInitMessage message)
        {
            base.Start(session, message);

            this._serverPayload = message.GetBytes().ToArray();
            this._clientPayload = this.Session.ClientInitMessage.GetBytes().ToArray();

            this.Session.RegisterMessage("SSH_MSG_KEXECDH_REPLY");

            this.Session.MessageReceived += Session_MessageReceived;

            //3.2.1 Elliptic Curve Key Pair Generation Primitive
            //Elliptic curve key pairs should be generated as follows:
            //Input: Valid elliptic curve domain parameters T = (p, a, b, G, n, h) or (m, f(x), a, b,G, n, h).
            //Output: An elliptic curve key pair (d,Q) associated with T.
            //Actions: Generate an elliptic curve key pair as follows:
            //1. Randomly or pseudorandomly select an integer d in the interval [1, n − 1].
            //2. Compute Q = dG.
            //3. Output (d,Q).
            
            BigInteger p;
            BigInteger.TryParse("00FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF", NumberStyles.AllowHexSpecifier, CultureInfo.CurrentCulture, out p);



            BigInteger n;
            BigInteger.TryParse("00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973", NumberStyles.AllowHexSpecifier, CultureInfo.CurrentCulture, out n);
            BigInteger G;
            BigInteger.TryParse("00036B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296", NumberStyles.AllowHexSpecifier, CultureInfo.CurrentCulture, out G);

            BigInteger d;

            do
            {
                d = BigInteger.Random(n.BitLength);
            } while (d < 1 || d > n);

            var Q = d * G;


            this.SendMessage(new KeyExchangeEcdhInitMessage(d, Q));

        }

        private void Session_MessageReceived(object sender, MessageEventArgs<MessageRenci> e)
        {
            var message = e.Message as KeyExchangeEcdhReplyMessage;
            if (message != null)
            {
                //  Unregister message once received
                this.Session.UnRegisterMessage("SSH_MSG_KEXECDH_REPLY");

                this.HandleServerEcdhReply();

                //  When SSH_MSG_KEXDH_REPLY received key exchange is completed
                this.Finish();
            }
        }

        /// <summary>
        /// Validates the exchange hash.
        /// </summary>
        /// <returns>
        /// true if exchange hash is valid; otherwise false.
        /// </returns>
        protected override bool ValidateExchangeHash()
        {
            //var exchangeHash = this.CalculateHash();

            //var length = (uint)(this._hostKey[0] << 24 | this._hostKey[1] << 16 | this._hostKey[2] << 8 | this._hostKey[3]);

            //var algorithmName = Encoding.UTF8.GetString(this._hostKey, 4, (int)length);

            //var key = this.Session.ConnectionInfo.HostKeyAlgorithms[algorithmName](this._hostKey);

            //this.Session.ConnectionInfo.CurrentHostKeyAlgorithm = algorithmName;

            //if (this.CanTrustHostKey(key))
            //{

            //    return key.VerifySignature(exchangeHash, this._signature);
            //}
            //else
            //{
            //    return false;
            //}

            return false;
        }

        /// <summary>
        /// Populates the client exchange value.
        /// </summary>
        //protected void PopulateClientExchangeValue()
        //{
        //    if (this._group.IsZero)
        //        throw new ArgumentNullException("_group");

        //    if (this._prime.IsZero)
        //        throw new ArgumentNullException("_prime");

        //    var bitLength = this._prime.BitLength;

        //    do
        //    {
        //        this._randomValue = BigInteger.Random(bitLength);

        //        this._clientExchangeValue = BigInteger.ModPow(this._group, this._randomValue, this._prime);

        //    } while (this._clientExchangeValue < 1 || this._clientExchangeValue > ((this._prime - 1)));
        //}

        protected virtual void HandleServerEcdhReply()
        {
            //this._serverExchangeValue = serverExchangeValue;
            //this._hostKey = hostKey;
            //this.SharedKey = BigInteger.ModPow(serverExchangeValue, this._randomValue, this._prime);
            //this._signature = signature;
        }

        protected override byte[] CalculateHash()
        {
            var hashData = new _ExchangeHashData
            {
                ClientVersion = this.Session.ClientVersion,
                ServerVersion = this.Session.ServerVersion,
                ClientPayload = this._clientPayload,
                ServerPayload = this._serverPayload,
                HostKey = this._hostKey,
                SharedKey = this.SharedKey,
            }.GetBytes();

            //string   V_C, client's identification string (CR and LF excluded)
            //string   V_S, server's identification string (CR and LF excluded)
            //string   I_C, payload of the client's SSH_MSG_KEXINIT
            //string   I_S, payload of the server's SSH_MSG_KEXINIT
            //string   K_S, server's public host key
            //string   Q_C, client's ephemeral public key octet string
            //string   Q_S, server's ephemeral public key octet string
            //mpint    K,   shared secret
            return this.Hash(hashData);
        }

        private class _ExchangeHashData : SshData
        {
            public string ServerVersion { get; set; }

            public string ClientVersion { get; set; }

            public byte[] ClientPayload { get; set; }

            public byte[] ServerPayload { get; set; }

            public byte[] HostKey { get; set; }

            public UInt32 MinimumGroupSize { get; set; }

            public UInt32 PreferredGroupSize { get; set; }

            public UInt32 MaximumGroupSize { get; set; }

            public BigInteger Prime { get; set; }

            public BigInteger SubGroup { get; set; }

            public BigInteger ClientExchangeValue { get; set; }

            public BigInteger ServerExchangeValue { get; set; }

            public BigInteger SharedKey { get; set; }

            protected override void LoadData()
            {
                throw new NotImplementedException();
            }

            protected override void SaveData()
            {
                this.Write(this.ClientVersion);
                this.Write(this.ServerVersion);
                this.WriteBinaryString(this.ClientPayload);
                this.WriteBinaryString(this.ServerPayload);
                this.WriteBinaryString(this.HostKey);
                this.Write(this.MinimumGroupSize);
                this.Write(this.PreferredGroupSize);
                this.Write(this.MaximumGroupSize);
                this.Write(this.Prime);
                this.Write(this.SubGroup);
                this.Write(this.ClientExchangeValue);
                this.Write(this.ServerExchangeValue);
                this.Write(this.SharedKey);
            }
        }

    }
}

#endif
// file ...\X\Renci.SshNet\Security\KeyHostAlgorithm.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security
{
    /// <summary>
    /// Implements key support for host algorithm.
    /// </summary>
    public class KeyHostAlgorithm : HostAlgorithm
    {
        /// <summary>
        /// Gets the key.
        /// </summary>
        public Key Key { get; private set; }

        /// <summary>
        /// Gets the public key data.
        /// </summary>
        public override byte[] Data
        {
            get
            {
                return new SshKeyData(this.Name, this.Key.Public).GetBytes();
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="KeyHostAlgorithm"/> class.
        /// </summary>
        /// <param name="name">Host key name.</param>
        /// <param name="key">Host key.</param>
        public KeyHostAlgorithm(string name, Key key)
            : base(name)
        {
            this.Key = key;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="HostAlgorithm"/> class.
        /// </summary>
        /// <param name="name">Host key name.</param>
        /// <param name="key">Host key.</param>
        /// <param name="data">Host key encoded data.</param>
        public KeyHostAlgorithm(string name, Key key, byte[] data)
            : base(name)
        {
            this.Key = key;

            var sshKey = new SshKeyData();
            sshKey.Load(data);
            this.Key.Public = sshKey.Keys;
        }

        /// <summary>
        /// Signs the specified data.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <returns>
        /// Signed data.
        /// </returns>
        public override byte[] Sign(byte[] data)
        {
            return new SignatureKeyData(this.Name, this.Key.Sign(data)).GetBytes();
        }

        /// <summary>
        /// Verifies the signature.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <param name="signature">The signature.</param>
        /// <returns>
        ///   <c>True</c> is signature was successfully verifies; otherwise <c>false</c>.
        /// </returns>
        public override bool VerifySignature(byte[] data, byte[] signature)
        {
            var signatureData = new SignatureKeyData();
            signatureData.Load(signature);

            return this.Key.VerifySignature(data, signatureData.Signature);
        }

        private class SshKeyData : SshData
        {
            public BigInteger[] Keys { get; private set; }

            private string Name { get; set; }

            public SshKeyData()
            {
            }

            public SshKeyData(string name, params BigInteger[] keys)
            {
                this.Name = name;
                this.Keys = keys;
            }

            protected override void LoadData()
            {
                this.Name = this.ReadString();
                var keys = new List<BigInteger>();
                while (!this.IsEndOfData)
                {
                    keys.Add(this.ReadBigInt());
                }
                this.Keys = keys.ToArray();
            }

            protected override void SaveData()
            {
                this.Write(this.Name);
                foreach (var key in this.Keys)
                {
                    this.Write(key);
                }
            }
        }

        private class SignatureKeyData : SshData
        {
            /// <summary>
            /// Gets or sets the name of the algorithm.
            /// </summary>
            /// <value>
            /// The name of the algorithm.
            /// </value>
            private string AlgorithmName { get; set; }

            /// <summary>
            /// Gets or sets the signature.
            /// </summary>
            /// <value>
            /// The signature.
            /// </value>
            public byte[] Signature { get; private set; }

            public SignatureKeyData()
            {
            }

            public SignatureKeyData(string name, byte[] signature)
            {
                this.AlgorithmName = name;
                this.Signature = signature;
            }

            /// <summary>
            /// Called when type specific data need to be loaded.
            /// </summary>
            protected override void LoadData()
            {
                this.AlgorithmName = this.ReadString();
                this.Signature = this.ReadBinaryString();
            }

            /// <summary>
            /// Called when type specific data need to be saved.
            /// </summary>
            protected override void SaveData()
            {
                this.Write(this.AlgorithmName);
                this.WriteBinaryString(this.Signature);
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\AsymmetricCipher.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Security.Cryptography
{
    /// <summary>
    /// Base class for asymmetric cipher implementations.
    /// </summary>
    public abstract class AsymmetricCipher  : Cipher
    {
        public override byte MinimumSize
        {
            get { return 0; }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\BlockCipher.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography
{
    /// <summary>
    /// Base class for block cipher implementations.
    /// </summary>
    public abstract class BlockCipher : SymmetricCipher
    {
        private readonly CipherModeRenci _mode;

        private readonly CipherPadding _padding;

        /// <summary>
        /// Gets the size of the block in bytes.
        /// </summary>
        /// <value>
        /// The size of the block in bytes.
        /// </value>
        private readonly byte _blockSize;

        /// <summary>
        /// Gets the minimum data size.
        /// </summary>
        /// <value>
        /// The minimum data size.
        /// </value>
        public override byte MinimumSize
        {
            get { return BlockSize; }
        }

        /// <summary>
        /// Gets the size of the block.
        /// </summary>
        /// <value>
        /// The size of the block.
        /// </value>
        public byte BlockSize
        {
            get
            {
                return _blockSize;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BlockCipher"/> class.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <param name="blockSize">Size of the block.</param>
        /// <param name="mode">Cipher mode.</param>
        /// <param name="padding">Cipher padding.</param>
        /// <exception cref="ArgumentNullException"><paramref name="key"/> is null.</exception>
        protected BlockCipher(byte[] key, byte blockSize, CipherModeRenci mode, CipherPadding padding)
            : base(key)
        {
            _blockSize = blockSize;
            _mode = mode;
            _padding = padding;

            if (_mode != null)
                _mode.Init(this);
        }

        /// <summary>
        /// Encrypts the specified data.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <returns>Encrypted data</returns>
        public override byte[] Encrypt(byte[] data)
        {
            if (data.Length % _blockSize > 0)
            {
                if (_padding == null)
                {
                    throw new ArgumentException("data");
                }
                data = _padding.Pad(_blockSize, data);
            }

            var output = new byte[data.Length];
            var writtenBytes = 0;

            for (var i = 0; i < data.Length / _blockSize; i++)
            {
                if (_mode == null)
                {
                    writtenBytes += EncryptBlock(data, i * _blockSize, _blockSize, output, i * _blockSize);
                }
                else
                {
                    writtenBytes += _mode.EncryptBlock(data, i * _blockSize, _blockSize, output, i * _blockSize);
                }
            }

            if (writtenBytes < data.Length)
            {
                throw new InvalidOperationException("Encryption error.");
            }

            return output;
        }

        /// <summary>
        /// Decrypts the specified data.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <returns>Decrypted data</returns>
        public override byte[] Decrypt(byte[] data)
        {
            if (data.Length % _blockSize > 0)
            {
                if (_padding == null)
                {
                    throw new ArgumentException("data");
                }
                data = _padding.Pad(_blockSize, data);
            }

            var output = new byte[data.Length];

            var writtenBytes = 0;
            for (var i = 0; i < data.Length / _blockSize; i++)
            {
                if (_mode == null)
                {
                    writtenBytes += DecryptBlock(data, i * _blockSize, _blockSize, output, i * _blockSize);
                }
                else
                {
                    writtenBytes += _mode.DecryptBlock(data, i * _blockSize, _blockSize, output, i * _blockSize);
                }
            }

            if (writtenBytes < data.Length)
            {
                throw new InvalidOperationException("Encryption error.");
            }

            return output;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Cipher.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography
{
    /// <summary>
    /// Base class for cipher implementation.
    /// </summary>
    public abstract class Cipher
    {
        /// <summary>
        /// Gets the minimum data size.
        /// </summary>
        /// <value>
        /// The minimum data size.
        /// </value>
        public abstract byte MinimumSize { get; }

        /// <summary>
        /// Encrypts the specified input.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <returns>Encrypted data.</returns>
        public abstract byte[] Encrypt(byte[] input);

        /// <summary>
        /// Decrypts the specified input.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <returns>Decrypted data.</returns>
        public abstract byte[] Decrypt(byte[] input);

        #region Packing functions

        /// <summary>
        /// Populates buffer with big endian number representation.
        /// </summary>
        /// <param name="number">The number to convert.</param>
        /// <param name="buffer">The buffer.</param>
        protected static void UInt32ToBigEndian(uint number, byte[] buffer)
        {
            buffer[0] = (byte)(number >> 24);
            buffer[1] = (byte)(number >> 16);
            buffer[2] = (byte)(number >> 8);
            buffer[3] = (byte)(number);
        }

        /// <summary>
        /// Populates buffer with big endian number representation.
        /// </summary>
        /// <param name="number">The number to convert.</param>
        /// <param name="buffer">The buffer.</param>
        /// <param name="offset">The buffer offset.</param>
        protected static void UInt32ToBigEndian(uint number, byte[] buffer, int offset)
        {
            buffer[offset] = (byte)(number >> 24);
            buffer[offset + 1] = (byte)(number >> 16);
            buffer[offset + 2] = (byte)(number >> 8);
            buffer[offset + 3] = (byte)(number);
        }

        /// <summary>
        /// Converts big endian bytes into number.
        /// </summary>
        /// <param name="buffer">The buffer.</param>
        /// <returns>Converted <see cref="Int32" />.</returns>
        protected static uint BigEndianToUInt32(byte[] buffer)
        {
            uint n = (uint)buffer[0] << 24;
            n |= (uint)buffer[1] << 16;
            n |= (uint)buffer[2] << 8;
            n |= (uint)buffer[3];
            return n;
        }

        /// <summary>
        /// Converts big endian bytes into number.
        /// </summary>
        /// <param name="buffer">The buffer.</param>
        /// <param name="offset">The buffer offset.</param>
        /// <returns>Converted <see cref="UInt32" />.</returns>
        protected static uint BigEndianToUInt32(byte[] buffer, int offset)
        {
            uint n = (uint)buffer[offset] << 24;
            n |= (uint)buffer[offset + 1] << 16;
            n |= (uint)buffer[offset + 2] << 8;
            n |= (uint)buffer[offset + 3];
            return n;
        }

        /// <summary>
        /// Converts big endian bytes into number.
        /// </summary>
        /// <param name="buffer">The buffer.</param>
        /// <returns>Converted <see cref="UInt64" />.</returns>
        protected static ulong BigEndianToUInt64(byte[] buffer)
        {
            uint hi = BigEndianToUInt32(buffer);
            uint lo = BigEndianToUInt32(buffer, 4);
            return ((ulong)hi << 32) | (ulong)lo;
        }

        /// <summary>
        /// Converts big endian bytes into number.
        /// </summary>
        /// <param name="buffer">The buffer.</param>
        /// <param name="offset">The buffer offset.</param>
        /// <returns>Converted <see cref="UInt64" />.</returns>
        protected static ulong BigEndianToUInt64(byte[] buffer, int offset)
        {
            uint hi = BigEndianToUInt32(buffer, offset);
            uint lo = BigEndianToUInt32(buffer, offset + 4);
            return ((ulong)hi << 32) | (ulong)lo;
        }

        /// <summary>
        /// Populates buffer with big endian number representation.
        /// </summary>
        /// <param name="number">The number to convert.</param>
        /// <param name="buffer">The buffer.</param>
        protected static void UInt64ToBigEndian(ulong number, byte[] buffer)
        {
            UInt32ToBigEndian((uint)(number >> 32), buffer);
            UInt32ToBigEndian((uint)(number), buffer, 4);
        }

        /// <summary>
        /// Populates buffer with big endian number representation.
        /// </summary>
        /// <param name="number">The number to convert.</param>
        /// <param name="buffer">The buffer.</param>
        /// <param name="offset">The buffer offset.</param>
        protected static void UInt64ToBigEndian(ulong number, byte[] buffer, int offset)
        {
            UInt32ToBigEndian((uint)(number >> 32), buffer, offset);
            UInt32ToBigEndian((uint)(number), buffer, offset + 4);
        }

        /// <summary>
        /// Populates buffer with little endian number representation.
        /// </summary>
        /// <param name="number">The number to convert.</param>
        /// <param name="buffer">The buffer.</param>
        protected static void UInt32ToLittleEndian(uint number, byte[] buffer)
        {
            buffer[0] = (byte)(number);
            buffer[1] = (byte)(number >> 8);
            buffer[2] = (byte)(number >> 16);
            buffer[3] = (byte)(number >> 24);
        }

        /// <summary>
        /// Populates buffer with little endian number representation.
        /// </summary>
        /// <param name="number">The number to convert.</param>
        /// <param name="buffer">The buffer.</param>
        /// <param name="offset">The buffer offset.</param>
        protected static void UInt32ToLittleEndian(uint number, byte[] buffer, int offset)
        {
            buffer[offset] = (byte)(number);
            buffer[offset + 1] = (byte)(number >> 8);
            buffer[offset + 2] = (byte)(number >> 16);
            buffer[offset + 3] = (byte)(number >> 24);
        }

        /// <summary>
        /// Converts little endian bytes into number.
        /// </summary>
        /// <param name="buffer">The buffer.</param>
        /// <returns>Converted <see cref="UInt32" />.</returns>
        protected static uint LittleEndianToUInt32(byte[] buffer)
        {
            uint n = (uint)buffer[0];
            n |= (uint)buffer[1] << 8;
            n |= (uint)buffer[2] << 16;
            n |= (uint)buffer[3] << 24;
            return n;
        }

        /// <summary>
        /// Converts little endian bytes into number.
        /// </summary>
        /// <param name="buffer">The buffer.</param>
        /// <param name="offset">The buffer offset.</param>
        /// <returns>Converted <see cref="Int32" />.</returns>
        protected static uint LittleEndianToUInt32(byte[] buffer, int offset)
        {
            uint n = (uint)buffer[offset];
            n |= (uint)buffer[offset + 1] << 8;
            n |= (uint)buffer[offset + 2] << 16;
            n |= (uint)buffer[offset + 3] << 24;
            return n;
        }

        /// <summary>
        /// Converts little endian bytes into number.
        /// </summary>
        /// <param name="buffer">The buffer.</param>
        /// <returns>Converted <see cref="UInt64" />.</returns>
        protected static ulong LittleEndianToUInt64(byte[] buffer)
        {
            uint lo = LittleEndianToUInt32(buffer);
            uint hi = LittleEndianToUInt32(buffer, 4);
            return ((ulong)hi << 32) | (ulong)lo;
        }

        /// <summary>
        /// Converts little endian bytes into number.
        /// </summary>
        /// <param name="buffer">The buffer.</param>
        /// <param name="offset">The buffer offset.</param>
        /// <returns>Converted <see cref="UInt64" />.</returns>
        protected static ulong LittleEndianToUInt64(byte[] buffer, int offset)
        {
            uint lo = LittleEndianToUInt32(buffer, offset);
            uint hi = LittleEndianToUInt32(buffer, offset + 4);
            return ((ulong)hi << 32) | (ulong)lo;
        }

        /// <summary>
        /// Populates buffer with little endian number representation.
        /// </summary>
        /// <param name="number">The number to convert.</param>
        /// <param name="buffer">The buffer.</param>
        protected static void UInt64ToLittleEndian(ulong number, byte[] buffer)
        {
            UInt32ToLittleEndian((uint)(number), buffer);
            UInt32ToLittleEndian((uint)(number >> 32), buffer, 4);
        }

        /// <summary>
        /// Populates buffer with little endian number representation.
        /// </summary>
        /// <param name="number">The number to convert.</param>
        /// <param name="buffer">The buffer.</param>
        /// <param name="offset">The buffer offset.</param>
        protected static void UInt64ToLittleEndian(ulong number, byte[] buffer, int offset)
        {
            UInt32ToLittleEndian((uint)(number), buffer, offset);
            UInt32ToLittleEndian((uint)(number >> 32), buffer, offset + 4);
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\CipherDigitalSignature.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography
{
    /// <summary>
    /// Implements digital signature where where asymmetric cipher is used,
    /// </summary>
    public abstract class CipherDigitalSignature : DigitalSignature
    {
        private readonly AsymmetricCipher _cipher;

        private readonly ObjectIdentifier _oid;

        /// <summary>
        /// Initializes a new instance of the <see cref="CipherDigitalSignature"/> class.
        /// </summary>
        /// <param name="oid">The object identifier.</param>
        /// <param name="cipher">The cipher.</param>
        public CipherDigitalSignature(ObjectIdentifier oid, AsymmetricCipher cipher)
        {
            if (cipher == null)
                throw new ArgumentNullException("cipher");

            this._cipher = cipher;
            this._oid = oid;
        }

        /// <summary>
        /// Verifies the signature.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <param name="signature">The signature.</param>
        /// <returns>
        ///   <c>True</c> if signature was successfully verified; otherwise <c>false</c>.
        /// </returns>
        public override bool Verify(byte[] input, byte[] signature)
        {
            var encryptedSignature = this._cipher.Decrypt(signature);
            var hashData = this.Hash(input);
            var expected = DerEncode(hashData);
            return expected.SequenceEqual(encryptedSignature);
        }

        /// <summary>
        /// Creates the signature.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <returns>
        /// Signed input data.
        /// </returns>
        public override byte[] Sign(byte[] input)
        {
            //  Calculate hash value
            var hashData = this.Hash(input);

            //  Calculate DER string
            var derEncodedHash = DerEncode(hashData);

            return this._cipher.Encrypt(derEncodedHash).TrimLeadingZero().ToArray();
        }

        /// <summary>
        /// Hashes the specified input.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <returns>Hashed data.</returns>
        protected abstract byte[] Hash(byte[] input);

        /// <summary>
        /// Encodes hash using DER.
        /// </summary>
        /// <param name="hashData">The hash data.</param>
        /// <returns>DER Encoded byte array</returns>
        protected byte[] DerEncode(byte[] hashData)
        {
            var data = new DerData();

            var alg = new DerData();
            alg.Write(this._oid);
            alg.WriteNull();

            data.Write(alg);
            data.Write(hashData);

            return data.Encode();
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\DigitalSignature.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Security.Cryptography
{
    /// <summary>
    /// Base class for signature implementations
    /// </summary>
    public abstract class DigitalSignature
    {
        /// <summary>
        /// Verifies the signature.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <param name="signature">The signature.</param>
        /// <returns><c>True</c> if signature was successfully verified; otherwise <c>false</c>.</returns>
        public abstract bool Verify(byte[] input, byte[] signature);

        /// <summary>
        /// Creates the signature.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <returns>Signed input data.</returns>
        public abstract byte[] Sign(byte[] input);
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\DsaDigitalSignature.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography
{
    /// <summary>
    /// Implements DSA digital signature algorithm.
    /// </summary>
    public class DsaDigitalSignature : DigitalSignature, IDisposable
    {
        private HashAlgorithm _hash;

        private readonly DsaKey _key;

        /// <summary>
        /// Initializes a new instance of the <see cref="DsaDigitalSignature" /> class.
        /// </summary>
        /// <param name="key">The DSA key.</param>
        /// <exception cref="System.ArgumentNullException">key</exception>
        public DsaDigitalSignature(DsaKey key)
        {
            if (key == null)
                throw new ArgumentNullException("key");

            this._key = key;

            this._hash = new SHA1Hash();
        }

        /// <summary>
        /// Verifies the signature.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <param name="signature">The signature.</param>
        /// <returns>
        ///   <c>True</c> if signature was successfully verified; otherwise <c>false</c>.
        /// </returns>
        /// <exception cref="System.InvalidOperationException">Invalid signature.</exception>
        public override bool Verify(byte[] input, byte[] signature)
        {
            var hashInput = this._hash.ComputeHash(input);

            BigInteger hm = new BigInteger(hashInput.Reverse().Concat(new byte[] { 0 }).ToArray());

            if (signature.Length != 40)
                throw new InvalidOperationException("Invalid signature.");

            //  Extract r and s numbers from the signature
            var rBytes = new byte[21];
            var sBytes = new byte[21];

            for (int i = 0, j = 20; i < 20; i++, j--)
            {
                rBytes[i] = signature[j - 1];
                sBytes[i] = signature[j + 20 - 1];
            }

            BigInteger r = new BigInteger(rBytes);
            BigInteger s = new BigInteger(sBytes);

            //  Reject the signature if 0 < r < q or 0 < s < q is not satisfied.
            if (r <= 0 || r >= this._key.Q)
                return false;

            if (s <= 0 || s >= this._key.Q)
                return false;

            //  Calculate w = s−1 mod q
            BigInteger w = BigInteger.ModInverse(s, this._key.Q);

            //  Calculate u1 = H(m)·w mod q
            BigInteger u1 = hm * w % this._key.Q;

            //  Calculate u2 = r * w mod q
            BigInteger u2 = r * w % this._key.Q;

            u1 = BigInteger.ModPow(this._key.G, u1, this._key.P);
            u2 = BigInteger.ModPow(this._key.Y, u2, this._key.P);

            //  Calculate v = ((g pow u1 * y pow u2) mod p) mod q
            BigInteger v = ((u1 * u2) % this._key.P) % this._key.Q;

            //  The signature is valid if v = r
            return v == r;
        }

        /// <summary>
        /// Creates the signature.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <returns>
        /// Signed input data.
        /// </returns>
        /// <exception cref="SshException">Invalid DSA key.</exception>
        public override byte[] Sign(byte[] input)
        {
            var hashInput = this._hash.ComputeHash(input);

            BigInteger m = new BigInteger(hashInput.Reverse().Concat(new byte[] { 0 }).ToArray());

            BigInteger s;
            BigInteger r;

            do
            {
                BigInteger k = BigInteger.Zero;

                do
                {
                    //  Generate a random per-message value k where 0 < k < q
                    var bitLength = this._key.Q.BitLength;

                    if (this._key.Q < BigInteger.Zero)
                        throw new SshException("Invalid DSA key.");

                    while (k <= 0 || k >= this._key.Q)
                    {
                        k = BigInteger.Random(bitLength);
                    }

                    //  Calculate r = ((g pow k) mod p) mod q
                    r = BigInteger.ModPow(this._key.G, k, this._key.P) % this._key.Q;

                    //      In the unlikely case that r = 0, start again with a different random k
                } while (r.IsZero);


                //  Calculate s = ((k pow −1)(H(m) + x*r)) mod q
                k = (BigInteger.ModInverse(k, this._key.Q) * (m + this._key.X * r));

                s = k % this._key.Q;

                //  In the unlikely case that s = 0, start again with a different random k
            } while (s.IsZero);

            //  The signature is (r, s)
            var signature = new byte[40];

            // issue #1918: pad part with zero's on the left if length is less than 20
            var rBytes = r.ToByteArray().Reverse().TrimLeadingZero().ToArray();
            Array.Copy(rBytes, 0, signature, 20 - rBytes.Length, rBytes.Length);

            // issue #1918: pad part with zero's on the left if length is less than 20
            var sBytes = s.ToByteArray().Reverse().TrimLeadingZero().ToArray();
            Array.Copy(sBytes, 0, signature, 40 - sBytes.Length, sBytes.Length);

            return signature;
        }

        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged ResourceMessages.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!this._isDisposed)
            {
                // If disposing equals true, dispose all managed
                // and unmanaged ResourceMessages.
                if (disposing)
                {
                    // Dispose managed ResourceMessages.
                    if (this._hash != null)
                    {
                        this._hash.Clear();
                        this._hash = null;
                    }
                }

                // Note disposing has been done.
                this._isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="SshCommand"/> is reclaimed by garbage collection.
        /// </summary>
        ~DsaDigitalSignature()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\DsaKey.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security
{
    /// <summary>
    /// Contains DSA private and public key
    /// </summary>
    public class DsaKey : Key, IDisposable
    {
        /// <summary>
        /// Gets the P.
        /// </summary>
        public BigInteger P
        {
            get
            {
                return this._privateKey[0];
            }
        }

        /// <summary>
        /// Gets the Q.
        /// </summary>
        public BigInteger Q
        {
            get
            {
                return this._privateKey[1];
            }
        }

        /// <summary>
        /// Gets the G.
        /// </summary>
        public BigInteger G
        {
            get
            {
                return this._privateKey[2];
            }
        }

        /// <summary>
        /// Gets public key Y.
        /// </summary>
        public BigInteger Y
        {
            get
            {
                return this._privateKey[3];
            }
        }

        /// <summary>
        /// Gets private key X.
        /// </summary>
        public BigInteger X
        {
            get
            {
                return this._privateKey[4];
            }
        }

        /// <summary>
        /// Gets the length of the key.
        /// </summary>
        /// <value>
        /// The length of the key.
        /// </value>
        public override int KeyLength
        {
            get
            {
                return this.P.BitLength;
            }
        }

        private DsaDigitalSignature _digitalSignature;
        /// <summary>
        /// Gets the digital signature.
        /// </summary>
        protected override DigitalSignature DigitalSignature
        {
            get
            {
                if (this._digitalSignature == null)
                {
                    this._digitalSignature = new DsaDigitalSignature(this);
                }
                return this._digitalSignature;
            }
        }

        /// <summary>
        /// Gets or sets the public.
        /// </summary>
        /// <value>
        /// The public.
        /// </value>
        public override BigInteger[] Public
        {
            get
            {
                return new BigInteger[] { this.P, this.Q, this.G, this.Y };
            }
            set
            {
                if (value.Length != 4)
                    throw new InvalidOperationException("Invalid public key.");

                this._privateKey = value;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DsaKey"/> class.
        /// </summary>
        public DsaKey()
        {
            this._privateKey = new BigInteger[5];
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DsaKey"/> class.
        /// </summary>
        /// <param name="data">DER encoded private key data.</param>
        public DsaKey(byte[] data)
            : base(data)
        {
            if (this._privateKey.Length != 5)
                throw new InvalidOperationException("Invalid private key.");
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DsaKey" /> class.
        /// </summary>
        /// <param name="p">The p.</param>
        /// <param name="q">The q.</param>
        /// <param name="g">The g.</param>
        /// <param name="y">The y.</param>
        /// <param name="x">The x.</param>
        public DsaKey(BigInteger p, BigInteger q, BigInteger g, BigInteger y, BigInteger x)
        {
            this._privateKey = new BigInteger[5];
            this._privateKey[0] = p;
            this._privateKey[1] = q;
            this._privateKey[2] = g;
            this._privateKey[3] = y;
            this._privateKey[4] = x;
        }

        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged ResourceMessages.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!this._isDisposed)
            {
                // If disposing equals true, dispose all managed
                // and unmanaged ResourceMessages.
                if (disposing)
                {
                    // Dispose managed ResourceMessages.
                    if (this._digitalSignature != null)
                    {
                        this._digitalSignature.Dispose();
                        this._digitalSignature = null;
                    }
                }

                // Note disposing has been done.
                this._isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="SshCommand"/> is reclaimed by garbage collection.
        /// </summary>
        ~DsaKey()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\HMAC.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography
{
    /// <summary>
    /// Provides HMAC algorithm implementation.
    /// </summary>
    /// <typeparam name="T">Class that implements <see cref="T:System.Security.Cryptography.HashAlgorithm" />.</typeparam>
    public class HMac<T> : KeyedHashAlgorithm where T : HashAlgorithm, new()
    {
        private HashAlgorithm _hash;
        //private bool _isHashing;
        private byte[] _innerPadding;
        private byte[] _outerPadding;

        /// <summary>
        /// Gets the size of the block.
        /// </summary>
        /// <value>
        /// The size of the block.
        /// </value>
        protected int BlockSize
        {
            get
            {
                return this._hash.InputBlockSize;
            }
        }

        private HMac()
        {
            // Create the hash algorithms.
            this._hash = new T();
            this.HashSizeValue = this._hash.HashSize;
        }

        /// <summary>
        /// Rfc 2104.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <param name="hashSizeValue">The size, in bits, of the computed hash code.</param>
        public HMac(byte[] key, int hashSizeValue)
            : this(key)
        {
            this.HashSizeValue = hashSizeValue;
        }

        /// <summary>
        /// Rfc 2104.
        /// </summary>
        /// <param name="key">The key.</param>
        public HMac(byte[] key)
            : this()
        {
            base.KeyValue = key;

            this.InternalInitialize();
        }


        /// <summary>
        /// Gets or sets the key to use in the hash algorithm.
        /// </summary>
        /// <returns>The key to use in the hash algorithm.</returns>
        public override byte[] Key
        {
            get
            {
                return (byte[])base.KeyValue.Clone();
            }
            set
            {
                this.SetKey(value);
            }
        }

        /// <summary>
        /// Initializes an implementation of the <see cref="T:System.Security.Cryptography.HashAlgorithm" /> class.
        /// </summary>
        public override void Initialize()
        {
            this.InternalInitialize();
        }

        /// <summary>
        /// Hashes the core.
        /// </summary>
        /// <param name="rgb">The RGB.</param>
        /// <param name="ib">The ib.</param>
        /// <param name="cb">The cb.</param>
        protected override void HashCore(byte[] rgb, int ib, int cb)
        {
            this._hash.TransformBlock(rgb, ib, cb, rgb, ib);
        }

        /// <summary>
        /// Finalizes the hash computation after the last data is processed by the cryptographic stream object.
        /// </summary>
        /// <returns>
        /// The computed hash code.
        /// </returns>
        protected override byte[] HashFinal()
        {
            // Finalize the original hash.
            this._hash.TransformFinalBlock(new byte[0], 0, 0);

            var hashValue = this._hash.Hash;

            // Write the outer array.
            this._hash.TransformBlock(this._outerPadding, 0, this.BlockSize, this._outerPadding, 0);

            // Write the inner hash and finalize the hash.            
            this._hash.TransformFinalBlock(hashValue, 0, hashValue.Length);

            return this._hash.Hash.Take(this.HashSize / 8).ToArray();
        }

        private void InternalInitialize()
        {
            this.SetKey(base.KeyValue);
        }

        private void SetKey(byte[] value)
        {
            this._hash.Initialize();

            if (value.Length > this.BlockSize)
            {
                this.KeyValue = this._hash.ComputeHash(value);
                // No need to call Initialize, ComputeHash does it automatically.
            }
            else
            {
                this.KeyValue = (byte[]) value.Clone();
            }

            this._innerPadding = new byte[this.BlockSize];
            this._outerPadding = new byte[this.BlockSize];

            // Compute inner and outer padding.
            for (var i = 0; i < this.KeyValue.Length; i++)
            {
                this._innerPadding[i] = (byte)(0x36 ^ this.KeyValue[i]);
                this._outerPadding[i] = (byte)(0x5C ^ this.KeyValue[i]);
            }
            for (var i = this.KeyValue.Length; i < this.BlockSize; i++)
            {
                this._innerPadding[i] = 0x36;
                this._outerPadding[i] = 0x5C;
            }

            this._hash.TransformBlock(this._innerPadding, 0, this.BlockSize, this._innerPadding, 0);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);

            if (this._hash != null)
            {
                this._hash.Clear();
                this._hash = null;
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Key.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security
{
    /// <summary>
    /// Base class for asymmetric cipher algorithms
    /// </summary>
    public abstract class Key
    {
        /// <summary>
        /// Specifies array of big integers that represent private key
        /// </summary>
        protected BigInteger[] _privateKey;

        /// <summary>
        /// Gets the key specific digital signature.
        /// </summary>
        protected abstract DigitalSignature DigitalSignature { get; }

        /// <summary>
        /// Gets or sets the public key.
        /// </summary>
        /// <value>
        /// The public.
        /// </value>
        public abstract BigInteger[] Public { get; set; }

        /// <summary>
        /// Gets the length of the key.
        /// </summary>
        /// <value>
        /// The length of the key.
        /// </value>
        public abstract int KeyLength { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="Key"/> class.
        /// </summary>
        /// <param name="data">DER encoded private key data.</param>
        public Key(byte[] data)
        {
            if (data == null)
                throw new ArgumentNullException("data");

            var der = new DerData(data);
            var version = der.ReadBigInteger();

            var keys = new List<BigInteger>();
            while (!der.IsEndOfData)
            {
                keys.Add(der.ReadBigInteger());
            }

            this._privateKey = keys.ToArray();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Key"/> class.
        /// </summary>
        public Key()
        {
        }

        /// <summary>
        /// Signs the specified data with the key.
        /// </summary>
        /// <param name="data">The data to sign.</param>
        /// <returns>
        /// Signed data.
        /// </returns>
        public byte[] Sign(byte[] data)
        {
            return this.DigitalSignature.Sign(data);
        }

        /// <summary>
        /// Verifies the signature.
        /// </summary>
        /// <param name="data">The data to verify.</param>
        /// <param name="signature">The signature to verify against.</param>
        /// <returns><c>True</c> is signature was successfully verifies; otherwise <c>false</c>.</returns>
        public bool VerifySignature(byte[] data, byte[] signature)
        {
            return this.DigitalSignature.Verify(data, signature);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\RsaDigitalSignature.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography
{
    /// <summary>
    /// Implements RSA digital signature algorithm.
    /// </summary>
    public class RsaDigitalSignature : CipherDigitalSignature, IDisposable
    {
        private HashAlgorithm _hash;

        /// <summary>
        /// Initializes a new instance of the <see cref="RsaDigitalSignature"/> class.
        /// </summary>
        /// <param name="rsaKey">The RSA key.</param>
        public RsaDigitalSignature(RsaKey rsaKey)
            : base(new ObjectIdentifier(1, 3, 14, 3, 2, 26), new RsaCipher(rsaKey))
        {
            this._hash = new SHA1Hash();
        }

        /// <summary>
        /// Hashes the specified input.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <returns>
        /// Hashed data.
        /// </returns>
        protected override byte[] Hash(byte[] input)
        {
            return this._hash.ComputeHash(input);
        }

        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged ResourceMessages.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!this._isDisposed)
            {
                // If disposing equals true, dispose all managed
                // and unmanaged ResourceMessages.
                if (disposing)
                {
                    // Dispose managed ResourceMessages.
                    if (this._hash != null)
                    {
                        this._hash.Clear();
                        this._hash = null;
                    }
                }

                // Note disposing has been done.
                this._isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="SshCommand"/> is reclaimed by garbage collection.
        /// </summary>
        ~RsaDigitalSignature()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\RsaKey.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security
{
    /// <summary>
    /// Contains RSA private and public key
    /// </summary>
    public class RsaKey : Key, IDisposable
    {
        /// <summary>
        /// Gets the modulus.
        /// </summary>
        public BigInteger Modulus
        {
            get
            {
                return this._privateKey[0];
            }
        }

        /// <summary>
        /// Gets the exponent.
        /// </summary>
        public BigInteger Exponent
        {
            get
            {
                return this._privateKey[1];
            }
        }

        /// <summary>
        /// Gets the D.
        /// </summary>
        public BigInteger D
        {
            get
            {
                if (this._privateKey.Length > 2)
                    return this._privateKey[2];
                return BigInteger.Zero;
            }
        }

        /// <summary>
        /// Gets the P.
        /// </summary>
        public BigInteger P
        {
            get
            {
                if (this._privateKey.Length > 3)
                    return this._privateKey[3];
                return BigInteger.Zero;
            }
        }

        /// <summary>
        /// Gets the Q.
        /// </summary>
        public BigInteger Q
        {
            get
            {
                if (this._privateKey.Length > 4)
                    return this._privateKey[4];
                return BigInteger.Zero;
            }
        }

        /// <summary>
        /// Gets the DP.
        /// </summary>
        public BigInteger DP
        {
            get
            {
                if (this._privateKey.Length > 5)
                    return this._privateKey[5];
                return BigInteger.Zero;
            }
        }

        /// <summary>
        /// Gets the DQ.
        /// </summary>
        public BigInteger DQ
        {
            get
            {
                if (this._privateKey.Length > 6)
                    return this._privateKey[6];
                return BigInteger.Zero;
            }
        }

        /// <summary>
        /// Gets the inverse Q.
        /// </summary>
        public BigInteger InverseQ
        {
            get
            {
                if (this._privateKey.Length > 7)
                    return this._privateKey[7];
                return BigInteger.Zero;
            }
        }

        /// <summary>
        /// Gets the length of the key.
        /// </summary>
        /// <value>
        /// The length of the key.
        /// </value>
        public override int KeyLength
        {
            get
            {
                return this.Modulus.BitLength;
            }
        }

        private RsaDigitalSignature _digitalSignature;
        /// <summary>
        /// Gets the digital signature.
        /// </summary>
        protected override DigitalSignature DigitalSignature
        {
            get
            {
                if (this._digitalSignature == null)
                {
                    this._digitalSignature = new RsaDigitalSignature(this);
                }
                return this._digitalSignature;
            }
        }

        /// <summary>
        /// Gets or sets the public.
        /// </summary>
        /// <value>
        /// The public.
        /// </value>
        public override BigInteger[] Public
        {
            get
            {
                return new BigInteger[] { this.Exponent, this.Modulus };
            }
            set
            {
                if (value.Length != 2)
                    throw new InvalidOperationException("Invalid private key.");

                this._privateKey = new BigInteger[] { value[1], value[0] };
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RsaKey"/> class.
        /// </summary>
        public RsaKey()
        {

        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RsaKey"/> class.
        /// </summary>
        /// <param name="data">DER encoded private key data.</param>
        public RsaKey(byte[] data)
            : base(data)
        {
            if (this._privateKey.Length != 8)
                throw new InvalidOperationException("Invalid private key.");
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RsaKey"/> class.
        /// </summary>
        /// <param name="modulus">The modulus.</param>
        /// <param name="exponent">The exponent.</param>
        /// <param name="d">The d.</param>
        /// <param name="p">The p.</param>
        /// <param name="q">The q.</param>
        /// <param name="inverseQ">The inverse Q.</param>
        public RsaKey(BigInteger modulus, BigInteger exponent, BigInteger d, BigInteger p, BigInteger q, BigInteger inverseQ)
        {
            this._privateKey = new BigInteger[8];
            this._privateKey[0] = modulus;
            this._privateKey[1] = exponent;
            this._privateKey[2] = d;
            this._privateKey[3] = p;
            this._privateKey[4] = q;
            this._privateKey[5] = PrimeExponent(d, p);
            this._privateKey[6] = PrimeExponent(d, q);
            this._privateKey[7] = inverseQ;
        }

        private static BigInteger PrimeExponent(BigInteger privateExponent, BigInteger prime)
        {
            BigInteger pe = prime - new BigInteger(1);
            return privateExponent % pe;
        }

        #region IDisposable Members

        private bool _isDisposed;

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged ResourceMessages.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged ResourceMessages.</param>
        protected virtual void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!this._isDisposed)
            {
                // If disposing equals true, dispose all managed
                // and unmanaged ResourceMessages.
                if (disposing)
                {
                    // Dispose managed ResourceMessages.
                    if (this._digitalSignature != null)
                    {
                        this._digitalSignature.Dispose();
                        this._digitalSignature = null;
                    }
                }

                // Note disposing has been done.
                this._isDisposed = true;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="SshCommand"/> is reclaimed by garbage collection.
        /// </summary>
        ~RsaKey()
        {
            // Do not re-create Dispose clean-up code here.
            // Calling Dispose(false) is optimal in terms of
            // readability and maintainability.
            Dispose(false);
        }

        #endregion
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\StreamCipher.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography
{
    /// <summary>
    /// Base class of stream cipher algorithms.
    /// </summary>
    public abstract class StreamCipher : SymmetricCipher
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="StreamCipher"/> class.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <exception cref="ArgumentNullException"><paramref name="key"/> is null.</exception>
        protected StreamCipher(byte[] key)
            : base(key)
        {
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\SymmetricCipher.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography
{
    /// <summary>
    /// Base class for symmetric cipher implementations.
    /// </summary>
    public abstract class SymmetricCipher : Cipher
    {
        /// <summary>
        /// Gets the key.
        /// </summary>
        protected byte[] Key { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SymmetricCipher"/> class.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <exception cref="ArgumentNullException"><paramref name="key"/> is null.</exception>
        protected SymmetricCipher(byte[] key)
        {
            if (key == null)
                throw new ArgumentNullException("key");

            this.Key = key;
        }

        /// <summary>
        /// Encrypts the specified region of the input byte array and copies the encrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to encrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write encrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes encrypted.
        /// </returns>
        public abstract int EncryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);

        /// <summary>
        /// Decrypts the specified region of the input byte array and copies the decrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to decrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write decrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes decrypted.
        /// </returns>
        public abstract int DecryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Ciphers\AesCipher.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography.Ciphers
{
    /// <summary>
    /// AES cipher implementation.
    /// </summary>
    public sealed class AesCipher : BlockCipher
    {
        private const uint m1 = 0x80808080;

        private const uint m2 = 0x7f7f7f7f;

        private const uint m3 = 0x0000001b;

        private int _rounds;

        private uint[] _encryptionKey;

        private uint[] _decryptionKey;

        private uint C0, C1, C2, C3;

        #region Static Definition Tables

        private static readonly byte[] S =
		{
			99, 124, 119, 123, 242, 107, 111, 197,
			48,   1, 103,  43, 254, 215, 171, 118,
			202, 130, 201, 125, 250,  89,  71, 240,
			173, 212, 162, 175, 156, 164, 114, 192,
			183, 253, 147,  38,  54,  63, 247, 204,
			52, 165, 229, 241, 113, 216,  49,  21,
			4, 199,  35, 195,  24, 150,   5, 154,
			7,  18, 128, 226, 235,  39, 178, 117,
			9, 131,  44,  26,  27, 110,  90, 160,
			82,  59, 214, 179,  41, 227,  47, 132,
			83, 209,   0, 237,  32, 252, 177,  91,
			106, 203, 190,  57,  74,  76,  88, 207,
			208, 239, 170, 251,  67,  77,  51, 133,
			69, 249,   2, 127,  80,  60, 159, 168,
			81, 163,  64, 143, 146, 157,  56, 245,
			188, 182, 218,  33,  16, 255, 243, 210,
			205,  12,  19, 236,  95, 151,  68,  23,
			196, 167, 126,  61, 100,  93,  25, 115,
			96, 129,  79, 220,  34,  42, 144, 136,
			70, 238, 184,  20, 222,  94,  11, 219,
			224,  50,  58,  10,  73,   6,  36,  92,
			194, 211, 172,  98, 145, 149, 228, 121,
			231, 200,  55, 109, 141, 213,  78, 169,
			108,  86, 244, 234, 101, 122, 174,   8,
			186, 120,  37,  46,  28, 166, 180, 198,
			232, 221, 116,  31,  75, 189, 139, 138,
			112,  62, 181, 102,  72,   3, 246,  14,
			97,  53,  87, 185, 134, 193,  29, 158,
			225, 248, 152,  17, 105, 217, 142, 148,
			155,  30, 135, 233, 206,  85,  40, 223,
			140, 161, 137,  13, 191, 230,  66, 104,
			65, 153,  45,  15, 176,  84, 187,  22
		};

        // The inverse S-box
        private static readonly byte[] Si =
		{
			82,   9, 106, 213,  48,  54, 165,  56,
			191,  64, 163, 158, 129, 243, 215, 251,
			124, 227,  57, 130, 155,  47, 255, 135,
			52, 142,  67,  68, 196, 222, 233, 203,
			84, 123, 148,  50, 166, 194,  35,  61,
			238,  76, 149,  11,  66, 250, 195,  78,
			8,  46, 161, 102,  40, 217,  36, 178,
			118,  91, 162,  73, 109, 139, 209,  37,
			114, 248, 246, 100, 134, 104, 152,  22,
			212, 164,  92, 204,  93, 101, 182, 146,
			108, 112,  72,  80, 253, 237, 185, 218,
			94,  21,  70,  87, 167, 141, 157, 132,
			144, 216, 171,   0, 140, 188, 211,  10,
			247, 228,  88,   5, 184, 179,  69,   6,
			208,  44,  30, 143, 202,  63,  15,   2,
			193, 175, 189,   3,   1,  19, 138, 107,
			58, 145,  17,  65,  79, 103, 220, 234,
			151, 242, 207, 206, 240, 180, 230, 115,
			150, 172, 116,  34, 231, 173,  53, 133,
			226, 249,  55, 232,  28, 117, 223, 110,
			71, 241,  26, 113,  29,  41, 197, 137,
			111, 183,  98,  14, 170,  24, 190,  27,
			252,  86,  62,  75, 198, 210, 121,  32,
			154, 219, 192, 254, 120, 205,  90, 244,
			31, 221, 168,  51, 136,   7, 199,  49,
			177,  18,  16,  89,  39, 128, 236,  95,
			96,  81, 127, 169,  25, 181,  74,  13,
			45, 229, 122, 159, 147, 201, 156, 239,
			160, 224,  59,  77, 174,  42, 245, 176,
			200, 235, 187,  60, 131,  83, 153,  97,
			23,  43,   4, 126, 186, 119, 214,  38,
			225, 105,  20,  99,  85,  33,  12, 125
		};

        // vector used in calculating key schedule (powers of x in GF(256))
        private static readonly byte[] rcon =
		{
			0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
			0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91
		};

        // precomputation tables of calculations for rounds
        private static readonly uint[] T0 =
		{
			0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6, 0x0df2f2ff,
			0xbd6b6bd6, 0xb16f6fde, 0x54c5c591, 0x50303060, 0x03010102,
			0xa96767ce, 0x7d2b2b56, 0x19fefee7, 0x62d7d7b5, 0xe6abab4d,
			0x9a7676ec, 0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa,
			0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb, 0xecadad41,
			0x67d4d4b3, 0xfda2a25f, 0xeaafaf45, 0xbf9c9c23, 0xf7a4a453,
			0x967272e4, 0x5bc0c09b, 0xc2b7b775, 0x1cfdfde1, 0xae93933d,
			0x6a26264c, 0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83,
			0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9, 0x937171e2,
			0x73d8d8ab, 0x53313162, 0x3f15152a, 0x0c040408, 0x52c7c795,
			0x65232346, 0x5ec3c39d, 0x28181830, 0xa1969637, 0x0f05050a,
			0xb59a9a2f, 0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df,
			0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea, 0x1b090912,
			0x9e83831d, 0x742c2c58, 0x2e1a1a34, 0x2d1b1b36, 0xb26e6edc,
			0xee5a5ab4, 0xfba0a05b, 0xf65252a4, 0x4d3b3b76, 0x61d6d6b7,
			0xceb3b37d, 0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413,
			0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1, 0x60202040,
			0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6, 0xbe6a6ad4, 0x46cbcb8d,
			0xd9bebe67, 0x4b393972, 0xde4a4a94, 0xd44c4c98, 0xe85858b0,
			0x4acfcf85, 0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed,
			0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511, 0xcf45458a,
			0x10f9f9e9, 0x06020204, 0x817f7ffe, 0xf05050a0, 0x443c3c78,
			0xba9f9f25, 0xe3a8a84b, 0xf35151a2, 0xfea3a35d, 0xc0404080,
			0x8a8f8f05, 0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1,
			0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142, 0x30101020,
			0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf, 0x4ccdcd81, 0x140c0c18,
			0x35131326, 0x2fececc3, 0xe15f5fbe, 0xa2979735, 0xcc444488,
			0x3917172e, 0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a,
			0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6, 0xa06060c0,
			0x98818119, 0xd14f4f9e, 0x7fdcdca3, 0x66222244, 0x7e2a2a54,
			0xab90903b, 0x8388880b, 0xca46468c, 0x29eeeec7, 0xd3b8b86b,
			0x3c141428, 0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad,
			0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14, 0xdb494992,
			0x0a06060c, 0x6c242448, 0xe45c5cb8, 0x5dc2c29f, 0x6ed3d3bd,
			0xefacac43, 0xa66262c4, 0xa8919139, 0xa4959531, 0x37e4e4d3,
			0x8b7979f2, 0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda,
			0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949, 0xb46c6cd8,
			0xfa5656ac, 0x07f4f4f3, 0x25eaeacf, 0xaf6565ca, 0x8e7a7af4,
			0xe9aeae47, 0x18080810, 0xd5baba6f, 0x887878f0, 0x6f25254a,
			0x722e2e5c, 0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697,
			0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e, 0xdd4b4b96,
			0xdcbdbd61, 0x868b8b0d, 0x858a8a0f, 0x907070e0, 0x423e3e7c,
			0xc4b5b571, 0xaa6666cc, 0xd8484890, 0x05030306, 0x01f6f6f7,
			0x120e0e1c, 0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969,
			0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27, 0x38e1e1d9,
			0x13f8f8eb, 0xb398982b, 0x33111122, 0xbb6969d2, 0x70d9d9a9,
			0x898e8e07, 0xa7949433, 0xb69b9b2d, 0x221e1e3c, 0x92878715,
			0x20e9e9c9, 0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5,
			0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a, 0xdabfbf65,
			0x31e6e6d7, 0xc6424284, 0xb86868d0, 0xc3414182, 0xb0999929,
			0x772d2d5a, 0x110f0f1e, 0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d,
			0x3a16162c
		};

        private static readonly uint[] T1 =
		{
			0x6363c6a5, 0x7c7cf884, 0x7777ee99, 0x7b7bf68d, 0xf2f2ff0d,
			0x6b6bd6bd, 0x6f6fdeb1, 0xc5c59154, 0x30306050, 0x01010203,
			0x6767cea9, 0x2b2b567d, 0xfefee719, 0xd7d7b562, 0xabab4de6,
			0x7676ec9a, 0xcaca8f45, 0x82821f9d, 0xc9c98940, 0x7d7dfa87,
			0xfafaef15, 0x5959b2eb, 0x47478ec9, 0xf0f0fb0b, 0xadad41ec,
			0xd4d4b367, 0xa2a25ffd, 0xafaf45ea, 0x9c9c23bf, 0xa4a453f7,
			0x7272e496, 0xc0c09b5b, 0xb7b775c2, 0xfdfde11c, 0x93933dae,
			0x26264c6a, 0x36366c5a, 0x3f3f7e41, 0xf7f7f502, 0xcccc834f,
			0x3434685c, 0xa5a551f4, 0xe5e5d134, 0xf1f1f908, 0x7171e293,
			0xd8d8ab73, 0x31316253, 0x15152a3f, 0x0404080c, 0xc7c79552,
			0x23234665, 0xc3c39d5e, 0x18183028, 0x969637a1, 0x05050a0f,
			0x9a9a2fb5, 0x07070e09, 0x12122436, 0x80801b9b, 0xe2e2df3d,
			0xebebcd26, 0x27274e69, 0xb2b27fcd, 0x7575ea9f, 0x0909121b,
			0x83831d9e, 0x2c2c5874, 0x1a1a342e, 0x1b1b362d, 0x6e6edcb2,
			0x5a5ab4ee, 0xa0a05bfb, 0x5252a4f6, 0x3b3b764d, 0xd6d6b761,
			0xb3b37dce, 0x2929527b, 0xe3e3dd3e, 0x2f2f5e71, 0x84841397,
			0x5353a6f5, 0xd1d1b968, 0x00000000, 0xededc12c, 0x20204060,
			0xfcfce31f, 0xb1b179c8, 0x5b5bb6ed, 0x6a6ad4be, 0xcbcb8d46,
			0xbebe67d9, 0x3939724b, 0x4a4a94de, 0x4c4c98d4, 0x5858b0e8,
			0xcfcf854a, 0xd0d0bb6b, 0xefefc52a, 0xaaaa4fe5, 0xfbfbed16,
			0x434386c5, 0x4d4d9ad7, 0x33336655, 0x85851194, 0x45458acf,
			0xf9f9e910, 0x02020406, 0x7f7ffe81, 0x5050a0f0, 0x3c3c7844,
			0x9f9f25ba, 0xa8a84be3, 0x5151a2f3, 0xa3a35dfe, 0x404080c0,
			0x8f8f058a, 0x92923fad, 0x9d9d21bc, 0x38387048, 0xf5f5f104,
			0xbcbc63df, 0xb6b677c1, 0xdadaaf75, 0x21214263, 0x10102030,
			0xffffe51a, 0xf3f3fd0e, 0xd2d2bf6d, 0xcdcd814c, 0x0c0c1814,
			0x13132635, 0xececc32f, 0x5f5fbee1, 0x979735a2, 0x444488cc,
			0x17172e39, 0xc4c49357, 0xa7a755f2, 0x7e7efc82, 0x3d3d7a47,
			0x6464c8ac, 0x5d5dbae7, 0x1919322b, 0x7373e695, 0x6060c0a0,
			0x81811998, 0x4f4f9ed1, 0xdcdca37f, 0x22224466, 0x2a2a547e,
			0x90903bab, 0x88880b83, 0x46468cca, 0xeeeec729, 0xb8b86bd3,
			0x1414283c, 0xdedea779, 0x5e5ebce2, 0x0b0b161d, 0xdbdbad76,
			0xe0e0db3b, 0x32326456, 0x3a3a744e, 0x0a0a141e, 0x494992db,
			0x06060c0a, 0x2424486c, 0x5c5cb8e4, 0xc2c29f5d, 0xd3d3bd6e,
			0xacac43ef, 0x6262c4a6, 0x919139a8, 0x959531a4, 0xe4e4d337,
			0x7979f28b, 0xe7e7d532, 0xc8c88b43, 0x37376e59, 0x6d6ddab7,
			0x8d8d018c, 0xd5d5b164, 0x4e4e9cd2, 0xa9a949e0, 0x6c6cd8b4,
			0x5656acfa, 0xf4f4f307, 0xeaeacf25, 0x6565caaf, 0x7a7af48e,
			0xaeae47e9, 0x08081018, 0xbaba6fd5, 0x7878f088, 0x25254a6f,
			0x2e2e5c72, 0x1c1c3824, 0xa6a657f1, 0xb4b473c7, 0xc6c69751,
			0xe8e8cb23, 0xdddda17c, 0x7474e89c, 0x1f1f3e21, 0x4b4b96dd,
			0xbdbd61dc, 0x8b8b0d86, 0x8a8a0f85, 0x7070e090, 0x3e3e7c42,
			0xb5b571c4, 0x6666ccaa, 0x484890d8, 0x03030605, 0xf6f6f701,
			0x0e0e1c12, 0x6161c2a3, 0x35356a5f, 0x5757aef9, 0xb9b969d0,
			0x86861791, 0xc1c19958, 0x1d1d3a27, 0x9e9e27b9, 0xe1e1d938,
			0xf8f8eb13, 0x98982bb3, 0x11112233, 0x6969d2bb, 0xd9d9a970,
			0x8e8e0789, 0x949433a7, 0x9b9b2db6, 0x1e1e3c22, 0x87871592,
			0xe9e9c920, 0xcece8749, 0x5555aaff, 0x28285078, 0xdfdfa57a,
			0x8c8c038f, 0xa1a159f8, 0x89890980, 0x0d0d1a17, 0xbfbf65da,
			0xe6e6d731, 0x424284c6, 0x6868d0b8, 0x414182c3, 0x999929b0,
			0x2d2d5a77, 0x0f0f1e11, 0xb0b07bcb, 0x5454a8fc, 0xbbbb6dd6,
			0x16162c3a
		};

        private static readonly uint[] T2 =
		{
			0x63c6a563, 0x7cf8847c, 0x77ee9977, 0x7bf68d7b, 0xf2ff0df2,
			0x6bd6bd6b, 0x6fdeb16f, 0xc59154c5, 0x30605030, 0x01020301,
			0x67cea967, 0x2b567d2b, 0xfee719fe, 0xd7b562d7, 0xab4de6ab,
			0x76ec9a76, 0xca8f45ca, 0x821f9d82, 0xc98940c9, 0x7dfa877d,
			0xfaef15fa, 0x59b2eb59, 0x478ec947, 0xf0fb0bf0, 0xad41ecad,
			0xd4b367d4, 0xa25ffda2, 0xaf45eaaf, 0x9c23bf9c, 0xa453f7a4,
			0x72e49672, 0xc09b5bc0, 0xb775c2b7, 0xfde11cfd, 0x933dae93,
			0x264c6a26, 0x366c5a36, 0x3f7e413f, 0xf7f502f7, 0xcc834fcc,
			0x34685c34, 0xa551f4a5, 0xe5d134e5, 0xf1f908f1, 0x71e29371,
			0xd8ab73d8, 0x31625331, 0x152a3f15, 0x04080c04, 0xc79552c7,
			0x23466523, 0xc39d5ec3, 0x18302818, 0x9637a196, 0x050a0f05,
			0x9a2fb59a, 0x070e0907, 0x12243612, 0x801b9b80, 0xe2df3de2,
			0xebcd26eb, 0x274e6927, 0xb27fcdb2, 0x75ea9f75, 0x09121b09,
			0x831d9e83, 0x2c58742c, 0x1a342e1a, 0x1b362d1b, 0x6edcb26e,
			0x5ab4ee5a, 0xa05bfba0, 0x52a4f652, 0x3b764d3b, 0xd6b761d6,
			0xb37dceb3, 0x29527b29, 0xe3dd3ee3, 0x2f5e712f, 0x84139784,
			0x53a6f553, 0xd1b968d1, 0x00000000, 0xedc12ced, 0x20406020,
			0xfce31ffc, 0xb179c8b1, 0x5bb6ed5b, 0x6ad4be6a, 0xcb8d46cb,
			0xbe67d9be, 0x39724b39, 0x4a94de4a, 0x4c98d44c, 0x58b0e858,
			0xcf854acf, 0xd0bb6bd0, 0xefc52aef, 0xaa4fe5aa, 0xfbed16fb,
			0x4386c543, 0x4d9ad74d, 0x33665533, 0x85119485, 0x458acf45,
			0xf9e910f9, 0x02040602, 0x7ffe817f, 0x50a0f050, 0x3c78443c,
			0x9f25ba9f, 0xa84be3a8, 0x51a2f351, 0xa35dfea3, 0x4080c040,
			0x8f058a8f, 0x923fad92, 0x9d21bc9d, 0x38704838, 0xf5f104f5,
			0xbc63dfbc, 0xb677c1b6, 0xdaaf75da, 0x21426321, 0x10203010,
			0xffe51aff, 0xf3fd0ef3, 0xd2bf6dd2, 0xcd814ccd, 0x0c18140c,
			0x13263513, 0xecc32fec, 0x5fbee15f, 0x9735a297, 0x4488cc44,
			0x172e3917, 0xc49357c4, 0xa755f2a7, 0x7efc827e, 0x3d7a473d,
			0x64c8ac64, 0x5dbae75d, 0x19322b19, 0x73e69573, 0x60c0a060,
			0x81199881, 0x4f9ed14f, 0xdca37fdc, 0x22446622, 0x2a547e2a,
			0x903bab90, 0x880b8388, 0x468cca46, 0xeec729ee, 0xb86bd3b8,
			0x14283c14, 0xdea779de, 0x5ebce25e, 0x0b161d0b, 0xdbad76db,
			0xe0db3be0, 0x32645632, 0x3a744e3a, 0x0a141e0a, 0x4992db49,
			0x060c0a06, 0x24486c24, 0x5cb8e45c, 0xc29f5dc2, 0xd3bd6ed3,
			0xac43efac, 0x62c4a662, 0x9139a891, 0x9531a495, 0xe4d337e4,
			0x79f28b79, 0xe7d532e7, 0xc88b43c8, 0x376e5937, 0x6ddab76d,
			0x8d018c8d, 0xd5b164d5, 0x4e9cd24e, 0xa949e0a9, 0x6cd8b46c,
			0x56acfa56, 0xf4f307f4, 0xeacf25ea, 0x65caaf65, 0x7af48e7a,
			0xae47e9ae, 0x08101808, 0xba6fd5ba, 0x78f08878, 0x254a6f25,
			0x2e5c722e, 0x1c38241c, 0xa657f1a6, 0xb473c7b4, 0xc69751c6,
			0xe8cb23e8, 0xdda17cdd, 0x74e89c74, 0x1f3e211f, 0x4b96dd4b,
			0xbd61dcbd, 0x8b0d868b, 0x8a0f858a, 0x70e09070, 0x3e7c423e,
			0xb571c4b5, 0x66ccaa66, 0x4890d848, 0x03060503, 0xf6f701f6,
			0x0e1c120e, 0x61c2a361, 0x356a5f35, 0x57aef957, 0xb969d0b9,
			0x86179186, 0xc19958c1, 0x1d3a271d, 0x9e27b99e, 0xe1d938e1,
			0xf8eb13f8, 0x982bb398, 0x11223311, 0x69d2bb69, 0xd9a970d9,
			0x8e07898e, 0x9433a794, 0x9b2db69b, 0x1e3c221e, 0x87159287,
			0xe9c920e9, 0xce8749ce, 0x55aaff55, 0x28507828, 0xdfa57adf,
			0x8c038f8c, 0xa159f8a1, 0x89098089, 0x0d1a170d, 0xbf65dabf,
			0xe6d731e6, 0x4284c642, 0x68d0b868, 0x4182c341, 0x9929b099,
			0x2d5a772d, 0x0f1e110f, 0xb07bcbb0, 0x54a8fc54, 0xbb6dd6bb,
			0x162c3a16
		};

        private static readonly uint[] T3 =
		{
			0xc6a56363, 0xf8847c7c, 0xee997777, 0xf68d7b7b, 0xff0df2f2,
			0xd6bd6b6b, 0xdeb16f6f, 0x9154c5c5, 0x60503030, 0x02030101,
			0xcea96767, 0x567d2b2b, 0xe719fefe, 0xb562d7d7, 0x4de6abab,
			0xec9a7676, 0x8f45caca, 0x1f9d8282, 0x8940c9c9, 0xfa877d7d,
			0xef15fafa, 0xb2eb5959, 0x8ec94747, 0xfb0bf0f0, 0x41ecadad,
			0xb367d4d4, 0x5ffda2a2, 0x45eaafaf, 0x23bf9c9c, 0x53f7a4a4,
			0xe4967272, 0x9b5bc0c0, 0x75c2b7b7, 0xe11cfdfd, 0x3dae9393,
			0x4c6a2626, 0x6c5a3636, 0x7e413f3f, 0xf502f7f7, 0x834fcccc,
			0x685c3434, 0x51f4a5a5, 0xd134e5e5, 0xf908f1f1, 0xe2937171,
			0xab73d8d8, 0x62533131, 0x2a3f1515, 0x080c0404, 0x9552c7c7,
			0x46652323, 0x9d5ec3c3, 0x30281818, 0x37a19696, 0x0a0f0505,
			0x2fb59a9a, 0x0e090707, 0x24361212, 0x1b9b8080, 0xdf3de2e2,
			0xcd26ebeb, 0x4e692727, 0x7fcdb2b2, 0xea9f7575, 0x121b0909,
			0x1d9e8383, 0x58742c2c, 0x342e1a1a, 0x362d1b1b, 0xdcb26e6e,
			0xb4ee5a5a, 0x5bfba0a0, 0xa4f65252, 0x764d3b3b, 0xb761d6d6,
			0x7dceb3b3, 0x527b2929, 0xdd3ee3e3, 0x5e712f2f, 0x13978484,
			0xa6f55353, 0xb968d1d1, 0x00000000, 0xc12ceded, 0x40602020,
			0xe31ffcfc, 0x79c8b1b1, 0xb6ed5b5b, 0xd4be6a6a, 0x8d46cbcb,
			0x67d9bebe, 0x724b3939, 0x94de4a4a, 0x98d44c4c, 0xb0e85858,
			0x854acfcf, 0xbb6bd0d0, 0xc52aefef, 0x4fe5aaaa, 0xed16fbfb,
			0x86c54343, 0x9ad74d4d, 0x66553333, 0x11948585, 0x8acf4545,
			0xe910f9f9, 0x04060202, 0xfe817f7f, 0xa0f05050, 0x78443c3c,
			0x25ba9f9f, 0x4be3a8a8, 0xa2f35151, 0x5dfea3a3, 0x80c04040,
			0x058a8f8f, 0x3fad9292, 0x21bc9d9d, 0x70483838, 0xf104f5f5,
			0x63dfbcbc, 0x77c1b6b6, 0xaf75dada, 0x42632121, 0x20301010,
			0xe51affff, 0xfd0ef3f3, 0xbf6dd2d2, 0x814ccdcd, 0x18140c0c,
			0x26351313, 0xc32fecec, 0xbee15f5f, 0x35a29797, 0x88cc4444,
			0x2e391717, 0x9357c4c4, 0x55f2a7a7, 0xfc827e7e, 0x7a473d3d,
			0xc8ac6464, 0xbae75d5d, 0x322b1919, 0xe6957373, 0xc0a06060,
			0x19988181, 0x9ed14f4f, 0xa37fdcdc, 0x44662222, 0x547e2a2a,
			0x3bab9090, 0x0b838888, 0x8cca4646, 0xc729eeee, 0x6bd3b8b8,
			0x283c1414, 0xa779dede, 0xbce25e5e, 0x161d0b0b, 0xad76dbdb,
			0xdb3be0e0, 0x64563232, 0x744e3a3a, 0x141e0a0a, 0x92db4949,
			0x0c0a0606, 0x486c2424, 0xb8e45c5c, 0x9f5dc2c2, 0xbd6ed3d3,
			0x43efacac, 0xc4a66262, 0x39a89191, 0x31a49595, 0xd337e4e4,
			0xf28b7979, 0xd532e7e7, 0x8b43c8c8, 0x6e593737, 0xdab76d6d,
			0x018c8d8d, 0xb164d5d5, 0x9cd24e4e, 0x49e0a9a9, 0xd8b46c6c,
			0xacfa5656, 0xf307f4f4, 0xcf25eaea, 0xcaaf6565, 0xf48e7a7a,
			0x47e9aeae, 0x10180808, 0x6fd5baba, 0xf0887878, 0x4a6f2525,
			0x5c722e2e, 0x38241c1c, 0x57f1a6a6, 0x73c7b4b4, 0x9751c6c6,
			0xcb23e8e8, 0xa17cdddd, 0xe89c7474, 0x3e211f1f, 0x96dd4b4b,
			0x61dcbdbd, 0x0d868b8b, 0x0f858a8a, 0xe0907070, 0x7c423e3e,
			0x71c4b5b5, 0xccaa6666, 0x90d84848, 0x06050303, 0xf701f6f6,
			0x1c120e0e, 0xc2a36161, 0x6a5f3535, 0xaef95757, 0x69d0b9b9,
			0x17918686, 0x9958c1c1, 0x3a271d1d, 0x27b99e9e, 0xd938e1e1,
			0xeb13f8f8, 0x2bb39898, 0x22331111, 0xd2bb6969, 0xa970d9d9,
			0x07898e8e, 0x33a79494, 0x2db69b9b, 0x3c221e1e, 0x15928787,
			0xc920e9e9, 0x8749cece, 0xaaff5555, 0x50782828, 0xa57adfdf,
			0x038f8c8c, 0x59f8a1a1, 0x09808989, 0x1a170d0d, 0x65dabfbf,
			0xd731e6e6, 0x84c64242, 0xd0b86868, 0x82c34141, 0x29b09999,
			0x5a772d2d, 0x1e110f0f, 0x7bcbb0b0, 0xa8fc5454, 0x6dd6bbbb,
			0x2c3a1616
		};

        private static readonly uint[] Tinv0 =
		{
			0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a, 0xcb6bab3b,
			0xf1459d1f, 0xab58faac, 0x9303e34b, 0x55fa3020, 0xf66d76ad,
			0x9176cc88, 0x254c02f5, 0xfcd7e54f, 0xd7cb2ac5, 0x80443526,
			0x8fa362b5, 0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d,
			0x02752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b, 0xe75f8f03,
			0x959c9215, 0xeb7a6dbf, 0xda595295, 0x2d83bed4, 0xd3217458,
			0x2969e049, 0x44c8c98e, 0x6a89c275, 0x78798ef4, 0x6b3e5899,
			0xdd71b927, 0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d,
			0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362, 0xe07764b1,
			0x84ae6bbb, 0x1ca081fe, 0x942b08f9, 0x58684870, 0x19fd458f,
			0x876cde94, 0xb7f87b52, 0x23d373ab, 0xe2024b72, 0x578f1fe3,
			0x2aab5566, 0x0728ebb2, 0x03c2b52f, 0x9a7bc586, 0xa50837d3,
			0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed, 0x2b1ccf8a,
			0x92b479a7, 0xf0f207f3, 0xa1e2694e, 0xcdf4da65, 0xd5be0506,
			0x1f6234d1, 0x8afea6c4, 0x9d532e34, 0xa055f3a2, 0x32e18a05,
			0x75ebf6a4, 0x39ec830b, 0xaaef6040, 0x069f715e, 0x51106ebd,
			0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d, 0xb58d5491,
			0x055dc471, 0x6fd40604, 0xff155060, 0x24fb9819, 0x97e9bdd6,
			0xcc434089, 0x779ed967, 0xbd42e8b0, 0x888b8907, 0x385b19e7,
			0xdbeec879, 0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x00000000,
			0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c, 0xfbff0efd,
			0x5638850f, 0x1ed5ae3d, 0x27392d36, 0x64d90f0a, 0x21a65c68,
			0xd1545b9b, 0x3a2e3624, 0xb1670a0c, 0x0fe75793, 0xd296eeb4,
			0x9e919b1b, 0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c,
			0x0aba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12, 0x0b0d090e,
			0xadc78bf2, 0xb9a8b62d, 0xc8a91e14, 0x8519f157, 0x4c0775af,
			0xbbdd99ee, 0xfd607fa3, 0x9f2601f7, 0xbcf5725c, 0xc53b6644,
			0x347efb5b, 0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8,
			0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684, 0x7d244a85,
			0xf83dbbd2, 0x1132f9ae, 0x6da129c7, 0x4b2f9e1d, 0xf330b2dc,
			0xec52860d, 0xd0e3c177, 0x6c16b32b, 0x99b970a9, 0xfa489411,
			0x2264e947, 0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322,
			0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498, 0xcf81f5a6,
			0x28de7aa5, 0x268eb7da, 0xa4bfad3f, 0xe49d3a2c, 0x0d927850,
			0x9bcc5f6a, 0x62467e54, 0xc2138df6, 0xe8b8d890, 0x5ef7392e,
			0xf5afc382, 0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf,
			0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb, 0x097826cd,
			0xf418596e, 0x01b79aec, 0xa89a4f83, 0x656e95e6, 0x7ee6ffaa,
			0x08cfbc21, 0xe6e815ef, 0xd99be7ba, 0xce366f4a, 0xd4099fea,
			0xd67cb029, 0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235,
			0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733, 0x4a9804f1,
			0xf7daec41, 0x0e50cd7f, 0x2ff69117, 0x8dd64d76, 0x4db0ef43,
			0x544daacc, 0xdf0496e4, 0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1,
			0x7f516546, 0x04ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb,
			0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d, 0x8c61d79a,
			0x7a0ca137, 0x8e14f859, 0x893c13eb, 0xee27a9ce, 0x35c961b7,
			0xede51ce1, 0x3cb1477a, 0x59dfd29c, 0x3f73f255, 0x79ce1418,
			0xbf37c773, 0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478,
			0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2, 0x72c31d16,
			0x0c25e2bc, 0x8b493c28, 0x41950dff, 0x7101a839, 0xdeb30c08,
			0x9ce4b4d8, 0x90c15664, 0x6184cb7b, 0x70b632d5, 0x745c6c48,
			0x4257b8d0
		};

        private static readonly uint[] Tinv1 =
		{
			0xa7f45150, 0x65417e53, 0xa4171ac3, 0x5e273a96, 0x6bab3bcb,
			0x459d1ff1, 0x58faacab, 0x03e34b93, 0xfa302055, 0x6d76adf6,
			0x76cc8891, 0x4c02f525, 0xd7e54ffc, 0xcb2ac5d7, 0x44352680,
			0xa362b58f, 0x5ab1de49, 0x1bba2567, 0x0eea4598, 0xc0fe5de1,
			0x752fc302, 0xf04c8112, 0x97468da3, 0xf9d36bc6, 0x5f8f03e7,
			0x9c921595, 0x7a6dbfeb, 0x595295da, 0x83bed42d, 0x217458d3,
			0x69e04929, 0xc8c98e44, 0x89c2756a, 0x798ef478, 0x3e58996b,
			0x71b927dd, 0x4fe1beb6, 0xad88f017, 0xac20c966, 0x3ace7db4,
			0x4adf6318, 0x311ae582, 0x33519760, 0x7f536245, 0x7764b1e0,
			0xae6bbb84, 0xa081fe1c, 0x2b08f994, 0x68487058, 0xfd458f19,
			0x6cde9487, 0xf87b52b7, 0xd373ab23, 0x024b72e2, 0x8f1fe357,
			0xab55662a, 0x28ebb207, 0xc2b52f03, 0x7bc5869a, 0x0837d3a5,
			0x872830f2, 0xa5bf23b2, 0x6a0302ba, 0x8216ed5c, 0x1ccf8a2b,
			0xb479a792, 0xf207f3f0, 0xe2694ea1, 0xf4da65cd, 0xbe0506d5,
			0x6234d11f, 0xfea6c48a, 0x532e349d, 0x55f3a2a0, 0xe18a0532,
			0xebf6a475, 0xec830b39, 0xef6040aa, 0x9f715e06, 0x106ebd51,
			0x8a213ef9, 0x06dd963d, 0x053eddae, 0xbde64d46, 0x8d5491b5,
			0x5dc47105, 0xd406046f, 0x155060ff, 0xfb981924, 0xe9bdd697,
			0x434089cc, 0x9ed96777, 0x42e8b0bd, 0x8b890788, 0x5b19e738,
			0xeec879db, 0x0a7ca147, 0x0f427ce9, 0x1e84f8c9, 0x00000000,
			0x86800983, 0xed2b3248, 0x70111eac, 0x725a6c4e, 0xff0efdfb,
			0x38850f56, 0xd5ae3d1e, 0x392d3627, 0xd90f0a64, 0xa65c6821,
			0x545b9bd1, 0x2e36243a, 0x670a0cb1, 0xe757930f, 0x96eeb4d2,
			0x919b1b9e, 0xc5c0804f, 0x20dc61a2, 0x4b775a69, 0x1a121c16,
			0xba93e20a, 0x2aa0c0e5, 0xe0223c43, 0x171b121d, 0x0d090e0b,
			0xc78bf2ad, 0xa8b62db9, 0xa91e14c8, 0x19f15785, 0x0775af4c,
			0xdd99eebb, 0x607fa3fd, 0x2601f79f, 0xf5725cbc, 0x3b6644c5,
			0x7efb5b34, 0x29438b76, 0xc623cbdc, 0xfcedb668, 0xf1e4b863,
			0xdc31d7ca, 0x85634210, 0x22971340, 0x11c68420, 0x244a857d,
			0x3dbbd2f8, 0x32f9ae11, 0xa129c76d, 0x2f9e1d4b, 0x30b2dcf3,
			0x52860dec, 0xe3c177d0, 0x16b32b6c, 0xb970a999, 0x489411fa,
			0x64e94722, 0x8cfca8c4, 0x3ff0a01a, 0x2c7d56d8, 0x903322ef,
			0x4e4987c7, 0xd138d9c1, 0xa2ca8cfe, 0x0bd49836, 0x81f5a6cf,
			0xde7aa528, 0x8eb7da26, 0xbfad3fa4, 0x9d3a2ce4, 0x9278500d,
			0xcc5f6a9b, 0x467e5462, 0x138df6c2, 0xb8d890e8, 0xf7392e5e,
			0xafc382f5, 0x805d9fbe, 0x93d0697c, 0x2dd56fa9, 0x1225cfb3,
			0x99acc83b, 0x7d1810a7, 0x639ce86e, 0xbb3bdb7b, 0x7826cd09,
			0x18596ef4, 0xb79aec01, 0x9a4f83a8, 0x6e95e665, 0xe6ffaa7e,
			0xcfbc2108, 0xe815efe6, 0x9be7bad9, 0x366f4ace, 0x099fead4,
			0x7cb029d6, 0xb2a431af, 0x233f2a31, 0x94a5c630, 0x66a235c0,
			0xbc4e7437, 0xca82fca6, 0xd090e0b0, 0xd8a73315, 0x9804f14a,
			0xdaec41f7, 0x50cd7f0e, 0xf691172f, 0xd64d768d, 0xb0ef434d,
			0x4daacc54, 0x0496e4df, 0xb5d19ee3, 0x886a4c1b, 0x1f2cc1b8,
			0x5165467f, 0xea5e9d04, 0x358c015d, 0x7487fa73, 0x410bfb2e,
			0x1d67b35a, 0xd2db9252, 0x5610e933, 0x47d66d13, 0x61d79a8c,
			0x0ca1377a, 0x14f8598e, 0x3c13eb89, 0x27a9ceee, 0xc961b735,
			0xe51ce1ed, 0xb1477a3c, 0xdfd29c59, 0x73f2553f, 0xce141879,
			0x37c773bf, 0xcdf753ea, 0xaafd5f5b, 0x6f3ddf14, 0xdb447886,
			0xf3afca81, 0xc468b93e, 0x3424382c, 0x40a3c25f, 0xc31d1672,
			0x25e2bc0c, 0x493c288b, 0x950dff41, 0x01a83971, 0xb30c08de,
			0xe4b4d89c, 0xc1566490, 0x84cb7b61, 0xb632d570, 0x5c6c4874,
			0x57b8d042
		};

        private static readonly uint[] Tinv2 =
		{
			0xf45150a7, 0x417e5365, 0x171ac3a4, 0x273a965e, 0xab3bcb6b,
			0x9d1ff145, 0xfaacab58, 0xe34b9303, 0x302055fa, 0x76adf66d,
			0xcc889176, 0x02f5254c, 0xe54ffcd7, 0x2ac5d7cb, 0x35268044,
			0x62b58fa3, 0xb1de495a, 0xba25671b, 0xea45980e, 0xfe5de1c0,
			0x2fc30275, 0x4c8112f0, 0x468da397, 0xd36bc6f9, 0x8f03e75f,
			0x9215959c, 0x6dbfeb7a, 0x5295da59, 0xbed42d83, 0x7458d321,
			0xe0492969, 0xc98e44c8, 0xc2756a89, 0x8ef47879, 0x58996b3e,
			0xb927dd71, 0xe1beb64f, 0x88f017ad, 0x20c966ac, 0xce7db43a,
			0xdf63184a, 0x1ae58231, 0x51976033, 0x5362457f, 0x64b1e077,
			0x6bbb84ae, 0x81fe1ca0, 0x08f9942b, 0x48705868, 0x458f19fd,
			0xde94876c, 0x7b52b7f8, 0x73ab23d3, 0x4b72e202, 0x1fe3578f,
			0x55662aab, 0xebb20728, 0xb52f03c2, 0xc5869a7b, 0x37d3a508,
			0x2830f287, 0xbf23b2a5, 0x0302ba6a, 0x16ed5c82, 0xcf8a2b1c,
			0x79a792b4, 0x07f3f0f2, 0x694ea1e2, 0xda65cdf4, 0x0506d5be,
			0x34d11f62, 0xa6c48afe, 0x2e349d53, 0xf3a2a055, 0x8a0532e1,
			0xf6a475eb, 0x830b39ec, 0x6040aaef, 0x715e069f, 0x6ebd5110,
			0x213ef98a, 0xdd963d06, 0x3eddae05, 0xe64d46bd, 0x5491b58d,
			0xc471055d, 0x06046fd4, 0x5060ff15, 0x981924fb, 0xbdd697e9,
			0x4089cc43, 0xd967779e, 0xe8b0bd42, 0x8907888b, 0x19e7385b,
			0xc879dbee, 0x7ca1470a, 0x427ce90f, 0x84f8c91e, 0x00000000,
			0x80098386, 0x2b3248ed, 0x111eac70, 0x5a6c4e72, 0x0efdfbff,
			0x850f5638, 0xae3d1ed5, 0x2d362739, 0x0f0a64d9, 0x5c6821a6,
			0x5b9bd154, 0x36243a2e, 0x0a0cb167, 0x57930fe7, 0xeeb4d296,
			0x9b1b9e91, 0xc0804fc5, 0xdc61a220, 0x775a694b, 0x121c161a,
			0x93e20aba, 0xa0c0e52a, 0x223c43e0, 0x1b121d17, 0x090e0b0d,
			0x8bf2adc7, 0xb62db9a8, 0x1e14c8a9, 0xf1578519, 0x75af4c07,
			0x99eebbdd, 0x7fa3fd60, 0x01f79f26, 0x725cbcf5, 0x6644c53b,
			0xfb5b347e, 0x438b7629, 0x23cbdcc6, 0xedb668fc, 0xe4b863f1,
			0x31d7cadc, 0x63421085, 0x97134022, 0xc6842011, 0x4a857d24,
			0xbbd2f83d, 0xf9ae1132, 0x29c76da1, 0x9e1d4b2f, 0xb2dcf330,
			0x860dec52, 0xc177d0e3, 0xb32b6c16, 0x70a999b9, 0x9411fa48,
			0xe9472264, 0xfca8c48c, 0xf0a01a3f, 0x7d56d82c, 0x3322ef90,
			0x4987c74e, 0x38d9c1d1, 0xca8cfea2, 0xd498360b, 0xf5a6cf81,
			0x7aa528de, 0xb7da268e, 0xad3fa4bf, 0x3a2ce49d, 0x78500d92,
			0x5f6a9bcc, 0x7e546246, 0x8df6c213, 0xd890e8b8, 0x392e5ef7,
			0xc382f5af, 0x5d9fbe80, 0xd0697c93, 0xd56fa92d, 0x25cfb312,
			0xacc83b99, 0x1810a77d, 0x9ce86e63, 0x3bdb7bbb, 0x26cd0978,
			0x596ef418, 0x9aec01b7, 0x4f83a89a, 0x95e6656e, 0xffaa7ee6,
			0xbc2108cf, 0x15efe6e8, 0xe7bad99b, 0x6f4ace36, 0x9fead409,
			0xb029d67c, 0xa431afb2, 0x3f2a3123, 0xa5c63094, 0xa235c066,
			0x4e7437bc, 0x82fca6ca, 0x90e0b0d0, 0xa73315d8, 0x04f14a98,
			0xec41f7da, 0xcd7f0e50, 0x91172ff6, 0x4d768dd6, 0xef434db0,
			0xaacc544d, 0x96e4df04, 0xd19ee3b5, 0x6a4c1b88, 0x2cc1b81f,
			0x65467f51, 0x5e9d04ea, 0x8c015d35, 0x87fa7374, 0x0bfb2e41,
			0x67b35a1d, 0xdb9252d2, 0x10e93356, 0xd66d1347, 0xd79a8c61,
			0xa1377a0c, 0xf8598e14, 0x13eb893c, 0xa9ceee27, 0x61b735c9,
			0x1ce1ede5, 0x477a3cb1, 0xd29c59df, 0xf2553f73, 0x141879ce,
			0xc773bf37, 0xf753eacd, 0xfd5f5baa, 0x3ddf146f, 0x447886db,
			0xafca81f3, 0x68b93ec4, 0x24382c34, 0xa3c25f40, 0x1d1672c3,
			0xe2bc0c25, 0x3c288b49, 0x0dff4195, 0xa8397101, 0x0c08deb3,
			0xb4d89ce4, 0x566490c1, 0xcb7b6184, 0x32d570b6, 0x6c48745c,
			0xb8d04257
		};

        private static readonly uint[] Tinv3 =
		{
			0x5150a7f4, 0x7e536541, 0x1ac3a417, 0x3a965e27, 0x3bcb6bab,
			0x1ff1459d, 0xacab58fa, 0x4b9303e3, 0x2055fa30, 0xadf66d76,
			0x889176cc, 0xf5254c02, 0x4ffcd7e5, 0xc5d7cb2a, 0x26804435,
			0xb58fa362, 0xde495ab1, 0x25671bba, 0x45980eea, 0x5de1c0fe,
			0xc302752f, 0x8112f04c, 0x8da39746, 0x6bc6f9d3, 0x03e75f8f,
			0x15959c92, 0xbfeb7a6d, 0x95da5952, 0xd42d83be, 0x58d32174,
			0x492969e0, 0x8e44c8c9, 0x756a89c2, 0xf478798e, 0x996b3e58,
			0x27dd71b9, 0xbeb64fe1, 0xf017ad88, 0xc966ac20, 0x7db43ace,
			0x63184adf, 0xe582311a, 0x97603351, 0x62457f53, 0xb1e07764,
			0xbb84ae6b, 0xfe1ca081, 0xf9942b08, 0x70586848, 0x8f19fd45,
			0x94876cde, 0x52b7f87b, 0xab23d373, 0x72e2024b, 0xe3578f1f,
			0x662aab55, 0xb20728eb, 0x2f03c2b5, 0x869a7bc5, 0xd3a50837,
			0x30f28728, 0x23b2a5bf, 0x02ba6a03, 0xed5c8216, 0x8a2b1ccf,
			0xa792b479, 0xf3f0f207, 0x4ea1e269, 0x65cdf4da, 0x06d5be05,
			0xd11f6234, 0xc48afea6, 0x349d532e, 0xa2a055f3, 0x0532e18a,
			0xa475ebf6, 0x0b39ec83, 0x40aaef60, 0x5e069f71, 0xbd51106e,
			0x3ef98a21, 0x963d06dd, 0xddae053e, 0x4d46bde6, 0x91b58d54,
			0x71055dc4, 0x046fd406, 0x60ff1550, 0x1924fb98, 0xd697e9bd,
			0x89cc4340, 0x67779ed9, 0xb0bd42e8, 0x07888b89, 0xe7385b19,
			0x79dbeec8, 0xa1470a7c, 0x7ce90f42, 0xf8c91e84, 0x00000000,
			0x09838680, 0x3248ed2b, 0x1eac7011, 0x6c4e725a, 0xfdfbff0e,
			0x0f563885, 0x3d1ed5ae, 0x3627392d, 0x0a64d90f, 0x6821a65c,
			0x9bd1545b, 0x243a2e36, 0x0cb1670a, 0x930fe757, 0xb4d296ee,
			0x1b9e919b, 0x804fc5c0, 0x61a220dc, 0x5a694b77, 0x1c161a12,
			0xe20aba93, 0xc0e52aa0, 0x3c43e022, 0x121d171b, 0x0e0b0d09,
			0xf2adc78b, 0x2db9a8b6, 0x14c8a91e, 0x578519f1, 0xaf4c0775,
			0xeebbdd99, 0xa3fd607f, 0xf79f2601, 0x5cbcf572, 0x44c53b66,
			0x5b347efb, 0x8b762943, 0xcbdcc623, 0xb668fced, 0xb863f1e4,
			0xd7cadc31, 0x42108563, 0x13402297, 0x842011c6, 0x857d244a,
			0xd2f83dbb, 0xae1132f9, 0xc76da129, 0x1d4b2f9e, 0xdcf330b2,
			0x0dec5286, 0x77d0e3c1, 0x2b6c16b3, 0xa999b970, 0x11fa4894,
			0x472264e9, 0xa8c48cfc, 0xa01a3ff0, 0x56d82c7d, 0x22ef9033,
			0x87c74e49, 0xd9c1d138, 0x8cfea2ca, 0x98360bd4, 0xa6cf81f5,
			0xa528de7a, 0xda268eb7, 0x3fa4bfad, 0x2ce49d3a, 0x500d9278,
			0x6a9bcc5f, 0x5462467e, 0xf6c2138d, 0x90e8b8d8, 0x2e5ef739,
			0x82f5afc3, 0x9fbe805d, 0x697c93d0, 0x6fa92dd5, 0xcfb31225,
			0xc83b99ac, 0x10a77d18, 0xe86e639c, 0xdb7bbb3b, 0xcd097826,
			0x6ef41859, 0xec01b79a, 0x83a89a4f, 0xe6656e95, 0xaa7ee6ff,
			0x2108cfbc, 0xefe6e815, 0xbad99be7, 0x4ace366f, 0xead4099f,
			0x29d67cb0, 0x31afb2a4, 0x2a31233f, 0xc63094a5, 0x35c066a2,
			0x7437bc4e, 0xfca6ca82, 0xe0b0d090, 0x3315d8a7, 0xf14a9804,
			0x41f7daec, 0x7f0e50cd, 0x172ff691, 0x768dd64d, 0x434db0ef,
			0xcc544daa, 0xe4df0496, 0x9ee3b5d1, 0x4c1b886a, 0xc1b81f2c,
			0x467f5165, 0x9d04ea5e, 0x015d358c, 0xfa737487, 0xfb2e410b,
			0xb35a1d67, 0x9252d2db, 0xe9335610, 0x6d1347d6, 0x9a8c61d7,
			0x377a0ca1, 0x598e14f8, 0xeb893c13, 0xceee27a9, 0xb735c961,
			0xe1ede51c, 0x7a3cb147, 0x9c59dfd2, 0x553f73f2, 0x1879ce14,
			0x73bf37c7, 0x53eacdf7, 0x5f5baafd, 0xdf146f3d, 0x7886db44,
			0xca81f3af, 0xb93ec468, 0x382c3424, 0xc25f40a3, 0x1672c31d,
			0xbc0c25e2, 0x288b493c, 0xff41950d, 0x397101a8, 0x08deb30c,
			0xd89ce4b4, 0x6490c156, 0x7b6184cb, 0xd570b632, 0x48745c6c,
			0xd04257b8
		};

        #endregion

        /// <summary>
        /// Initializes a new instance of the <see cref="AesCipher"/> class.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <param name="mode">The mode.</param>
        /// <param name="padding">The padding.</param>
        /// <exception cref="ArgumentNullException"><paramref name="key"/> is null.</exception>
        /// <exception cref="ArgumentException">Keysize is not valid for this algorithm.</exception>
        public AesCipher(byte[] key, CipherModeRenci mode, CipherPadding padding)
            : base(key, 16, mode, padding)
        {
            var keySize = key.Length * 8;

            if (!(keySize == 256 || keySize == 192 || keySize == 128))
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "KeySize '{0}' is not valid for this algorithm.", keySize));
        }

        /// <summary>
        /// Encrypts the specified region of the input byte array and copies the encrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to encrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write encrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes encrypted.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="inputBuffer"/> or <paramref name="outputBuffer"/> is null.</exception>
        /// <exception cref="IndexOutOfRangeException"><paramref name="inputBuffer"/> or <paramref name="outputBuffer"/> is too short.</exception>
        public override int EncryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            if (inputBuffer == null)
                throw new ArgumentNullException("inputBuffer");

            if (outputBuffer == null)
                throw new ArgumentNullException("outputBuffer");

            if ((inputOffset + (32 / 2)) > inputBuffer.Length)
            {
                throw new IndexOutOfRangeException("input buffer too short");
            }

            if ((outputOffset + (32 / 2)) > outputBuffer.Length)
            {
                throw new IndexOutOfRangeException("output buffer too short");
            }

            if (this._encryptionKey == null)
            {
                this._encryptionKey = this.GenerateWorkingKey(true, this.Key);
            }

            this.UnPackBlock(inputBuffer, inputOffset);

            this.EncryptBlock(this._encryptionKey);

            this.PackBlock(outputBuffer, outputOffset);

            return this.BlockSize;
        }

        /// <summary>
        /// Decrypts the specified region of the input byte array and copies the decrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to decrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write decrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes decrypted.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="inputBuffer"/> or <paramref name="outputBuffer"/> is null.</exception>
        /// <exception cref="IndexOutOfRangeException"><paramref name="inputBuffer"/> or <paramref name="outputBuffer"/> is too short.</exception>
        public override int DecryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            if (inputBuffer == null)
                throw new ArgumentNullException("inputBuffer");

            if (outputBuffer == null)
                throw new ArgumentNullException("outputBuffer");

            if ((inputOffset + (32 / 2)) > inputBuffer.Length)
            {
                throw new IndexOutOfRangeException("input buffer too short");
            }

            if ((outputOffset + (32 / 2)) > outputBuffer.Length)
            {
                throw new IndexOutOfRangeException("output buffer too short");
            }

            if (this._decryptionKey == null)
            {
                this._decryptionKey = this.GenerateWorkingKey(false, this.Key);
            }

            this.UnPackBlock(inputBuffer, inputOffset);

            this.DecryptBlock(this._decryptionKey);

            this.PackBlock(outputBuffer, outputOffset);

            return this.BlockSize;
        }

        private uint[] GenerateWorkingKey(bool isEncryption, byte[] key)
        {
            int KC = key.Length / 4;  // key length in words

            if (((KC != 4) && (KC != 6) && (KC != 8)) || ((KC * 4) != key.Length))
                throw new ArgumentException("Key length not 128/192/256 bits.");

            _rounds = KC + 6;  // This is not always true for the generalized Rijndael that allows larger block sizes
            uint[] W = new uint[(_rounds + 1) *  4];   // 4 words in a block

            //
            // copy the key into the round key array
            //

            int t = 0;

            for (int i = 0; i < key.Length; t++)
            {
                W[(t >> 2) * 4 + (t & 3)] = LittleEndianToUInt32(key, i);
                i += 4;
            }

            //
            // while not enough round key material calculated
            // calculate new values
            //
            int k = (_rounds + 1) << 2;
            for (int i = KC; (i < k); i++)
            {
                uint temp = W[((i - 1) >> 2) * 4 + ((i - 1) & 3)];
                if ((i % KC) == 0)
                {
                    temp = SubWord(Shift(temp, 8)) ^ rcon[(i / KC) - 1];
                }
                else if ((KC > 6) && ((i % KC) == 4))
                {
                    temp = SubWord(temp);
                }

                W[(i >> 2) * 4 + (i & 3)] = W[((i - KC) >> 2) * 4 + ((i - KC) & 3)] ^ temp;
            }

            if (!isEncryption)
            {
                for (int j = 1; j < _rounds; j++)
                {
                    for (int i = 0; i < 4; i++)
                    {
                        W[j * 4 + i] = InvMcol(W[j * 4 + i]);
                    }
                }
            }

            return W;
        }

        private uint Shift(uint r, int shift)
        {
            return (r >> shift) | (r << (32 - shift));
        }

        private uint FFmulX(uint x)
        {
            return ((x & m2) << 1) ^ (((x & m1) >> 7) * m3);
        }

        private uint InvMcol(uint x)
        {
            uint f2 = FFmulX(x);
            uint f4 = FFmulX(f2);
            uint f8 = FFmulX(f4);
            uint f9 = x ^ f8;

            return f2 ^ f4 ^ f8 ^ Shift(f2 ^ f9, 8) ^ Shift(f4 ^ f9, 16) ^ Shift(f9, 24);
        }

        private uint SubWord(uint x)
        {
            return (uint)S[x & 255]
                | (((uint)S[(x >> 8) & 255]) << 8)
                | (((uint)S[(x >> 16) & 255]) << 16)
                | (((uint)S[(x >> 24) & 255]) << 24);
        }

        private void UnPackBlock(byte[] bytes, int off)
        {
            C0 = LittleEndianToUInt32(bytes, off);
            C1 = LittleEndianToUInt32(bytes, off + 4);
            C2 = LittleEndianToUInt32(bytes, off + 8);
            C3 = LittleEndianToUInt32(bytes, off + 12);
        }

        private void PackBlock(byte[] bytes, int off)
        {
            UInt32ToLittleEndian(C0, bytes, off);
            UInt32ToLittleEndian(C1, bytes, off + 4);
            UInt32ToLittleEndian(C2, bytes, off + 8);
            UInt32ToLittleEndian(C3, bytes, off + 12);
        }

        private void EncryptBlock(uint[] KW)
        {
            int r;
            uint r0, r1, r2, r3;

            C0 ^= KW[0 * 4 + 0];
            C1 ^= KW[0 * 4 + 1];
            C2 ^= KW[0 * 4 + 2];
            C3 ^= KW[0 * 4 + 3];

            for (r = 1; r < _rounds - 1; )
            {
                r0 = T0[C0 & 255] ^ T1[(C1 >> 8) & 255] ^ T2[(C2 >> 16) & 255] ^ T3[C3 >> 24] ^ KW[r * 4 + 0];
                r1 = T0[C1 & 255] ^ T1[(C2 >> 8) & 255] ^ T2[(C3 >> 16) & 255] ^ T3[C0 >> 24] ^ KW[r * 4 + 1];
                r2 = T0[C2 & 255] ^ T1[(C3 >> 8) & 255] ^ T2[(C0 >> 16) & 255] ^ T3[C1 >> 24] ^ KW[r * 4 + 2];
                r3 = T0[C3 & 255] ^ T1[(C0 >> 8) & 255] ^ T2[(C1 >> 16) & 255] ^ T3[C2 >> 24] ^ KW[r++ * 4 + 3];
                C0 = T0[r0 & 255] ^ T1[(r1 >> 8) & 255] ^ T2[(r2 >> 16) & 255] ^ T3[r3 >> 24] ^ KW[r * 4 + 0];
                C1 = T0[r1 & 255] ^ T1[(r2 >> 8) & 255] ^ T2[(r3 >> 16) & 255] ^ T3[r0 >> 24] ^ KW[r * 4 + 1];
                C2 = T0[r2 & 255] ^ T1[(r3 >> 8) & 255] ^ T2[(r0 >> 16) & 255] ^ T3[r1 >> 24] ^ KW[r * 4 + 2];
                C3 = T0[r3 & 255] ^ T1[(r0 >> 8) & 255] ^ T2[(r1 >> 16) & 255] ^ T3[r2 >> 24] ^ KW[r++ * 4 + 3];
            }

            r0 = T0[C0 & 255] ^ T1[(C1 >> 8) & 255] ^ T2[(C2 >> 16) & 255] ^ T3[C3 >> 24] ^ KW[r * 4 + 0];
            r1 = T0[C1 & 255] ^ T1[(C2 >> 8) & 255] ^ T2[(C3 >> 16) & 255] ^ T3[C0 >> 24] ^ KW[r * 4 + 1];
            r2 = T0[C2 & 255] ^ T1[(C3 >> 8) & 255] ^ T2[(C0 >> 16) & 255] ^ T3[C1 >> 24] ^ KW[r * 4 + 2];
            r3 = T0[C3 & 255] ^ T1[(C0 >> 8) & 255] ^ T2[(C1 >> 16) & 255] ^ T3[C2 >> 24] ^ KW[r++ * 4 + 3];

            // the final round's table is a simple function of S so we don't use a whole other four tables for it

            C0 = (uint)S[r0 & 255] ^ (((uint)S[(r1 >> 8) & 255]) << 8) ^ (((uint)S[(r2 >> 16) & 255]) << 16) ^ (((uint)S[r3 >> 24]) << 24) ^ KW[r * 4 + 0];
            C1 = (uint)S[r1 & 255] ^ (((uint)S[(r2 >> 8) & 255]) << 8) ^ (((uint)S[(r3 >> 16) & 255]) << 16) ^ (((uint)S[r0 >> 24]) << 24) ^ KW[r * 4 + 1];
            C2 = (uint)S[r2 & 255] ^ (((uint)S[(r3 >> 8) & 255]) << 8) ^ (((uint)S[(r0 >> 16) & 255]) << 16) ^ (((uint)S[r1 >> 24]) << 24) ^ KW[r * 4 + 2];
            C3 = (uint)S[r3 & 255] ^ (((uint)S[(r0 >> 8) & 255]) << 8) ^ (((uint)S[(r1 >> 16) & 255]) << 16) ^ (((uint)S[r2 >> 24]) << 24) ^ KW[r * 4 + 3];
        }

        private void DecryptBlock(uint[] KW)
        {
            int r;
            uint r0, r1, r2, r3;

            C0 ^= KW[_rounds * 4 + 0];
            C1 ^= KW[_rounds * 4 + 1];
            C2 ^= KW[_rounds * 4 + 2];
            C3 ^= KW[_rounds * 4 + 3];

            for (r = _rounds - 1; r > 1; )
            {
                r0 = Tinv0[C0 & 255] ^ Tinv1[(C3 >> 8) & 255] ^ Tinv2[(C2 >> 16) & 255] ^ Tinv3[C1 >> 24] ^ KW[r * 4 + 0];
                r1 = Tinv0[C1 & 255] ^ Tinv1[(C0 >> 8) & 255] ^ Tinv2[(C3 >> 16) & 255] ^ Tinv3[C2 >> 24] ^ KW[r * 4 + 1];
                r2 = Tinv0[C2 & 255] ^ Tinv1[(C1 >> 8) & 255] ^ Tinv2[(C0 >> 16) & 255] ^ Tinv3[C3 >> 24] ^ KW[r * 4 + 2];
                r3 = Tinv0[C3 & 255] ^ Tinv1[(C2 >> 8) & 255] ^ Tinv2[(C1 >> 16) & 255] ^ Tinv3[C0 >> 24] ^ KW[r-- * 4 + 3];
                C0 = Tinv0[r0 & 255] ^ Tinv1[(r3 >> 8) & 255] ^ Tinv2[(r2 >> 16) & 255] ^ Tinv3[r1 >> 24] ^ KW[r * 4 + 0];
                C1 = Tinv0[r1 & 255] ^ Tinv1[(r0 >> 8) & 255] ^ Tinv2[(r3 >> 16) & 255] ^ Tinv3[r2 >> 24] ^ KW[r * 4 + 1];
                C2 = Tinv0[r2 & 255] ^ Tinv1[(r1 >> 8) & 255] ^ Tinv2[(r0 >> 16) & 255] ^ Tinv3[r3 >> 24] ^ KW[r * 4 + 2];
                C3 = Tinv0[r3 & 255] ^ Tinv1[(r2 >> 8) & 255] ^ Tinv2[(r1 >> 16) & 255] ^ Tinv3[r0 >> 24] ^ KW[r-- * 4 + 3];
            }

            r0 = Tinv0[C0 & 255] ^ Tinv1[(C3 >> 8) & 255] ^ Tinv2[(C2 >> 16) & 255] ^ Tinv3[C1 >> 24] ^ KW[r * 4 + 0];
            r1 = Tinv0[C1 & 255] ^ Tinv1[(C0 >> 8) & 255] ^ Tinv2[(C3 >> 16) & 255] ^ Tinv3[C2 >> 24] ^ KW[r * 4 + 1];
            r2 = Tinv0[C2 & 255] ^ Tinv1[(C1 >> 8) & 255] ^ Tinv2[(C0 >> 16) & 255] ^ Tinv3[C3 >> 24] ^ KW[r * 4 + 2];
            r3 = Tinv0[C3 & 255] ^ Tinv1[(C2 >> 8) & 255] ^ Tinv2[(C1 >> 16) & 255] ^ Tinv3[C0 >> 24] ^ KW[r * 4 + 3];

            // the final round's table is a simple function of Si so we don't use a whole other four tables for it

            C0 = (uint)Si[r0 & 255] ^ (((uint)Si[(r3 >> 8) & 255]) << 8) ^ (((uint)Si[(r2 >> 16) & 255]) << 16) ^ (((uint)Si[r1 >> 24]) << 24) ^ KW[0 * 4 + 0];
            C1 = (uint)Si[r1 & 255] ^ (((uint)Si[(r0 >> 8) & 255]) << 8) ^ (((uint)Si[(r3 >> 16) & 255]) << 16) ^ (((uint)Si[r2 >> 24]) << 24) ^ KW[0 * 4 + 1];
            C2 = (uint)Si[r2 & 255] ^ (((uint)Si[(r1 >> 8) & 255]) << 8) ^ (((uint)Si[(r0 >> 16) & 255]) << 16) ^ (((uint)Si[r3 >> 24]) << 24) ^ KW[0 * 4 + 2];
            C3 = (uint)Si[r3 & 255] ^ (((uint)Si[(r2 >> 8) & 255]) << 8) ^ (((uint)Si[(r1 >> 16) & 255]) << 16) ^ (((uint)Si[r0 >> 24]) << 24) ^ KW[0 * 4 + 3];
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Ciphers\Arc4Cipher.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography.Ciphers
{
    /// <summary>
    /// Implements ARCH4 cipher algorithm
    /// </summary>
    public sealed class Arc4Cipher : StreamCipher
    {
        private static readonly int STATE_LENGTH = 256;

        /// <summary>
        ///  Holds the state of the RC4 engine
        /// </summary>
        private byte[] _engineState;

        private int _x;

        private int _y;

        private byte[] _workingKey;

        /// <summary>
        /// Gets the minimum data size.
        /// </summary>
        /// <value>
        /// The minimum data size.
        /// </value>
        public override byte MinimumSize
        {
            get { return 0; }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Arc4Cipher" /> class.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <param name="dischargeFirstBytes">if set to <c>true</c> will disharged first 1536 bytes.</param>
        /// <exception cref="ArgumentNullException"><paramref name="key" /> is null.</exception>
        public Arc4Cipher(byte[] key, bool dischargeFirstBytes)
            : base(key)
        {
            this._workingKey = key;
            SetKey(this._workingKey);
            //   The first 1536 bytes of keystream
            //   generated by the cipher MUST be discarded, and the first byte of the
            //   first encrypted packet MUST be encrypted using the 1537th byte of
            //   keystream.
            if (dischargeFirstBytes)
                this.Encrypt(new byte[1536]);
        }

        /// <summary>
        /// Encrypts the specified region of the input byte array and copies the encrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to encrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write encrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes encrypted.
        /// </returns>
        public override int EncryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            return this.ProcessBytes(inputBuffer, inputOffset, inputCount, outputBuffer, outputOffset);
        }

        /// <summary>
        /// Decrypts the specified region of the input byte array and copies the decrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to decrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write decrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes decrypted.
        /// </returns>
        public override int DecryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            return this.ProcessBytes(inputBuffer, inputOffset, inputCount, outputBuffer, outputOffset);
        }

        /// <summary>
        /// Encrypts the specified input.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <returns>
        /// Encrypted data.
        /// </returns>
        /// <exception cref="System.NotImplementedException"></exception>
        public override byte[] Encrypt(byte[] input)
        {
            var output = new byte[input.Length];
            this.ProcessBytes(input, 0, input.Length, output, 0);
            return output;
        }

        /// <summary>
        /// Decrypts the specified input.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <returns>
        /// Decrypted data.
        /// </returns>
        /// <exception cref="System.NotImplementedException"></exception>
        public override byte[] Decrypt(byte[] input)
        {
            var output = new byte[input.Length];
            this.ProcessBytes(input, 0, input.Length, output, 0);
            return output;
        }

        private int ProcessBytes(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            if ((inputOffset + inputCount) > inputBuffer.Length)
            {
                throw new IndexOutOfRangeException("input buffer too short");
            }

            if ((outputOffset + inputCount) > outputBuffer.Length)
            {
                throw new IndexOutOfRangeException("output buffer too short");
            }

            for (int i = 0; i < inputCount; i++)
            {
                this._x = (this._x + 1) & 0xff;
                this._y = (this._engineState[this._x] + this._y) & 0xff;

                // swap
                byte tmp = this._engineState[this._x];
                this._engineState[this._x] = this._engineState[this._y];
                this._engineState[this._y] = tmp;

                // xor
                outputBuffer[i + outputOffset] = (byte)(inputBuffer[i + inputOffset] ^ this._engineState[(this._engineState[this._x] + this._engineState[this._y]) & 0xff]);
            }
            return inputCount;
        }

        private void SetKey(byte[] keyBytes)
        {
            this._workingKey = keyBytes;

            this._x = 0;
            this._y = 0;

            if (this._engineState == null)
            {
                this._engineState = new byte[STATE_LENGTH];
            }

            // reset the state of the engine
            for (var i = 0; i < STATE_LENGTH; i++)
            {
                this._engineState[i] = (byte) i;
            }

            int i1 = 0;
            int i2 = 0;

            for (var i = 0; i < STATE_LENGTH; i++)
            {
                i2 = ((keyBytes[i1] & 0xff) + this._engineState[i] + i2) & 0xff;
                // do the byte-swap inline
                byte tmp = this._engineState[i];
                this._engineState[i] = this._engineState[i2];
                this._engineState[i2] = tmp;
                i1 = (i1 + 1) % keyBytes.Length;
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Ciphers\BlowfishCipher.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography.Ciphers
{
	/// <summary>
    /// Blowfish cipher implementation.
    /// </summary>
	public sealed class BlowfishCipher : BlockCipher
	{
		#region Static reference tables

		private readonly static uint[] KP =
		{
			0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344,
			0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89,
			0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C,
			0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917,
			0x9216D5D9, 0x8979FB1B
		},
		KS0 =
		{
			0xD1310BA6, 0x98DFB5AC, 0x2FFD72DB, 0xD01ADFB7,
			0xB8E1AFED, 0x6A267E96, 0xBA7C9045, 0xF12C7F99,
			0x24A19947, 0xB3916CF7, 0x0801F2E2, 0x858EFC16,
			0x636920D8, 0x71574E69, 0xA458FEA3, 0xF4933D7E,
			0x0D95748F, 0x728EB658, 0x718BCD58, 0x82154AEE,
			0x7B54A41D, 0xC25A59B5, 0x9C30D539, 0x2AF26013,
			0xC5D1B023, 0x286085F0, 0xCA417918, 0xB8DB38EF,
			0x8E79DCB0, 0x603A180E, 0x6C9E0E8B, 0xB01E8A3E,
			0xD71577C1, 0xBD314B27, 0x78AF2FDA, 0x55605C60,
			0xE65525F3, 0xAA55AB94, 0x57489862, 0x63E81440,
			0x55CA396A, 0x2AAB10B6, 0xB4CC5C34, 0x1141E8CE,
			0xA15486AF, 0x7C72E993, 0xB3EE1411, 0x636FBC2A,
			0x2BA9C55D, 0x741831F6, 0xCE5C3E16, 0x9B87931E,
			0xAFD6BA33, 0x6C24CF5C, 0x7A325381, 0x28958677,
			0x3B8F4898, 0x6B4BB9AF, 0xC4BFE81B, 0x66282193,
			0x61D809CC, 0xFB21A991, 0x487CAC60, 0x5DEC8032,
			0xEF845D5D, 0xE98575B1, 0xDC262302, 0xEB651B88,
			0x23893E81, 0xD396ACC5, 0x0F6D6FF3, 0x83F44239,
			0x2E0B4482, 0xA4842004, 0x69C8F04A, 0x9E1F9B5E,
			0x21C66842, 0xF6E96C9A, 0x670C9C61, 0xABD388F0,
			0x6A51A0D2, 0xD8542F68, 0x960FA728, 0xAB5133A3,
			0x6EEF0B6C, 0x137A3BE4, 0xBA3BF050, 0x7EFB2A98,
			0xA1F1651D, 0x39AF0176, 0x66CA593E, 0x82430E88,
			0x8CEE8619, 0x456F9FB4, 0x7D84A5C3, 0x3B8B5EBE,
			0xE06F75D8, 0x85C12073, 0x401A449F, 0x56C16AA6,
			0x4ED3AA62, 0x363F7706, 0x1BFEDF72, 0x429B023D,
			0x37D0D724, 0xD00A1248, 0xDB0FEAD3, 0x49F1C09B,
			0x075372C9, 0x80991B7B, 0x25D479D8, 0xF6E8DEF7,
			0xE3FE501A, 0xB6794C3B, 0x976CE0BD, 0x04C006BA,
			0xC1A94FB6, 0x409F60C4, 0x5E5C9EC2, 0x196A2463,
			0x68FB6FAF, 0x3E6C53B5, 0x1339B2EB, 0x3B52EC6F,
			0x6DFC511F, 0x9B30952C, 0xCC814544, 0xAF5EBD09,
			0xBEE3D004, 0xDE334AFD, 0x660F2807, 0x192E4BB3,
			0xC0CBA857, 0x45C8740F, 0xD20B5F39, 0xB9D3FBDB,
			0x5579C0BD, 0x1A60320A, 0xD6A100C6, 0x402C7279,
			0x679F25FE, 0xFB1FA3CC, 0x8EA5E9F8, 0xDB3222F8,
			0x3C7516DF, 0xFD616B15, 0x2F501EC8, 0xAD0552AB,
			0x323DB5FA, 0xFD238760, 0x53317B48, 0x3E00DF82,
			0x9E5C57BB, 0xCA6F8CA0, 0x1A87562E, 0xDF1769DB,
			0xD542A8F6, 0x287EFFC3, 0xAC6732C6, 0x8C4F5573,
			0x695B27B0, 0xBBCA58C8, 0xE1FFA35D, 0xB8F011A0,
			0x10FA3D98, 0xFD2183B8, 0x4AFCB56C, 0x2DD1D35B,
			0x9A53E479, 0xB6F84565, 0xD28E49BC, 0x4BFB9790,
			0xE1DDF2DA, 0xA4CB7E33, 0x62FB1341, 0xCEE4C6E8,
			0xEF20CADA, 0x36774C01, 0xD07E9EFE, 0x2BF11FB4,
			0x95DBDA4D, 0xAE909198, 0xEAAD8E71, 0x6B93D5A0,
			0xD08ED1D0, 0xAFC725E0, 0x8E3C5B2F, 0x8E7594B7,
			0x8FF6E2FB, 0xF2122B64, 0x8888B812, 0x900DF01C,
			0x4FAD5EA0, 0x688FC31C, 0xD1CFF191, 0xB3A8C1AD,
			0x2F2F2218, 0xBE0E1777, 0xEA752DFE, 0x8B021FA1,
			0xE5A0CC0F, 0xB56F74E8, 0x18ACF3D6, 0xCE89E299,
			0xB4A84FE0, 0xFD13E0B7, 0x7CC43B81, 0xD2ADA8D9,
			0x165FA266, 0x80957705, 0x93CC7314, 0x211A1477,
			0xE6AD2065, 0x77B5FA86, 0xC75442F5, 0xFB9D35CF,
			0xEBCDAF0C, 0x7B3E89A0, 0xD6411BD3, 0xAE1E7E49,
			0x00250E2D, 0x2071B35E, 0x226800BB, 0x57B8E0AF,
			0x2464369B, 0xF009B91E, 0x5563911D, 0x59DFA6AA,
			0x78C14389, 0xD95A537F, 0x207D5BA2, 0x02E5B9C5,
			0x83260376, 0x6295CFA9, 0x11C81968, 0x4E734A41,
			0xB3472DCA, 0x7B14A94A, 0x1B510052, 0x9A532915,
			0xD60F573F, 0xBC9BC6E4, 0x2B60A476, 0x81E67400,
			0x08BA6FB5, 0x571BE91F, 0xF296EC6B, 0x2A0DD915,
			0xB6636521, 0xE7B9F9B6, 0xFF34052E, 0xC5855664,
			0x53B02D5D, 0xA99F8FA1, 0x08BA4799, 0x6E85076A
		},
		KS1 =
		{
			0x4B7A70E9, 0xB5B32944, 0xDB75092E, 0xC4192623,
			0xAD6EA6B0, 0x49A7DF7D, 0x9CEE60B8, 0x8FEDB266,
			0xECAA8C71, 0x699A17FF, 0x5664526C, 0xC2B19EE1,
			0x193602A5, 0x75094C29, 0xA0591340, 0xE4183A3E,
			0x3F54989A, 0x5B429D65, 0x6B8FE4D6, 0x99F73FD6,
			0xA1D29C07, 0xEFE830F5, 0x4D2D38E6, 0xF0255DC1,
			0x4CDD2086, 0x8470EB26, 0x6382E9C6, 0x021ECC5E,
			0x09686B3F, 0x3EBAEFC9, 0x3C971814, 0x6B6A70A1,
			0x687F3584, 0x52A0E286, 0xB79C5305, 0xAA500737,
			0x3E07841C, 0x7FDEAE5C, 0x8E7D44EC, 0x5716F2B8,
			0xB03ADA37, 0xF0500C0D, 0xF01C1F04, 0x0200B3FF,
			0xAE0CF51A, 0x3CB574B2, 0x25837A58, 0xDC0921BD,
			0xD19113F9, 0x7CA92FF6, 0x94324773, 0x22F54701,
			0x3AE5E581, 0x37C2DADC, 0xC8B57634, 0x9AF3DDA7,
			0xA9446146, 0x0FD0030E, 0xECC8C73E, 0xA4751E41,
			0xE238CD99, 0x3BEA0E2F, 0x3280BBA1, 0x183EB331,
			0x4E548B38, 0x4F6DB908, 0x6F420D03, 0xF60A04BF,
			0x2CB81290, 0x24977C79, 0x5679B072, 0xBCAF89AF,
			0xDE9A771F, 0xD9930810, 0xB38BAE12, 0xDCCF3F2E,
			0x5512721F, 0x2E6B7124, 0x501ADDE6, 0x9F84CD87,
			0x7A584718, 0x7408DA17, 0xBC9F9ABC, 0xE94B7D8C,
			0xEC7AEC3A, 0xDB851DFA, 0x63094366, 0xC464C3D2,
			0xEF1C1847, 0x3215D908, 0xDD433B37, 0x24C2BA16,
			0x12A14D43, 0x2A65C451, 0x50940002, 0x133AE4DD,
			0x71DFF89E, 0x10314E55, 0x81AC77D6, 0x5F11199B,
			0x043556F1, 0xD7A3C76B, 0x3C11183B, 0x5924A509,
			0xF28FE6ED, 0x97F1FBFA, 0x9EBABF2C, 0x1E153C6E,
			0x86E34570, 0xEAE96FB1, 0x860E5E0A, 0x5A3E2AB3,
			0x771FE71C, 0x4E3D06FA, 0x2965DCB9, 0x99E71D0F,
			0x803E89D6, 0x5266C825, 0x2E4CC978, 0x9C10B36A,
			0xC6150EBA, 0x94E2EA78, 0xA5FC3C53, 0x1E0A2DF4,
			0xF2F74EA7, 0x361D2B3D, 0x1939260F, 0x19C27960,
			0x5223A708, 0xF71312B6, 0xEBADFE6E, 0xEAC31F66,
			0xE3BC4595, 0xA67BC883, 0xB17F37D1, 0x018CFF28,
			0xC332DDEF, 0xBE6C5AA5, 0x65582185, 0x68AB9802,
			0xEECEA50F, 0xDB2F953B, 0x2AEF7DAD, 0x5B6E2F84,
			0x1521B628, 0x29076170, 0xECDD4775, 0x619F1510,
			0x13CCA830, 0xEB61BD96, 0x0334FE1E, 0xAA0363CF,
			0xB5735C90, 0x4C70A239, 0xD59E9E0B, 0xCBAADE14,
			0xEECC86BC, 0x60622CA7, 0x9CAB5CAB, 0xB2F3846E,
			0x648B1EAF, 0x19BDF0CA, 0xA02369B9, 0x655ABB50,
			0x40685A32, 0x3C2AB4B3, 0x319EE9D5, 0xC021B8F7,
			0x9B540B19, 0x875FA099, 0x95F7997E, 0x623D7DA8,
			0xF837889A, 0x97E32D77, 0x11ED935F, 0x16681281,
			0x0E358829, 0xC7E61FD6, 0x96DEDFA1, 0x7858BA99,
			0x57F584A5, 0x1B227263, 0x9B83C3FF, 0x1AC24696,
			0xCDB30AEB, 0x532E3054, 0x8FD948E4, 0x6DBC3128,
			0x58EBF2EF, 0x34C6FFEA, 0xFE28ED61, 0xEE7C3C73,
			0x5D4A14D9, 0xE864B7E3, 0x42105D14, 0x203E13E0,
			0x45EEE2B6, 0xA3AAABEA, 0xDB6C4F15, 0xFACB4FD0,
			0xC742F442, 0xEF6ABBB5, 0x654F3B1D, 0x41CD2105,
			0xD81E799E, 0x86854DC7, 0xE44B476A, 0x3D816250,
			0xCF62A1F2, 0x5B8D2646, 0xFC8883A0, 0xC1C7B6A3,
			0x7F1524C3, 0x69CB7492, 0x47848A0B, 0x5692B285,
			0x095BBF00, 0xAD19489D, 0x1462B174, 0x23820E00,
			0x58428D2A, 0x0C55F5EA, 0x1DADF43E, 0x233F7061,
			0x3372F092, 0x8D937E41, 0xD65FECF1, 0x6C223BDB,
			0x7CDE3759, 0xCBEE7460, 0x4085F2A7, 0xCE77326E,
			0xA6078084, 0x19F8509E, 0xE8EFD855, 0x61D99735,
			0xA969A7AA, 0xC50C06C2, 0x5A04ABFC, 0x800BCADC,
			0x9E447A2E, 0xC3453484, 0xFDD56705, 0x0E1E9EC9,
			0xDB73DBD3, 0x105588CD, 0x675FDA79, 0xE3674340,
			0xC5C43465, 0x713E38D8, 0x3D28F89E, 0xF16DFF20,
			0x153E21E7, 0x8FB03D4A, 0xE6E39F2B, 0xDB83ADF7
		},
		KS2 =
		{
			0xE93D5A68, 0x948140F7, 0xF64C261C, 0x94692934,
			0x411520F7, 0x7602D4F7, 0xBCF46B2E, 0xD4A20068,
			0xD4082471, 0x3320F46A, 0x43B7D4B7, 0x500061AF,
			0x1E39F62E, 0x97244546, 0x14214F74, 0xBF8B8840,
			0x4D95FC1D, 0x96B591AF, 0x70F4DDD3, 0x66A02F45,
			0xBFBC09EC, 0x03BD9785, 0x7FAC6DD0, 0x31CB8504,
			0x96EB27B3, 0x55FD3941, 0xDA2547E6, 0xABCA0A9A,
			0x28507825, 0x530429F4, 0x0A2C86DA, 0xE9B66DFB,
			0x68DC1462, 0xD7486900, 0x680EC0A4, 0x27A18DEE,
			0x4F3FFEA2, 0xE887AD8C, 0xB58CE006, 0x7AF4D6B6,
			0xAACE1E7C, 0xD3375FEC, 0xCE78A399, 0x406B2A42,
			0x20FE9E35, 0xD9F385B9, 0xEE39D7AB, 0x3B124E8B,
			0x1DC9FAF7, 0x4B6D1856, 0x26A36631, 0xEAE397B2,
			0x3A6EFA74, 0xDD5B4332, 0x6841E7F7, 0xCA7820FB,
			0xFB0AF54E, 0xD8FEB397, 0x454056AC, 0xBA489527,
			0x55533A3A, 0x20838D87, 0xFE6BA9B7, 0xD096954B,
			0x55A867BC, 0xA1159A58, 0xCCA92963, 0x99E1DB33,
			0xA62A4A56, 0x3F3125F9, 0x5EF47E1C, 0x9029317C,
			0xFDF8E802, 0x04272F70, 0x80BB155C, 0x05282CE3,
			0x95C11548, 0xE4C66D22, 0x48C1133F, 0xC70F86DC,
			0x07F9C9EE, 0x41041F0F, 0x404779A4, 0x5D886E17,
			0x325F51EB, 0xD59BC0D1, 0xF2BCC18F, 0x41113564,
			0x257B7834, 0x602A9C60, 0xDFF8E8A3, 0x1F636C1B,
			0x0E12B4C2, 0x02E1329E, 0xAF664FD1, 0xCAD18115,
			0x6B2395E0, 0x333E92E1, 0x3B240B62, 0xEEBEB922,
			0x85B2A20E, 0xE6BA0D99, 0xDE720C8C, 0x2DA2F728,
			0xD0127845, 0x95B794FD, 0x647D0862, 0xE7CCF5F0,
			0x5449A36F, 0x877D48FA, 0xC39DFD27, 0xF33E8D1E,
			0x0A476341, 0x992EFF74, 0x3A6F6EAB, 0xF4F8FD37,
			0xA812DC60, 0xA1EBDDF8, 0x991BE14C, 0xDB6E6B0D,
			0xC67B5510, 0x6D672C37, 0x2765D43B, 0xDCD0E804,
			0xF1290DC7, 0xCC00FFA3, 0xB5390F92, 0x690FED0B,
			0x667B9FFB, 0xCEDB7D9C, 0xA091CF0B, 0xD9155EA3,
			0xBB132F88, 0x515BAD24, 0x7B9479BF, 0x763BD6EB,
			0x37392EB3, 0xCC115979, 0x8026E297, 0xF42E312D,
			0x6842ADA7, 0xC66A2B3B, 0x12754CCC, 0x782EF11C,
			0x6A124237, 0xB79251E7, 0x06A1BBE6, 0x4BFB6350,
			0x1A6B1018, 0x11CAEDFA, 0x3D25BDD8, 0xE2E1C3C9,
			0x44421659, 0x0A121386, 0xD90CEC6E, 0xD5ABEA2A,
			0x64AF674E, 0xDA86A85F, 0xBEBFE988, 0x64E4C3FE,
			0x9DBC8057, 0xF0F7C086, 0x60787BF8, 0x6003604D,
			0xD1FD8346, 0xF6381FB0, 0x7745AE04, 0xD736FCCC,
			0x83426B33, 0xF01EAB71, 0xB0804187, 0x3C005E5F,
			0x77A057BE, 0xBDE8AE24, 0x55464299, 0xBF582E61,
			0x4E58F48F, 0xF2DDFDA2, 0xF474EF38, 0x8789BDC2,
			0x5366F9C3, 0xC8B38E74, 0xB475F255, 0x46FCD9B9,
			0x7AEB2661, 0x8B1DDF84, 0x846A0E79, 0x915F95E2,
			0x466E598E, 0x20B45770, 0x8CD55591, 0xC902DE4C,
			0xB90BACE1, 0xBB8205D0, 0x11A86248, 0x7574A99E,
			0xB77F19B6, 0xE0A9DC09, 0x662D09A1, 0xC4324633,
			0xE85A1F02, 0x09F0BE8C, 0x4A99A025, 0x1D6EFE10,
			0x1AB93D1D, 0x0BA5A4DF, 0xA186F20F, 0x2868F169,
			0xDCB7DA83, 0x573906FE, 0xA1E2CE9B, 0x4FCD7F52,
			0x50115E01, 0xA70683FA, 0xA002B5C4, 0x0DE6D027,
			0x9AF88C27, 0x773F8641, 0xC3604C06, 0x61A806B5,
			0xF0177A28, 0xC0F586E0, 0x006058AA, 0x30DC7D62,
			0x11E69ED7, 0x2338EA63, 0x53C2DD94, 0xC2C21634,
			0xBBCBEE56, 0x90BCB6DE, 0xEBFC7DA1, 0xCE591D76,
			0x6F05E409, 0x4B7C0188, 0x39720A3D, 0x7C927C24,
			0x86E3725F, 0x724D9DB9, 0x1AC15BB4, 0xD39EB8FC,
			0xED545578, 0x08FCA5B5, 0xD83D7CD3, 0x4DAD0FC4,
			0x1E50EF5E, 0xB161E6F8, 0xA28514D9, 0x6C51133C,
			0x6FD5C7E7, 0x56E14EC4, 0x362ABFCE, 0xDDC6C837,
			0xD79A3234, 0x92638212, 0x670EFA8E, 0x406000E0
		},
		KS3 =
		{
			0x3A39CE37, 0xD3FAF5CF, 0xABC27737, 0x5AC52D1B,
			0x5CB0679E, 0x4FA33742, 0xD3822740, 0x99BC9BBE,
			0xD5118E9D, 0xBF0F7315, 0xD62D1C7E, 0xC700C47B,
			0xB78C1B6B, 0x21A19045, 0xB26EB1BE, 0x6A366EB4,
			0x5748AB2F, 0xBC946E79, 0xC6A376D2, 0x6549C2C8,
			0x530FF8EE, 0x468DDE7D, 0xD5730A1D, 0x4CD04DC6,
			0x2939BBDB, 0xA9BA4650, 0xAC9526E8, 0xBE5EE304,
			0xA1FAD5F0, 0x6A2D519A, 0x63EF8CE2, 0x9A86EE22,
			0xC089C2B8, 0x43242EF6, 0xA51E03AA, 0x9CF2D0A4,
			0x83C061BA, 0x9BE96A4D, 0x8FE51550, 0xBA645BD6,
			0x2826A2F9, 0xA73A3AE1, 0x4BA99586, 0xEF5562E9,
			0xC72FEFD3, 0xF752F7DA, 0x3F046F69, 0x77FA0A59,
			0x80E4A915, 0x87B08601, 0x9B09E6AD, 0x3B3EE593,
			0xE990FD5A, 0x9E34D797, 0x2CF0B7D9, 0x022B8B51,
			0x96D5AC3A, 0x017DA67D, 0xD1CF3ED6, 0x7C7D2D28,
			0x1F9F25CF, 0xADF2B89B, 0x5AD6B472, 0x5A88F54C,
			0xE029AC71, 0xE019A5E6, 0x47B0ACFD, 0xED93FA9B,
			0xE8D3C48D, 0x283B57CC, 0xF8D56629, 0x79132E28,
			0x785F0191, 0xED756055, 0xF7960E44, 0xE3D35E8C,
			0x15056DD4, 0x88F46DBA, 0x03A16125, 0x0564F0BD,
			0xC3EB9E15, 0x3C9057A2, 0x97271AEC, 0xA93A072A,
			0x1B3F6D9B, 0x1E6321F5, 0xF59C66FB, 0x26DCF319,
			0x7533D928, 0xB155FDF5, 0x03563482, 0x8ABA3CBB,
			0x28517711, 0xC20AD9F8, 0xABCC5167, 0xCCAD925F,
			0x4DE81751, 0x3830DC8E, 0x379D5862, 0x9320F991,
			0xEA7A90C2, 0xFB3E7BCE, 0x5121CE64, 0x774FBE32,
			0xA8B6E37E, 0xC3293D46, 0x48DE5369, 0x6413E680,
			0xA2AE0810, 0xDD6DB224, 0x69852DFD, 0x09072166,
			0xB39A460A, 0x6445C0DD, 0x586CDECF, 0x1C20C8AE,
			0x5BBEF7DD, 0x1B588D40, 0xCCD2017F, 0x6BB4E3BB,
			0xDDA26A7E, 0x3A59FF45, 0x3E350A44, 0xBCB4CDD5,
			0x72EACEA8, 0xFA6484BB, 0x8D6612AE, 0xBF3C6F47,
			0xD29BE463, 0x542F5D9E, 0xAEC2771B, 0xF64E6370,
			0x740E0D8D, 0xE75B1357, 0xF8721671, 0xAF537D5D,
			0x4040CB08, 0x4EB4E2CC, 0x34D2466A, 0x0115AF84,
			0xE1B00428, 0x95983A1D, 0x06B89FB4, 0xCE6EA048,
			0x6F3F3B82, 0x3520AB82, 0x011A1D4B, 0x277227F8,
			0x611560B1, 0xE7933FDC, 0xBB3A792B, 0x344525BD,
			0xA08839E1, 0x51CE794B, 0x2F32C9B7, 0xA01FBAC9,
			0xE01CC87E, 0xBCC7D1F6, 0xCF0111C3, 0xA1E8AAC7,
			0x1A908749, 0xD44FBD9A, 0xD0DADECB, 0xD50ADA38,
			0x0339C32A, 0xC6913667, 0x8DF9317C, 0xE0B12B4F,
			0xF79E59B7, 0x43F5BB3A, 0xF2D519FF, 0x27D9459C,
			0xBF97222C, 0x15E6FC2A, 0x0F91FC71, 0x9B941525,
			0xFAE59361, 0xCEB69CEB, 0xC2A86459, 0x12BAA8D1,
			0xB6C1075E, 0xE3056A0C, 0x10D25065, 0xCB03A442,
			0xE0EC6E0E, 0x1698DB3B, 0x4C98A0BE, 0x3278E964,
			0x9F1F9532, 0xE0D392DF, 0xD3A0342B, 0x8971F21E,
			0x1B0A7441, 0x4BA3348C, 0xC5BE7120, 0xC37632D8,
			0xDF359F8D, 0x9B992F2E, 0xE60B6F47, 0x0FE3F11D,
			0xE54CDA54, 0x1EDAD891, 0xCE6279CF, 0xCD3E7E6F,
			0x1618B166, 0xFD2C1D05, 0x848FD2C5, 0xF6FB2299,
			0xF523F357, 0xA6327623, 0x93A83531, 0x56CCCD02,
			0xACF08162, 0x5A75EBB5, 0x6E163697, 0x88D273CC,
			0xDE966292, 0x81B949D0, 0x4C50901B, 0x71C65614,
			0xE6C6C7BD, 0x327A140A, 0x45E1D006, 0xC3F27B9A,
			0xC9AA53FD, 0x62A80F00, 0xBB25BFE2, 0x35BDD2F6,
			0x71126905, 0xB2040222, 0xB6CBCF7C, 0xCD769C2B,
			0x53113EC0, 0x1640E3D3, 0x38ABBD60, 0x2547ADF0,
			0xBA38209C, 0xF746CE76, 0x77AFA1C5, 0x20756060,
			0x85CBFE4E, 0x8AE88DD8, 0x7AAAF9B0, 0x4CF9AA7E,
			0x1948C25C, 0x02FB8A8C, 0x01C36AE4, 0xD6EBE1F9,
			0x90D4F869, 0xA65CDEA0, 0x3F09252D, 0xC208E69F,
			0xB74E6132, 0xCE77E25B, 0x578FDFE3, 0x3AC372E6
		};

		#endregion

	    private const int _rounds = 16;

	    private const int _sboxSk = 256;

	    private const int _pSize = _rounds + 2;

	    /// <summary>
        /// The s-boxes
        /// </summary>
		private readonly uint[] _s0, _s1, _s2, _s3;

        /// <summary>
        /// The p-array
        /// </summary>
		private readonly uint[] _p;

		/// <summary>
		/// Initializes a new instance of the <see cref="BlowfishCipher"/> class.
		/// </summary>
		/// <param name="key">The key.</param>
		/// <param name="mode">The mode.</param>
		/// <param name="padding">The padding.</param>
		/// <exception cref="ArgumentNullException"><paramref name="key"/> is null.</exception>
		/// <exception cref="ArgumentException">Keysize is not valid for this algorithm.</exception>
		public BlowfishCipher(byte[] key, CipherModeRenci mode, CipherPadding padding)
			: base(key, 8, mode, padding)
		{
			var keySize = key.Length * 8;

			if (keySize < 1 || keySize > 448)
				throw new ArgumentException(string.Format("KeySize '{0}' is not valid for this algorithm.", keySize));

			this._s0 = new uint[_sboxSk];

			this._s1 = new uint[_sboxSk];

			this._s2 = new uint[_sboxSk];

			this._s3 = new uint[_sboxSk];

			this._p = new uint[_pSize];

			this.SetKey(key);
		}

		/// <summary>
		/// Encrypts the specified region of the input byte array and copies the encrypted data to the specified region of the output byte array.
		/// </summary>
		/// <param name="inputBuffer">The input data to encrypt.</param>
		/// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
		/// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
		/// <param name="outputBuffer">The output to which to write encrypted data.</param>
		/// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
		/// <returns>
		/// The number of bytes encrypted.
		/// </returns>
		public override int EncryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
		{
			if (inputCount != this.BlockSize)
				throw new ArgumentException("inputCount");

			uint xl = BigEndianToUInt32(inputBuffer, inputOffset);
			uint xr = BigEndianToUInt32(inputBuffer, inputOffset + 4);

			xl ^= this._p[0];

			for (int i = 1; i < _rounds; i += 2)
			{
				xr ^= F(xl) ^ this._p[i];
				xl ^= F(xr) ^ this._p[i + 1];
			}

			xr ^= this._p[_rounds + 1];

			UInt32ToBigEndian(xr, outputBuffer, outputOffset);
			UInt32ToBigEndian(xl, outputBuffer, outputOffset + 4);

			return this.BlockSize;
		}

		/// <summary>
		/// Decrypts the specified region of the input byte array and copies the decrypted data to the specified region of the output byte array.
		/// </summary>
		/// <param name="inputBuffer">The input data to decrypt.</param>
		/// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
		/// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
		/// <param name="outputBuffer">The output to which to write decrypted data.</param>
		/// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
		/// <returns>
		/// The number of bytes decrypted.
		/// </returns>
		public override int DecryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
		{
			if (inputCount != this.BlockSize)
				throw new ArgumentException("inputCount");

			uint xl = BigEndianToUInt32(inputBuffer, inputOffset);
			uint xr = BigEndianToUInt32(inputBuffer, inputOffset + 4);

			xl ^= this._p[_rounds + 1];

			for (int i = _rounds; i > 0; i -= 2)
			{
				xr ^= F(xl) ^ this._p[i];
				xl ^= F(xr) ^ this._p[i - 1];
			}

			xr ^= this._p[0];

			UInt32ToBigEndian(xr, outputBuffer, outputOffset);
			UInt32ToBigEndian(xl, outputBuffer, outputOffset + 4);

			return this.BlockSize;
		}

		private uint F(uint x)
		{
			return (((this._s0[x >> 24] + this._s1[(x >> 16) & 0xff]) ^ this._s2[(x >> 8) & 0xff]) + this._s3[x & 0xff]);
		}

		private void SetKey(byte[] key)
		{
			/*
			* - comments are from _Applied Crypto_, Schneier, p338
			* please be careful comparing the two, AC numbers the
			* arrays from 1, the enclosed code from 0.
			*
			* (1)
			* Initialise the S-boxes and the P-array, with a fixed string
			* This string contains the hexadecimal digits of pi (3.141...)
			*/
			Buffer.BlockCopy(KS0, 0, this._s0, 0, _sboxSk * sizeof(uint));
			Buffer.BlockCopy(KS1, 0, this._s1, 0, _sboxSk * sizeof(uint));
			Buffer.BlockCopy(KS2, 0, this._s2, 0, _sboxSk * sizeof(uint));
			Buffer.BlockCopy(KS3, 0, this._s3, 0, _sboxSk * sizeof(uint));

			Buffer.BlockCopy(KP, 0, this._p, 0, _pSize * sizeof(uint));

			/*
			* (2)
			* Now, XOR P[0] with the first 32 bits of the key, XOR P[1] with the
			* second 32-bits of the key, and so on for all bits of the key
			* (up to P[17]).  Repeatedly cycle through the key bits until the
			* entire P-array has been XOR-ed with the key bits
			*/
			int keyLength = key.Length;
			int keyIndex = 0;

			for (int i = 0; i < _pSize; i++)
			{
				// Get the 32 bits of the key, in 4 * 8 bit chunks
				uint data = 0x0000000;
				for (int j = 0; j < 4; j++)
				{
					// create a 32 bit block
					data = (data << 8) | (uint)key[keyIndex++];

					// wrap when we get to the end of the key
					if (keyIndex >= keyLength)
					{
						keyIndex = 0;
					}
				}
				// XOR the newly created 32 bit chunk onto the P-array
				this._p[i] ^= data;
			}

			/*
			* (3)
			* Encrypt the all-zero string with the Blowfish algorithm, using
			* the subkeys described in (1) and (2)
			*
			* (4)
			* Replace P1 and P2 with the output of step (3)
			*
			* (5)
			* Encrypt the output of step(3) using the Blowfish algorithm,
			* with the modified subkeys.
			*
			* (6)
			* Replace P3 and P4 with the output of step (5)
			*
			* (7)
			* Continue the process, replacing all elements of the P-array
			* and then all four S-boxes in order, with the output of the
			* continuously changing Blowfish algorithm
			*/

			ProcessTable(0, 0, this._p);
			ProcessTable(this._p[_pSize - 2], this._p[_pSize - 1], this._s0);
			ProcessTable(this._s0[_sboxSk - 2], this._s0[_sboxSk - 1], this._s1);
			ProcessTable(this._s1[_sboxSk - 2], this._s1[_sboxSk - 1], this._s2);
			ProcessTable(this._s2[_sboxSk - 2], this._s2[_sboxSk - 1], this._s3);
		}

		/// <summary>
		/// apply the encryption cycle to each value pair in the table.
		/// </summary>
		/// <param name="xl">The xl.</param>
		/// <param name="xr">The xr.</param>
		/// <param name="table">The table.</param>
		private void ProcessTable(uint xl, uint xr, uint[] table)
		{
			int size = table.Length;

			for (int s = 0; s < size; s += 2)
			{
				xl ^= _p[0];

				for (int i = 1; i < _rounds; i += 2)
				{
					xr ^= F(xl) ^ _p[i];
					xl ^= F(xr) ^ _p[i + 1];
				}

				xr ^= _p[_rounds + 1];

				table[s] = xr;
				table[s + 1] = xl;

				xr = xl;            // end of cycle swap
				xl = table[s];
			}
		}
	}
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Ciphers\CastCipher.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography.Ciphers
{
    /// <summary>
    /// Implements CAST cipher algorithm
    /// </summary>
    public sealed class CastCipher : BlockCipher
    {
        internal static readonly int MAX_ROUNDS = 16;

        internal static readonly int RED_ROUNDS = 12;

        /// <summary>
        /// The rotating round key
        /// </summary>
        private readonly int[] _kr = new int[17];

        /// <summary>
        /// The masking round key
        /// </summary>
        private readonly uint[] _km = new uint[17];

        private int _rounds = MAX_ROUNDS;

        /// <summary>
        /// Initializes a new instance of the <see cref="CastCipher"/> class.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <param name="mode">The mode.</param>
        /// <param name="padding">The padding.</param>
        /// <exception cref="ArgumentNullException"><paramref name="key"/> is null.</exception>
        /// <exception cref="ArgumentException">Keysize is not valid for this algorithm.</exception>
        public CastCipher(byte[] key, CipherModeRenci mode, CipherPadding padding)
            : base(key, 8, mode, padding)
        {
            var keySize = key.Length * 8;

            if (!(keySize >= 40 && keySize <= 128 && keySize % 8 == 0))
                throw new ArgumentException(string.Format("KeySize '{0}' is not valid for this algorithm.", keySize));

            this.SetKey(key);
        }

        /// <summary>
        /// Encrypts the specified region of the input byte array and copies the encrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to encrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write encrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes encrypted.
        /// </returns>
        public override int EncryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            // process the input block
            // batch the units up into a 32 bit chunk and go for it
            // the array is in bytes, the increment is 8x8 bits = 64

            uint L0 = BigEndianToUInt32(inputBuffer, inputOffset);
            uint R0 = BigEndianToUInt32(inputBuffer, inputOffset + 4);

            uint[] result = new uint[2];
            this.CastEncipher(L0, R0, result);

            // now stuff them into the destination block
            UInt32ToBigEndian(result[0], outputBuffer, outputOffset);
            UInt32ToBigEndian(result[1], outputBuffer, outputOffset + 4);

            return this.BlockSize;
        }

        /// <summary>
        /// Decrypts the specified region of the input byte array and copies the decrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to decrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write decrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes decrypted.
        /// </returns>
        public override int DecryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            // process the input block
            // batch the units up into a 32 bit chunk and go for it
            // the array is in bytes, the increment is 8x8 bits = 64
            uint L16 = BigEndianToUInt32(inputBuffer, inputOffset);
            uint R16 = BigEndianToUInt32(inputBuffer, inputOffset + 4);

            uint[] result = new uint[2];
            this.CastDecipher(L16, R16, result);

            // now stuff them into the destination block
            UInt32ToBigEndian(result[0], outputBuffer, outputOffset);
            UInt32ToBigEndian(result[1], outputBuffer, outputOffset + 4);

            return this.BlockSize;
        }

        #region Static Definition Tables

        internal static readonly uint[] S1 =
		{
			0x30fb40d4, 0x9fa0ff0b, 0x6beccd2f, 0x3f258c7a, 0x1e213f2f, 0x9c004dd3, 0x6003e540, 0xcf9fc949,
			0xbfd4af27, 0x88bbbdb5, 0xe2034090, 0x98d09675, 0x6e63a0e0, 0x15c361d2, 0xc2e7661d, 0x22d4ff8e,
			0x28683b6f, 0xc07fd059, 0xff2379c8, 0x775f50e2, 0x43c340d3, 0xdf2f8656, 0x887ca41a, 0xa2d2bd2d,
			0xa1c9e0d6, 0x346c4819, 0x61b76d87, 0x22540f2f, 0x2abe32e1, 0xaa54166b, 0x22568e3a, 0xa2d341d0,
			0x66db40c8, 0xa784392f, 0x004dff2f, 0x2db9d2de, 0x97943fac, 0x4a97c1d8, 0x527644b7, 0xb5f437a7,
			0xb82cbaef, 0xd751d159, 0x6ff7f0ed, 0x5a097a1f, 0x827b68d0, 0x90ecf52e, 0x22b0c054, 0xbc8e5935,
			0x4b6d2f7f, 0x50bb64a2, 0xd2664910, 0xbee5812d, 0xb7332290, 0xe93b159f, 0xb48ee411, 0x4bff345d,
			0xfd45c240, 0xad31973f, 0xc4f6d02e, 0x55fc8165, 0xd5b1caad, 0xa1ac2dae, 0xa2d4b76d, 0xc19b0c50,
			0x882240f2, 0x0c6e4f38, 0xa4e4bfd7, 0x4f5ba272, 0x564c1d2f, 0xc59c5319, 0xb949e354, 0xb04669fe,
			0xb1b6ab8a, 0xc71358dd, 0x6385c545, 0x110f935d, 0x57538ad5, 0x6a390493, 0xe63d37e0, 0x2a54f6b3,
			0x3a787d5f, 0x6276a0b5, 0x19a6fcdf, 0x7a42206a, 0x29f9d4d5, 0xf61b1891, 0xbb72275e, 0xaa508167,
			0x38901091, 0xc6b505eb, 0x84c7cb8c, 0x2ad75a0f, 0x874a1427, 0xa2d1936b, 0x2ad286af, 0xaa56d291,
			0xd7894360, 0x425c750d, 0x93b39e26, 0x187184c9, 0x6c00b32d, 0x73e2bb14, 0xa0bebc3c, 0x54623779,
			0x64459eab, 0x3f328b82, 0x7718cf82, 0x59a2cea6, 0x04ee002e, 0x89fe78e6, 0x3fab0950, 0x325ff6c2,
			0x81383f05, 0x6963c5c8, 0x76cb5ad6, 0xd49974c9, 0xca180dcf, 0x380782d5, 0xc7fa5cf6, 0x8ac31511,
			0x35e79e13, 0x47da91d0, 0xf40f9086, 0xa7e2419e, 0x31366241, 0x051ef495, 0xaa573b04, 0x4a805d8d,
			0x548300d0, 0x00322a3c, 0xbf64cddf, 0xba57a68e, 0x75c6372b, 0x50afd341, 0xa7c13275, 0x915a0bf5,
			0x6b54bfab, 0x2b0b1426, 0xab4cc9d7, 0x449ccd82, 0xf7fbf265, 0xab85c5f3, 0x1b55db94, 0xaad4e324,
			0xcfa4bd3f, 0x2deaa3e2, 0x9e204d02, 0xc8bd25ac, 0xeadf55b3, 0xd5bd9e98, 0xe31231b2, 0x2ad5ad6c,
			0x954329de, 0xadbe4528, 0xd8710f69, 0xaa51c90f, 0xaa786bf6, 0x22513f1e, 0xaa51a79b, 0x2ad344cc,
			0x7b5a41f0, 0xd37cfbad, 0x1b069505, 0x41ece491, 0xb4c332e6, 0x032268d4, 0xc9600acc, 0xce387e6d,
			0xbf6bb16c, 0x6a70fb78, 0x0d03d9c9, 0xd4df39de, 0xe01063da, 0x4736f464, 0x5ad328d8, 0xb347cc96,
			0x75bb0fc3, 0x98511bfb, 0x4ffbcc35, 0xb58bcf6a, 0xe11f0abc, 0xbfc5fe4a, 0xa70aec10, 0xac39570a,
			0x3f04442f, 0x6188b153, 0xe0397a2e, 0x5727cb79, 0x9ceb418f, 0x1cacd68d, 0x2ad37c96, 0x0175cb9d,
			0xc69dff09, 0xc75b65f0, 0xd9db40d8, 0xec0e7779, 0x4744ead4, 0xb11c3274, 0xdd24cb9e, 0x7e1c54bd,
			0xf01144f9, 0xd2240eb1, 0x9675b3fd, 0xa3ac3755, 0xd47c27af, 0x51c85f4d, 0x56907596, 0xa5bb15e6,
			0x580304f0, 0xca042cf1, 0x011a37ea, 0x8dbfaadb, 0x35ba3e4a, 0x3526ffa0, 0xc37b4d09, 0xbc306ed9,
			0x98a52666, 0x5648f725, 0xff5e569d, 0x0ced63d0, 0x7c63b2cf, 0x700b45e1, 0xd5ea50f1, 0x85a92872,
			0xaf1fbda7, 0xd4234870, 0xa7870bf3, 0x2d3b4d79, 0x42e04198, 0x0cd0ede7, 0x26470db8, 0xf881814c,
			0x474d6ad7, 0x7c0c5e5c, 0xd1231959, 0x381b7298, 0xf5d2f4db, 0xab838653, 0x6e2f1e23, 0x83719c9e,
			0xbd91e046, 0x9a56456e, 0xdc39200c, 0x20c8c571, 0x962bda1c, 0xe1e696ff, 0xb141ab08, 0x7cca89b9,
			0x1a69e783, 0x02cc4843, 0xa2f7c579, 0x429ef47d, 0x427b169c, 0x5ac9f049, 0xdd8f0f00, 0x5c8165bf
		},
        S2 =
		{
			0x1f201094, 0xef0ba75b, 0x69e3cf7e, 0x393f4380, 0xfe61cf7a, 0xeec5207a, 0x55889c94, 0x72fc0651,
			0xada7ef79, 0x4e1d7235, 0xd55a63ce, 0xde0436ba, 0x99c430ef, 0x5f0c0794, 0x18dcdb7d, 0xa1d6eff3,
			0xa0b52f7b, 0x59e83605, 0xee15b094, 0xe9ffd909, 0xdc440086, 0xef944459, 0xba83ccb3, 0xe0c3cdfb,
			0xd1da4181, 0x3b092ab1, 0xf997f1c1, 0xa5e6cf7b, 0x01420ddb, 0xe4e7ef5b, 0x25a1ff41, 0xe180f806,
			0x1fc41080, 0x179bee7a, 0xd37ac6a9, 0xfe5830a4, 0x98de8b7f, 0x77e83f4e, 0x79929269, 0x24fa9f7b,
			0xe113c85b, 0xacc40083, 0xd7503525, 0xf7ea615f, 0x62143154, 0x0d554b63, 0x5d681121, 0xc866c359,
			0x3d63cf73, 0xcee234c0, 0xd4d87e87, 0x5c672b21, 0x071f6181, 0x39f7627f, 0x361e3084, 0xe4eb573b,
			0x602f64a4, 0xd63acd9c, 0x1bbc4635, 0x9e81032d, 0x2701f50c, 0x99847ab4, 0xa0e3df79, 0xba6cf38c,
			0x10843094, 0x2537a95e, 0xf46f6ffe, 0xa1ff3b1f, 0x208cfb6a, 0x8f458c74, 0xd9e0a227, 0x4ec73a34,
			0xfc884f69, 0x3e4de8df, 0xef0e0088, 0x3559648d, 0x8a45388c, 0x1d804366, 0x721d9bfd, 0xa58684bb,
			0xe8256333, 0x844e8212, 0x128d8098, 0xfed33fb4, 0xce280ae1, 0x27e19ba5, 0xd5a6c252, 0xe49754bd,
			0xc5d655dd, 0xeb667064, 0x77840b4d, 0xa1b6a801, 0x84db26a9, 0xe0b56714, 0x21f043b7, 0xe5d05860,
			0x54f03084, 0x066ff472, 0xa31aa153, 0xdadc4755, 0xb5625dbf, 0x68561be6, 0x83ca6b94, 0x2d6ed23b,
			0xeccf01db, 0xa6d3d0ba, 0xb6803d5c, 0xaf77a709, 0x33b4a34c, 0x397bc8d6, 0x5ee22b95, 0x5f0e5304,
			0x81ed6f61, 0x20e74364, 0xb45e1378, 0xde18639b, 0x881ca122, 0xb96726d1, 0x8049a7e8, 0x22b7da7b,
			0x5e552d25, 0x5272d237, 0x79d2951c, 0xc60d894c, 0x488cb402, 0x1ba4fe5b, 0xa4b09f6b, 0x1ca815cf,
			0xa20c3005, 0x8871df63, 0xb9de2fcb, 0x0cc6c9e9, 0x0beeff53, 0xe3214517, 0xb4542835, 0x9f63293c,
			0xee41e729, 0x6e1d2d7c, 0x50045286, 0x1e6685f3, 0xf33401c6, 0x30a22c95, 0x31a70850, 0x60930f13,
			0x73f98417, 0xa1269859, 0xec645c44, 0x52c877a9, 0xcdff33a6, 0xa02b1741, 0x7cbad9a2, 0x2180036f,
			0x50d99c08, 0xcb3f4861, 0xc26bd765, 0x64a3f6ab, 0x80342676, 0x25a75e7b, 0xe4e6d1fc, 0x20c710e6,
			0xcdf0b680, 0x17844d3b, 0x31eef84d, 0x7e0824e4, 0x2ccb49eb, 0x846a3bae, 0x8ff77888, 0xee5d60f6,
			0x7af75673, 0x2fdd5cdb, 0xa11631c1, 0x30f66f43, 0xb3faec54, 0x157fd7fa, 0xef8579cc, 0xd152de58,
			0xdb2ffd5e, 0x8f32ce19, 0x306af97a, 0x02f03ef8, 0x99319ad5, 0xc242fa0f, 0xa7e3ebb0, 0xc68e4906,
			0xb8da230c, 0x80823028, 0xdcdef3c8, 0xd35fb171, 0x088a1bc8, 0xbec0c560, 0x61a3c9e8, 0xbca8f54d,
			0xc72feffa, 0x22822e99, 0x82c570b4, 0xd8d94e89, 0x8b1c34bc, 0x301e16e6, 0x273be979, 0xb0ffeaa6,
			0x61d9b8c6, 0x00b24869, 0xb7ffce3f, 0x08dc283b, 0x43daf65a, 0xf7e19798, 0x7619b72f, 0x8f1c9ba4,
			0xdc8637a0, 0x16a7d3b1, 0x9fc393b7, 0xa7136eeb, 0xc6bcc63e, 0x1a513742, 0xef6828bc, 0x520365d6,
			0x2d6a77ab, 0x3527ed4b, 0x821fd216, 0x095c6e2e, 0xdb92f2fb, 0x5eea29cb, 0x145892f5, 0x91584f7f,
			0x5483697b, 0x2667a8cc, 0x85196048, 0x8c4bacea, 0x833860d4, 0x0d23e0f9, 0x6c387e8a, 0x0ae6d249,
			0xb284600c, 0xd835731d, 0xdcb1c647, 0xac4c56ea, 0x3ebd81b3, 0x230eabb0, 0x6438bc87, 0xf0b5b1fa,
			0x8f5ea2b3, 0xfc184642, 0x0a036b7a, 0x4fb089bd, 0x649da589, 0xa345415e, 0x5c038323, 0x3e5d3bb9,
			0x43d79572, 0x7e6dd07c, 0x06dfdf1e, 0x6c6cc4ef, 0x7160a539, 0x73bfbe70, 0x83877605, 0x4523ecf1
		},
        S3 =
		{
			0x8defc240, 0x25fa5d9f, 0xeb903dbf, 0xe810c907, 0x47607fff, 0x369fe44b, 0x8c1fc644, 0xaececa90,
			0xbeb1f9bf, 0xeefbcaea, 0xe8cf1950, 0x51df07ae, 0x920e8806, 0xf0ad0548, 0xe13c8d83, 0x927010d5,
			0x11107d9f, 0x07647db9, 0xb2e3e4d4, 0x3d4f285e, 0xb9afa820, 0xfade82e0, 0xa067268b, 0x8272792e,
			0x553fb2c0, 0x489ae22b, 0xd4ef9794, 0x125e3fbc, 0x21fffcee, 0x825b1bfd, 0x9255c5ed, 0x1257a240,
			0x4e1a8302, 0xbae07fff, 0x528246e7, 0x8e57140e, 0x3373f7bf, 0x8c9f8188, 0xa6fc4ee8, 0xc982b5a5,
			0xa8c01db7, 0x579fc264, 0x67094f31, 0xf2bd3f5f, 0x40fff7c1, 0x1fb78dfc, 0x8e6bd2c1, 0x437be59b,
			0x99b03dbf, 0xb5dbc64b, 0x638dc0e6, 0x55819d99, 0xa197c81c, 0x4a012d6e, 0xc5884a28, 0xccc36f71,
			0xb843c213, 0x6c0743f1, 0x8309893c, 0x0feddd5f, 0x2f7fe850, 0xd7c07f7e, 0x02507fbf, 0x5afb9a04,
			0xa747d2d0, 0x1651192e, 0xaf70bf3e, 0x58c31380, 0x5f98302e, 0x727cc3c4, 0x0a0fb402, 0x0f7fef82,
			0x8c96fdad, 0x5d2c2aae, 0x8ee99a49, 0x50da88b8, 0x8427f4a0, 0x1eac5790, 0x796fb449, 0x8252dc15,
			0xefbd7d9b, 0xa672597d, 0xada840d8, 0x45f54504, 0xfa5d7403, 0xe83ec305, 0x4f91751a, 0x925669c2,
			0x23efe941, 0xa903f12e, 0x60270df2, 0x0276e4b6, 0x94fd6574, 0x927985b2, 0x8276dbcb, 0x02778176,
			0xf8af918d, 0x4e48f79e, 0x8f616ddf, 0xe29d840e, 0x842f7d83, 0x340ce5c8, 0x96bbb682, 0x93b4b148,
			0xef303cab, 0x984faf28, 0x779faf9b, 0x92dc560d, 0x224d1e20, 0x8437aa88, 0x7d29dc96, 0x2756d3dc,
			0x8b907cee, 0xb51fd240, 0xe7c07ce3, 0xe566b4a1, 0xc3e9615e, 0x3cf8209d, 0x6094d1e3, 0xcd9ca341,
			0x5c76460e, 0x00ea983b, 0xd4d67881, 0xfd47572c, 0xf76cedd9, 0xbda8229c, 0x127dadaa, 0x438a074e,
			0x1f97c090, 0x081bdb8a, 0x93a07ebe, 0xb938ca15, 0x97b03cff, 0x3dc2c0f8, 0x8d1ab2ec, 0x64380e51,
			0x68cc7bfb, 0xd90f2788, 0x12490181, 0x5de5ffd4, 0xdd7ef86a, 0x76a2e214, 0xb9a40368, 0x925d958f,
			0x4b39fffa, 0xba39aee9, 0xa4ffd30b, 0xfaf7933b, 0x6d498623, 0x193cbcfa, 0x27627545, 0x825cf47a,
			0x61bd8ba0, 0xd11e42d1, 0xcead04f4, 0x127ea392, 0x10428db7, 0x8272a972, 0x9270c4a8, 0x127de50b,
			0x285ba1c8, 0x3c62f44f, 0x35c0eaa5, 0xe805d231, 0x428929fb, 0xb4fcdf82, 0x4fb66a53, 0x0e7dc15b,
			0x1f081fab, 0x108618ae, 0xfcfd086d, 0xf9ff2889, 0x694bcc11, 0x236a5cae, 0x12deca4d, 0x2c3f8cc5,
			0xd2d02dfe, 0xf8ef5896, 0xe4cf52da, 0x95155b67, 0x494a488c, 0xb9b6a80c, 0x5c8f82bc, 0x89d36b45,
			0x3a609437, 0xec00c9a9, 0x44715253, 0x0a874b49, 0xd773bc40, 0x7c34671c, 0x02717ef6, 0x4feb5536,
			0xa2d02fff, 0xd2bf60c4, 0xd43f03c0, 0x50b4ef6d, 0x07478cd1, 0x006e1888, 0xa2e53f55, 0xb9e6d4bc,
			0xa2048016, 0x97573833, 0xd7207d67, 0xde0f8f3d, 0x72f87b33, 0xabcc4f33, 0x7688c55d, 0x7b00a6b0,
			0x947b0001, 0x570075d2, 0xf9bb88f8, 0x8942019e, 0x4264a5ff, 0x856302e0, 0x72dbd92b, 0xee971b69,
			0x6ea22fde, 0x5f08ae2b, 0xaf7a616d, 0xe5c98767, 0xcf1febd2, 0x61efc8c2, 0xf1ac2571, 0xcc8239c2,
			0x67214cb8, 0xb1e583d1, 0xb7dc3e62, 0x7f10bdce, 0xf90a5c38, 0x0ff0443d, 0x606e6dc6, 0x60543a49,
			0x5727c148, 0x2be98a1d, 0x8ab41738, 0x20e1be24, 0xaf96da0f, 0x68458425, 0x99833be5, 0x600d457d,
			0x282f9350, 0x8334b362, 0xd91d1120, 0x2b6d8da0, 0x642b1e31, 0x9c305a00, 0x52bce688, 0x1b03588a,
			0xf7baefd5, 0x4142ed9c, 0xa4315c11, 0x83323ec5, 0xdfef4636, 0xa133c501, 0xe9d3531c, 0xee353783
		},
        S4 =
		{
			0x9db30420, 0x1fb6e9de, 0xa7be7bef, 0xd273a298, 0x4a4f7bdb, 0x64ad8c57, 0x85510443, 0xfa020ed1,
			0x7e287aff, 0xe60fb663, 0x095f35a1, 0x79ebf120, 0xfd059d43, 0x6497b7b1, 0xf3641f63, 0x241e4adf,
			0x28147f5f, 0x4fa2b8cd, 0xc9430040, 0x0cc32220, 0xfdd30b30, 0xc0a5374f, 0x1d2d00d9, 0x24147b15,
			0xee4d111a, 0x0fca5167, 0x71ff904c, 0x2d195ffe, 0x1a05645f, 0x0c13fefe, 0x081b08ca, 0x05170121,
			0x80530100, 0xe83e5efe, 0xac9af4f8, 0x7fe72701, 0xd2b8ee5f, 0x06df4261, 0xbb9e9b8a, 0x7293ea25,
			0xce84ffdf, 0xf5718801, 0x3dd64b04, 0xa26f263b, 0x7ed48400, 0x547eebe6, 0x446d4ca0, 0x6cf3d6f5,
			0x2649abdf, 0xaea0c7f5, 0x36338cc1, 0x503f7e93, 0xd3772061, 0x11b638e1, 0x72500e03, 0xf80eb2bb,
			0xabe0502e, 0xec8d77de, 0x57971e81, 0xe14f6746, 0xc9335400, 0x6920318f, 0x081dbb99, 0xffc304a5,
			0x4d351805, 0x7f3d5ce3, 0xa6c866c6, 0x5d5bcca9, 0xdaec6fea, 0x9f926f91, 0x9f46222f, 0x3991467d,
			0xa5bf6d8e, 0x1143c44f, 0x43958302, 0xd0214eeb, 0x022083b8, 0x3fb6180c, 0x18f8931e, 0x281658e6,
			0x26486e3e, 0x8bd78a70, 0x7477e4c1, 0xb506e07c, 0xf32d0a25, 0x79098b02, 0xe4eabb81, 0x28123b23,
			0x69dead38, 0x1574ca16, 0xdf871b62, 0x211c40b7, 0xa51a9ef9, 0x0014377b, 0x041e8ac8, 0x09114003,
			0xbd59e4d2, 0xe3d156d5, 0x4fe876d5, 0x2f91a340, 0x557be8de, 0x00eae4a7, 0x0ce5c2ec, 0x4db4bba6,
			0xe756bdff, 0xdd3369ac, 0xec17b035, 0x06572327, 0x99afc8b0, 0x56c8c391, 0x6b65811c, 0x5e146119,
			0x6e85cb75, 0xbe07c002, 0xc2325577, 0x893ff4ec, 0x5bbfc92d, 0xd0ec3b25, 0xb7801ab7, 0x8d6d3b24,
			0x20c763ef, 0xc366a5fc, 0x9c382880, 0x0ace3205, 0xaac9548a, 0xeca1d7c7, 0x041afa32, 0x1d16625a,
			0x6701902c, 0x9b757a54, 0x31d477f7, 0x9126b031, 0x36cc6fdb, 0xc70b8b46, 0xd9e66a48, 0x56e55a79,
			0x026a4ceb, 0x52437eff, 0x2f8f76b4, 0x0df980a5, 0x8674cde3, 0xedda04eb, 0x17a9be04, 0x2c18f4df,
			0xb7747f9d, 0xab2af7b4, 0xefc34d20, 0x2e096b7c, 0x1741a254, 0xe5b6a035, 0x213d42f6, 0x2c1c7c26,
			0x61c2f50f, 0x6552daf9, 0xd2c231f8, 0x25130f69, 0xd8167fa2, 0x0418f2c8, 0x001a96a6, 0x0d1526ab,
			0x63315c21, 0x5e0a72ec, 0x49bafefd, 0x187908d9, 0x8d0dbd86, 0x311170a7, 0x3e9b640c, 0xcc3e10d7,
			0xd5cad3b6, 0x0caec388, 0xf73001e1, 0x6c728aff, 0x71eae2a1, 0x1f9af36e, 0xcfcbd12f, 0xc1de8417,
			0xac07be6b, 0xcb44a1d8, 0x8b9b0f56, 0x013988c3, 0xb1c52fca, 0xb4be31cd, 0xd8782806, 0x12a3a4e2,
			0x6f7de532, 0x58fd7eb6, 0xd01ee900, 0x24adffc2, 0xf4990fc5, 0x9711aac5, 0x001d7b95, 0x82e5e7d2,
			0x109873f6, 0x00613096, 0xc32d9521, 0xada121ff, 0x29908415, 0x7fbb977f, 0xaf9eb3db, 0x29c9ed2a,
			0x5ce2a465, 0xa730f32c, 0xd0aa3fe8, 0x8a5cc091, 0xd49e2ce7, 0x0ce454a9, 0xd60acd86, 0x015f1919,
			0x77079103, 0xdea03af6, 0x78a8565e, 0xdee356df, 0x21f05cbe, 0x8b75e387, 0xb3c50651, 0xb8a5c3ef,
			0xd8eeb6d2, 0xe523be77, 0xc2154529, 0x2f69efdf, 0xafe67afb, 0xf470c4b2, 0xf3e0eb5b, 0xd6cc9876,
			0x39e4460c, 0x1fda8538, 0x1987832f, 0xca007367, 0xa99144f8, 0x296b299e, 0x492fc295, 0x9266beab,
			0xb5676e69, 0x9bd3ddda, 0xdf7e052f, 0xdb25701c, 0x1b5e51ee, 0xf65324e6, 0x6afce36c, 0x0316cc04,
			0x8644213e, 0xb7dc59d0, 0x7965291f, 0xccd6fd43, 0x41823979, 0x932bcdf6, 0xb657c34d, 0x4edfd282,
			0x7ae5290c, 0x3cb9536b, 0x851e20fe, 0x9833557e, 0x13ecf0b0, 0xd3ffb372, 0x3f85c5c1, 0x0aef7ed2
		},
        S5 =
		{
			0x7ec90c04, 0x2c6e74b9, 0x9b0e66df, 0xa6337911, 0xb86a7fff, 0x1dd358f5, 0x44dd9d44, 0x1731167f,
			0x08fbf1fa, 0xe7f511cc, 0xd2051b00, 0x735aba00, 0x2ab722d8, 0x386381cb, 0xacf6243a, 0x69befd7a,
			0xe6a2e77f, 0xf0c720cd, 0xc4494816, 0xccf5c180, 0x38851640, 0x15b0a848, 0xe68b18cb, 0x4caadeff,
			0x5f480a01, 0x0412b2aa, 0x259814fc, 0x41d0efe2, 0x4e40b48d, 0x248eb6fb, 0x8dba1cfe, 0x41a99b02,
			0x1a550a04, 0xba8f65cb, 0x7251f4e7, 0x95a51725, 0xc106ecd7, 0x97a5980a, 0xc539b9aa, 0x4d79fe6a,
			0xf2f3f763, 0x68af8040, 0xed0c9e56, 0x11b4958b, 0xe1eb5a88, 0x8709e6b0, 0xd7e07156, 0x4e29fea7,
			0x6366e52d, 0x02d1c000, 0xc4ac8e05, 0x9377f571, 0x0c05372a, 0x578535f2, 0x2261be02, 0xd642a0c9,
			0xdf13a280, 0x74b55bd2, 0x682199c0, 0xd421e5ec, 0x53fb3ce8, 0xc8adedb3, 0x28a87fc9, 0x3d959981,
			0x5c1ff900, 0xfe38d399, 0x0c4eff0b, 0x062407ea, 0xaa2f4fb1, 0x4fb96976, 0x90c79505, 0xb0a8a774,
			0xef55a1ff, 0xe59ca2c2, 0xa6b62d27, 0xe66a4263, 0xdf65001f, 0x0ec50966, 0xdfdd55bc, 0x29de0655,
			0x911e739a, 0x17af8975, 0x32c7911c, 0x89f89468, 0x0d01e980, 0x524755f4, 0x03b63cc9, 0x0cc844b2,
			0xbcf3f0aa, 0x87ac36e9, 0xe53a7426, 0x01b3d82b, 0x1a9e7449, 0x64ee2d7e, 0xcddbb1da, 0x01c94910,
			0xb868bf80, 0x0d26f3fd, 0x9342ede7, 0x04a5c284, 0x636737b6, 0x50f5b616, 0xf24766e3, 0x8eca36c1,
			0x136e05db, 0xfef18391, 0xfb887a37, 0xd6e7f7d4, 0xc7fb7dc9, 0x3063fcdf, 0xb6f589de, 0xec2941da,
			0x26e46695, 0xb7566419, 0xf654efc5, 0xd08d58b7, 0x48925401, 0xc1bacb7f, 0xe5ff550f, 0xb6083049,
			0x5bb5d0e8, 0x87d72e5a, 0xab6a6ee1, 0x223a66ce, 0xc62bf3cd, 0x9e0885f9, 0x68cb3e47, 0x086c010f,
			0xa21de820, 0xd18b69de, 0xf3f65777, 0xfa02c3f6, 0x407edac3, 0xcbb3d550, 0x1793084d, 0xb0d70eba,
			0x0ab378d5, 0xd951fb0c, 0xded7da56, 0x4124bbe4, 0x94ca0b56, 0x0f5755d1, 0xe0e1e56e, 0x6184b5be,
			0x580a249f, 0x94f74bc0, 0xe327888e, 0x9f7b5561, 0xc3dc0280, 0x05687715, 0x646c6bd7, 0x44904db3,
			0x66b4f0a3, 0xc0f1648a, 0x697ed5af, 0x49e92ff6, 0x309e374f, 0x2cb6356a, 0x85808573, 0x4991f840,
			0x76f0ae02, 0x083be84d, 0x28421c9a, 0x44489406, 0x736e4cb8, 0xc1092910, 0x8bc95fc6, 0x7d869cf4,
			0x134f616f, 0x2e77118d, 0xb31b2be1, 0xaa90b472, 0x3ca5d717, 0x7d161bba, 0x9cad9010, 0xaf462ba2,
			0x9fe459d2, 0x45d34559, 0xd9f2da13, 0xdbc65487, 0xf3e4f94e, 0x176d486f, 0x097c13ea, 0x631da5c7,
			0x445f7382, 0x175683f4, 0xcdc66a97, 0x70be0288, 0xb3cdcf72, 0x6e5dd2f3, 0x20936079, 0x459b80a5,
			0xbe60e2db, 0xa9c23101, 0xeba5315c, 0x224e42f2, 0x1c5c1572, 0xf6721b2c, 0x1ad2fff3, 0x8c25404e,
			0x324ed72f, 0x4067b7fd, 0x0523138e, 0x5ca3bc78, 0xdc0fd66e, 0x75922283, 0x784d6b17, 0x58ebb16e,
			0x44094f85, 0x3f481d87, 0xfcfeae7b, 0x77b5ff76, 0x8c2302bf, 0xaaf47556, 0x5f46b02a, 0x2b092801,
			0x3d38f5f7, 0x0ca81f36, 0x52af4a8a, 0x66d5e7c0, 0xdf3b0874, 0x95055110, 0x1b5ad7a8, 0xf61ed5ad,
			0x6cf6e479, 0x20758184, 0xd0cefa65, 0x88f7be58, 0x4a046826, 0x0ff6f8f3, 0xa09c7f70, 0x5346aba0,
			0x5ce96c28, 0xe176eda3, 0x6bac307f, 0x376829d2, 0x85360fa9, 0x17e3fe2a, 0x24b79767, 0xf5a96b20,
			0xd6cd2595, 0x68ff1ebf, 0x7555442c, 0xf19f06be, 0xf9e0659a, 0xeeb9491d, 0x34010718, 0xbb30cab8,
			0xe822fe15, 0x88570983, 0x750e6249, 0xda627e55, 0x5e76ffa8, 0xb1534546, 0x6d47de08, 0xefe9e7d4
		},
        S6 =
		{
			0xf6fa8f9d, 0x2cac6ce1, 0x4ca34867, 0xe2337f7c, 0x95db08e7, 0x016843b4, 0xeced5cbc, 0x325553ac,
			0xbf9f0960, 0xdfa1e2ed, 0x83f0579d, 0x63ed86b9, 0x1ab6a6b8, 0xde5ebe39, 0xf38ff732, 0x8989b138,
			0x33f14961, 0xc01937bd, 0xf506c6da, 0xe4625e7e, 0xa308ea99, 0x4e23e33c, 0x79cbd7cc, 0x48a14367,
			0xa3149619, 0xfec94bd5, 0xa114174a, 0xeaa01866, 0xa084db2d, 0x09a8486f, 0xa888614a, 0x2900af98,
			0x01665991, 0xe1992863, 0xc8f30c60, 0x2e78ef3c, 0xd0d51932, 0xcf0fec14, 0xf7ca07d2, 0xd0a82072,
			0xfd41197e, 0x9305a6b0, 0xe86be3da, 0x74bed3cd, 0x372da53c, 0x4c7f4448, 0xdab5d440, 0x6dba0ec3,
			0x083919a7, 0x9fbaeed9, 0x49dbcfb0, 0x4e670c53, 0x5c3d9c01, 0x64bdb941, 0x2c0e636a, 0xba7dd9cd,
			0xea6f7388, 0xe70bc762, 0x35f29adb, 0x5c4cdd8d, 0xf0d48d8c, 0xb88153e2, 0x08a19866, 0x1ae2eac8,
			0x284caf89, 0xaa928223, 0x9334be53, 0x3b3a21bf, 0x16434be3, 0x9aea3906, 0xefe8c36e, 0xf890cdd9,
			0x80226dae, 0xc340a4a3, 0xdf7e9c09, 0xa694a807, 0x5b7c5ecc, 0x221db3a6, 0x9a69a02f, 0x68818a54,
			0xceb2296f, 0x53c0843a, 0xfe893655, 0x25bfe68a, 0xb4628abc, 0xcf222ebf, 0x25ac6f48, 0xa9a99387,
			0x53bddb65, 0xe76ffbe7, 0xe967fd78, 0x0ba93563, 0x8e342bc1, 0xe8a11be9, 0x4980740d, 0xc8087dfc,
			0x8de4bf99, 0xa11101a0, 0x7fd37975, 0xda5a26c0, 0xe81f994f, 0x9528cd89, 0xfd339fed, 0xb87834bf,
			0x5f04456d, 0x22258698, 0xc9c4c83b, 0x2dc156be, 0x4f628daa, 0x57f55ec5, 0xe2220abe, 0xd2916ebf,
			0x4ec75b95, 0x24f2c3c0, 0x42d15d99, 0xcd0d7fa0, 0x7b6e27ff, 0xa8dc8af0, 0x7345c106, 0xf41e232f,
			0x35162386, 0xe6ea8926, 0x3333b094, 0x157ec6f2, 0x372b74af, 0x692573e4, 0xe9a9d848, 0xf3160289,
			0x3a62ef1d, 0xa787e238, 0xf3a5f676, 0x74364853, 0x20951063, 0x4576698d, 0xb6fad407, 0x592af950,
			0x36f73523, 0x4cfb6e87, 0x7da4cec0, 0x6c152daa, 0xcb0396a8, 0xc50dfe5d, 0xfcd707ab, 0x0921c42f,
			0x89dff0bb, 0x5fe2be78, 0x448f4f33, 0x754613c9, 0x2b05d08d, 0x48b9d585, 0xdc049441, 0xc8098f9b,
			0x7dede786, 0xc39a3373, 0x42410005, 0x6a091751, 0x0ef3c8a6, 0x890072d6, 0x28207682, 0xa9a9f7be,
			0xbf32679d, 0xd45b5b75, 0xb353fd00, 0xcbb0e358, 0x830f220a, 0x1f8fb214, 0xd372cf08, 0xcc3c4a13,
			0x8cf63166, 0x061c87be, 0x88c98f88, 0x6062e397, 0x47cf8e7a, 0xb6c85283, 0x3cc2acfb, 0x3fc06976,
			0x4e8f0252, 0x64d8314d, 0xda3870e3, 0x1e665459, 0xc10908f0, 0x513021a5, 0x6c5b68b7, 0x822f8aa0,
			0x3007cd3e, 0x74719eef, 0xdc872681, 0x073340d4, 0x7e432fd9, 0x0c5ec241, 0x8809286c, 0xf592d891,
			0x08a930f6, 0x957ef305, 0xb7fbffbd, 0xc266e96f, 0x6fe4ac98, 0xb173ecc0, 0xbc60b42a, 0x953498da,
			0xfba1ae12, 0x2d4bd736, 0x0f25faab, 0xa4f3fceb, 0xe2969123, 0x257f0c3d, 0x9348af49, 0x361400bc,
			0xe8816f4a, 0x3814f200, 0xa3f94043, 0x9c7a54c2, 0xbc704f57, 0xda41e7f9, 0xc25ad33a, 0x54f4a084,
			0xb17f5505, 0x59357cbe, 0xedbd15c8, 0x7f97c5ab, 0xba5ac7b5, 0xb6f6deaf, 0x3a479c3a, 0x5302da25,
			0x653d7e6a, 0x54268d49, 0x51a477ea, 0x5017d55b, 0xd7d25d88, 0x44136c76, 0x0404a8c8, 0xb8e5a121,
			0xb81a928a, 0x60ed5869, 0x97c55b96, 0xeaec991b, 0x29935913, 0x01fdb7f1, 0x088e8dfa, 0x9ab6f6f5,
			0x3b4cbf9f, 0x4a5de3ab, 0xe6051d35, 0xa0e1d855, 0xd36b4cf1, 0xf544edeb, 0xb0e93524, 0xbebb8fbd,
			0xa2d762cf, 0x49c92f54, 0x38b5f331, 0x7128a454, 0x48392905, 0xa65b1db8, 0x851c97bd, 0xd675cf2f
		},
        S7 =
		{
			0x85e04019, 0x332bf567, 0x662dbfff, 0xcfc65693, 0x2a8d7f6f, 0xab9bc912, 0xde6008a1, 0x2028da1f,
			0x0227bce7, 0x4d642916, 0x18fac300, 0x50f18b82, 0x2cb2cb11, 0xb232e75c, 0x4b3695f2, 0xb28707de,
			0xa05fbcf6, 0xcd4181e9, 0xe150210c, 0xe24ef1bd, 0xb168c381, 0xfde4e789, 0x5c79b0d8, 0x1e8bfd43,
			0x4d495001, 0x38be4341, 0x913cee1d, 0x92a79c3f, 0x089766be, 0xbaeeadf4, 0x1286becf, 0xb6eacb19,
			0x2660c200, 0x7565bde4, 0x64241f7a, 0x8248dca9, 0xc3b3ad66, 0x28136086, 0x0bd8dfa8, 0x356d1cf2,
			0x107789be, 0xb3b2e9ce, 0x0502aa8f, 0x0bc0351e, 0x166bf52a, 0xeb12ff82, 0xe3486911, 0xd34d7516,
			0x4e7b3aff, 0x5f43671b, 0x9cf6e037, 0x4981ac83, 0x334266ce, 0x8c9341b7, 0xd0d854c0, 0xcb3a6c88,
			0x47bc2829, 0x4725ba37, 0xa66ad22b, 0x7ad61f1e, 0x0c5cbafa, 0x4437f107, 0xb6e79962, 0x42d2d816,
			0x0a961288, 0xe1a5c06e, 0x13749e67, 0x72fc081a, 0xb1d139f7, 0xf9583745, 0xcf19df58, 0xbec3f756,
			0xc06eba30, 0x07211b24, 0x45c28829, 0xc95e317f, 0xbc8ec511, 0x38bc46e9, 0xc6e6fa14, 0xbae8584a,
			0xad4ebc46, 0x468f508b, 0x7829435f, 0xf124183b, 0x821dba9f, 0xaff60ff4, 0xea2c4e6d, 0x16e39264,
			0x92544a8b, 0x009b4fc3, 0xaba68ced, 0x9ac96f78, 0x06a5b79a, 0xb2856e6e, 0x1aec3ca9, 0xbe838688,
			0x0e0804e9, 0x55f1be56, 0xe7e5363b, 0xb3a1f25d, 0xf7debb85, 0x61fe033c, 0x16746233, 0x3c034c28,
			0xda6d0c74, 0x79aac56c, 0x3ce4e1ad, 0x51f0c802, 0x98f8f35a, 0x1626a49f, 0xeed82b29, 0x1d382fe3,
			0x0c4fb99a, 0xbb325778, 0x3ec6d97b, 0x6e77a6a9, 0xcb658b5c, 0xd45230c7, 0x2bd1408b, 0x60c03eb7,
			0xb9068d78, 0xa33754f4, 0xf430c87d, 0xc8a71302, 0xb96d8c32, 0xebd4e7be, 0xbe8b9d2d, 0x7979fb06,
			0xe7225308, 0x8b75cf77, 0x11ef8da4, 0xe083c858, 0x8d6b786f, 0x5a6317a6, 0xfa5cf7a0, 0x5dda0033,
			0xf28ebfb0, 0xf5b9c310, 0xa0eac280, 0x08b9767a, 0xa3d9d2b0, 0x79d34217, 0x021a718d, 0x9ac6336a,
			0x2711fd60, 0x438050e3, 0x069908a8, 0x3d7fedc4, 0x826d2bef, 0x4eeb8476, 0x488dcf25, 0x36c9d566,
			0x28e74e41, 0xc2610aca, 0x3d49a9cf, 0xbae3b9df, 0xb65f8de6, 0x92aeaf64, 0x3ac7d5e6, 0x9ea80509,
			0xf22b017d, 0xa4173f70, 0xdd1e16c3, 0x15e0d7f9, 0x50b1b887, 0x2b9f4fd5, 0x625aba82, 0x6a017962,
			0x2ec01b9c, 0x15488aa9, 0xd716e740, 0x40055a2c, 0x93d29a22, 0xe32dbf9a, 0x058745b9, 0x3453dc1e,
			0xd699296e, 0x496cff6f, 0x1c9f4986, 0xdfe2ed07, 0xb87242d1, 0x19de7eae, 0x053e561a, 0x15ad6f8c,
			0x66626c1c, 0x7154c24c, 0xea082b2a, 0x93eb2939, 0x17dcb0f0, 0x58d4f2ae, 0x9ea294fb, 0x52cf564c,
			0x9883fe66, 0x2ec40581, 0x763953c3, 0x01d6692e, 0xd3a0c108, 0xa1e7160e, 0xe4f2dfa6, 0x693ed285,
			0x74904698, 0x4c2b0edd, 0x4f757656, 0x5d393378, 0xa132234f, 0x3d321c5d, 0xc3f5e194, 0x4b269301,
			0xc79f022f, 0x3c997e7e, 0x5e4f9504, 0x3ffafbbd, 0x76f7ad0e, 0x296693f4, 0x3d1fce6f, 0xc61e45be,
			0xd3b5ab34, 0xf72bf9b7, 0x1b0434c0, 0x4e72b567, 0x5592a33d, 0xb5229301, 0xcfd2a87f, 0x60aeb767,
			0x1814386b, 0x30bcc33d, 0x38a0c07d, 0xfd1606f2, 0xc363519b, 0x589dd390, 0x5479f8e6, 0x1cb8d647,
			0x97fd61a9, 0xea7759f4, 0x2d57539d, 0x569a58cf, 0xe84e63ad, 0x462e1b78, 0x6580f87e, 0xf3817914,
			0x91da55f4, 0x40a230f3, 0xd1988f35, 0xb6e318d2, 0x3ffa50bc, 0x3d40f021, 0xc3c0bdae, 0x4958c24c,
			0x518f36b2, 0x84b1d370, 0x0fedce83, 0x878ddada, 0xf2a279c7, 0x94e01be8, 0x90716f4b, 0x954b8aa3
		},
        S8 =
		{
			0xe216300d, 0xbbddfffc, 0xa7ebdabd, 0x35648095, 0x7789f8b7, 0xe6c1121b, 0x0e241600, 0x052ce8b5,
			0x11a9cfb0, 0xe5952f11, 0xece7990a, 0x9386d174, 0x2a42931c, 0x76e38111, 0xb12def3a, 0x37ddddfc,
			0xde9adeb1, 0x0a0cc32c, 0xbe197029, 0x84a00940, 0xbb243a0f, 0xb4d137cf, 0xb44e79f0, 0x049eedfd,
			0x0b15a15d, 0x480d3168, 0x8bbbde5a, 0x669ded42, 0xc7ece831, 0x3f8f95e7, 0x72df191b, 0x7580330d,
			0x94074251, 0x5c7dcdfa, 0xabbe6d63, 0xaa402164, 0xb301d40a, 0x02e7d1ca, 0x53571dae, 0x7a3182a2,
			0x12a8ddec, 0xfdaa335d, 0x176f43e8, 0x71fb46d4, 0x38129022, 0xce949ad4, 0xb84769ad, 0x965bd862,
			0x82f3d055, 0x66fb9767, 0x15b80b4e, 0x1d5b47a0, 0x4cfde06f, 0xc28ec4b8, 0x57e8726e, 0x647a78fc,
			0x99865d44, 0x608bd593, 0x6c200e03, 0x39dc5ff6, 0x5d0b00a3, 0xae63aff2, 0x7e8bd632, 0x70108c0c,
			0xbbd35049, 0x2998df04, 0x980cf42a, 0x9b6df491, 0x9e7edd53, 0x06918548, 0x58cb7e07, 0x3b74ef2e,
			0x522fffb1, 0xd24708cc, 0x1c7e27cd, 0xa4eb215b, 0x3cf1d2e2, 0x19b47a38, 0x424f7618, 0x35856039,
			0x9d17dee7, 0x27eb35e6, 0xc9aff67b, 0x36baf5b8, 0x09c467cd, 0xc18910b1, 0xe11dbf7b, 0x06cd1af8,
			0x7170c608, 0x2d5e3354, 0xd4de495a, 0x64c6d006, 0xbcc0c62c, 0x3dd00db3, 0x708f8f34, 0x77d51b42,
			0x264f620f, 0x24b8d2bf, 0x15c1b79e, 0x46a52564, 0xf8d7e54e, 0x3e378160, 0x7895cda5, 0x859c15a5,
			0xe6459788, 0xc37bc75f, 0xdb07ba0c, 0x0676a3ab, 0x7f229b1e, 0x31842e7b, 0x24259fd7, 0xf8bef472,
			0x835ffcb8, 0x6df4c1f2, 0x96f5b195, 0xfd0af0fc, 0xb0fe134c, 0xe2506d3d, 0x4f9b12ea, 0xf215f225,
			0xa223736f, 0x9fb4c428, 0x25d04979, 0x34c713f8, 0xc4618187, 0xea7a6e98, 0x7cd16efc, 0x1436876c,
			0xf1544107, 0xbedeee14, 0x56e9af27, 0xa04aa441, 0x3cf7c899, 0x92ecbae6, 0xdd67016d, 0x151682eb,
			0xa842eedf, 0xfdba60b4, 0xf1907b75, 0x20e3030f, 0x24d8c29e, 0xe139673b, 0xefa63fb8, 0x71873054,
			0xb6f2cf3b, 0x9f326442, 0xcb15a4cc, 0xb01a4504, 0xf1e47d8d, 0x844a1be5, 0xbae7dfdc, 0x42cbda70,
			0xcd7dae0a, 0x57e85b7a, 0xd53f5af6, 0x20cf4d8c, 0xcea4d428, 0x79d130a4, 0x3486ebfb, 0x33d3cddc,
			0x77853b53, 0x37effcb5, 0xc5068778, 0xe580b3e6, 0x4e68b8f4, 0xc5c8b37e, 0x0d809ea2, 0x398feb7c,
			0x132a4f94, 0x43b7950e, 0x2fee7d1c, 0x223613bd, 0xdd06caa2, 0x37df932b, 0xc4248289, 0xacf3ebc3,
			0x5715f6b7, 0xef3478dd, 0xf267616f, 0xc148cbe4, 0x9052815e, 0x5e410fab, 0xb48a2465, 0x2eda7fa4,
			0xe87b40e4, 0xe98ea084, 0x5889e9e1, 0xefd390fc, 0xdd07d35b, 0xdb485694, 0x38d7e5b2, 0x57720101,
			0x730edebc, 0x5b643113, 0x94917e4f, 0x503c2fba, 0x646f1282, 0x7523d24a, 0xe0779695, 0xf9c17a8f,
			0x7a5b2121, 0xd187b896, 0x29263a4d, 0xba510cdf, 0x81f47c9f, 0xad1163ed, 0xea7b5965, 0x1a00726e,
			0x11403092, 0x00da6d77, 0x4a0cdd61, 0xad1f4603, 0x605bdfb0, 0x9eedc364, 0x22ebe6a8, 0xcee7d28a,
			0xa0e736a0, 0x5564a6b9, 0x10853209, 0xc7eb8f37, 0x2de705ca, 0x8951570f, 0xdf09822b, 0xbd691a6c,
			0xaa12e4f2, 0x87451c0f, 0xe0f6a27a, 0x3ada4819, 0x4cf1764f, 0x0d771c2b, 0x67cdb156, 0x350d8384,
			0x5938fa0f, 0x42399ef3, 0x36997b07, 0x0e84093d, 0x4aa93e61, 0x8360d87b, 0x1fa98b0c, 0x1149382c,
			0xe97625a5, 0x0614d1b7, 0x0e25244b, 0x0c768347, 0x589e8d82, 0x0d2059d1, 0xa466bb1e, 0xf8da0a82,
			0x04f19130, 0xba6e4ec0, 0x99265164, 0x1ee7230d, 0x50b2ad80, 0xeaee6801, 0x8db2a283, 0xea8bf59e
		};

        #endregion

        /// <summary>
        /// Sets the subkeys using the same nomenclatureas described in RFC2144.
        /// </summary>
        /// <param name="key">The key.</param>
        private void SetKey(byte[] key)
        {
            /*
            * Determine the key size here, if required
            *
            * if keysize <= 80bits, use 12 rounds instead of 16
            * if keysize < 128bits, pad with 0
            *
            * Typical key sizes => 40, 64, 80, 128
            */

            if (key.Length < 11)
            {
                this._rounds = RED_ROUNDS;
            }

            int[] z = new int[16];
            int[] x = new int[16];

            uint z03, z47, z8B, zCF;
            uint x03, x47, x8B, xCF;

            /* copy the key into x */
            for (int i = 0; i < key.Length; i++)
            {
                x[i] = (int)(key[i] & 0xff);
            }

            /*
            * This will look different because the selection of
            * bytes from the input key I've already chosen the
            * correct int.
            */
            x03 = IntsTo32bits(x, 0x0);
            x47 = IntsTo32bits(x, 0x4);
            x8B = IntsTo32bits(x, 0x8);
            xCF = IntsTo32bits(x, 0xC);

            z03 = x03 ^ S5[x[0xD]] ^ S6[x[0xF]] ^ S7[x[0xC]] ^ S8[x[0xE]] ^ S7[x[0x8]];

            Bits32ToInts(z03, z, 0x0);
            z47 = x8B ^ S5[z[0x0]] ^ S6[z[0x2]] ^ S7[z[0x1]] ^ S8[z[0x3]] ^ S8[x[0xA]];
            Bits32ToInts(z47, z, 0x4);
            z8B = xCF ^ S5[z[0x7]] ^ S6[z[0x6]] ^ S7[z[0x5]] ^ S8[z[0x4]] ^ S5[x[0x9]];
            Bits32ToInts(z8B, z, 0x8);
            zCF = x47 ^ S5[z[0xA]] ^ S6[z[0x9]] ^ S7[z[0xB]] ^ S8[z[0x8]] ^ S6[x[0xB]];
            Bits32ToInts(zCF, z, 0xC);
            this._km[1] = S5[z[0x8]] ^ S6[z[0x9]] ^ S7[z[0x7]] ^ S8[z[0x6]] ^ S5[z[0x2]];
            this._km[2] = S5[z[0xA]] ^ S6[z[0xB]] ^ S7[z[0x5]] ^ S8[z[0x4]] ^ S6[z[0x6]];
            this._km[3] = S5[z[0xC]] ^ S6[z[0xD]] ^ S7[z[0x3]] ^ S8[z[0x2]] ^ S7[z[0x9]];
            this._km[4] = S5[z[0xE]] ^ S6[z[0xF]] ^ S7[z[0x1]] ^ S8[z[0x0]] ^ S8[z[0xC]];

            z03 = IntsTo32bits(z, 0x0);
            z47 = IntsTo32bits(z, 0x4);
            z8B = IntsTo32bits(z, 0x8);
            zCF = IntsTo32bits(z, 0xC);
            x03 = z8B ^ S5[z[0x5]] ^ S6[z[0x7]] ^ S7[z[0x4]] ^ S8[z[0x6]] ^ S7[z[0x0]];
            Bits32ToInts(x03, x, 0x0);
            x47 = z03 ^ S5[x[0x0]] ^ S6[x[0x2]] ^ S7[x[0x1]] ^ S8[x[0x3]] ^ S8[z[0x2]];
            Bits32ToInts(x47, x, 0x4);
            x8B = z47 ^ S5[x[0x7]] ^ S6[x[0x6]] ^ S7[x[0x5]] ^ S8[x[0x4]] ^ S5[z[0x1]];
            Bits32ToInts(x8B, x, 0x8);
            xCF = zCF ^ S5[x[0xA]] ^ S6[x[0x9]] ^ S7[x[0xB]] ^ S8[x[0x8]] ^ S6[z[0x3]];
            Bits32ToInts(xCF, x, 0xC);
            this._km[5] = S5[x[0x3]] ^ S6[x[0x2]] ^ S7[x[0xC]] ^ S8[x[0xD]] ^ S5[x[0x8]];
            this._km[6] = S5[x[0x1]] ^ S6[x[0x0]] ^ S7[x[0xE]] ^ S8[x[0xF]] ^ S6[x[0xD]];
            this._km[7] = S5[x[0x7]] ^ S6[x[0x6]] ^ S7[x[0x8]] ^ S8[x[0x9]] ^ S7[x[0x3]];
            this._km[8] = S5[x[0x5]] ^ S6[x[0x4]] ^ S7[x[0xA]] ^ S8[x[0xB]] ^ S8[x[0x7]];

            x03 = IntsTo32bits(x, 0x0);
            x47 = IntsTo32bits(x, 0x4);
            x8B = IntsTo32bits(x, 0x8);
            xCF = IntsTo32bits(x, 0xC);
            z03 = x03 ^ S5[x[0xD]] ^ S6[x[0xF]] ^ S7[x[0xC]] ^ S8[x[0xE]] ^ S7[x[0x8]];
            Bits32ToInts(z03, z, 0x0);
            z47 = x8B ^ S5[z[0x0]] ^ S6[z[0x2]] ^ S7[z[0x1]] ^ S8[z[0x3]] ^ S8[x[0xA]];
            Bits32ToInts(z47, z, 0x4);
            z8B = xCF ^ S5[z[0x7]] ^ S6[z[0x6]] ^ S7[z[0x5]] ^ S8[z[0x4]] ^ S5[x[0x9]];
            Bits32ToInts(z8B, z, 0x8);
            zCF = x47 ^ S5[z[0xA]] ^ S6[z[0x9]] ^ S7[z[0xB]] ^ S8[z[0x8]] ^ S6[x[0xB]];
            Bits32ToInts(zCF, z, 0xC);
            this._km[9] = S5[z[0x3]] ^ S6[z[0x2]] ^ S7[z[0xC]] ^ S8[z[0xD]] ^ S5[z[0x9]];
            this._km[10] = S5[z[0x1]] ^ S6[z[0x0]] ^ S7[z[0xE]] ^ S8[z[0xF]] ^ S6[z[0xc]];
            this._km[11] = S5[z[0x7]] ^ S6[z[0x6]] ^ S7[z[0x8]] ^ S8[z[0x9]] ^ S7[z[0x2]];
            this._km[12] = S5[z[0x5]] ^ S6[z[0x4]] ^ S7[z[0xA]] ^ S8[z[0xB]] ^ S8[z[0x6]];

            z03 = IntsTo32bits(z, 0x0);
            z47 = IntsTo32bits(z, 0x4);
            z8B = IntsTo32bits(z, 0x8);
            zCF = IntsTo32bits(z, 0xC);
            x03 = z8B ^ S5[z[0x5]] ^ S6[z[0x7]] ^ S7[z[0x4]] ^ S8[z[0x6]] ^ S7[z[0x0]];
            Bits32ToInts(x03, x, 0x0);
            x47 = z03 ^ S5[x[0x0]] ^ S6[x[0x2]] ^ S7[x[0x1]] ^ S8[x[0x3]] ^ S8[z[0x2]];
            Bits32ToInts(x47, x, 0x4);
            x8B = z47 ^ S5[x[0x7]] ^ S6[x[0x6]] ^ S7[x[0x5]] ^ S8[x[0x4]] ^ S5[z[0x1]];
            Bits32ToInts(x8B, x, 0x8);
            xCF = zCF ^ S5[x[0xA]] ^ S6[x[0x9]] ^ S7[x[0xB]] ^ S8[x[0x8]] ^ S6[z[0x3]];
            Bits32ToInts(xCF, x, 0xC);
            this._km[13] = S5[x[0x8]] ^ S6[x[0x9]] ^ S7[x[0x7]] ^ S8[x[0x6]] ^ S5[x[0x3]];
            this._km[14] = S5[x[0xA]] ^ S6[x[0xB]] ^ S7[x[0x5]] ^ S8[x[0x4]] ^ S6[x[0x7]];
            this._km[15] = S5[x[0xC]] ^ S6[x[0xD]] ^ S7[x[0x3]] ^ S8[x[0x2]] ^ S7[x[0x8]];
            this._km[16] = S5[x[0xE]] ^ S6[x[0xF]] ^ S7[x[0x1]] ^ S8[x[0x0]] ^ S8[x[0xD]];

            x03 = IntsTo32bits(x, 0x0);
            x47 = IntsTo32bits(x, 0x4);
            x8B = IntsTo32bits(x, 0x8);
            xCF = IntsTo32bits(x, 0xC);
            z03 = x03 ^ S5[x[0xD]] ^ S6[x[0xF]] ^ S7[x[0xC]] ^ S8[x[0xE]] ^ S7[x[0x8]];
            Bits32ToInts(z03, z, 0x0);
            z47 = x8B ^ S5[z[0x0]] ^ S6[z[0x2]] ^ S7[z[0x1]] ^ S8[z[0x3]] ^ S8[x[0xA]];
            Bits32ToInts(z47, z, 0x4);
            z8B = xCF ^ S5[z[0x7]] ^ S6[z[0x6]] ^ S7[z[0x5]] ^ S8[z[0x4]] ^ S5[x[0x9]];
            Bits32ToInts(z8B, z, 0x8);
            zCF = x47 ^ S5[z[0xA]] ^ S6[z[0x9]] ^ S7[z[0xB]] ^ S8[z[0x8]] ^ S6[x[0xB]];
            Bits32ToInts(zCF, z, 0xC);
            this._kr[1] = (int)((S5[z[0x8]] ^ S6[z[0x9]] ^ S7[z[0x7]] ^ S8[z[0x6]] ^ S5[z[0x2]]) & 0x1f);
            this._kr[2] = (int)((S5[z[0xA]] ^ S6[z[0xB]] ^ S7[z[0x5]] ^ S8[z[0x4]] ^ S6[z[0x6]]) & 0x1f);
            this._kr[3] = (int)((S5[z[0xC]] ^ S6[z[0xD]] ^ S7[z[0x3]] ^ S8[z[0x2]] ^ S7[z[0x9]]) & 0x1f);
            this._kr[4] = (int)((S5[z[0xE]] ^ S6[z[0xF]] ^ S7[z[0x1]] ^ S8[z[0x0]] ^ S8[z[0xC]]) & 0x1f);

            z03 = IntsTo32bits(z, 0x0);
            z47 = IntsTo32bits(z, 0x4);
            z8B = IntsTo32bits(z, 0x8);
            zCF = IntsTo32bits(z, 0xC);
            x03 = z8B ^ S5[z[0x5]] ^ S6[z[0x7]] ^ S7[z[0x4]] ^ S8[z[0x6]] ^ S7[z[0x0]];
            Bits32ToInts(x03, x, 0x0);
            x47 = z03 ^ S5[x[0x0]] ^ S6[x[0x2]] ^ S7[x[0x1]] ^ S8[x[0x3]] ^ S8[z[0x2]];
            Bits32ToInts(x47, x, 0x4);
            x8B = z47 ^ S5[x[0x7]] ^ S6[x[0x6]] ^ S7[x[0x5]] ^ S8[x[0x4]] ^ S5[z[0x1]];
            Bits32ToInts(x8B, x, 0x8);
            xCF = zCF ^ S5[x[0xA]] ^ S6[x[0x9]] ^ S7[x[0xB]] ^ S8[x[0x8]] ^ S6[z[0x3]];
            Bits32ToInts(xCF, x, 0xC);
            this._kr[5] = (int)((S5[x[0x3]] ^ S6[x[0x2]] ^ S7[x[0xC]] ^ S8[x[0xD]] ^ S5[x[0x8]]) & 0x1f);
            this._kr[6] = (int)((S5[x[0x1]] ^ S6[x[0x0]] ^ S7[x[0xE]] ^ S8[x[0xF]] ^ S6[x[0xD]]) & 0x1f);
            this._kr[7] = (int)((S5[x[0x7]] ^ S6[x[0x6]] ^ S7[x[0x8]] ^ S8[x[0x9]] ^ S7[x[0x3]]) & 0x1f);
            this._kr[8] = (int)((S5[x[0x5]] ^ S6[x[0x4]] ^ S7[x[0xA]] ^ S8[x[0xB]] ^ S8[x[0x7]]) & 0x1f);

            x03 = IntsTo32bits(x, 0x0);
            x47 = IntsTo32bits(x, 0x4);
            x8B = IntsTo32bits(x, 0x8);
            xCF = IntsTo32bits(x, 0xC);
            z03 = x03 ^ S5[x[0xD]] ^ S6[x[0xF]] ^ S7[x[0xC]] ^ S8[x[0xE]] ^ S7[x[0x8]];
            Bits32ToInts(z03, z, 0x0);
            z47 = x8B ^ S5[z[0x0]] ^ S6[z[0x2]] ^ S7[z[0x1]] ^ S8[z[0x3]] ^ S8[x[0xA]];
            Bits32ToInts(z47, z, 0x4);
            z8B = xCF ^ S5[z[0x7]] ^ S6[z[0x6]] ^ S7[z[0x5]] ^ S8[z[0x4]] ^ S5[x[0x9]];
            Bits32ToInts(z8B, z, 0x8);
            zCF = x47 ^ S5[z[0xA]] ^ S6[z[0x9]] ^ S7[z[0xB]] ^ S8[z[0x8]] ^ S6[x[0xB]];
            Bits32ToInts(zCF, z, 0xC);
            this._kr[9] = (int)((S5[z[0x3]] ^ S6[z[0x2]] ^ S7[z[0xC]] ^ S8[z[0xD]] ^ S5[z[0x9]]) & 0x1f);
            this._kr[10] = (int)((S5[z[0x1]] ^ S6[z[0x0]] ^ S7[z[0xE]] ^ S8[z[0xF]] ^ S6[z[0xc]]) & 0x1f);
            this._kr[11] = (int)((S5[z[0x7]] ^ S6[z[0x6]] ^ S7[z[0x8]] ^ S8[z[0x9]] ^ S7[z[0x2]]) & 0x1f);
            this._kr[12] = (int)((S5[z[0x5]] ^ S6[z[0x4]] ^ S7[z[0xA]] ^ S8[z[0xB]] ^ S8[z[0x6]]) & 0x1f);

            z03 = IntsTo32bits(z, 0x0);
            z47 = IntsTo32bits(z, 0x4);
            z8B = IntsTo32bits(z, 0x8);
            zCF = IntsTo32bits(z, 0xC);
            x03 = z8B ^ S5[z[0x5]] ^ S6[z[0x7]] ^ S7[z[0x4]] ^ S8[z[0x6]] ^ S7[z[0x0]];
            Bits32ToInts(x03, x, 0x0);
            x47 = z03 ^ S5[x[0x0]] ^ S6[x[0x2]] ^ S7[x[0x1]] ^ S8[x[0x3]] ^ S8[z[0x2]];
            Bits32ToInts(x47, x, 0x4);
            x8B = z47 ^ S5[x[0x7]] ^ S6[x[0x6]] ^ S7[x[0x5]] ^ S8[x[0x4]] ^ S5[z[0x1]];
            Bits32ToInts(x8B, x, 0x8);
            xCF = zCF ^ S5[x[0xA]] ^ S6[x[0x9]] ^ S7[x[0xB]] ^ S8[x[0x8]] ^ S6[z[0x3]];
            Bits32ToInts(xCF, x, 0xC);
            this._kr[13] = (int)((S5[x[0x8]] ^ S6[x[0x9]] ^ S7[x[0x7]] ^ S8[x[0x6]] ^ S5[x[0x3]]) & 0x1f);
            this._kr[14] = (int)((S5[x[0xA]] ^ S6[x[0xB]] ^ S7[x[0x5]] ^ S8[x[0x4]] ^ S6[x[0x7]]) & 0x1f);
            this._kr[15] = (int)((S5[x[0xC]] ^ S6[x[0xD]] ^ S7[x[0x3]] ^ S8[x[0x2]] ^ S7[x[0x8]]) & 0x1f);
            this._kr[16] = (int)((S5[x[0xE]] ^ S6[x[0xF]] ^ S7[x[0x1]] ^ S8[x[0x0]] ^ S8[x[0xD]]) & 0x1f);
        }

        /// <summary>
        /// The first of the three processing functions for the encryption and decryption.
        /// </summary>
        /// <param name="D">The input to be processed.</param>
        /// <param name="Kmi">The mask to be used from Km[n].</param>
        /// <param name="Kri">The rotation value to be used.</param>
        /// <returns></returns>
        private static uint F1(uint D, uint Kmi, int Kri)
        {
            uint I = Kmi + D;
            I = I << Kri | (I >> (32 - Kri));
            return ((S1[(I >> 24) & 0xff] ^ S2[(I >> 16) & 0xff]) - S3[(I >> 8) & 0xff]) + S4[I & 0xff];
        }

        /// <summary>
        /// The second of the three processing functions for the encryption and decryption.
        /// </summary>
        /// <param name="D">The input to be processed.</param>
        /// <param name="Kmi">The mask to be used from Km[n].</param>
        /// <param name="Kri">The rotation value to be used.</param>
        /// <returns></returns>
        private static uint F2(uint D, uint Kmi, int Kri)
        {
            uint I = Kmi ^ D;
            I = I << Kri | (I >> (32 - Kri));
            return ((S1[(I >> 24) & 0xff] - S2[(I >> 16) & 0xff]) + S3[(I >> 8) & 0xff]) ^ S4[I & 0xff];
        }

        /// <summary>
        /// The third of the three processing functions for the encryption and decryption.
        /// </summary>
        /// <param name="D">The input to be processed.</param>
        /// <param name="Kmi">The mask to be used from Km[n].</param>
        /// <param name="Kri">The rotation value to be used.</param>
        /// <returns></returns>
        private static uint F3(uint D, uint Kmi, int Kri)
        {
            uint I = Kmi - D;
            I = I << Kri | (I >> (32 - Kri));
            return ((S1[(I >> 24) & 0xff] + S2[(I >> 16) & 0xff]) ^ S3[(I >> 8) & 0xff]) - S4[I & 0xff];
        }

        /// <summary>
        /// Does the 16 rounds to encrypt the block.
        /// </summary>
        /// <param name="L0">The LH-32bits of the plaintext block.</param>
        /// <param name="R0">The RH-32bits of the plaintext block.</param>
        /// <param name="result">The result.</param>
        private void CastEncipher(uint L0, uint R0, uint[] result)
        {
            uint Lp = L0;        // the previous value, equiv to L[i-1]
            uint Rp = R0;        // equivalent to R[i-1]

            /*
            * numbering consistent with paper to make
            * checking and validating easier
            */
            uint Li = L0, Ri = R0;

            for (int i = 1; i <= this._rounds; i++)
            {
                Lp = Li;
                Rp = Ri;

                Li = Rp;
                switch (i)
                {
                    case 1:
                    case 4:
                    case 7:
                    case 10:
                    case 13:
                    case 16:
                        Ri = Lp ^ F1(Rp, this._km[i], this._kr[i]);
                        break;
                    case 2:
                    case 5:
                    case 8:
                    case 11:
                    case 14:
                        Ri = Lp ^ F2(Rp, this._km[i], this._kr[i]);
                        break;
                    case 3:
                    case 6:
                    case 9:
                    case 12:
                    case 15:
                        Ri = Lp ^ F3(Rp, this._km[i], this._kr[i]);
                        break;
                }
            }

            result[0] = Ri;
            result[1] = Li;
        }

        private void CastDecipher(uint L16, uint R16, uint[] result)
        {
            uint Lp = L16;        // the previous value, equiv to L[i-1]
            uint Rp = R16;        // equivalent to R[i-1]

            /*
            * numbering consistent with paper to make
            * checking and validating easier
            */
            uint Li = L16, Ri = R16;

            for (int i = this._rounds; i > 0; i--)
            {
                Lp = Li;
                Rp = Ri;

                Li = Rp;
                switch (i)
                {
                    case 1:
                    case 4:
                    case 7:
                    case 10:
                    case 13:
                    case 16:
                        Ri = Lp ^ F1(Rp, this._km[i], this._kr[i]);
                        break;
                    case 2:
                    case 5:
                    case 8:
                    case 11:
                    case 14:
                        Ri = Lp ^ F2(Rp, this._km[i], this._kr[i]);
                        break;
                    case 3:
                    case 6:
                    case 9:
                    case 12:
                    case 15:
                        Ri = Lp ^ F3(Rp, this._km[i], this._kr[i]);
                        break;
                }
            }

            result[0] = Ri;
            result[1] = Li;
        }

        private static void Bits32ToInts(uint inData, int[] b, int offset)
        {
            b[offset + 3] = (int)(inData & 0xff);
            b[offset + 2] = (int)((inData >> 8) & 0xff);
            b[offset + 1] = (int)((inData >> 16) & 0xff);
            b[offset] = (int)((inData >> 24) & 0xff);
        }

        private static uint IntsTo32bits(int[] b, int i)
        {
            return (uint)(((b[i] & 0xff) << 24) |
                ((b[i + 1] & 0xff) << 16) |
                ((b[i + 2] & 0xff) << 8) |
                ((b[i + 3] & 0xff)));
        }

    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Ciphers\CipherMode.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography.Ciphers
{
    /// <summary>
    /// Base class for cipher mode implementations
    /// </summary>
    public abstract class CipherModeRenci
    {
        /// <summary>
        /// Gets the cipher.
        /// </summary>
        protected BlockCipher Cipher;

        /// <summary>
        /// Gets the IV vector.
        /// </summary>
        protected byte[] IV;

        /// <summary>
        /// Holds block size of the cipher.
        /// </summary>
        protected int _blockSize;

        /// <summary>
        /// Initializes a new instance of the <see cref="CipherModeRenci"/> class.
        /// </summary>
        /// <param name="iv">The iv.</param>
        protected CipherModeRenci(byte[] iv)
        {
            this.IV = iv;
        }

        /// <summary>
        /// Initializes the specified cipher mode.
        /// </summary>
        /// <param name="cipher">The cipher.</param>
        internal void Init(BlockCipher cipher)
        {
            this.Cipher = cipher;
            this._blockSize = cipher.BlockSize;
            this.IV = this.IV.Take(this._blockSize).ToArray();
        }

        /// <summary>
        /// Encrypts the specified region of the input byte array and copies the encrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to encrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write encrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes encrypted.
        /// </returns>
        public abstract int EncryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);

        /// <summary>
        /// Decrypts the specified region of the input byte array and copies the decrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to decrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write decrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes decrypted.
        /// </returns>
        public abstract int DecryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Ciphers\CipherPadding.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Security.Cryptography.Ciphers
{
    /// <summary>
    /// Base class for cipher padding implementations
    /// </summary>
    public abstract class CipherPadding
    {
        /// <summary>
        /// Pads specified input to match block size.
        /// </summary>
        /// <param name="blockSize">Size of the block.</param>
        /// <param name="input">The input.</param>
        /// <returns>Padded data array.</returns>
        public abstract byte[] Pad(int blockSize, byte[] input);
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Ciphers\DesCipher.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography.Ciphers
{
	/// <summary>
	/// Implements DES cipher algorithm.
	/// </summary>
	public class DesCipher : BlockCipher
	{
		private int[] _encryptionKey;

		private int[] _decryptionKey;

		#region Static tables

		private static readonly short[] bytebit =
		{
			128, 64, 32, 16, 8, 4, 2, 1
		};

		private static readonly int[] bigbyte =
		{
			0x800000,	0x400000,	0x200000,	0x100000,
			0x80000,	0x40000,	0x20000,	0x10000,
			0x8000,		0x4000,		0x2000,		0x1000,
			0x800,		0x400,		0x200,		0x100,
			0x80,		0x40,		0x20,		0x10,
			0x8,		0x4,		0x2,		0x1
		};

		/*
		* Use the key schedule specified in the Standard (ANSI X3.92-1981).
		*/
		private static readonly byte[] pc1 =
		{
			56, 48, 40, 32, 24, 16,  8,   0, 57, 49, 41, 33, 25, 17,
			9,  1, 58, 50, 42, 34, 26,  18, 10,  2, 59, 51, 43, 35,
			62, 54, 46, 38, 30, 22, 14,   6, 61, 53, 45, 37, 29, 21,
			13,  5, 60, 52, 44, 36, 28,  20, 12,  4, 27, 19, 11,  3
		};

		private static readonly byte[] totrot =
		{
			1, 2, 4, 6, 8, 10, 12, 14,
			15, 17, 19, 21, 23, 25, 27, 28
		};

		private static readonly byte[] pc2 =
		{
			13, 16, 10, 23,  0,  4,  2, 27, 14,  5, 20,  9,
			22, 18, 11,  3, 25,  7, 15,  6, 26, 19, 12,  1,
			40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32, 47,
			43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31
		};

		private static readonly uint[] SP1 =
		{
			0x01010400, 0x00000000, 0x00010000, 0x01010404,
			0x01010004, 0x00010404, 0x00000004, 0x00010000,
			0x00000400, 0x01010400, 0x01010404, 0x00000400,
			0x01000404, 0x01010004, 0x01000000, 0x00000004,
			0x00000404, 0x01000400, 0x01000400, 0x00010400,
			0x00010400, 0x01010000, 0x01010000, 0x01000404,
			0x00010004, 0x01000004, 0x01000004, 0x00010004,
			0x00000000, 0x00000404, 0x00010404, 0x01000000,
			0x00010000, 0x01010404, 0x00000004, 0x01010000,
			0x01010400, 0x01000000, 0x01000000, 0x00000400,
			0x01010004, 0x00010000, 0x00010400, 0x01000004,
			0x00000400, 0x00000004, 0x01000404, 0x00010404,
			0x01010404, 0x00010004, 0x01010000, 0x01000404,
			0x01000004, 0x00000404, 0x00010404, 0x01010400,
			0x00000404, 0x01000400, 0x01000400, 0x00000000,
			0x00010004, 0x00010400, 0x00000000, 0x01010004
		};

		private static readonly uint[] SP2 =
		{
			0x80108020, 0x80008000, 0x00008000, 0x00108020,
			0x00100000, 0x00000020, 0x80100020, 0x80008020,
			0x80000020, 0x80108020, 0x80108000, 0x80000000,
			0x80008000, 0x00100000, 0x00000020, 0x80100020,
			0x00108000, 0x00100020, 0x80008020, 0x00000000,
			0x80000000, 0x00008000, 0x00108020, 0x80100000,
			0x00100020, 0x80000020, 0x00000000, 0x00108000,
			0x00008020, 0x80108000, 0x80100000, 0x00008020,
			0x00000000, 0x00108020, 0x80100020, 0x00100000,
			0x80008020, 0x80100000, 0x80108000, 0x00008000,
			0x80100000, 0x80008000, 0x00000020, 0x80108020,
			0x00108020, 0x00000020, 0x00008000, 0x80000000,
			0x00008020, 0x80108000, 0x00100000, 0x80000020,
			0x00100020, 0x80008020, 0x80000020, 0x00100020,
			0x00108000, 0x00000000, 0x80008000, 0x00008020,
			0x80000000, 0x80100020, 0x80108020, 0x00108000
		};

		private static readonly uint[] SP3 =
		{
			0x00000208, 0x08020200, 0x00000000, 0x08020008,
			0x08000200, 0x00000000, 0x00020208, 0x08000200,
			0x00020008, 0x08000008, 0x08000008, 0x00020000,
			0x08020208, 0x00020008, 0x08020000, 0x00000208,
			0x08000000, 0x00000008, 0x08020200, 0x00000200,
			0x00020200, 0x08020000, 0x08020008, 0x00020208,
			0x08000208, 0x00020200, 0x00020000, 0x08000208,
			0x00000008, 0x08020208, 0x00000200, 0x08000000,
			0x08020200, 0x08000000, 0x00020008, 0x00000208,
			0x00020000, 0x08020200, 0x08000200, 0x00000000,
			0x00000200, 0x00020008, 0x08020208, 0x08000200,
			0x08000008, 0x00000200, 0x00000000, 0x08020008,
			0x08000208, 0x00020000, 0x08000000, 0x08020208,
			0x00000008, 0x00020208, 0x00020200, 0x08000008,
			0x08020000, 0x08000208, 0x00000208, 0x08020000,
			0x00020208, 0x00000008, 0x08020008, 0x00020200
		};

		private static readonly uint[] SP4 =
		{
			0x00802001, 0x00002081, 0x00002081, 0x00000080,
			0x00802080, 0x00800081, 0x00800001, 0x00002001,
			0x00000000, 0x00802000, 0x00802000, 0x00802081,
			0x00000081, 0x00000000, 0x00800080, 0x00800001,
			0x00000001, 0x00002000, 0x00800000, 0x00802001,
			0x00000080, 0x00800000, 0x00002001, 0x00002080,
			0x00800081, 0x00000001, 0x00002080, 0x00800080,
			0x00002000, 0x00802080, 0x00802081, 0x00000081,
			0x00800080, 0x00800001, 0x00802000, 0x00802081,
			0x00000081, 0x00000000, 0x00000000, 0x00802000,
			0x00002080, 0x00800080, 0x00800081, 0x00000001,
			0x00802001, 0x00002081, 0x00002081, 0x00000080,
			0x00802081, 0x00000081, 0x00000001, 0x00002000,
			0x00800001, 0x00002001, 0x00802080, 0x00800081,
			0x00002001, 0x00002080, 0x00800000, 0x00802001,
			0x00000080, 0x00800000, 0x00002000, 0x00802080
		};

		private static readonly uint[] SP5 =
		{
			0x00000100, 0x02080100, 0x02080000, 0x42000100,
			0x00080000, 0x00000100, 0x40000000, 0x02080000,
			0x40080100, 0x00080000, 0x02000100, 0x40080100,
			0x42000100, 0x42080000, 0x00080100, 0x40000000,
			0x02000000, 0x40080000, 0x40080000, 0x00000000,
			0x40000100, 0x42080100, 0x42080100, 0x02000100,
			0x42080000, 0x40000100, 0x00000000, 0x42000000,
			0x02080100, 0x02000000, 0x42000000, 0x00080100,
			0x00080000, 0x42000100, 0x00000100, 0x02000000,
			0x40000000, 0x02080000, 0x42000100, 0x40080100,
			0x02000100, 0x40000000, 0x42080000, 0x02080100,
			0x40080100, 0x00000100, 0x02000000, 0x42080000,
			0x42080100, 0x00080100, 0x42000000, 0x42080100,
			0x02080000, 0x00000000, 0x40080000, 0x42000000,
			0x00080100, 0x02000100, 0x40000100, 0x00080000,
			0x00000000, 0x40080000, 0x02080100, 0x40000100
		};

		private static readonly uint[] SP6 =
		{
			0x20000010, 0x20400000, 0x00004000, 0x20404010,
			0x20400000, 0x00000010, 0x20404010, 0x00400000,
			0x20004000, 0x00404010, 0x00400000, 0x20000010,
			0x00400010, 0x20004000, 0x20000000, 0x00004010,
			0x00000000, 0x00400010, 0x20004010, 0x00004000,
			0x00404000, 0x20004010, 0x00000010, 0x20400010,
			0x20400010, 0x00000000, 0x00404010, 0x20404000,
			0x00004010, 0x00404000, 0x20404000, 0x20000000,
			0x20004000, 0x00000010, 0x20400010, 0x00404000,
			0x20404010, 0x00400000, 0x00004010, 0x20000010,
			0x00400000, 0x20004000, 0x20000000, 0x00004010,
			0x20000010, 0x20404010, 0x00404000, 0x20400000,
			0x00404010, 0x20404000, 0x00000000, 0x20400010,
			0x00000010, 0x00004000, 0x20400000, 0x00404010,
			0x00004000, 0x00400010, 0x20004010, 0x00000000,
			0x20404000, 0x20000000, 0x00400010, 0x20004010
		};

		private static readonly uint[] SP7 =
		{
			0x00200000, 0x04200002, 0x04000802, 0x00000000,
			0x00000800, 0x04000802, 0x00200802, 0x04200800,
			0x04200802, 0x00200000, 0x00000000, 0x04000002,
			0x00000002, 0x04000000, 0x04200002, 0x00000802,
			0x04000800, 0x00200802, 0x00200002, 0x04000800,
			0x04000002, 0x04200000, 0x04200800, 0x00200002,
			0x04200000, 0x00000800, 0x00000802, 0x04200802,
			0x00200800, 0x00000002, 0x04000000, 0x00200800,
			0x04000000, 0x00200800, 0x00200000, 0x04000802,
			0x04000802, 0x04200002, 0x04200002, 0x00000002,
			0x00200002, 0x04000000, 0x04000800, 0x00200000,
			0x04200800, 0x00000802, 0x00200802, 0x04200800,
			0x00000802, 0x04000002, 0x04200802, 0x04200000,
			0x00200800, 0x00000000, 0x00000002, 0x04200802,
			0x00000000, 0x00200802, 0x04200000, 0x00000800,
			0x04000002, 0x04000800, 0x00000800, 0x00200002
		};

		private static readonly uint[] SP8 =
		{
			0x10001040, 0x00001000, 0x00040000, 0x10041040,
			0x10000000, 0x10001040, 0x00000040, 0x10000000,
			0x00040040, 0x10040000, 0x10041040, 0x00041000,
			0x10041000, 0x00041040, 0x00001000, 0x00000040,
			0x10040000, 0x10000040, 0x10001000, 0x00001040,
			0x00041000, 0x00040040, 0x10040040, 0x10041000,
			0x00001040, 0x00000000, 0x00000000, 0x10040040,
			0x10000040, 0x10001000, 0x00041040, 0x00040000,
			0x00041040, 0x00040000, 0x10041000, 0x00001000,
			0x00000040, 0x10040040, 0x00001000, 0x00041040,
			0x10001000, 0x00000040, 0x10000040, 0x10040000,
			0x10040040, 0x10000000, 0x00040000, 0x10001040,
			0x00000000, 0x10041040, 0x00040040, 0x10000040,
			0x10040000, 0x10001000, 0x10001040, 0x00000000,
			0x10041040, 0x00041000, 0x00041000, 0x00001040,
			0x00001040, 0x00040040, 0x10000000, 0x10041000
		};

		#endregion

		/// <summary>
		/// Initializes a new instance of the <see cref="DesCipher"/> class.
		/// </summary>
		/// <param name="key">The key.</param>
		/// <param name="mode">The mode.</param>
		/// <param name="padding">The padding.</param>
		/// <exception cref="ArgumentNullException"><paramref name="key"/> is null.</exception>
		public DesCipher(byte[] key, CipherModeRenci mode, CipherPadding padding)
			: base(key, 8, mode, padding)
		{
		}

		/// <summary>
		/// Encrypts the specified region of the input byte array and copies the encrypted data to the specified region of the output byte array.
		/// </summary>
		/// <param name="inputBuffer">The input data to encrypt.</param>
		/// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
		/// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
		/// <param name="outputBuffer">The output to which to write encrypted data.</param>
		/// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
		/// <returns>
		/// The number of bytes encrypted.
		/// </returns>
		public override int EncryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
		{
			if ((inputOffset + this.BlockSize) > inputBuffer.Length)
				throw new IndexOutOfRangeException("input buffer too short");

			if ((outputOffset + this.BlockSize) > outputBuffer.Length)
				throw new IndexOutOfRangeException("output buffer too short");

			if (this._encryptionKey == null)
			{
				this._encryptionKey = GenerateWorkingKey(true, this.Key);
			}

			DesFunc(this._encryptionKey, inputBuffer, inputOffset, outputBuffer, outputOffset);

			return this.BlockSize;
		}

		/// <summary>
		/// Decrypts the specified region of the input byte array and copies the decrypted data to the specified region of the output byte array.
		/// </summary>
		/// <param name="inputBuffer">The input data to decrypt.</param>
		/// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
		/// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
		/// <param name="outputBuffer">The output to which to write decrypted data.</param>
		/// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
		/// <returns>
		/// The number of bytes decrypted.
		/// </returns>
		public override int DecryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
		{
			if ((inputOffset + this.BlockSize) > inputBuffer.Length)
				throw new IndexOutOfRangeException("input buffer too short");

			if ((outputOffset + this.BlockSize) > outputBuffer.Length)
				throw new IndexOutOfRangeException("output buffer too short");

			if (this._decryptionKey == null)
			{
				this._decryptionKey = GenerateWorkingKey(false, this.Key);
			}

			DesFunc(this._decryptionKey, inputBuffer, inputOffset, outputBuffer, outputOffset);

			return this.BlockSize;
		}

        /// <summary>
        /// Generates the working key.
        /// </summary>
        /// <param name="encrypting">if set to <c>true</c> [encrypting].</param>
        /// <param name="key">The key.</param>
        /// <returns>Generated working key.</returns>
		protected int[] GenerateWorkingKey(bool encrypting, byte[] key)
		{
			this.ValidateKey();

			int[] newKey = new int[32];
			bool[] pc1m = new bool[56];
			bool[] pcr = new bool[56];

			for (int j = 0; j < 56; j++)
			{
				int l = pc1[j];

				pc1m[j] = ((key[(uint)l >> 3] & bytebit[l & 07]) != 0);
			}

			for (int i = 0; i < 16; i++)
			{
				int l, m, n;

				if (encrypting)
				{
					m = i << 1;
				}
				else
				{
					m = (15 - i) << 1;
				}

				n = m + 1;
				newKey[m] = newKey[n] = 0;

				for (int j = 0; j < 28; j++)
				{
					l = j + totrot[i];
					if (l < 28)
					{
						pcr[j] = pc1m[l];
					}
					else
					{
						pcr[j] = pc1m[l - 28];
					}
				}

				for (int j = 28; j < 56; j++)
				{
					l = j + totrot[i];
					if (l < 56)
					{
						pcr[j] = pc1m[l];
					}
					else
					{
						pcr[j] = pc1m[l - 28];
					}
				}

				for (int j = 0; j < 24; j++)
				{
					if (pcr[pc2[j]])
					{
						newKey[m] |= bigbyte[j];
					}

					if (pcr[pc2[j + 24]])
					{
						newKey[n] |= bigbyte[j];
					}
				}
			}

			//
			// store the processed key
			//
			for (int i = 0; i != 32; i += 2)
			{
				int i1, i2;

				i1 = newKey[i];
				i2 = newKey[i + 1];

				newKey[i] = (int)  ((uint)((i1 & 0x00fc0000) << 6) |
									(uint)((i1 & 0x00000fc0) << 10) |
									((uint)(i2 & 0x00fc0000) >> 10) |
									((uint)(i2 & 0x00000fc0) >> 6));

				newKey[i + 1] = (int)((uint)((i1 & 0x0003f000) << 12) |
									  (uint)((i1 & 0x0000003f) << 16) |
									  ((uint)(i2 & 0x0003f000) >> 4) |
									   (uint)(i2 & 0x0000003f));
			}

			return newKey;
		}

		/// <summary>
		/// Validates the key.
		/// </summary>
		protected virtual void ValidateKey()
		{
			var keySize = this.Key.Length * 8;
			
			if (!(keySize == 64))
				throw new ArgumentException(string.Format("KeySize '{0}' is not valid for this algorithm.", keySize));
		}

		/// <summary>
		/// Performs DES function.
		/// </summary>
		/// <param name="wKey">The w key.</param>
		/// <param name="input">The input.</param>
		/// <param name="inOff">The in off.</param>
		/// <param name="outBytes">The out bytes.</param>
		/// <param name="outOff">The out off.</param>
		protected static void DesFunc(int[] wKey, byte[] input, int inOff, byte[] outBytes, int outOff)
		{
			uint left = BigEndianToUInt32(input, inOff);
			uint right = BigEndianToUInt32(input, inOff + 4);
			uint work;

			work = ((left >> 4) ^ right) & 0x0f0f0f0f;
			right ^= work;
			left ^= (work << 4);
			work = ((left >> 16) ^ right) & 0x0000ffff;
			right ^= work;
			left ^= (work << 16);
			work = ((right >> 2) ^ left) & 0x33333333;
			left ^= work;
			right ^= (work << 2);
			work = ((right >> 8) ^ left) & 0x00ff00ff;
			left ^= work;
			right ^= (work << 8);
			right = (right << 1) | (right >> 31);
			work = (left ^ right) & 0xaaaaaaaa;
			left ^= work;
			right ^= work;
			left = (left << 1) | (left >> 31);

			for (int round = 0; round < 8; round++)
			{
				uint fval;

				work = (right << 28) | (right >> 4);
				work ^= (uint)wKey[round * 4 + 0];
				fval = SP7[work & 0x3f];
				fval |= SP5[(work >> 8) & 0x3f];
				fval |= SP3[(work >> 16) & 0x3f];
				fval |= SP1[(work >> 24) & 0x3f];
				work = right ^ (uint)wKey[round * 4 + 1];
				fval |= SP8[work & 0x3f];
				fval |= SP6[(work >> 8) & 0x3f];
				fval |= SP4[(work >> 16) & 0x3f];
				fval |= SP2[(work >> 24) & 0x3f];
				left ^= fval;
				work = (left << 28) | (left >> 4);
				work ^= (uint)wKey[round * 4 + 2];
				fval = SP7[work & 0x3f];
				fval |= SP5[(work >> 8) & 0x3f];
				fval |= SP3[(work >> 16) & 0x3f];
				fval |= SP1[(work >> 24) & 0x3f];
				work = left ^ (uint)wKey[round * 4 + 3];
				fval |= SP8[work & 0x3f];
				fval |= SP6[(work >> 8) & 0x3f];
				fval |= SP4[(work >> 16) & 0x3f];
				fval |= SP2[(work >> 24) & 0x3f];
				right ^= fval;
			}

			right = (right << 31) | (right >> 1);
			work = (left ^ right) & 0xaaaaaaaa;
			left ^= work;
			right ^= work;
			left = (left << 31) | (left >> 1);
			work = ((left >> 8) ^ right) & 0x00ff00ff;
			right ^= work;
			left ^= (work << 8);
			work = ((left >> 2) ^ right) & 0x33333333;
			right ^= work;
			left ^= (work << 2);
			work = ((right >> 16) ^ left) & 0x0000ffff;
			left ^= work;
			right ^= (work << 16);
			work = ((right >> 4) ^ left) & 0x0f0f0f0f;
			left ^= work;
			right ^= (work << 4);

			UInt32ToBigEndian(right, outBytes, outOff);
			UInt32ToBigEndian(left, outBytes, outOff + 4);
		}
	}
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Ciphers\RsaCipher.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography.Ciphers
{
    /// <summary>
    /// Implements RSA cipher algorithm.
    /// </summary>
    public class RsaCipher : AsymmetricCipher
    {
        private readonly bool _isPrivate;

        private readonly RsaKey _key;

        /// <summary>
        /// Initializes a new instance of the <see cref="RsaCipher"/> class.
        /// </summary>
        /// <param name="key">The RSA key.</param>
        public RsaCipher(RsaKey key)
        {
            if (key == null)
                throw new ArgumentNullException("key");

            this._key = key;
            this._isPrivate = !this._key.D.IsZero;
        }

        /// <summary>
        /// Encrypts the specified data.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <returns>Encrypted data.</returns>
        public override byte[] Encrypt(byte[] data)
        {
            //  Calculate signature
            var bitLength = this._key.Modulus.BitLength;

            var paddedBlock = new byte[bitLength / 8 + (bitLength % 8 > 0 ? 1 : 0) - 1];

            paddedBlock[0] = 0x01;
            for (int i = 1; i < paddedBlock.Length - data.Length - 1; i++)
            {
                paddedBlock[i] = 0xFF;
            }

            Buffer.BlockCopy(data, 0, paddedBlock, paddedBlock.Length - data.Length, data.Length);

            return this.Transform(paddedBlock);
        }

        /// <summary>
        /// Decrypts the specified data.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <returns>
        /// Decrypted data.
        /// </returns>
        /// <exception cref="System.NotSupportedException">Only block type 01 or 02 are supported.</exception>
        /// <exception cref="NotSupportedException">Thrown when decrypted block type is not supported.</exception>
        public override byte[] Decrypt(byte[] data)
        {
            var paddedBlock = this.Transform(data);

            if (paddedBlock[0] != 1 && paddedBlock[0] != 2)
                throw new NotSupportedException("Only block type 01 or 02 are supported.");

            var position = 1;
            while (position < paddedBlock.Length && paddedBlock[position] != 0)
                position++;
            position++;

            var result = new byte[paddedBlock.Length - position];

            Buffer.BlockCopy(paddedBlock, position, result, 0, result.Length);

            return result;
        }

        private byte[] Transform(byte[] data)
        {
            var bytes = new List<byte>(data.Reverse());
            bytes.Add(0);

            var input = new BigInteger(bytes.ToArray());

            BigInteger result;

            if (this._isPrivate)
            {
                BigInteger random = BigInteger.One;

                var max = this._key.Modulus - 1;
                
                var bitLength = this._key.Modulus.BitLength;

                if (max < BigInteger.One)
                    throw new SshException("Invalid RSA key.");

                while (random <= BigInteger.One || random >= max)
                {
                    random = BigInteger.Random(bitLength);
                }

                BigInteger blindedInput = BigInteger.PositiveMod((BigInteger.ModPow(random, this._key.Exponent, this._key.Modulus) * input), this._key.Modulus);

                // mP = ((input Mod p) ^ dP)) Mod p
                var mP = BigInteger.ModPow((blindedInput % this._key.P), this._key.DP, this._key.P);

                // mQ = ((input Mod q) ^ dQ)) Mod q
                var mQ = BigInteger.ModPow((blindedInput % this._key.Q), this._key.DQ, this._key.Q);

                var h = BigInteger.PositiveMod(((mP - mQ) * this._key.InverseQ), this._key.P);

                var m = h * this._key.Q + mQ;

                BigInteger rInv = BigInteger.ModInverse(random, this._key.Modulus);

                result = BigInteger.PositiveMod((m * rInv), this._key.Modulus);
            }
            else
            {
                result = BigInteger.ModPow(input, this._key.Exponent, this._key.Modulus);
            }
            
            return result.ToByteArray().Reverse().ToArray();
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Ciphers\SerpentCipher.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography.Ciphers
{
	/// <summary>
	/// Implements Serpent cipher algorithm.
	/// </summary>
	public sealed class SerpentCipher : BlockCipher
	{
	    private const int ROUNDS = 32;

	    private const int PHI = unchecked((int) 0x9E3779B9); // (Sqrt(5) - 1) * 2**31

	    private readonly int[] _workingKey;

		private int _x0, _x1, _x2, _x3;    // registers

		/// <summary>
		/// Initializes a new instance of the <see cref="SerpentCipher"/> class.
		/// </summary>
		/// <param name="key">The key.</param>
		/// <param name="mode">The mode.</param>
		/// <param name="padding">The padding.</param>
		/// <exception cref="ArgumentNullException"><paramref name="key"/> is null.</exception>
		/// <exception cref="ArgumentException">Keysize is not valid for this algorithm.</exception>
		public SerpentCipher(byte[] key, CipherModeRenci mode, CipherPadding padding)
			: base(key, 16, mode, padding)
		{
			var keySize = key.Length * 8;

			if (!(keySize == 128 || keySize == 192 || keySize == 256))
				throw new ArgumentException(string.Format("KeySize '{0}' is not valid for this algorithm.", keySize));

			this._workingKey = this.MakeWorkingKey(key);
		}

		/// <summary>
		/// Encrypts the specified region of the input byte array and copies the encrypted data to the specified region of the output byte array.
		/// </summary>
		/// <param name="inputBuffer">The input data to encrypt.</param>
		/// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
		/// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
		/// <param name="outputBuffer">The output to which to write encrypted data.</param>
		/// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
		/// <returns>
		/// The number of bytes encrypted.
		/// </returns>
		public override int EncryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
		{
			if (inputCount != this.BlockSize)
				throw new ArgumentException("inputCount");

			this._x3 = BytesToWord(inputBuffer, inputOffset);
			this._x2 = BytesToWord(inputBuffer, inputOffset + 4);
			this._x1 = BytesToWord(inputBuffer, inputOffset + 8);
			this._x0 = BytesToWord(inputBuffer, inputOffset + 12);

			Sb0(this._workingKey[0] ^ this._x0, this._workingKey[1] ^ this._x1, this._workingKey[2] ^ this._x2, this._workingKey[3] ^ this._x3); LT();
			Sb1(this._workingKey[4] ^ this._x0, this._workingKey[5] ^ this._x1, this._workingKey[6] ^ this._x2, this._workingKey[7] ^ this._x3); LT();
			Sb2(this._workingKey[8] ^ this._x0, this._workingKey[9] ^ this._x1, this._workingKey[10] ^ this._x2, this._workingKey[11] ^ this._x3); LT();
			Sb3(this._workingKey[12] ^ this._x0, this._workingKey[13] ^ this._x1, this._workingKey[14] ^ this._x2, this._workingKey[15] ^ this._x3); LT();
			Sb4(this._workingKey[16] ^ this._x0, this._workingKey[17] ^ this._x1, this._workingKey[18] ^ this._x2, this._workingKey[19] ^ this._x3); LT();
			Sb5(this._workingKey[20] ^ this._x0, this._workingKey[21] ^ this._x1, this._workingKey[22] ^ this._x2, this._workingKey[23] ^ this._x3); LT();
			Sb6(this._workingKey[24] ^ this._x0, this._workingKey[25] ^ this._x1, this._workingKey[26] ^ this._x2, this._workingKey[27] ^ this._x3); LT();
			Sb7(this._workingKey[28] ^ this._x0, this._workingKey[29] ^ this._x1, this._workingKey[30] ^ this._x2, this._workingKey[31] ^ this._x3); LT();
			Sb0(this._workingKey[32] ^ this._x0, this._workingKey[33] ^ this._x1, this._workingKey[34] ^ this._x2, this._workingKey[35] ^ this._x3); LT();
			Sb1(this._workingKey[36] ^ this._x0, this._workingKey[37] ^ this._x1, this._workingKey[38] ^ this._x2, this._workingKey[39] ^ this._x3); LT();
			Sb2(this._workingKey[40] ^ this._x0, this._workingKey[41] ^ this._x1, this._workingKey[42] ^ this._x2, this._workingKey[43] ^ this._x3); LT();
			Sb3(this._workingKey[44] ^ this._x0, this._workingKey[45] ^ this._x1, this._workingKey[46] ^ this._x2, this._workingKey[47] ^ this._x3); LT();
			Sb4(this._workingKey[48] ^ this._x0, this._workingKey[49] ^ this._x1, this._workingKey[50] ^ this._x2, this._workingKey[51] ^ this._x3); LT();
			Sb5(this._workingKey[52] ^ this._x0, this._workingKey[53] ^ this._x1, this._workingKey[54] ^ this._x2, this._workingKey[55] ^ this._x3); LT();
			Sb6(this._workingKey[56] ^ this._x0, this._workingKey[57] ^ this._x1, this._workingKey[58] ^ this._x2, this._workingKey[59] ^ this._x3); LT();
			Sb7(this._workingKey[60] ^ this._x0, this._workingKey[61] ^ this._x1, this._workingKey[62] ^ this._x2, this._workingKey[63] ^ this._x3); LT();
			Sb0(this._workingKey[64] ^ this._x0, this._workingKey[65] ^ this._x1, this._workingKey[66] ^ this._x2, this._workingKey[67] ^ this._x3); LT();
			Sb1(this._workingKey[68] ^ this._x0, this._workingKey[69] ^ this._x1, this._workingKey[70] ^ this._x2, this._workingKey[71] ^ this._x3); LT();
			Sb2(this._workingKey[72] ^ this._x0, this._workingKey[73] ^ this._x1, this._workingKey[74] ^ this._x2, this._workingKey[75] ^ this._x3); LT();
			Sb3(this._workingKey[76] ^ this._x0, this._workingKey[77] ^ this._x1, this._workingKey[78] ^ this._x2, this._workingKey[79] ^ this._x3); LT();
			Sb4(this._workingKey[80] ^ this._x0, this._workingKey[81] ^ this._x1, this._workingKey[82] ^ this._x2, this._workingKey[83] ^ this._x3); LT();
			Sb5(this._workingKey[84] ^ this._x0, this._workingKey[85] ^ this._x1, this._workingKey[86] ^ this._x2, this._workingKey[87] ^ this._x3); LT();
			Sb6(this._workingKey[88] ^ this._x0, this._workingKey[89] ^ this._x1, this._workingKey[90] ^ this._x2, this._workingKey[91] ^ this._x3); LT();
			Sb7(this._workingKey[92] ^ this._x0, this._workingKey[93] ^ this._x1, this._workingKey[94] ^ this._x2, this._workingKey[95] ^ this._x3); LT();
			Sb0(this._workingKey[96] ^ this._x0, this._workingKey[97] ^ this._x1, this._workingKey[98] ^ this._x2, this._workingKey[99] ^ this._x3); LT();
			Sb1(this._workingKey[100] ^ this._x0, this._workingKey[101] ^ this._x1, this._workingKey[102] ^ this._x2, this._workingKey[103] ^ this._x3); LT();
			Sb2(this._workingKey[104] ^ this._x0, this._workingKey[105] ^ this._x1, this._workingKey[106] ^ this._x2, this._workingKey[107] ^ this._x3); LT();
			Sb3(this._workingKey[108] ^ this._x0, this._workingKey[109] ^ this._x1, this._workingKey[110] ^ this._x2, this._workingKey[111] ^ this._x3); LT();
			Sb4(this._workingKey[112] ^ this._x0, this._workingKey[113] ^ this._x1, this._workingKey[114] ^ this._x2, this._workingKey[115] ^ this._x3); LT();
			Sb5(this._workingKey[116] ^ this._x0, this._workingKey[117] ^ this._x1, this._workingKey[118] ^ this._x2, this._workingKey[119] ^ this._x3); LT();
			Sb6(this._workingKey[120] ^ this._x0, this._workingKey[121] ^ this._x1, this._workingKey[122] ^ this._x2, this._workingKey[123] ^ this._x3); LT();
			Sb7(this._workingKey[124] ^ this._x0, this._workingKey[125] ^ this._x1, this._workingKey[126] ^ this._x2, this._workingKey[127] ^ this._x3);

			WordToBytes(this._workingKey[131] ^ this._x3, outputBuffer, outputOffset);
			WordToBytes(this._workingKey[130] ^ this._x2, outputBuffer, outputOffset + 4);
			WordToBytes(this._workingKey[129] ^ this._x1, outputBuffer, outputOffset + 8);
			WordToBytes(this._workingKey[128] ^ this._x0, outputBuffer, outputOffset + 12);

			return this.BlockSize;
		}

		/// <summary>
		/// Decrypts the specified region of the input byte array and copies the decrypted data to the specified region of the output byte array.
		/// </summary>
		/// <param name="inputBuffer">The input data to decrypt.</param>
		/// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
		/// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
		/// <param name="outputBuffer">The output to which to write decrypted data.</param>
		/// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
		/// <returns>
		/// The number of bytes decrypted.
		/// </returns>
		public override int DecryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
		{
			if (inputCount != this.BlockSize)
				throw new ArgumentException("inputCount");

			this._x3 = this._workingKey[131] ^ BytesToWord(inputBuffer, inputOffset);
			this._x2 = this._workingKey[130] ^ BytesToWord(inputBuffer, inputOffset + 4);
			this._x1 = this._workingKey[129] ^ BytesToWord(inputBuffer, inputOffset + 8);
			this._x0 = this._workingKey[128] ^ BytesToWord(inputBuffer, inputOffset + 12);

			Ib7(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[124]; this._x1 ^= this._workingKey[125]; this._x2 ^= this._workingKey[126]; this._x3 ^= this._workingKey[127];
			InverseLT(); Ib6(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[120]; this._x1 ^= this._workingKey[121]; this._x2 ^= this._workingKey[122]; this._x3 ^= this._workingKey[123];
			InverseLT(); Ib5(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[116]; this._x1 ^= this._workingKey[117]; this._x2 ^= this._workingKey[118]; this._x3 ^= this._workingKey[119];
			InverseLT(); Ib4(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[112]; this._x1 ^= this._workingKey[113]; this._x2 ^= this._workingKey[114]; this._x3 ^= this._workingKey[115];
			InverseLT(); Ib3(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[108]; this._x1 ^= this._workingKey[109]; this._x2 ^= this._workingKey[110]; this._x3 ^= this._workingKey[111];
			InverseLT(); Ib2(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[104]; this._x1 ^= this._workingKey[105]; this._x2 ^= this._workingKey[106]; this._x3 ^= this._workingKey[107];
			InverseLT(); Ib1(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[100]; this._x1 ^= this._workingKey[101]; this._x2 ^= this._workingKey[102]; this._x3 ^= this._workingKey[103];
			InverseLT(); Ib0(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[96]; this._x1 ^= this._workingKey[97]; this._x2 ^= this._workingKey[98]; this._x3 ^= this._workingKey[99];
			InverseLT(); Ib7(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[92]; this._x1 ^= this._workingKey[93]; this._x2 ^= this._workingKey[94]; this._x3 ^= this._workingKey[95];
			InverseLT(); Ib6(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[88]; this._x1 ^= this._workingKey[89]; this._x2 ^= this._workingKey[90]; this._x3 ^= this._workingKey[91];
			InverseLT(); Ib5(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[84]; this._x1 ^= this._workingKey[85]; this._x2 ^= this._workingKey[86]; this._x3 ^= this._workingKey[87];
			InverseLT(); Ib4(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[80]; this._x1 ^= this._workingKey[81]; this._x2 ^= this._workingKey[82]; this._x3 ^= this._workingKey[83];
			InverseLT(); Ib3(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[76]; this._x1 ^= this._workingKey[77]; this._x2 ^= this._workingKey[78]; this._x3 ^= this._workingKey[79];
			InverseLT(); Ib2(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[72]; this._x1 ^= this._workingKey[73]; this._x2 ^= this._workingKey[74]; this._x3 ^= this._workingKey[75];
			InverseLT(); Ib1(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[68]; this._x1 ^= this._workingKey[69]; this._x2 ^= this._workingKey[70]; this._x3 ^= this._workingKey[71];
			InverseLT(); Ib0(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[64]; this._x1 ^= this._workingKey[65]; this._x2 ^= this._workingKey[66]; this._x3 ^= this._workingKey[67];
			InverseLT(); Ib7(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[60]; this._x1 ^= this._workingKey[61]; this._x2 ^= this._workingKey[62]; this._x3 ^= this._workingKey[63];
			InverseLT(); Ib6(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[56]; this._x1 ^= this._workingKey[57]; this._x2 ^= this._workingKey[58]; this._x3 ^= this._workingKey[59];
			InverseLT(); Ib5(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[52]; this._x1 ^= this._workingKey[53]; this._x2 ^= this._workingKey[54]; this._x3 ^= this._workingKey[55];
			InverseLT(); Ib4(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[48]; this._x1 ^= this._workingKey[49]; this._x2 ^= this._workingKey[50]; this._x3 ^= this._workingKey[51];
			InverseLT(); Ib3(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[44]; this._x1 ^= this._workingKey[45]; this._x2 ^= this._workingKey[46]; this._x3 ^= this._workingKey[47];
			InverseLT(); Ib2(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[40]; this._x1 ^= this._workingKey[41]; this._x2 ^= this._workingKey[42]; this._x3 ^= this._workingKey[43];
			InverseLT(); Ib1(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[36]; this._x1 ^= this._workingKey[37]; this._x2 ^= this._workingKey[38]; this._x3 ^= this._workingKey[39];
			InverseLT(); Ib0(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[32]; this._x1 ^= this._workingKey[33]; this._x2 ^= this._workingKey[34]; this._x3 ^= this._workingKey[35];
			InverseLT(); Ib7(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[28]; this._x1 ^= this._workingKey[29]; this._x2 ^= this._workingKey[30]; this._x3 ^= this._workingKey[31];
			InverseLT(); Ib6(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[24]; this._x1 ^= this._workingKey[25]; this._x2 ^= this._workingKey[26]; this._x3 ^= this._workingKey[27];
			InverseLT(); Ib5(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[20]; this._x1 ^= this._workingKey[21]; this._x2 ^= this._workingKey[22]; this._x3 ^= this._workingKey[23];
			InverseLT(); Ib4(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[16]; this._x1 ^= this._workingKey[17]; this._x2 ^= this._workingKey[18]; this._x3 ^= this._workingKey[19];
			InverseLT(); Ib3(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[12]; this._x1 ^= this._workingKey[13]; this._x2 ^= this._workingKey[14]; this._x3 ^= this._workingKey[15];
			InverseLT(); Ib2(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[8]; this._x1 ^= this._workingKey[9]; this._x2 ^= this._workingKey[10]; this._x3 ^= this._workingKey[11];
			InverseLT(); Ib1(this._x0, this._x1, this._x2, this._x3);
			this._x0 ^= this._workingKey[4]; this._x1 ^= this._workingKey[5]; this._x2 ^= this._workingKey[6]; this._x3 ^= this._workingKey[7];
			InverseLT(); Ib0(this._x0, this._x1, this._x2, this._x3);

			WordToBytes(this._x3 ^ this._workingKey[3], outputBuffer, outputOffset);
			WordToBytes(this._x2 ^ this._workingKey[2], outputBuffer, outputOffset + 4);
			WordToBytes(this._x1 ^ this._workingKey[1], outputBuffer, outputOffset + 8);
			WordToBytes(this._x0 ^ this._workingKey[0], outputBuffer, outputOffset + 12);

			return this.BlockSize;
		}

		/**
		* Expand a user-supplied key material into a session key.
		*
		* @param key  The user-key bytes (multiples of 4) to use.
		* @exception ArgumentException
		*/
		private int[] MakeWorkingKey(byte[] key)
		{
			//
			// pad key to 256 bits
			//
			int[] kPad = new int[16];
			int off;
			int length = 0;

			for (off = key.Length - 4; off > 0; off -= 4)
			{
				kPad[length++] = BytesToWord(key, off);
			}

			if (off == 0)
			{
				kPad[length++] = BytesToWord(key, 0);
				if (length < 8)
				{
					kPad[length] = 1;
				}
			}
			else
			{
				throw new ArgumentException("key must be a multiple of 4 bytes");
			}

			//
			// expand the padded key up to 33 x 128 bits of key material
			//
			int amount = (ROUNDS + 1) * 4;
			int[] w = new int[amount];

			//
			// compute w0 to w7 from w-8 to w-1
			//
			for (int i = 8; i < 16; i++)
			{
				kPad[i] = RotateLeft(kPad[i - 8] ^ kPad[i - 5] ^ kPad[i - 3] ^ kPad[i - 1] ^ PHI ^ (i - 8), 11);
			}

            Buffer.BlockCopy(kPad, 8, w, 0, 8);

			//
			// compute w8 to w136
			//
			for (int i = 8; i < amount; i++)
			{
				w[i] = RotateLeft(w[i - 8] ^ w[i - 5] ^ w[i - 3] ^ w[i - 1] ^ PHI ^ i, 11);
			}

			//
			// create the working keys by processing w with the Sbox and IP
			//
			Sb3(w[0], w[1], w[2], w[3]);
			w[0] = this._x0; w[1] = this._x1; w[2] = this._x2; w[3] = this._x3;
			Sb2(w[4], w[5], w[6], w[7]);
			w[4] = this._x0; w[5] = this._x1; w[6] = this._x2; w[7] = this._x3;
			Sb1(w[8], w[9], w[10], w[11]);
			w[8] = this._x0; w[9] = this._x1; w[10] = this._x2; w[11] = this._x3;
			Sb0(w[12], w[13], w[14], w[15]);
			w[12] = this._x0; w[13] = this._x1; w[14] = this._x2; w[15] = this._x3;
			Sb7(w[16], w[17], w[18], w[19]);
			w[16] = this._x0; w[17] = this._x1; w[18] = this._x2; w[19] = this._x3;
			Sb6(w[20], w[21], w[22], w[23]);
			w[20] = this._x0; w[21] = this._x1; w[22] = this._x2; w[23] = this._x3;
			Sb5(w[24], w[25], w[26], w[27]);
			w[24] = this._x0; w[25] = this._x1; w[26] = this._x2; w[27] = this._x3;
			Sb4(w[28], w[29], w[30], w[31]);
			w[28] = this._x0; w[29] = this._x1; w[30] = this._x2; w[31] = this._x3;
			Sb3(w[32], w[33], w[34], w[35]);
			w[32] = this._x0; w[33] = this._x1; w[34] = this._x2; w[35] = this._x3;
			Sb2(w[36], w[37], w[38], w[39]);
			w[36] = this._x0; w[37] = this._x1; w[38] = this._x2; w[39] = this._x3;
			Sb1(w[40], w[41], w[42], w[43]);
			w[40] = this._x0; w[41] = this._x1; w[42] = this._x2; w[43] = this._x3;
			Sb0(w[44], w[45], w[46], w[47]);
			w[44] = this._x0; w[45] = this._x1; w[46] = this._x2; w[47] = this._x3;
			Sb7(w[48], w[49], w[50], w[51]);
			w[48] = this._x0; w[49] = this._x1; w[50] = this._x2; w[51] = this._x3;
			Sb6(w[52], w[53], w[54], w[55]);
			w[52] = this._x0; w[53] = this._x1; w[54] = this._x2; w[55] = this._x3;
			Sb5(w[56], w[57], w[58], w[59]);
			w[56] = this._x0; w[57] = this._x1; w[58] = this._x2; w[59] = this._x3;
			Sb4(w[60], w[61], w[62], w[63]);
			w[60] = this._x0; w[61] = this._x1; w[62] = this._x2; w[63] = this._x3;
			Sb3(w[64], w[65], w[66], w[67]);
			w[64] = this._x0; w[65] = this._x1; w[66] = this._x2; w[67] = this._x3;
			Sb2(w[68], w[69], w[70], w[71]);
			w[68] = this._x0; w[69] = this._x1; w[70] = this._x2; w[71] = this._x3;
			Sb1(w[72], w[73], w[74], w[75]);
			w[72] = this._x0; w[73] = this._x1; w[74] = this._x2; w[75] = this._x3;
			Sb0(w[76], w[77], w[78], w[79]);
			w[76] = this._x0; w[77] = this._x1; w[78] = this._x2; w[79] = this._x3;
			Sb7(w[80], w[81], w[82], w[83]);
			w[80] = this._x0; w[81] = this._x1; w[82] = this._x2; w[83] = this._x3;
			Sb6(w[84], w[85], w[86], w[87]);
			w[84] = this._x0; w[85] = this._x1; w[86] = this._x2; w[87] = this._x3;
			Sb5(w[88], w[89], w[90], w[91]);
			w[88] = this._x0; w[89] = this._x1; w[90] = this._x2; w[91] = this._x3;
			Sb4(w[92], w[93], w[94], w[95]);
			w[92] = this._x0; w[93] = this._x1; w[94] = this._x2; w[95] = this._x3;
			Sb3(w[96], w[97], w[98], w[99]);
			w[96] = this._x0; w[97] = this._x1; w[98] = this._x2; w[99] = this._x3;
			Sb2(w[100], w[101], w[102], w[103]);
			w[100] = this._x0; w[101] = this._x1; w[102] = this._x2; w[103] = this._x3;
			Sb1(w[104], w[105], w[106], w[107]);
			w[104] = this._x0; w[105] = this._x1; w[106] = this._x2; w[107] = this._x3;
			Sb0(w[108], w[109], w[110], w[111]);
			w[108] = this._x0; w[109] = this._x1; w[110] = this._x2; w[111] = this._x3;
			Sb7(w[112], w[113], w[114], w[115]);
			w[112] = this._x0; w[113] = this._x1; w[114] = this._x2; w[115] = this._x3;
			Sb6(w[116], w[117], w[118], w[119]);
			w[116] = this._x0; w[117] = this._x1; w[118] = this._x2; w[119] = this._x3;
			Sb5(w[120], w[121], w[122], w[123]);
			w[120] = this._x0; w[121] = this._x1; w[122] = this._x2; w[123] = this._x3;
			Sb4(w[124], w[125], w[126], w[127]);
			w[124] = this._x0; w[125] = this._x1; w[126] = this._x2; w[127] = this._x3;
			Sb3(w[128], w[129], w[130], w[131]);
			w[128] = this._x0; w[129] = this._x1; w[130] = this._x2; w[131] = this._x3;

			return w;
		}

		private static int RotateLeft(int x, int bits)
		{
			return ((x << bits) | (int)((uint)x >> (32 - bits)));
		}

        private static int RotateRight(int x, int bits)
		{
			return ((int)((uint)x >> bits) | (x << (32 - bits)));
		}

        private static int BytesToWord(byte[] src, int srcOff)
		{
			return (((src[srcOff] & 0xff) << 24) | ((src[srcOff + 1] & 0xff) << 16) |
			((src[srcOff + 2] & 0xff) << 8) | ((src[srcOff + 3] & 0xff)));
		}

        private static void WordToBytes(int word, byte[] dst, int dstOff)
		{
			dst[dstOff + 3] = (byte)(word);
			dst[dstOff + 2] = (byte)((uint)word >> 8);
			dst[dstOff + 1] = (byte)((uint)word >> 16);
			dst[dstOff] = (byte)((uint)word >> 24);
		}

		/*
		* The sboxes below are based on the work of Brian Gladman and
		* Sam Simpson, whose original notice appears below.
		* <p>
		* For further details see:
		*      http://fp.gladman.plus.com/cryptography_technology/serpent/
		* </p>
		*/

		/* Partially optimised Serpent S Box bool functions derived  */
		/* using a recursive descent analyser but without a full search */
		/* of all subtrees. This set of S boxes is the result of work    */
		/* by Sam Simpson and Brian Gladman using the spare time on a    */
		/* cluster of high capacity servers to search for S boxes with    */
		/* this customised search engine. There are now an average of    */
		/* 15.375 terms    per S box.                                        */
		/*                                                              */
		/* Copyright:   Dr B. R Gladman (gladman@seven77.demon.co.uk)   */
		/*                and Sam Simpson (s.simpson@mia.co.uk)            */
		/*              17th December 1998                                */
		/*                                                              */
		/* We hereby give permission for information in this file to be */
		/* used freely subject only to acknowledgement of its origin.    */

        /// <summary>
        /// S0 - { 3, 8,15, 1,10, 6, 5,11,14,13, 4, 2, 7, 0, 9,12 } - 15 terms.
        /// </summary>
        /// <param name="a">A.</param>
        /// <param name="b">The b.</param>
        /// <param name="c">The c.</param>
        /// <param name="d">The d.</param>
        private void Sb0(int a, int b, int c, int d)
		{
			int t1 = a ^ d;
			int t3 = c ^ t1;
			int t4 = b ^ t3;
			this._x3 = (a & d) ^ t4;
			int t7 = a ^ (b & t1);
			this._x2 = t4 ^ (c | t7);
			int t12 = this._x3 & (t3 ^ t7);
			this._x1 = (~t3) ^ t12;
			this._x0 = t12 ^ (~t7);
		}

        /// <summary>
        /// InvSO - {13, 3,11, 0,10, 6, 5,12, 1,14, 4, 7,15, 9, 8, 2 } - 15 terms.
        /// </summary>
        /// <param name="a">A.</param>
        /// <param name="b">The b.</param>
        /// <param name="c">The c.</param>
        /// <param name="d">The d.</param>
        private void Ib0(int a, int b, int c, int d)
		{
			int t1 = ~a;
			int t2 = a ^ b;
			int t4 = d ^ (t1 | t2);
			int t5 = c ^ t4;
			this._x2 = t2 ^ t5;
			int t8 = t1 ^ (d & t2);
			this._x1 = t4 ^ (this._x2 & t8);
			this._x3 = (a & t4) ^ (t5 | this._x1);
			this._x0 = this._x3 ^ (t5 ^ t8);
		}

        /// <summary>
        /// S1 - {15,12, 2, 7, 9, 0, 5,10, 1,11,14, 8, 6,13, 3, 4 } - 14 terms.
        /// </summary>
        /// <param name="a">A.</param>
        /// <param name="b">The b.</param>
        /// <param name="c">The c.</param>
        /// <param name="d">The d.</param>
        private void Sb1(int a, int b, int c, int d)
		{
			int t2 = b ^ (~a);
			int t5 = c ^ (a | t2);
			this._x2 = d ^ t5;
			int t7 = b ^ (d | t2);
			int t8 = t2 ^ this._x2;
			this._x3 = t8 ^ (t5 & t7);
			int t11 = t5 ^ t7;
			this._x1 = this._x3 ^ t11;
			this._x0 = t5 ^ (t8 & t11);
		}

        /// <summary>
        /// InvS1 - { 5, 8, 2,14,15, 6,12, 3,11, 4, 7, 9, 1,13,10, 0 } - 14 steps.
        /// </summary>
        /// <param name="a">A.</param>
        /// <param name="b">The b.</param>
        /// <param name="c">The c.</param>
        /// <param name="d">The d.</param>
        private void Ib1(int a, int b, int c, int d)
		{
			int t1 = b ^ d;
			int t3 = a ^ (b & t1);
			int t4 = t1 ^ t3;
			this._x3 = c ^ t4;
			int t7 = b ^ (t1 & t3);
			int t8 = this._x3 | t7;
			this._x1 = t3 ^ t8;
			int t10 = ~this._x1;
			int t11 = this._x3 ^ t7;
			this._x0 = t10 ^ t11;
			this._x2 = t4 ^ (t10 | t11);
		}

        /// <summary>
        /// S2 - { 8, 6, 7, 9, 3,12,10,15,13, 1,14, 4, 0,11, 5, 2 } - 16 terms.
        /// </summary>
        /// <param name="a">A.</param>
        /// <param name="b">The b.</param>
        /// <param name="c">The c.</param>
        /// <param name="d">The d.</param>
        private void Sb2(int a, int b, int c, int d)
		{
			int t1 = ~a;
			int t2 = b ^ d;
			int t3 = c & t1;
			this._x0 = t2 ^ t3;
			int t5 = c ^ t1;
			int t6 = c ^ this._x0;
			int t7 = b & t6;
			this._x3 = t5 ^ t7;
			this._x2 = a ^ ((d | t7) & (this._x0 | t5));
			this._x1 = (t2 ^ this._x3) ^ (this._x2 ^ (d | t1));
		}

        /// <summary>
        /// InvS2 - {12, 9,15, 4,11,14, 1, 2, 0, 3, 6,13, 5, 8,10, 7 } - 16 steps.
        /// </summary>
        /// <param name="a">A.</param>
        /// <param name="b">The b.</param>
        /// <param name="c">The c.</param>
        /// <param name="d">The d.</param>
        private void Ib2(int a, int b, int c, int d)
		{
			int t1 = b ^ d;
			int t2 = ~t1;
			int t3 = a ^ c;
			int t4 = c ^ t1;
			int t5 = b & t4;
			this._x0 = t3 ^ t5;
			int t7 = a | t2;
			int t8 = d ^ t7;
			int t9 = t3 | t8;
			this._x3 = t1 ^ t9;
			int t11 = ~t4;
			int t12 = this._x0 | this._x3;
			this._x1 = t11 ^ t12;
			this._x2 = (d & t11) ^ (t3 ^ t12);
		}

        /// <summary>
        /// S3 - { 0,15,11, 8,12, 9, 6, 3,13, 1, 2, 4,10, 7, 5,14 } - 16 terms.
        /// </summary>
        /// <param name="a">A.</param>
        /// <param name="b">The b.</param>
        /// <param name="c">The c.</param>
        /// <param name="d">The d.</param>
        private void Sb3(int a, int b, int c, int d)
		{
			int t1 = a ^ b;
			int t2 = a & c;
			int t3 = a | d;
			int t4 = c ^ d;
			int t5 = t1 & t3;
			int t6 = t2 | t5;
			this._x2 = t4 ^ t6;
			int t8 = b ^ t3;
			int t9 = t6 ^ t8;
			int t10 = t4 & t9;
			this._x0 = t1 ^ t10;
			int t12 = this._x2 & this._x0;
			this._x1 = t9 ^ t12;
			this._x3 = (b | d) ^ (t4 ^ t12);
		}

        /// <summary>
        /// InvS3 - { 0, 9,10, 7,11,14, 6,13, 3, 5,12, 2, 4, 8,15, 1 } - 15 terms
        /// </summary>
        /// <param name="a">A.</param>
        /// <param name="b">The b.</param>
        /// <param name="c">The c.</param>
        /// <param name="d">The d.</param>
        private void Ib3(int a, int b, int c, int d)
		{
			int t1 = a | b;
			int t2 = b ^ c;
			int t3 = b & t2;
			int t4 = a ^ t3;
			int t5 = c ^ t4;
			int t6 = d | t4;
			this._x0 = t2 ^ t6;
			int t8 = t2 | t6;
			int t9 = d ^ t8;
			this._x2 = t5 ^ t9;
			int t11 = t1 ^ t9;
			int t12 = this._x0 & t11;
			this._x3 = t4 ^ t12;
			this._x1 = this._x3 ^ (this._x0 ^ t11);
		}

        /// <summary>
        /// S4 - { 1,15, 8, 3,12, 0,11, 6, 2, 5, 4,10, 9,14, 7,13 } - 15 terms.
        /// </summary>
        /// <param name="a">A.</param>
        /// <param name="b">The b.</param>
        /// <param name="c">The c.</param>
        /// <param name="d">The d.</param>
        private void Sb4(int a, int b, int c, int d)
		{
			int t1 = a ^ d;
			int t2 = d & t1;
			int t3 = c ^ t2;
			int t4 = b | t3;
			this._x3 = t1 ^ t4;
			int t6 = ~b;
			int t7 = t1 | t6;
			this._x0 = t3 ^ t7;
			int t9 = a & this._x0;
			int t10 = t1 ^ t6;
			int t11 = t4 & t10;
			this._x2 = t9 ^ t11;
			this._x1 = (a ^ t3) ^ (t10 & this._x2);
		}

        /// <summary>
        /// InvS4 - { 5, 0, 8, 3,10, 9, 7,14, 2,12,11, 6, 4,15,13, 1 } - 15 terms.
        /// </summary>
        /// <param name="a">A.</param>
        /// <param name="b">The b.</param>
        /// <param name="c">The c.</param>
        /// <param name="d">The d.</param>
        private void Ib4(int a, int b, int c, int d)
		{
			int t1 = c | d;
			int t2 = a & t1;
			int t3 = b ^ t2;
			int t4 = a & t3;
			int t5 = c ^ t4;
			this._x1 = d ^ t5;
			int t7 = ~a;
			int t8 = t5 & this._x1;
			this._x3 = t3 ^ t8;
			int t10 = this._x1 | t7;
			int t11 = d ^ t10;
			this._x0 = this._x3 ^ t11;
			this._x2 = (t3 & t11) ^ (this._x1 ^ t7);
		}

        /// <summary>
        /// S5 - {15, 5, 2,11, 4,10, 9,12, 0, 3,14, 8,13, 6, 7, 1 } - 16 terms.
        /// </summary>
        /// <param name="a">A.</param>
        /// <param name="b">The b.</param>
        /// <param name="c">The c.</param>
        /// <param name="d">The d.</param>
        private void Sb5(int a, int b, int c, int d)
		{
			int t1 = ~a;
			int t2 = a ^ b;
			int t3 = a ^ d;
			int t4 = c ^ t1;
			int t5 = t2 | t3;
			this._x0 = t4 ^ t5;
			int t7 = d & this._x0;
			int t8 = t2 ^ this._x0;
			this._x1 = t7 ^ t8;
			int t10 = t1 | this._x0;
			int t11 = t2 | t7;
			int t12 = t3 ^ t10;
			this._x2 = t11 ^ t12;
			this._x3 = (b ^ t7) ^ (this._x1 & t12);
		}

        /// <summary>
        /// InvS5 - { 8,15, 2, 9, 4, 1,13,14,11, 6, 5, 3, 7,12,10, 0 } - 16 terms.
        /// </summary>
        /// <param name="a">A.</param>
        /// <param name="b">The b.</param>
        /// <param name="c">The c.</param>
        /// <param name="d">The d.</param>
        private void Ib5(int a, int b, int c, int d)
		{
			int t1 = ~c;
			int t2 = b & t1;
			int t3 = d ^ t2;
			int t4 = a & t3;
			int t5 = b ^ t1;
			this._x3 = t4 ^ t5;
			int t7 = b | this._x3;
			int t8 = a & t7;
			this._x1 = t3 ^ t8;
			int t10 = a | d;
			int t11 = t1 ^ t7;
			this._x0 = t10 ^ t11;
			this._x2 = (b & t10) ^ (t4 | (a ^ c));
		}

        /// <summary>
        /// S6 - { 7, 2,12, 5, 8, 4, 6,11,14, 9, 1,15,13, 3,10, 0 } - 15 terms.
        /// </summary>
        /// <param name="a">A.</param>
        /// <param name="b">The b.</param>
        /// <param name="c">The c.</param>
        /// <param name="d">The d.</param>
        private void Sb6(int a, int b, int c, int d)
		{
			int t1 = ~a;
			int t2 = a ^ d;
			int t3 = b ^ t2;
			int t4 = t1 | t2;
			int t5 = c ^ t4;
			this._x1 = b ^ t5;
			int t7 = t2 | this._x1;
			int t8 = d ^ t7;
			int t9 = t5 & t8;
			this._x2 = t3 ^ t9;
			int t11 = t5 ^ t8;
			this._x0 = this._x2 ^ t11;
			this._x3 = (~t5) ^ (t3 & t11);
		}

        /// <summary>
        /// InvS6 - {15,10, 1,13, 5, 3, 6, 0, 4, 9,14, 7, 2,12, 8,11 } - 15 terms.
        /// </summary>
        /// <param name="a">A.</param>
        /// <param name="b">The b.</param>
        /// <param name="c">The c.</param>
        /// <param name="d">The d.</param>
        private void Ib6(int a, int b, int c, int d)
		{
			int t1 = ~a;
			int t2 = a ^ b;
			int t3 = c ^ t2;
			int t4 = c | t1;
			int t5 = d ^ t4;
			this._x1 = t3 ^ t5;
			int t7 = t3 & t5;
			int t8 = t2 ^ t7;
			int t9 = b | t8;
			this._x3 = t5 ^ t9;
			int t11 = b | this._x3;
			this._x0 = t8 ^ t11;
			this._x2 = (d & t1) ^ (t3 ^ t11);
		}

        /// <summary>
        /// S7 - { 1,13,15, 0,14, 8, 2,11, 7, 4,12,10, 9, 3, 5, 6 } - 16 terms.
        /// </summary>
        /// <param name="a">A.</param>
        /// <param name="b">The b.</param>
        /// <param name="c">The c.</param>
        /// <param name="d">The d.</param>
        private void Sb7(int a, int b, int c, int d)
		{
			int t1 = b ^ c;
			int t2 = c & t1;
			int t3 = d ^ t2;
			int t4 = a ^ t3;
			int t5 = d | t1;
			int t6 = t4 & t5;
			this._x1 = b ^ t6;
			int t8 = t3 | this._x1;
			int t9 = a & t4;
			this._x3 = t1 ^ t9;
			int t11 = t4 ^ t8;
			int t12 = this._x3 & t11;
			this._x2 = t3 ^ t12;
			this._x0 = (~t11) ^ (this._x3 & this._x2);
		}

        /// <summary>
        /// InvS7 - { 3, 0, 6,13, 9,14,15, 8, 5,12,11, 7,10, 1, 4, 2 } - 17 terms.
        /// </summary>
        /// <param name="a">A.</param>
        /// <param name="b">The b.</param>
        /// <param name="c">The c.</param>
        /// <param name="d">The d.</param>
        private void Ib7(int a, int b, int c, int d)
		{
			int t3 = c | (a & b);
			int t4 = d & (a | b);
			this._x3 = t3 ^ t4;
			int t6 = ~d;
			int t7 = b ^ t4;
			int t9 = t7 | (this._x3 ^ t6);
			this._x1 = a ^ t9;
			this._x0 = (c ^ t7) ^ (d | this._x1);
			this._x2 = (t3 ^ this._x1) ^ (this._x0 ^ (a & this._x3));
		}

        /// <summary>
        /// Apply the linear transformation to the register set.
        /// </summary>
		private void LT()
		{
			int x0 = RotateLeft(this._x0, 13);
			int x2 = RotateLeft(this._x2, 3);
			int x1 = this._x1 ^ x0 ^ x2;
			int x3 = this._x3 ^ x2 ^ x0 << 3;

			this._x1 = RotateLeft(x1, 1);
			this._x3 = RotateLeft(x3, 7);
			this._x0 = RotateLeft(x0 ^ this._x1 ^ this._x3, 5);
			this._x2 = RotateLeft(x2 ^ this._x3 ^ (this._x1 << 7), 22);
		}

        /// <summary>
        /// Apply the inverse of the linear transformation to the register set.
        /// </summary>
		private void InverseLT()
		{
			int x2 = RotateRight(this._x2, 22) ^ this._x3 ^ (this._x1 << 7);
			int x0 = RotateRight(this._x0, 5) ^ this._x1 ^ this._x3;
			int x3 = RotateRight(this._x3, 7);
			int x1 = RotateRight(this._x1, 1);
			this._x3 = x3 ^ x2 ^ x0 << 3;
			this._x1 = x1 ^ x0 ^ x2;
			this._x2 = RotateRight(x2, 3);
			this._x0 = RotateRight(x0, 13);
		}
	}
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Ciphers\TripleDesCipher.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography.Ciphers
{
    /// <summary>
    /// Implements 3DES cipher algorithm.
    /// </summary>
    public sealed class TripleDesCipher : DesCipher
    {
        private int[] _encryptionKey1;

        private int[] _encryptionKey2;

        private int[] _encryptionKey3;

        private int[] _decryptionKey1;

        private int[] _decryptionKey2;

        private int[] _decryptionKey3;

        /// <summary>
        /// Initializes a new instance of the <see cref="TripleDesCipher"/> class.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <param name="mode">The mode.</param>
        /// <param name="padding">The padding.</param>
        /// <exception cref="ArgumentNullException"><paramref name="key"/> is null.</exception>
        public TripleDesCipher(byte[] key, CipherModeRenci mode, CipherPadding padding)
            : base(key, mode, padding)
        {
        }

        /// <summary>
        /// Encrypts the specified region of the input byte array and copies the encrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to encrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write encrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes encrypted.
        /// </returns>
        public override int EncryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            if ((inputOffset + this.BlockSize) > inputBuffer.Length)
                throw new IndexOutOfRangeException("input buffer too short");

            if ((outputOffset + this.BlockSize) > outputBuffer.Length)
                throw new IndexOutOfRangeException("output buffer too short");

            if (this._encryptionKey1 == null || this._encryptionKey2 == null || this._encryptionKey3 == null)
            {
                var part1 = new byte[8];
                var part2 = new byte[8];

                Buffer.BlockCopy(this.Key, 0, part1, 0, 8);
                Buffer.BlockCopy(this.Key, 8, part2, 0, 8);

                this._encryptionKey1 = this.GenerateWorkingKey(true, part1);

                this._encryptionKey2 = this.GenerateWorkingKey(false, part2);

                if (this.Key.Length == 24)
                {
                    var part3 = new byte[8];
                    Buffer.BlockCopy(this.Key, 16, part3, 0, 8);

                    this._encryptionKey3 = this.GenerateWorkingKey(true, part3);
                }
                else
                {
                    this._encryptionKey3 = this._encryptionKey1;
                }
            }

            byte[] temp = new byte[this.BlockSize];

            DesCipher.DesFunc(this._encryptionKey1, inputBuffer, inputOffset, temp, 0);
            DesCipher.DesFunc(this._encryptionKey2, temp, 0, temp, 0);
            DesCipher.DesFunc(this._encryptionKey3, temp, 0, outputBuffer, outputOffset);

            return this.BlockSize;
        }

        /// <summary>
        /// Decrypts the specified region of the input byte array and copies the decrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to decrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write decrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes decrypted.
        /// </returns>
        public override int DecryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            if ((inputOffset + this.BlockSize) > inputBuffer.Length)
                throw new IndexOutOfRangeException("input buffer too short");

            if ((outputOffset + this.BlockSize) > outputBuffer.Length)
                throw new IndexOutOfRangeException("output buffer too short");

            if (this._decryptionKey1 == null || this._decryptionKey2 == null || this._decryptionKey3 == null)
            {
                var part1 = new byte[8];
                var part2 = new byte[8];

                Buffer.BlockCopy(this.Key, 0, part1, 0, 8);
                Buffer.BlockCopy(this.Key, 8, part2, 0, 8);

                this._decryptionKey1 = this.GenerateWorkingKey(false, part1);
                this._decryptionKey2 = this.GenerateWorkingKey(true, part2);

                if (this.Key.Length == 24)
                {
                    var part3 = new byte[8];
                    Buffer.BlockCopy(this.Key, 16, part3, 0, 8);

                    this._decryptionKey3 = this.GenerateWorkingKey(false, part3);
                }
                else
                {
                    this._decryptionKey3 = this._decryptionKey1;
                }
            }

            byte[] temp = new byte[this.BlockSize];

            DesCipher.DesFunc(this._decryptionKey3, inputBuffer, inputOffset, temp, 0);
            DesCipher.DesFunc(this._decryptionKey2, temp, 0, temp, 0);
            DesCipher.DesFunc(this._decryptionKey1, temp, 0, outputBuffer, outputOffset);

            return this.BlockSize;
        }

        /// <summary>
        /// Validates the key.
        /// </summary>
        protected override void ValidateKey()
        {
            var keySize = this.Key.Length * 8;

            if (!(keySize == 128 || keySize == 128 + 64))
                throw new ArgumentException(string.Format("KeySize '{0}' is not valid for this algorithm.", keySize));
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Ciphers\TwofishCipher.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography.Ciphers
{
    /// <summary>
    /// Implements Twofish cipher algorithm
    /// </summary>
    public sealed class TwofishCipher : BlockCipher
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TwofishCipher"/> class.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <param name="mode">The mode.</param>
        /// <param name="padding">The padding.</param>
        /// <exception cref="ArgumentNullException"><paramref name="key"/> is null.</exception>
        /// <exception cref="ArgumentException">Keysize is not valid for this algorithm.</exception>
        public TwofishCipher(byte[] key, CipherModeRenci mode, CipherPadding padding)
            : base(key, 16, mode, padding)
        {
            var keySize = key.Length * 8;

            if (!(keySize == 128 || keySize == 192 || keySize == 256))
                throw new ArgumentException(string.Format("KeySize '{0}' is not valid for this algorithm.", keySize));

            //OneCodeTODO:   Refactor this algorithm

            // calculate the MDS matrix
            int[] m1 = new int[2];
            int[] mX = new int[2];
            int[] mY = new int[2];
            int j;

            for (int i = 0; i < MAX_KEY_BITS; i++)
            {
                j = P[0 + i] & 0xff;
                m1[0] = j;
                mX[0] = Mx_X(j) & 0xff;
                mY[0] = Mx_Y(j) & 0xff;

                j = P[(1 * 256) + i] & 0xff;
                m1[1] = j;
                mX[1] = Mx_X(j) & 0xff;
                mY[1] = Mx_Y(j) & 0xff;

                gMDS0[i] = m1[P_00] | mX[P_00] << 8 | mY[P_00] << 16 | mY[P_00] << 24;

                gMDS1[i] = mY[P_10] | mY[P_10] << 8 | mX[P_10] << 16 | m1[P_10] << 24;

                gMDS2[i] = mX[P_20] | mY[P_20] << 8 | m1[P_20] << 16 | mY[P_20] << 24;

                gMDS3[i] = mX[P_30] | m1[P_30] << 8 | mY[P_30] << 16 | mX[P_30] << 24;
            }

            this.k64Cnt = key.Length / 8; // pre-padded ?
            this.SetKey(key);
        }

        /// <summary>
        /// Encrypts the specified region of the input byte array and copies the encrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to encrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write encrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes encrypted.
        /// </returns>
        public override int EncryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            int x0 = BytesTo32Bits(inputBuffer, inputOffset) ^ gSubKeys[INPUT_WHITEN];
            int x1 = BytesTo32Bits(inputBuffer, inputOffset + 4) ^ gSubKeys[INPUT_WHITEN + 1];
            int x2 = BytesTo32Bits(inputBuffer, inputOffset + 8) ^ gSubKeys[INPUT_WHITEN + 2];
            int x3 = BytesTo32Bits(inputBuffer, inputOffset + 12) ^ gSubKeys[INPUT_WHITEN + 3];

            int k = ROUND_SUBKEYS;
            int t0, t1;
            for (int r = 0; r < ROUNDS; r += 2)
            {
                t0 = Fe32_0(gSBox, x0);
                t1 = Fe32_3(gSBox, x1);
                x2 ^= t0 + t1 + gSubKeys[k++];
                x2 = (int)((uint)x2 >> 1) | x2 << 31;
                x3 = (x3 << 1 | (int)((uint)x3 >> 31)) ^ (t0 + 2 * t1 + gSubKeys[k++]);

                t0 = Fe32_0(gSBox, x2);
                t1 = Fe32_3(gSBox, x3);
                x0 ^= t0 + t1 + gSubKeys[k++];
                x0 = (int)((uint)x0 >> 1) | x0 << 31;
                x1 = (x1 << 1 | (int)((uint)x1 >> 31)) ^ (t0 + 2 * t1 + gSubKeys[k++]);
            }

            Bits32ToBytes(x2 ^ gSubKeys[OUTPUT_WHITEN], outputBuffer, outputOffset);
            Bits32ToBytes(x3 ^ gSubKeys[OUTPUT_WHITEN + 1], outputBuffer, outputOffset + 4);
            Bits32ToBytes(x0 ^ gSubKeys[OUTPUT_WHITEN + 2], outputBuffer, outputOffset + 8);
            Bits32ToBytes(x1 ^ gSubKeys[OUTPUT_WHITEN + 3], outputBuffer, outputOffset + 12);

            return this.BlockSize;
        }

        /// <summary>
        /// Decrypts the specified region of the input byte array and copies the decrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to decrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write decrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes decrypted.
        /// </returns>
        public override int DecryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            int x2 = BytesTo32Bits(inputBuffer, inputOffset) ^ gSubKeys[OUTPUT_WHITEN];
            int x3 = BytesTo32Bits(inputBuffer, inputOffset + 4) ^ gSubKeys[OUTPUT_WHITEN + 1];
            int x0 = BytesTo32Bits(inputBuffer, inputOffset + 8) ^ gSubKeys[OUTPUT_WHITEN + 2];
            int x1 = BytesTo32Bits(inputBuffer, inputOffset + 12) ^ gSubKeys[OUTPUT_WHITEN + 3];

            int k = ROUND_SUBKEYS + 2 * ROUNDS - 1;
            int t0, t1;
            for (int r = 0; r < ROUNDS; r += 2)
            {
                t0 = Fe32_0(gSBox, x2);
                t1 = Fe32_3(gSBox, x3);
                x1 ^= t0 + 2 * t1 + gSubKeys[k--];
                x0 = (x0 << 1 | (int)((uint)x0 >> 31)) ^ (t0 + t1 + gSubKeys[k--]);
                x1 = (int)((uint)x1 >> 1) | x1 << 31;

                t0 = Fe32_0(gSBox, x0);
                t1 = Fe32_3(gSBox, x1);
                x3 ^= t0 + 2 * t1 + gSubKeys[k--];
                x2 = (x2 << 1 | (int)((uint)x2 >> 31)) ^ (t0 + t1 + gSubKeys[k--]);
                x3 = (int)((uint)x3 >> 1) | x3 << 31;
            }

            Bits32ToBytes(x0 ^ gSubKeys[INPUT_WHITEN], outputBuffer, outputOffset);
            Bits32ToBytes(x1 ^ gSubKeys[INPUT_WHITEN + 1], outputBuffer, outputOffset + 4);
            Bits32ToBytes(x2 ^ gSubKeys[INPUT_WHITEN + 2], outputBuffer, outputOffset + 8);
            Bits32ToBytes(x3 ^ gSubKeys[INPUT_WHITEN + 3], outputBuffer, outputOffset + 12);

            return this.BlockSize;
        }

        #region Static Definition Tables

        private static readonly byte[] P =  {
        //{  // p0
            (byte) 0xA9, (byte) 0x67, (byte) 0xB3, (byte) 0xE8,
            (byte) 0x04, (byte) 0xFD, (byte) 0xA3, (byte) 0x76,
            (byte) 0x9A, (byte) 0x92, (byte) 0x80, (byte) 0x78,
            (byte) 0xE4, (byte) 0xDD, (byte) 0xD1, (byte) 0x38,
            (byte) 0x0D, (byte) 0xC6, (byte) 0x35, (byte) 0x98,
            (byte) 0x18, (byte) 0xF7, (byte) 0xEC, (byte) 0x6C,
            (byte) 0x43, (byte) 0x75, (byte) 0x37, (byte) 0x26,
            (byte) 0xFA, (byte) 0x13, (byte) 0x94, (byte) 0x48,
            (byte) 0xF2, (byte) 0xD0, (byte) 0x8B, (byte) 0x30,
            (byte) 0x84, (byte) 0x54, (byte) 0xDF, (byte) 0x23,
            (byte) 0x19, (byte) 0x5B, (byte) 0x3D, (byte) 0x59,
            (byte) 0xF3, (byte) 0xAE, (byte) 0xA2, (byte) 0x82,
            (byte) 0x63, (byte) 0x01, (byte) 0x83, (byte) 0x2E,
            (byte) 0xD9, (byte) 0x51, (byte) 0x9B, (byte) 0x7C,
            (byte) 0xA6, (byte) 0xEB, (byte) 0xA5, (byte) 0xBE,
            (byte) 0x16, (byte) 0x0C, (byte) 0xE3, (byte) 0x61,
            (byte) 0xC0, (byte) 0x8C, (byte) 0x3A, (byte) 0xF5,
            (byte) 0x73, (byte) 0x2C, (byte) 0x25, (byte) 0x0B,
            (byte) 0xBB, (byte) 0x4E, (byte) 0x89, (byte) 0x6B,
            (byte) 0x53, (byte) 0x6A, (byte) 0xB4, (byte) 0xF1,
            (byte) 0xE1, (byte) 0xE6, (byte) 0xBD, (byte) 0x45,
            (byte) 0xE2, (byte) 0xF4, (byte) 0xB6, (byte) 0x66,
            (byte) 0xCC, (byte) 0x95, (byte) 0x03, (byte) 0x56,
            (byte) 0xD4, (byte) 0x1C, (byte) 0x1E, (byte) 0xD7,
            (byte) 0xFB, (byte) 0xC3, (byte) 0x8E, (byte) 0xB5,
            (byte) 0xE9, (byte) 0xCF, (byte) 0xBF, (byte) 0xBA,
            (byte) 0xEA, (byte) 0x77, (byte) 0x39, (byte) 0xAF,
            (byte) 0x33, (byte) 0xC9, (byte) 0x62, (byte) 0x71,
            (byte) 0x81, (byte) 0x79, (byte) 0x09, (byte) 0xAD,
            (byte) 0x24, (byte) 0xCD, (byte) 0xF9, (byte) 0xD8,
            (byte) 0xE5, (byte) 0xC5, (byte) 0xB9, (byte) 0x4D,
            (byte) 0x44, (byte) 0x08, (byte) 0x86, (byte) 0xE7,
            (byte) 0xA1, (byte) 0x1D, (byte) 0xAA, (byte) 0xED,
            (byte) 0x06, (byte) 0x70, (byte) 0xB2, (byte) 0xD2,
            (byte) 0x41, (byte) 0x7B, (byte) 0xA0, (byte) 0x11,
            (byte) 0x31, (byte) 0xC2, (byte) 0x27, (byte) 0x90,
            (byte) 0x20, (byte) 0xF6, (byte) 0x60, (byte) 0xFF,
            (byte) 0x96, (byte) 0x5C, (byte) 0xB1, (byte) 0xAB,
            (byte) 0x9E, (byte) 0x9C, (byte) 0x52, (byte) 0x1B,
            (byte) 0x5F, (byte) 0x93, (byte) 0x0A, (byte) 0xEF,
            (byte) 0x91, (byte) 0x85, (byte) 0x49, (byte) 0xEE,
            (byte) 0x2D, (byte) 0x4F, (byte) 0x8F, (byte) 0x3B,
            (byte) 0x47, (byte) 0x87, (byte) 0x6D, (byte) 0x46,
            (byte) 0xD6, (byte) 0x3E, (byte) 0x69, (byte) 0x64,
            (byte) 0x2A, (byte) 0xCE, (byte) 0xCB, (byte) 0x2F,
            (byte) 0xFC, (byte) 0x97, (byte) 0x05, (byte) 0x7A,
            (byte) 0xAC, (byte) 0x7F, (byte) 0xD5, (byte) 0x1A,
            (byte) 0x4B, (byte) 0x0E, (byte) 0xA7, (byte) 0x5A,
            (byte) 0x28, (byte) 0x14, (byte) 0x3F, (byte) 0x29,
            (byte) 0x88, (byte) 0x3C, (byte) 0x4C, (byte) 0x02,
            (byte) 0xB8, (byte) 0xDA, (byte) 0xB0, (byte) 0x17,
            (byte) 0x55, (byte) 0x1F, (byte) 0x8A, (byte) 0x7D,
            (byte) 0x57, (byte) 0xC7, (byte) 0x8D, (byte) 0x74,
            (byte) 0xB7, (byte) 0xC4, (byte) 0x9F, (byte) 0x72,
            (byte) 0x7E, (byte) 0x15, (byte) 0x22, (byte) 0x12,
            (byte) 0x58, (byte) 0x07, (byte) 0x99, (byte) 0x34,
            (byte) 0x6E, (byte) 0x50, (byte) 0xDE, (byte) 0x68,
            (byte) 0x65, (byte) 0xBC, (byte) 0xDB, (byte) 0xF8,
            (byte) 0xC8, (byte) 0xA8, (byte) 0x2B, (byte) 0x40,
            (byte) 0xDC, (byte) 0xFE, (byte) 0x32, (byte) 0xA4,
            (byte) 0xCA, (byte) 0x10, (byte) 0x21, (byte) 0xF0,
            (byte) 0xD3, (byte) 0x5D, (byte) 0x0F, (byte) 0x00,
            (byte) 0x6F, (byte) 0x9D, (byte) 0x36, (byte) 0x42,
            (byte) 0x4A, (byte) 0x5E, (byte) 0xC1, (byte) 0xE0,
        //                                    },
        //{  // p1
            (byte) 0x75, (byte) 0xF3, (byte) 0xC6, (byte) 0xF4,
            (byte) 0xDB, (byte) 0x7B, (byte) 0xFB, (byte) 0xC8,
            (byte) 0x4A, (byte) 0xD3, (byte) 0xE6, (byte) 0x6B,
            (byte) 0x45, (byte) 0x7D, (byte) 0xE8, (byte) 0x4B,
            (byte) 0xD6, (byte) 0x32, (byte) 0xD8, (byte) 0xFD,
            (byte) 0x37, (byte) 0x71, (byte) 0xF1, (byte) 0xE1,
            (byte) 0x30, (byte) 0x0F, (byte) 0xF8, (byte) 0x1B,
            (byte) 0x87, (byte) 0xFA, (byte) 0x06, (byte) 0x3F,
            (byte) 0x5E, (byte) 0xBA, (byte) 0xAE, (byte) 0x5B,
            (byte) 0x8A, (byte) 0x00, (byte) 0xBC, (byte) 0x9D,
            (byte) 0x6D, (byte) 0xC1, (byte) 0xB1, (byte) 0x0E,
            (byte) 0x80, (byte) 0x5D, (byte) 0xD2, (byte) 0xD5,
            (byte) 0xA0, (byte) 0x84, (byte) 0x07, (byte) 0x14,
            (byte) 0xB5, (byte) 0x90, (byte) 0x2C, (byte) 0xA3,
            (byte) 0xB2, (byte) 0x73, (byte) 0x4C, (byte) 0x54,
            (byte) 0x92, (byte) 0x74, (byte) 0x36, (byte) 0x51,
            (byte) 0x38, (byte) 0xB0, (byte) 0xBD, (byte) 0x5A,
            (byte) 0xFC, (byte) 0x60, (byte) 0x62, (byte) 0x96,
            (byte) 0x6C, (byte) 0x42, (byte) 0xF7, (byte) 0x10,
            (byte) 0x7C, (byte) 0x28, (byte) 0x27, (byte) 0x8C,
            (byte) 0x13, (byte) 0x95, (byte) 0x9C, (byte) 0xC7,
            (byte) 0x24, (byte) 0x46, (byte) 0x3B, (byte) 0x70,
            (byte) 0xCA, (byte) 0xE3, (byte) 0x85, (byte) 0xCB,
            (byte) 0x11, (byte) 0xD0, (byte) 0x93, (byte) 0xB8,
            (byte) 0xA6, (byte) 0x83, (byte) 0x20, (byte) 0xFF,
            (byte) 0x9F, (byte) 0x77, (byte) 0xC3, (byte) 0xCC,
            (byte) 0x03, (byte) 0x6F, (byte) 0x08, (byte) 0xBF,
            (byte) 0x40, (byte) 0xE7, (byte) 0x2B, (byte) 0xE2,
            (byte) 0x79, (byte) 0x0C, (byte) 0xAA, (byte) 0x82,
            (byte) 0x41, (byte) 0x3A, (byte) 0xEA, (byte) 0xB9,
            (byte) 0xE4, (byte) 0x9A, (byte) 0xA4, (byte) 0x97,
            (byte) 0x7E, (byte) 0xDA, (byte) 0x7A, (byte) 0x17,
            (byte) 0x66, (byte) 0x94, (byte) 0xA1, (byte) 0x1D,
            (byte) 0x3D, (byte) 0xF0, (byte) 0xDE, (byte) 0xB3,
            (byte) 0x0B, (byte) 0x72, (byte) 0xA7, (byte) 0x1C,
            (byte) 0xEF, (byte) 0xD1, (byte) 0x53, (byte) 0x3E,
            (byte) 0x8F, (byte) 0x33, (byte) 0x26, (byte) 0x5F,
            (byte) 0xEC, (byte) 0x76, (byte) 0x2A, (byte) 0x49,
            (byte) 0x81, (byte) 0x88, (byte) 0xEE, (byte) 0x21,
            (byte) 0xC4, (byte) 0x1A, (byte) 0xEB, (byte) 0xD9,
            (byte) 0xC5, (byte) 0x39, (byte) 0x99, (byte) 0xCD,
            (byte) 0xAD, (byte) 0x31, (byte) 0x8B, (byte) 0x01,
            (byte) 0x18, (byte) 0x23, (byte) 0xDD, (byte) 0x1F,
            (byte) 0x4E, (byte) 0x2D, (byte) 0xF9, (byte) 0x48,
            (byte) 0x4F, (byte) 0xF2, (byte) 0x65, (byte) 0x8E,
            (byte) 0x78, (byte) 0x5C, (byte) 0x58, (byte) 0x19,
            (byte) 0x8D, (byte) 0xE5, (byte) 0x98, (byte) 0x57,
            (byte) 0x67, (byte) 0x7F, (byte) 0x05, (byte) 0x64,
            (byte) 0xAF, (byte) 0x63, (byte) 0xB6, (byte) 0xFE,
            (byte) 0xF5, (byte) 0xB7, (byte) 0x3C, (byte) 0xA5,
            (byte) 0xCE, (byte) 0xE9, (byte) 0x68, (byte) 0x44,
            (byte) 0xE0, (byte) 0x4D, (byte) 0x43, (byte) 0x69,
            (byte) 0x29, (byte) 0x2E, (byte) 0xAC, (byte) 0x15,
            (byte) 0x59, (byte) 0xA8, (byte) 0x0A, (byte) 0x9E,
            (byte) 0x6E, (byte) 0x47, (byte) 0xDF, (byte) 0x34,
            (byte) 0x35, (byte) 0x6A, (byte) 0xCF, (byte) 0xDC,
            (byte) 0x22, (byte) 0xC9, (byte) 0xC0, (byte) 0x9B,
            (byte) 0x89, (byte) 0xD4, (byte) 0xED, (byte) 0xAB,
            (byte) 0x12, (byte) 0xA2, (byte) 0x0D, (byte) 0x52,
            (byte) 0xBB, (byte) 0x02, (byte) 0x2F, (byte) 0xA9,
            (byte) 0xD7, (byte) 0x61, (byte) 0x1E, (byte) 0xB4,
            (byte) 0x50, (byte) 0x04, (byte) 0xF6, (byte) 0xC2,
            (byte) 0x16, (byte) 0x25, (byte) 0x86, (byte) 0x56,
            (byte) 0x55, (byte) 0x09, (byte) 0xBE, (byte) 0x91
                                            //}
        };

        #endregion

        /**
        * Define the fixed p0/p1 permutations used in keyed S-box lookup.
        * By changing the following constant definitions, the S-boxes will
        * automatically Get changed in the Twofish engine.
        */
        private const int P_00 = 1;
        private const int P_01 = 0;
        private const int P_02 = 0;
        private const int P_03 = P_01 ^ 1;
        private const int P_04 = 1;

        private const int P_10 = 0;
        private const int P_11 = 0;
        private const int P_12 = 1;
        private const int P_13 = P_11 ^ 1;
        private const int P_14 = 0;

        private const int P_20 = 1;
        private const int P_21 = 1;
        private const int P_22 = 0;
        private const int P_23 = P_21 ^ 1;
        private const int P_24 = 0;

        private const int P_30 = 0;
        private const int P_31 = 1;
        private const int P_32 = 1;
        private const int P_33 = P_31 ^ 1;
        private const int P_34 = 1;

        /* Primitive polynomial for GF(256) */
        private const int GF256_FDBK = 0x169;
        private const int GF256_FDBK_2 = GF256_FDBK / 2;
        private const int GF256_FDBK_4 = GF256_FDBK / 4;

        private const int RS_GF_FDBK = 0x14D; // field generator

        //====================================
        // Useful constants
        //====================================

        private const int ROUNDS = 16;
        private const int MAX_ROUNDS = 16;  // bytes = 128 bits
        private const int MAX_KEY_BITS = 256;

        private const int INPUT_WHITEN = 0;
        private const int OUTPUT_WHITEN = INPUT_WHITEN + 16 / 4; // 4
        private const int ROUND_SUBKEYS = OUTPUT_WHITEN + 16 / 4;// 8

        private const int TOTAL_SUBKEYS = ROUND_SUBKEYS + 2 * MAX_ROUNDS;// 40

        private const int SK_STEP = 0x02020202;
        private const int SK_BUMP = 0x01010101;
        private const int SK_ROTL = 9;

        private readonly int[] gMDS0 = new int[MAX_KEY_BITS];
        private readonly int[] gMDS1 = new int[MAX_KEY_BITS];
        private readonly int[] gMDS2 = new int[MAX_KEY_BITS];
        private readonly int[] gMDS3 = new int[MAX_KEY_BITS];

        /**
        * gSubKeys[] and gSBox[] are eventually used in the
        * encryption and decryption methods.
        */
        private int[] gSubKeys;
        private int[] gSBox;

        private int k64Cnt;

        private void SetKey(byte[] key)
        {
            int[] k32e = new int[MAX_KEY_BITS / 64]; // 4
            int[] k32o = new int[MAX_KEY_BITS / 64]; // 4

            int[] sBoxKeys = new int[MAX_KEY_BITS / 64]; // 4
            gSubKeys = new int[TOTAL_SUBKEYS];

            if (k64Cnt < 1)
            {
                throw new ArgumentException("Key size less than 64 bits");
            }

            if (k64Cnt > 4)
            {
                throw new ArgumentException("Key size larger than 256 bits");
            }

            /*
            * k64Cnt is the number of 8 byte blocks (64 chunks)
            * that are in the input key.  The input key is a
            * maximum of 32 bytes ( 256 bits ), so the range
            * for k64Cnt is 1..4
            */
            for (int i = 0; i < k64Cnt; i++)
            {
                var p = i * 8;

                k32e[i] = BytesTo32Bits(key, p);
                k32o[i] = BytesTo32Bits(key, p + 4);

                sBoxKeys[k64Cnt - 1 - i] = RS_MDS_Encode(k32e[i], k32o[i]);
            }

            int q, A, B;
            for (int i = 0; i < TOTAL_SUBKEYS / 2; i++)
            {
                q = i * SK_STEP;
                A = F32(q, k32e);
                B = F32(q + SK_BUMP, k32o);
                B = B << 8 | (int)((uint)B >> 24);
                A += B;
                gSubKeys[i * 2] = A;
                A += B;
                gSubKeys[i * 2 + 1] = A << SK_ROTL | (int)((uint)A >> (32 - SK_ROTL));
            }

            /*
            * fully expand the table for speed
            */
            int k0 = sBoxKeys[0];
            int k1 = sBoxKeys[1];
            int k2 = sBoxKeys[2];
            int k3 = sBoxKeys[3];
            int b0, b1, b2, b3;
            gSBox = new int[4 * MAX_KEY_BITS];
            for (int i = 0; i < MAX_KEY_BITS; i++)
            {
                b0 = b1 = b2 = b3 = i;
                switch (k64Cnt & 3)
                {
                    case 1:
                        gSBox[i * 2] = gMDS0[(P[P_01 * 256 + b0] & 0xff) ^ M_b0(k0)];
                        gSBox[i * 2 + 1] = gMDS1[(P[P_11 * 256 + b1] & 0xff) ^ M_b1(k0)];
                        gSBox[i * 2 + 0x200] = gMDS2[(P[P_21 * 256 + b2] & 0xff) ^ M_b2(k0)];
                        gSBox[i * 2 + 0x201] = gMDS3[(P[P_31 * 256 + b3] & 0xff) ^ M_b3(k0)];
                        break;
                    case 0: /* 256 bits of key */
                        b0 = (P[P_04 * 256 + b0] & 0xff) ^ M_b0(k3);
                        b1 = (P[P_14 * 256 + b1] & 0xff) ^ M_b1(k3);
                        b2 = (P[P_24 * 256 + b2] & 0xff) ^ M_b2(k3);
                        b3 = (P[P_34 * 256 + b3] & 0xff) ^ M_b3(k3);
                        goto case 3;
                    case 3:
                        b0 = (P[P_03 * 256 + b0] & 0xff) ^ M_b0(k2);
                        b1 = (P[P_13 * 256 + b1] & 0xff) ^ M_b1(k2);
                        b2 = (P[P_23 * 256 + b2] & 0xff) ^ M_b2(k2);
                        b3 = (P[P_33 * 256 + b3] & 0xff) ^ M_b3(k2);
                        goto case 2;
                    case 2:
                        gSBox[i * 2] = gMDS0[(P[P_01 * 256 + (P[P_02 * 256 + b0] & 0xff) ^ M_b0(k1)] & 0xff) ^ M_b0(k0)];
                        gSBox[i * 2 + 1] = gMDS1[(P[P_11 * 256 + (P[P_12 * 256 + b1] & 0xff) ^ M_b1(k1)] & 0xff) ^ M_b1(k0)];
                        gSBox[i * 2 + 0x200] = gMDS2[(P[P_21 * 256 + (P[P_22 * 256 + b2] & 0xff) ^ M_b2(k1)] & 0xff) ^ M_b2(k0)];
                        gSBox[i * 2 + 0x201] = gMDS3[(P[P_31 * 256 + (P[P_32 * 256 + b3] & 0xff) ^ M_b3(k1)] & 0xff) ^ M_b3(k0)];
                        break;
                }
            }

            /*
            * the function exits having setup the gSBox with the
            * input key material.
            */
        }

        /*
        * TO-DO:  This can be optimised and made cleaner by combining
        * the functionality in this function and applying it appropriately
        * to the creation of the subkeys during key setup.
        */
        private int F32(int x, int[] k32)
        {
            int b0 = M_b0(x);
            int b1 = M_b1(x);
            int b2 = M_b2(x);
            int b3 = M_b3(x);
            int k0 = k32[0];
            int k1 = k32[1];
            int k2 = k32[2];
            int k3 = k32[3];

            int result = 0;
            switch (k64Cnt & 3)
            {
                case 1:
                    result = gMDS0[(P[P_01 * 256 + b0] & 0xff) ^ M_b0(k0)] ^
                             gMDS1[(P[P_11 * 256 + b1] & 0xff) ^ M_b1(k0)] ^
                             gMDS2[(P[P_21 * 256 + b2] & 0xff) ^ M_b2(k0)] ^
                             gMDS3[(P[P_31 * 256 + b3] & 0xff) ^ M_b3(k0)];
                    break;
                case 0: /* 256 bits of key */
                    b0 = (P[P_04 * 256 + b0] & 0xff) ^ M_b0(k3);
                    b1 = (P[P_14 * 256 + b1] & 0xff) ^ M_b1(k3);
                    b2 = (P[P_24 * 256 + b2] & 0xff) ^ M_b2(k3);
                    b3 = (P[P_34 * 256 + b3] & 0xff) ^ M_b3(k3);
                    goto case 3;
                case 3:
                    b0 = (P[P_03 * 256 + b0] & 0xff) ^ M_b0(k2);
                    b1 = (P[P_13 * 256 + b1] & 0xff) ^ M_b1(k2);
                    b2 = (P[P_23 * 256 + b2] & 0xff) ^ M_b2(k2);
                    b3 = (P[P_33 * 256 + b3] & 0xff) ^ M_b3(k2);
                    goto case 2;
                case 2:
                    result =
                    gMDS0[(P[P_01 * 256 + (P[P_02 * 256 + b0] & 0xff) ^ M_b0(k1)] & 0xff) ^ M_b0(k0)] ^
                    gMDS1[(P[P_11 * 256 + (P[P_12 * 256 + b1] & 0xff) ^ M_b1(k1)] & 0xff) ^ M_b1(k0)] ^
                    gMDS2[(P[P_21 * 256 + (P[P_22 * 256 + b2] & 0xff) ^ M_b2(k1)] & 0xff) ^ M_b2(k0)] ^
                    gMDS3[(P[P_31 * 256 + (P[P_32 * 256 + b3] & 0xff) ^ M_b3(k1)] & 0xff) ^ M_b3(k0)];
                    break;
            }
            return result;
        }

        /**
        * Use (12, 8) Reed-Solomon code over GF(256) to produce
        * a key S-box 32-bit entity from 2 key material 32-bit
        * entities.
        *
        * @param    k0 first 32-bit entity
        * @param    k1 second 32-bit entity
        * @return     Remainder polynomial Generated using RS code
        */
        private static int RS_MDS_Encode(int k0, int k1)
        {
            int r = k1;
            // shift 1 byte at a time
            r = RS_rem(r);
            r = RS_rem(r);
            r = RS_rem(r);
            r = RS_rem(r);
            r ^= k0;
            r = RS_rem(r);
            r = RS_rem(r);
            r = RS_rem(r);
            r = RS_rem(r);

            return r;
        }

        /**
        * Reed-Solomon code parameters: (12,8) reversible code:
        * <p>
        * <pre>
        * G(x) = x^4 + (a+1/a)x^3 + ax^2 + (a+1/a)x + 1
        * </pre>
        * where a = primitive root of field generator 0x14D
        * </p>
        */
        private static int RS_rem(int x)
        {
            int b = (int)(((uint)x >> 24) & 0xff);
            int g2 = ((b << 1) ^
                    ((b & 0x80) != 0 ? RS_GF_FDBK : 0)) & 0xff;
            int g3 = ((int)((uint)b >> 1) ^
                    ((b & 0x01) != 0 ? (int)((uint)RS_GF_FDBK >> 1) : 0)) ^ g2;
            return ((x << 8) ^ (g3 << 24) ^ (g2 << 16) ^ (g3 << 8) ^ b);
        }

        private static int LFSR1(int x)
        {
            return (x >> 1) ^
                    (((x & 0x01) != 0) ? GF256_FDBK_2 : 0);
        }

        private static int LFSR2(int x)
        {
            return (x >> 2) ^
                    (((x & 0x02) != 0) ? GF256_FDBK_2 : 0) ^
                    (((x & 0x01) != 0) ? GF256_FDBK_4 : 0);
        }

        private static int Mx_X(int x)
        {
            return x ^ LFSR2(x);
        } // 5B

        private static int Mx_Y(int x)
        {
            return x ^ LFSR1(x) ^ LFSR2(x);
        } // EF

        private static int M_b0(int x)
        {
            return x & 0xff;
        }

        private static int M_b1(int x)
        {
            return (int)((uint)x >> 8) & 0xff;
        }

        private static int M_b2(int x)
        {
            return (int)((uint)x >> 16) & 0xff;
        }

        private static int M_b3(int x)
        {
            return (int)((uint)x >> 24) & 0xff;
        }

        private static int Fe32_0(int[] gSBox1, int x)
        {
            return gSBox1[0x000 + 2 * (x & 0xff)] ^
                gSBox1[0x001 + 2 * ((int)((uint)x >> 8) & 0xff)] ^
                gSBox1[0x200 + 2 * ((int)((uint)x >> 16) & 0xff)] ^
                gSBox1[0x201 + 2 * ((int)((uint)x >> 24) & 0xff)];
        }

        private static int Fe32_3(int[] gSBox1, int x)
        {
            return gSBox1[0x000 + 2 * ((int)((uint)x >> 24) & 0xff)] ^
                gSBox1[0x001 + 2 * (x & 0xff)] ^
                gSBox1[0x200 + 2 * ((int)((uint)x >> 8) & 0xff)] ^
                gSBox1[0x201 + 2 * ((int)((uint)x >> 16) & 0xff)];
        }

        private static int BytesTo32Bits(byte[] b, int p)
        {
            return ((b[p] & 0xff)) |
                ((b[p + 1] & 0xff) << 8) |
                ((b[p + 2] & 0xff) << 16) |
                ((b[p + 3] & 0xff) << 24);
        }

        private static void Bits32ToBytes(int inData, byte[] b, int offset)
        {
            b[offset] = (byte)inData;
            b[offset + 1] = (byte)(inData >> 8);
            b[offset + 2] = (byte)(inData >> 16);
            b[offset + 3] = (byte)(inData >> 24);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Ciphers\Modes\CbcCipherMode.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography.Ciphers.Modes
{
    /// <summary>
    /// Implements CBC cipher mode
    /// </summary>
    public class CbcCipherMode : CipherModeRenci
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CbcCipherMode"/> class.
        /// </summary>
        /// <param name="iv">The iv.</param>
        public CbcCipherMode(byte[] iv)
            : base(iv)
        {
        }

        /// <summary>
        /// Encrypts the specified region of the input byte array and copies the encrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to encrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write encrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes encrypted.
        /// </returns>
        public override int EncryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            if (inputBuffer.Length - inputOffset < this._blockSize)
                throw new ArgumentException("Invalid input buffer");

            if (outputBuffer.Length - outputOffset < this._blockSize)
                throw new ArgumentException("Invalid output buffer");

            if (inputCount != this._blockSize)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "inputCount must be {0}.", this._blockSize));

            for (int i = 0; i < this._blockSize; i++)
            {
                this.IV[i] ^= inputBuffer[inputOffset + i];
            }

            this.Cipher.EncryptBlock(this.IV, 0, inputCount, outputBuffer, outputOffset);

            Buffer.BlockCopy(outputBuffer, outputOffset, this.IV, 0, this.IV.Length);


            return this._blockSize;
        }

        /// <summary>
        /// Decrypts the specified region of the input byte array and copies the decrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to decrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write decrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes decrypted.
        /// </returns>
        public override int DecryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            if (inputBuffer.Length - inputOffset < this._blockSize)
                throw new ArgumentException("Invalid input buffer");

            if (outputBuffer.Length - outputOffset < this._blockSize)
                throw new ArgumentException("Invalid output buffer");

            if (inputCount != this._blockSize)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "inputCount must be {0}.", this._blockSize));

            this.Cipher.DecryptBlock(inputBuffer, inputOffset, inputCount, outputBuffer, outputOffset);

            for (int i = 0; i < this._blockSize; i++)
            {
                outputBuffer[outputOffset + i] ^= this.IV[i];
            }

            Buffer.BlockCopy(inputBuffer, inputOffset, this.IV, 0, this.IV.Length);

            return this._blockSize;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Ciphers\Modes\CfbCipherMode.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography.Ciphers.Modes
{
    /// <summary>
    /// Implements CFB cipher mode
    /// </summary>
    public class CfbCipherMode : CipherModeRenci
    {
        private readonly byte[] _ivOutput;

        /// <summary>
        /// Initializes a new instance of the <see cref="CfbCipherMode"/> class.
        /// </summary>
        /// <param name="iv">The iv.</param>
        public CfbCipherMode(byte[] iv)
            : base(iv)
        {
            this._ivOutput = new byte[iv.Length];
        }

        /// <summary>
        /// Encrypts the specified region of the input byte array and copies the encrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to encrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write encrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes encrypted.
        /// </returns>
        public override int EncryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            if (inputBuffer.Length - inputOffset < this._blockSize)
                throw new ArgumentException("Invalid input buffer");

            if (outputBuffer.Length - outputOffset < this._blockSize)
                throw new ArgumentException("Invalid output buffer");

            if (inputCount != this._blockSize)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "inputCount must be {0}.", this._blockSize));

            this.Cipher.EncryptBlock(this.IV, 0, this.IV.Length, this._ivOutput, 0);

            for (int i = 0; i < this._blockSize; i++)
            {
                outputBuffer[outputOffset + i] = (byte)(this._ivOutput[i] ^ inputBuffer[inputOffset + i]);
            }

            Buffer.BlockCopy(this.IV, this._blockSize, this.IV, 0, this.IV.Length - this._blockSize);
            Buffer.BlockCopy(outputBuffer, outputOffset, this.IV, this.IV.Length - this._blockSize, this._blockSize);

            return this._blockSize;
        }

        /// <summary>
        /// Decrypts the specified region of the input byte array and copies the decrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to decrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write decrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes decrypted.
        /// </returns>
        public override int DecryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            if (inputBuffer.Length - inputOffset < this._blockSize)
                throw new ArgumentException("Invalid input buffer");

            if (outputBuffer.Length - outputOffset < this._blockSize)
                throw new ArgumentException("Invalid output buffer");

            if (inputCount != this._blockSize)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "inputCount must be {0}.", this._blockSize));

            this.Cipher.EncryptBlock(this.IV, 0, this.IV.Length, this._ivOutput, 0);

            Buffer.BlockCopy(this.IV, this._blockSize, this.IV, 0, this.IV.Length - this._blockSize);
            Buffer.BlockCopy(inputBuffer, inputOffset, this.IV, this.IV.Length - this._blockSize, this._blockSize);

            for (int i = 0; i < this._blockSize; i++)
            {
                outputBuffer[outputOffset + i] = (byte)(this._ivOutput[i] ^ inputBuffer[inputOffset + i]);
            }

            return this._blockSize;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Ciphers\Modes\CtrCipherMode.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography.Ciphers.Modes
{
    /// <summary>
    /// Implements CTR cipher mode
    /// </summary>
    public class CtrCipherMode : CipherModeRenci
    {
        private readonly byte[] _ivOutput;

        /// <summary>
        /// Initializes a new instance of the <see cref="CtrCipherMode"/> class.
        /// </summary>
        /// <param name="iv">The iv.</param>
        public CtrCipherMode(byte[] iv)
            : base(iv)
        {
            this._ivOutput = new byte[iv.Length];
        }

        /// <summary>
        /// Encrypts the specified region of the input byte array and copies the encrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to encrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write encrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes encrypted.
        /// </returns>
        public override int EncryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            if (inputBuffer.Length - inputOffset < this._blockSize)
                throw new ArgumentException("Invalid input buffer");

            if (outputBuffer.Length - outputOffset < this._blockSize)
                throw new ArgumentException("Invalid output buffer");

            if (inputCount != this._blockSize)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "inputCount must be {0}.", this._blockSize));

            this.Cipher.EncryptBlock(this.IV, 0, this.IV.Length, this._ivOutput, 0);

            for (int i = 0; i < this._blockSize; i++)
            {
                outputBuffer[outputOffset + i] = (byte)(this._ivOutput[i] ^ inputBuffer[inputOffset + i]);
            }

            int j = this.IV.Length;
            while (--j >= 0 && ++this.IV[j] == 0) ;

            return this._blockSize;
        }

        /// <summary>
        /// Decrypts the specified region of the input byte array and copies the decrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to decrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write decrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes decrypted.
        /// </returns>
        public override int DecryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            if (inputBuffer.Length - inputOffset < this._blockSize)
                throw new ArgumentException("Invalid input buffer");

            if (outputBuffer.Length - outputOffset < this._blockSize)
                throw new ArgumentException("Invalid output buffer");

            if (inputCount != this._blockSize)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "inputCount must be {0}.", this._blockSize));

            this.Cipher.EncryptBlock(this.IV, 0, this.IV.Length, this._ivOutput, 0);

            for (int i = 0; i < this._blockSize; i++)
            {
                outputBuffer[outputOffset + i] = (byte)(this._ivOutput[i] ^ inputBuffer[inputOffset + i]);
            }

            int j = this.IV.Length;
            while (--j >= 0 && ++this.IV[j] == 0) ;

            return this._blockSize;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Ciphers\Modes\OfbCipherMode.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography.Ciphers.Modes
{
    /// <summary>
    /// Implements OFB cipher mode
    /// </summary>
    public class OfbCipherMode : CipherModeRenci
    {
        private readonly byte[] _ivOutput;

        /// <summary>
        /// Initializes a new instance of the <see cref="OfbCipherMode"/> class.
        /// </summary>
        /// <param name="iv">The iv.</param>
        public OfbCipherMode(byte[] iv)
            : base(iv)
        {
            this._ivOutput = new byte[iv.Length];
        }

        /// <summary>
        /// Encrypts the specified region of the input byte array and copies the encrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to encrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write encrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes encrypted.
        /// </returns>
        public override int EncryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            if (inputBuffer.Length - inputOffset < this._blockSize)
                throw new ArgumentException("Invalid input buffer");

            if (outputBuffer.Length - outputOffset < this._blockSize)
                throw new ArgumentException("Invalid output buffer");

            if (inputCount != this._blockSize)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "inputCount must be {0}.", this._blockSize));

            this.Cipher.EncryptBlock(this.IV, 0, this.IV.Length, this._ivOutput, 0);

            for (int i = 0; i < this._blockSize; i++)
            {
                outputBuffer[outputOffset + i] = (byte)(this._ivOutput[i] ^ inputBuffer[inputOffset + i]);
            }

            Buffer.BlockCopy(this.IV, this._blockSize, this.IV, 0, this.IV.Length - this._blockSize);
            Buffer.BlockCopy(outputBuffer, outputOffset, this.IV, this.IV.Length - this._blockSize, this._blockSize);

            return this._blockSize;
        }

        /// <summary>
        /// Decrypts the specified region of the input byte array and copies the decrypted data to the specified region of the output byte array.
        /// </summary>
        /// <param name="inputBuffer">The input data to decrypt.</param>
        /// <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
        /// <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
        /// <param name="outputBuffer">The output to which to write decrypted data.</param>
        /// <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
        /// <returns>
        /// The number of bytes decrypted.
        /// </returns>
        public override int DecryptBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)
        {
            if (inputBuffer.Length - inputOffset < this._blockSize)
                throw new ArgumentException("Invalid input buffer");

            if (outputBuffer.Length - outputOffset < this._blockSize)
                throw new ArgumentException("Invalid output buffer");

            if (inputCount != this._blockSize)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "inputCount must be {0}.", this._blockSize));

            this.Cipher.EncryptBlock(this.IV, 0, this.IV.Length, this._ivOutput, 0);

            for (int i = 0; i < this._blockSize; i++)
            {
                outputBuffer[outputOffset + i] = (byte)(this._ivOutput[i] ^ inputBuffer[inputOffset + i]);
            }

            Buffer.BlockCopy(this.IV, this._blockSize, this.IV, 0, this.IV.Length - this._blockSize);
            Buffer.BlockCopy(outputBuffer, outputOffset, this.IV, this.IV.Length - this._blockSize, this._blockSize);

            return this._blockSize;
        }


    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Ciphers\Paddings\PKCS5Padding.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography.Ciphers.Paddings
{
    /// <summary>
    /// Implements PKCS5 cipher padding
    /// </summary>
    public class PKCS5Padding : CipherPadding
    {
        /// <summary>
        /// Transforms the specified input.
        /// </summary>
        /// <param name="blockSize">Size of the block.</param>
        /// <param name="input">The input.</param>
        /// <returns>
        /// Padded data array.
        /// </returns>
        public override byte[] Pad(int blockSize, byte[] input)
        {
            var numOfPaddedBytes = blockSize - (input.Length % blockSize);

            var output = new byte[input.Length + numOfPaddedBytes];
            Buffer.BlockCopy(input, 0, output, 0, input.Length);
            for (int i = 0; i < numOfPaddedBytes; i++)
            {
                output[input.Length + i] = (byte)numOfPaddedBytes;
            }

            return output;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Ciphers\Paddings\PKCS7Padding.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography.Ciphers.Paddings
{
    /// <summary>
    /// Implements PKCS7 cipher padding
    /// </summary>
    public class PKCS7Padding : CipherPadding
    {
        /// <summary>
        /// Transforms the specified input.
        /// </summary>
        /// <param name="blockSize">Size of the block.</param>
        /// <param name="input">The input.</param>
        /// <returns>
        /// Padded data array.
        /// </returns>
        public override byte[] Pad(int blockSize, byte[] input)
        {
            var numOfPaddedBytes = blockSize - (input.Length % blockSize);

            var output = new byte[input.Length + numOfPaddedBytes];
            Buffer.BlockCopy(input, 0, output, 0, input.Length);
            for (int i = 0; i < numOfPaddedBytes; i++)
            {
                output[input.Length + i] = (byte)numOfPaddedBytes;
            }

            return output;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Hashes\MD5Hash.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography
{
    /// <summary>
    /// MD5 algorithm implementation
    /// </summary>
    public sealed class MD5Hash : HashAlgorithm
    {
        private readonly byte[] _buffer = new byte[4];
        private int _bufferOffset;
        private long _byteCount;
        private int H1, H2, H3, H4;         // IV's
        private readonly int[] _hashValue = new int[16];
        private int _offset;

        /// <summary>
        /// Gets the size, in bits, of the computed hash code.
        /// </summary>
        /// <returns>The size, in bits, of the computed hash code.</returns>
        public override int HashSize
        {
            get
            {
                return 128;
            }
        }

        /// <summary>
        /// Gets the input block size.
        /// </summary>
        /// <returns>The input block size.</returns>
        public override int InputBlockSize
        {
            get
            {
                return 64;
            }
        }

        /// <summary>
        /// Gets the output block size.
        /// </summary>
        /// <returns>The output block size.</returns>
        public override int OutputBlockSize
        {
            get
            {
                return 64;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the current transform can be reused.
        /// </summary>
        /// <returns>Always true.</returns>
        public override bool CanReuseTransform
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Gets a value indicating whether multiple blocks can be transformed.
        /// </summary>
        /// <returns>true if multiple blocks can be transformed; otherwise, false.</returns>
        public override bool CanTransformMultipleBlocks
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MD5Hash"/> class.
        /// </summary>
        public MD5Hash()
        {
            this.InternalInitialize();
        }

        /// <summary>
        /// Routes data written to the object into the hash algorithm for computing the hash.
        /// </summary>
        /// <param name="array">The input to compute the hash code for.</param>
        /// <param name="ibStart">The offset into the byte array from which to begin using data.</param>
        /// <param name="cbSize">The number of bytes in the byte array to use as data.</param>
        protected override void HashCore(byte[] array, int ibStart, int cbSize)
        {
            //  Fill the current word
            while ((this._bufferOffset != 0) && (cbSize > 0))
            {
                this.Update(array[ibStart]);
                ibStart++;
                cbSize--;
            }

            //  Process whole words.
            while (cbSize > this._buffer.Length)
            {
                this.ProcessWord(array, ibStart);

                ibStart += this._buffer.Length;
                cbSize -= this._buffer.Length;
                this._byteCount += this._buffer.Length;
            }

            //  Load in the remainder.
            while (cbSize > 0)
            {
                this.Update(array[ibStart]);

                ibStart++;
                cbSize--;
            }
        }

        /// <summary>
        /// Finalizes the hash computation after the last data is processed by the cryptographic stream object.
        /// </summary>
        /// <returns>
        /// The computed hash code.
        /// </returns>
        protected override byte[] HashFinal()
        {
            long bitLength = (this._byteCount << 3);

            //  Add the pad bytes.
            this.Update((byte)128);

            while (this._bufferOffset != 0)
                this.Update((byte)0);

            if (this._offset > 14)
            {
                this.ProcessBlock();
            }

            this._hashValue[14] = (int)(bitLength & 0xffffffff);
            this._hashValue[15] = (int)((ulong)bitLength >> 32);

            this.ProcessBlock();

            var output = new byte[16];

            this.UnpackWord(H1, output, 0);
            this.UnpackWord(H2, output, 0 + 4);
            this.UnpackWord(H3, output, 0 + 8);
            this.UnpackWord(H4, output, 0 + 12);

            this.Initialize();

            return output;
        }

        /// <summary>
        /// Initializes an implementation of the <see cref="T:System.Security.Cryptography.HashAlgorithm"/> class.
        /// </summary>
        public override void Initialize()
        {
            this.InternalInitialize();
        }

        private void InternalInitialize()
        {
            this._byteCount = 0;
            this._bufferOffset = 0;
            for (var i = 0; i < 4; i++)
            {
                this._buffer[i] = 0;
            }

            H1 = unchecked((int)0x67452301);
            H2 = unchecked((int)0xefcdab89);
            H3 = unchecked((int)0x98badcfe);
            H4 = unchecked((int)0x10325476);

            this._offset = 0;
            for (var i = 0; i != this._hashValue.Length; i++)
            {
                this._hashValue[i] = 0;
            }
        }

        private void Update(byte input)
        {
            this._buffer[this._bufferOffset++] = input;

            if (this._bufferOffset == this._buffer.Length)
            {
                this.ProcessWord(this._buffer, 0);
                this._bufferOffset = 0;
            }

            this._byteCount++;
        }

        private void ProcessWord(byte[] input, int inOff)
        {
            this._hashValue[this._offset++] = (input[inOff] & 0xff) | ((input[inOff + 1] & 0xff) << 8)
                | ((input[inOff + 2] & 0xff) << 16) | ((input[inOff + 3] & 0xff) << 24);

            if (this._offset == 16)
            {
                ProcessBlock();
            }
        }

        private void UnpackWord(int word, byte[] outBytes, int outOff)
        {
            outBytes[outOff] = (byte)word;
            outBytes[outOff + 1] = (byte)((uint)word >> 8);
            outBytes[outOff + 2] = (byte)((uint)word >> 16);
            outBytes[outOff + 3] = (byte)((uint)word >> 24);
        }

        //
        // round 1 left rotates
        //
        private const int S11 = 7;
        private const int S12 = 12;
        private const int S13 = 17;
        private const int S14 = 22;

        //
        // round 2 left rotates
        //
        private const int S21 = 5;
        private const int S22 = 9;
        private const int S23 = 14;
        private const int S24 = 20;

        //
        // round 3 left rotates
        //
        private const int S31 = 4;
        private const int S32 = 11;
        private const int S33 = 16;
        private const int S34 = 23;

        //
        // round 4 left rotates
        //
        private const int S41 = 6;
        private const int S42 = 10;
        private const int S43 = 15;
        private const int S44 = 21;

        /*
        * rotate int x left n bits.
        */
        private static int RotateLeft(int x, int n)
        {
            return (x << n) | (int)((uint)x >> (32 - n));
        }

        /*
        * F, G, H and I are the basic MD5 functions.
        */
        private static int F(int u, int v, int w)
        {
            return (u & v) | (~u & w);
        }

        private static int G(int u, int v, int w)
        {
            return (u & w) | (v & ~w);
        }

        private static int H(int u, int v, int w)
        {
            return u ^ v ^ w;
        }

        private static int K(int u, int v, int w)
        {
            return v ^ (u | ~w);
        }

        private void ProcessBlock()
        {
            int a = H1;
            int b = H2;
            int c = H3;
            int d = H4;

            //
            // Round 1 - F cycle, 16 times.
            //
            a = RotateLeft((a + F(b, c, d) + this._hashValue[0] + unchecked((int)0xd76aa478)), S11) + b;
            d = RotateLeft((d + F(a, b, c) + this._hashValue[1] + unchecked((int)0xe8c7b756)), S12) + a;
            c = RotateLeft((c + F(d, a, b) + this._hashValue[2] + unchecked((int)0x242070db)), S13) + d;
            b = RotateLeft((b + F(c, d, a) + this._hashValue[3] + unchecked((int)0xc1bdceee)), S14) + c;
            a = RotateLeft((a + F(b, c, d) + this._hashValue[4] + unchecked((int)0xf57c0faf)), S11) + b;
            d = RotateLeft((d + F(a, b, c) + this._hashValue[5] + unchecked((int)0x4787c62a)), S12) + a;
            c = RotateLeft((c + F(d, a, b) + this._hashValue[6] + unchecked((int)0xa8304613)), S13) + d;
            b = RotateLeft((b + F(c, d, a) + this._hashValue[7] + unchecked((int)0xfd469501)), S14) + c;
            a = RotateLeft((a + F(b, c, d) + this._hashValue[8] + unchecked((int)0x698098d8)), S11) + b;
            d = RotateLeft((d + F(a, b, c) + this._hashValue[9] + unchecked((int)0x8b44f7af)), S12) + a;
            c = RotateLeft((c + F(d, a, b) + this._hashValue[10] + unchecked((int)0xffff5bb1)), S13) + d;
            b = RotateLeft((b + F(c, d, a) + this._hashValue[11] + unchecked((int)0x895cd7be)), S14) + c;
            a = RotateLeft((a + F(b, c, d) + this._hashValue[12] + unchecked((int)0x6b901122)), S11) + b;
            d = RotateLeft((d + F(a, b, c) + this._hashValue[13] + unchecked((int)0xfd987193)), S12) + a;
            c = RotateLeft((c + F(d, a, b) + this._hashValue[14] + unchecked((int)0xa679438e)), S13) + d;
            b = RotateLeft((b + F(c, d, a) + this._hashValue[15] + unchecked((int)0x49b40821)), S14) + c;

            //
            // Round 2 - G cycle, 16 times.
            //
            a = RotateLeft((a + G(b, c, d) + this._hashValue[1] + unchecked((int)0xf61e2562)), S21) + b;
            d = RotateLeft((d + G(a, b, c) + this._hashValue[6] + unchecked((int)0xc040b340)), S22) + a;
            c = RotateLeft((c + G(d, a, b) + this._hashValue[11] + unchecked((int)0x265e5a51)), S23) + d;
            b = RotateLeft((b + G(c, d, a) + this._hashValue[0] + unchecked((int)0xe9b6c7aa)), S24) + c;
            a = RotateLeft((a + G(b, c, d) + this._hashValue[5] + unchecked((int)0xd62f105d)), S21) + b;
            d = RotateLeft((d + G(a, b, c) + this._hashValue[10] + unchecked((int)0x02441453)), S22) + a;
            c = RotateLeft((c + G(d, a, b) + this._hashValue[15] + unchecked((int)0xd8a1e681)), S23) + d;
            b = RotateLeft((b + G(c, d, a) + this._hashValue[4] + unchecked((int)0xe7d3fbc8)), S24) + c;
            a = RotateLeft((a + G(b, c, d) + this._hashValue[9] + unchecked((int)0x21e1cde6)), S21) + b;
            d = RotateLeft((d + G(a, b, c) + this._hashValue[14] + unchecked((int)0xc33707d6)), S22) + a;
            c = RotateLeft((c + G(d, a, b) + this._hashValue[3] + unchecked((int)0xf4d50d87)), S23) + d;
            b = RotateLeft((b + G(c, d, a) + this._hashValue[8] + unchecked((int)0x455a14ed)), S24) + c;
            a = RotateLeft((a + G(b, c, d) + this._hashValue[13] + unchecked((int)0xa9e3e905)), S21) + b;
            d = RotateLeft((d + G(a, b, c) + this._hashValue[2] + unchecked((int)0xfcefa3f8)), S22) + a;
            c = RotateLeft((c + G(d, a, b) + this._hashValue[7] + unchecked((int)0x676f02d9)), S23) + d;
            b = RotateLeft((b + G(c, d, a) + this._hashValue[12] + unchecked((int)0x8d2a4c8a)), S24) + c;

            //
            // Round 3 - H cycle, 16 times.
            //
            a = RotateLeft((a + H(b, c, d) + this._hashValue[5] + unchecked((int)0xfffa3942)), S31) + b;
            d = RotateLeft((d + H(a, b, c) + this._hashValue[8] + unchecked((int)0x8771f681)), S32) + a;
            c = RotateLeft((c + H(d, a, b) + this._hashValue[11] + unchecked((int)0x6d9d6122)), S33) + d;
            b = RotateLeft((b + H(c, d, a) + this._hashValue[14] + unchecked((int)0xfde5380c)), S34) + c;
            a = RotateLeft((a + H(b, c, d) + this._hashValue[1] + unchecked((int)0xa4beea44)), S31) + b;
            d = RotateLeft((d + H(a, b, c) + this._hashValue[4] + unchecked((int)0x4bdecfa9)), S32) + a;
            c = RotateLeft((c + H(d, a, b) + this._hashValue[7] + unchecked((int)0xf6bb4b60)), S33) + d;
            b = RotateLeft((b + H(c, d, a) + this._hashValue[10] + unchecked((int)0xbebfbc70)), S34) + c;
            a = RotateLeft((a + H(b, c, d) + this._hashValue[13] + unchecked((int)0x289b7ec6)), S31) + b;
            d = RotateLeft((d + H(a, b, c) + this._hashValue[0] + unchecked((int)0xeaa127fa)), S32) + a;
            c = RotateLeft((c + H(d, a, b) + this._hashValue[3] + unchecked((int)0xd4ef3085)), S33) + d;
            b = RotateLeft((b + H(c, d, a) + this._hashValue[6] + unchecked((int)0x04881d05)), S34) + c;
            a = RotateLeft((a + H(b, c, d) + this._hashValue[9] + unchecked((int)0xd9d4d039)), S31) + b;
            d = RotateLeft((d + H(a, b, c) + this._hashValue[12] + unchecked((int)0xe6db99e5)), S32) + a;
            c = RotateLeft((c + H(d, a, b) + this._hashValue[15] + unchecked((int)0x1fa27cf8)), S33) + d;
            b = RotateLeft((b + H(c, d, a) + this._hashValue[2] + unchecked((int)0xc4ac5665)), S34) + c;

            //
            // Round 4 - K cycle, 16 times.
            //
            a = RotateLeft((a + K(b, c, d) + this._hashValue[0] + unchecked((int)0xf4292244)), S41) + b;
            d = RotateLeft((d + K(a, b, c) + this._hashValue[7] + unchecked((int)0x432aff97)), S42) + a;
            c = RotateLeft((c + K(d, a, b) + this._hashValue[14] + unchecked((int)0xab9423a7)), S43) + d;
            b = RotateLeft((b + K(c, d, a) + this._hashValue[5] + unchecked((int)0xfc93a039)), S44) + c;
            a = RotateLeft((a + K(b, c, d) + this._hashValue[12] + unchecked((int)0x655b59c3)), S41) + b;
            d = RotateLeft((d + K(a, b, c) + this._hashValue[3] + unchecked((int)0x8f0ccc92)), S42) + a;
            c = RotateLeft((c + K(d, a, b) + this._hashValue[10] + unchecked((int)0xffeff47d)), S43) + d;
            b = RotateLeft((b + K(c, d, a) + this._hashValue[1] + unchecked((int)0x85845dd1)), S44) + c;
            a = RotateLeft((a + K(b, c, d) + this._hashValue[8] + unchecked((int)0x6fa87e4f)), S41) + b;
            d = RotateLeft((d + K(a, b, c) + this._hashValue[15] + unchecked((int)0xfe2ce6e0)), S42) + a;
            c = RotateLeft((c + K(d, a, b) + this._hashValue[6] + unchecked((int)0xa3014314)), S43) + d;
            b = RotateLeft((b + K(c, d, a) + this._hashValue[13] + unchecked((int)0x4e0811a1)), S44) + c;
            a = RotateLeft((a + K(b, c, d) + this._hashValue[4] + unchecked((int)0xf7537e82)), S41) + b;
            d = RotateLeft((d + K(a, b, c) + this._hashValue[11] + unchecked((int)0xbd3af235)), S42) + a;
            c = RotateLeft((c + K(d, a, b) + this._hashValue[2] + unchecked((int)0x2ad7d2bb)), S43) + d;
            b = RotateLeft((b + K(c, d, a) + this._hashValue[9] + unchecked((int)0xeb86d391)), S44) + c;

            H1 += a;
            H2 += b;
            H3 += c;
            H4 += d;

            //
            // reset the offset and clean out the word buffer.
            //
            this._offset = 0;
            for (int i = 0; i != this._hashValue.Length; i++)
            {
                this._hashValue[i] = 0;
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Hashes\RIPEMD160Hash.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography
{
    /// <summary>
    /// 
    /// </summary>
    public sealed class RIPEMD160Hash : HashAlgorithm
    {
        private const int DIGEST_SIZE = 20;

        private readonly byte[] _buffer;
        private int _bufferOffset;
        private long _byteCount;
        private int _offset;
        private int H0, H1, H2, H3, H4; // IV's
        private readonly int[] X = new int[16];

        /// <summary>
        /// Gets the size, in bits, of the computed hash code.
        /// </summary>
        /// <returns>The size, in bits, of the computed hash code.</returns>
        public override int HashSize
        {
            get
            {
                return DIGEST_SIZE * 8;
            }
        }

        /// <summary>
        /// Gets the input block size.
        /// </summary>
        /// <returns>The input block size.</returns>
        public override int InputBlockSize
        {
            get
            {
                return 64;
            }
        }

        /// <summary>
        /// Gets the output block size.
        /// </summary>
        /// <returns>The output block size.</returns>
        public override int OutputBlockSize
        {
            get
            {
                return 64;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the current transform can be reused.
        /// </summary>
        /// <returns>Always true.</returns>
        public override bool CanReuseTransform
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Gets a value indicating whether multiple blocks can be transformed.
        /// </summary>
        /// <returns>true if multiple blocks can be transformed; otherwise, false.</returns>
        public override bool CanTransformMultipleBlocks
        {
            get
            {
                return true;
            }
        }

        protected override void HashCore(byte[] array, int ibStart, int cbSize)
        {
            //
            // fill the current word
            //
            while ((this._bufferOffset != 0) && (cbSize > 0))
            {
                this.Update(array[ibStart]);
                ibStart++;
                cbSize--;
            }

            //
            // process whole words.
            //
            while (cbSize > this._buffer.Length)
            {
                this.ProcessWord(array, ibStart);

                ibStart += this._buffer.Length;
                cbSize -= this._buffer.Length;
                this._byteCount += this._buffer.Length;
            }

            //
            // load in the remainder.
            //
            while (cbSize > 0)
            {
                this.Update(array[ibStart]);

                ibStart++;
                cbSize--;
            }
        }

        protected override byte[] HashFinal()
        {
            var output = new byte[DIGEST_SIZE];
            long bitLength = (this._byteCount << 3);

            //
            // add the pad bytes.
            //
            this.Update((byte)128);

            while (this._bufferOffset != 0)
                Update((byte)0);
            ProcessLength(bitLength);
            ProcessBlock();

            UnpackWord(H0, output, 0);
            UnpackWord(H1, output, 4);
            UnpackWord(H2, output, 8);
            UnpackWord(H3, output, 12);
            UnpackWord(H4, output, 16);

            this.InternalInitialize();

            return output;
        }

        /// <summary>
        /// Initializes an implementation of the <see cref="T:System.Security.Cryptography.HashAlgorithm" /> class.
        /// </summary>
        public override void Initialize()
        {
            this.InternalInitialize();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RIPEMD160Hash" /> class.
        /// </summary>
        public RIPEMD160Hash()
        {
            this._buffer = new byte[4];
            this.InternalInitialize();
        }

        private void ProcessWord(byte[] input, int inOff)
        {
            this.X[this._offset++] = (input[inOff] & 0xff) | ((input[inOff + 1] & 0xff) << 8)
                | ((input[inOff + 2] & 0xff) << 16) | ((input[inOff + 3] & 0xff) << 24);

            if (this._offset == 16)
            {
                ProcessBlock();
            }
        }

        private void ProcessLength(long bitLength)
        {
            if (this._offset > 14)
            {
                ProcessBlock();
            }

            this.X[14] = (int)(bitLength & 0xffffffff);
            this.X[15] = (int)((ulong)bitLength >> 32);
        }

        private void UnpackWord(int word, byte[] outBytes, int outOff)
        {
            outBytes[outOff] = (byte)word;
            outBytes[outOff + 1] = (byte)((uint)word >> 8);
            outBytes[outOff + 2] = (byte)((uint)word >> 16);
            outBytes[outOff + 3] = (byte)((uint)word >> 24);
        }

        private void Update(byte input)
        {
            this._buffer[this._bufferOffset++] = input;

            if (this._bufferOffset == this._buffer.Length)
            {
                ProcessWord(this._buffer, 0);
                this._bufferOffset = 0;
            }

            this._byteCount++;
        }

        /// <summary>
        /// Reset the chaining variables to the IV values.
        /// </summary>
        private void InternalInitialize()
        {
            this._byteCount = 0;
            this._bufferOffset = 0;
            for (int i = 0; i < _buffer.Length; i++)
            {
                this._buffer[i] = 0;
            }

            H0 = unchecked((int)0x67452301);
            H1 = unchecked((int)0xefcdab89);
            H2 = unchecked((int)0x98badcfe);
            H3 = unchecked((int)0x10325476);
            H4 = unchecked((int)0xc3d2e1f0);

            this._offset = 0;

            for (int i = 0; i != X.Length; i++)
            {
                this.X[i] = 0;
            }
        }

        private int RL(int x, int n)
        {
            return (x << n) | (int)((uint)x >> (32 - n));
        }

        /// <summary>
        /// Rounds 0-15
        /// </summary>
        /// <param name="x">The x.</param>
        /// <param name="y">The y.</param>
        /// <param name="z">The z.</param>
        /// <returns></returns>
        private int F1(int x, int y, int z)
        {
            return x ^ y ^ z;
        }

        /// <summary>
        /// Rounds 16-31
        /// </summary>
        /// <param name="x">The x.</param>
        /// <param name="y">The y.</param>
        /// <param name="z">The z.</param>
        /// <returns></returns>
        private int F2(int x, int y, int z)
        {
            return (x & y) | (~x & z);
        }

        /// <summary>
        /// ounds 32-47
        /// </summary>
        /// <param name="x">The x.</param>
        /// <param name="y">The y.</param>
        /// <param name="z">The z.</param>
        /// <returns></returns>
        private int F3(int x, int y, int z)
        {
            return (x | ~y) ^ z;
        }

        /// <summary>
        /// Rounds 48-63
        /// </summary>
        /// <param name="x">The x.</param>
        /// <param name="y">The y.</param>
        /// <param name="z">The z.</param>
        /// <returns></returns>
        private int F4(int x, int y, int z)
        {
            return (x & z) | (y & ~z);
        }

        /// <summary>
        /// ounds 64-79
        /// </summary>
        /// <param name="x">The x.</param>
        /// <param name="y">The y.</param>
        /// <param name="z">The z.</param>
        /// <returns></returns>
        private int F5(int x, int y, int z)
        {
            return x ^ (y | ~z);
        }

        private void ProcessBlock()
        {
            int a, aa;
            int b, bb;
            int c, cc;
            int d, dd;
            int e, ee;

            a = aa = H0;
            b = bb = H1;
            c = cc = H2;
            d = dd = H3;
            e = ee = H4;

            //
            // Rounds 1 - 16
            //
            // left
            a = RL(a + F1(b, c, d) + this.X[0], 11) + e; c = RL(c, 10);
            e = RL(e + F1(a, b, c) + this.X[1], 14) + d; b = RL(b, 10);
            d = RL(d + F1(e, a, b) + this.X[2], 15) + c; a = RL(a, 10);
            c = RL(c + F1(d, e, a) + this.X[3], 12) + b; e = RL(e, 10);
            b = RL(b + F1(c, d, e) + this.X[4], 5) + a; d = RL(d, 10);
            a = RL(a + F1(b, c, d) + this.X[5], 8) + e; c = RL(c, 10);
            e = RL(e + F1(a, b, c) + this.X[6], 7) + d; b = RL(b, 10);
            d = RL(d + F1(e, a, b) + this.X[7], 9) + c; a = RL(a, 10);
            c = RL(c + F1(d, e, a) + this.X[8], 11) + b; e = RL(e, 10);
            b = RL(b + F1(c, d, e) + this.X[9], 13) + a; d = RL(d, 10);
            a = RL(a + F1(b, c, d) + this.X[10], 14) + e; c = RL(c, 10);
            e = RL(e + F1(a, b, c) + this.X[11], 15) + d; b = RL(b, 10);
            d = RL(d + F1(e, a, b) + this.X[12], 6) + c; a = RL(a, 10);
            c = RL(c + F1(d, e, a) + this.X[13], 7) + b; e = RL(e, 10);
            b = RL(b + F1(c, d, e) + this.X[14], 9) + a; d = RL(d, 10);
            a = RL(a + F1(b, c, d) + this.X[15], 8) + e; c = RL(c, 10);

            // right
            aa = RL(aa + F5(bb, cc, dd) + this.X[5] + unchecked((int)0x50a28be6), 8) + ee; cc = RL(cc, 10);
            ee = RL(ee + F5(aa, bb, cc) + this.X[14] + unchecked((int)0x50a28be6), 9) + dd; bb = RL(bb, 10);
            dd = RL(dd + F5(ee, aa, bb) + this.X[7] + unchecked((int)0x50a28be6), 9) + cc; aa = RL(aa, 10);
            cc = RL(cc + F5(dd, ee, aa) + this.X[0] + unchecked((int)0x50a28be6), 11) + bb; ee = RL(ee, 10);
            bb = RL(bb + F5(cc, dd, ee) + this.X[9] + unchecked((int)0x50a28be6), 13) + aa; dd = RL(dd, 10);
            aa = RL(aa + F5(bb, cc, dd) + this.X[2] + unchecked((int)0x50a28be6), 15) + ee; cc = RL(cc, 10);
            ee = RL(ee + F5(aa, bb, cc) + this.X[11] + unchecked((int)0x50a28be6), 15) + dd; bb = RL(bb, 10);
            dd = RL(dd + F5(ee, aa, bb) + this.X[4] + unchecked((int)0x50a28be6), 5) + cc; aa = RL(aa, 10);
            cc = RL(cc + F5(dd, ee, aa) + this.X[13] + unchecked((int)0x50a28be6), 7) + bb; ee = RL(ee, 10);
            bb = RL(bb + F5(cc, dd, ee) + this.X[6] + unchecked((int)0x50a28be6), 7) + aa; dd = RL(dd, 10);
            aa = RL(aa + F5(bb, cc, dd) + this.X[15] + unchecked((int)0x50a28be6), 8) + ee; cc = RL(cc, 10);
            ee = RL(ee + F5(aa, bb, cc) + this.X[8] + unchecked((int)0x50a28be6), 11) + dd; bb = RL(bb, 10);
            dd = RL(dd + F5(ee, aa, bb) + this.X[1] + unchecked((int)0x50a28be6), 14) + cc; aa = RL(aa, 10);
            cc = RL(cc + F5(dd, ee, aa) + this.X[10] + unchecked((int)0x50a28be6), 14) + bb; ee = RL(ee, 10);
            bb = RL(bb + F5(cc, dd, ee) + this.X[3] + unchecked((int)0x50a28be6), 12) + aa; dd = RL(dd, 10);
            aa = RL(aa + F5(bb, cc, dd) + this.X[12] + unchecked((int)0x50a28be6), 6) + ee; cc = RL(cc, 10);

            //
            // Rounds 16-31
            //
            // left
            e = RL(e + F2(a, b, c) + this.X[7] + unchecked((int)0x5a827999), 7) + d; b = RL(b, 10);
            d = RL(d + F2(e, a, b) + this.X[4] + unchecked((int)0x5a827999), 6) + c; a = RL(a, 10);
            c = RL(c + F2(d, e, a) + this.X[13] + unchecked((int)0x5a827999), 8) + b; e = RL(e, 10);
            b = RL(b + F2(c, d, e) + this.X[1] + unchecked((int)0x5a827999), 13) + a; d = RL(d, 10);
            a = RL(a + F2(b, c, d) + this.X[10] + unchecked((int)0x5a827999), 11) + e; c = RL(c, 10);
            e = RL(e + F2(a, b, c) + this.X[6] + unchecked((int)0x5a827999), 9) + d; b = RL(b, 10);
            d = RL(d + F2(e, a, b) + this.X[15] + unchecked((int)0x5a827999), 7) + c; a = RL(a, 10);
            c = RL(c + F2(d, e, a) + this.X[3] + unchecked((int)0x5a827999), 15) + b; e = RL(e, 10);
            b = RL(b + F2(c, d, e) + this.X[12] + unchecked((int)0x5a827999), 7) + a; d = RL(d, 10);
            a = RL(a + F2(b, c, d) + this.X[0] + unchecked((int)0x5a827999), 12) + e; c = RL(c, 10);
            e = RL(e + F2(a, b, c) + this.X[9] + unchecked((int)0x5a827999), 15) + d; b = RL(b, 10);
            d = RL(d + F2(e, a, b) + this.X[5] + unchecked((int)0x5a827999), 9) + c; a = RL(a, 10);
            c = RL(c + F2(d, e, a) + this.X[2] + unchecked((int)0x5a827999), 11) + b; e = RL(e, 10);
            b = RL(b + F2(c, d, e) + this.X[14] + unchecked((int)0x5a827999), 7) + a; d = RL(d, 10);
            a = RL(a + F2(b, c, d) + this.X[11] + unchecked((int)0x5a827999), 13) + e; c = RL(c, 10);
            e = RL(e + F2(a, b, c) + this.X[8] + unchecked((int)0x5a827999), 12) + d; b = RL(b, 10);

            // right
            ee = RL(ee + F4(aa, bb, cc) + this.X[6] + unchecked((int)0x5c4dd124), 9) + dd; bb = RL(bb, 10);
            dd = RL(dd + F4(ee, aa, bb) + this.X[11] + unchecked((int)0x5c4dd124), 13) + cc; aa = RL(aa, 10);
            cc = RL(cc + F4(dd, ee, aa) + this.X[3] + unchecked((int)0x5c4dd124), 15) + bb; ee = RL(ee, 10);
            bb = RL(bb + F4(cc, dd, ee) + this.X[7] + unchecked((int)0x5c4dd124), 7) + aa; dd = RL(dd, 10);
            aa = RL(aa + F4(bb, cc, dd) + this.X[0] + unchecked((int)0x5c4dd124), 12) + ee; cc = RL(cc, 10);
            ee = RL(ee + F4(aa, bb, cc) + this.X[13] + unchecked((int)0x5c4dd124), 8) + dd; bb = RL(bb, 10);
            dd = RL(dd + F4(ee, aa, bb) + this.X[5] + unchecked((int)0x5c4dd124), 9) + cc; aa = RL(aa, 10);
            cc = RL(cc + F4(dd, ee, aa) + this.X[10] + unchecked((int)0x5c4dd124), 11) + bb; ee = RL(ee, 10);
            bb = RL(bb + F4(cc, dd, ee) + this.X[14] + unchecked((int)0x5c4dd124), 7) + aa; dd = RL(dd, 10);
            aa = RL(aa + F4(bb, cc, dd) + this.X[15] + unchecked((int)0x5c4dd124), 7) + ee; cc = RL(cc, 10);
            ee = RL(ee + F4(aa, bb, cc) + this.X[8] + unchecked((int)0x5c4dd124), 12) + dd; bb = RL(bb, 10);
            dd = RL(dd + F4(ee, aa, bb) + this.X[12] + unchecked((int)0x5c4dd124), 7) + cc; aa = RL(aa, 10);
            cc = RL(cc + F4(dd, ee, aa) + this.X[4] + unchecked((int)0x5c4dd124), 6) + bb; ee = RL(ee, 10);
            bb = RL(bb + F4(cc, dd, ee) + this.X[9] + unchecked((int)0x5c4dd124), 15) + aa; dd = RL(dd, 10);
            aa = RL(aa + F4(bb, cc, dd) + this.X[1] + unchecked((int)0x5c4dd124), 13) + ee; cc = RL(cc, 10);
            ee = RL(ee + F4(aa, bb, cc) + this.X[2] + unchecked((int)0x5c4dd124), 11) + dd; bb = RL(bb, 10);

            //
            // Rounds 32-47
            //
            // left
            d = RL(d + F3(e, a, b) + this.X[3] + unchecked((int)0x6ed9eba1), 11) + c; a = RL(a, 10);
            c = RL(c + F3(d, e, a) + this.X[10] + unchecked((int)0x6ed9eba1), 13) + b; e = RL(e, 10);
            b = RL(b + F3(c, d, e) + this.X[14] + unchecked((int)0x6ed9eba1), 6) + a; d = RL(d, 10);
            a = RL(a + F3(b, c, d) + this.X[4] + unchecked((int)0x6ed9eba1), 7) + e; c = RL(c, 10);
            e = RL(e + F3(a, b, c) + this.X[9] + unchecked((int)0x6ed9eba1), 14) + d; b = RL(b, 10);
            d = RL(d + F3(e, a, b) + this.X[15] + unchecked((int)0x6ed9eba1), 9) + c; a = RL(a, 10);
            c = RL(c + F3(d, e, a) + this.X[8] + unchecked((int)0x6ed9eba1), 13) + b; e = RL(e, 10);
            b = RL(b + F3(c, d, e) + this.X[1] + unchecked((int)0x6ed9eba1), 15) + a; d = RL(d, 10);
            a = RL(a + F3(b, c, d) + this.X[2] + unchecked((int)0x6ed9eba1), 14) + e; c = RL(c, 10);
            e = RL(e + F3(a, b, c) + this.X[7] + unchecked((int)0x6ed9eba1), 8) + d; b = RL(b, 10);
            d = RL(d + F3(e, a, b) + this.X[0] + unchecked((int)0x6ed9eba1), 13) + c; a = RL(a, 10);
            c = RL(c + F3(d, e, a) + this.X[6] + unchecked((int)0x6ed9eba1), 6) + b; e = RL(e, 10);
            b = RL(b + F3(c, d, e) + this.X[13] + unchecked((int)0x6ed9eba1), 5) + a; d = RL(d, 10);
            a = RL(a + F3(b, c, d) + this.X[11] + unchecked((int)0x6ed9eba1), 12) + e; c = RL(c, 10);
            e = RL(e + F3(a, b, c) + this.X[5] + unchecked((int)0x6ed9eba1), 7) + d; b = RL(b, 10);
            d = RL(d + F3(e, a, b) + this.X[12] + unchecked((int)0x6ed9eba1), 5) + c; a = RL(a, 10);

            // right
            dd = RL(dd + F3(ee, aa, bb) + this.X[15] + unchecked((int)0x6d703ef3), 9) + cc; aa = RL(aa, 10);
            cc = RL(cc + F3(dd, ee, aa) + this.X[5] + unchecked((int)0x6d703ef3), 7) + bb; ee = RL(ee, 10);
            bb = RL(bb + F3(cc, dd, ee) + this.X[1] + unchecked((int)0x6d703ef3), 15) + aa; dd = RL(dd, 10);
            aa = RL(aa + F3(bb, cc, dd) + this.X[3] + unchecked((int)0x6d703ef3), 11) + ee; cc = RL(cc, 10);
            ee = RL(ee + F3(aa, bb, cc) + this.X[7] + unchecked((int)0x6d703ef3), 8) + dd; bb = RL(bb, 10);
            dd = RL(dd + F3(ee, aa, bb) + this.X[14] + unchecked((int)0x6d703ef3), 6) + cc; aa = RL(aa, 10);
            cc = RL(cc + F3(dd, ee, aa) + this.X[6] + unchecked((int)0x6d703ef3), 6) + bb; ee = RL(ee, 10);
            bb = RL(bb + F3(cc, dd, ee) + this.X[9] + unchecked((int)0x6d703ef3), 14) + aa; dd = RL(dd, 10);
            aa = RL(aa + F3(bb, cc, dd) + this.X[11] + unchecked((int)0x6d703ef3), 12) + ee; cc = RL(cc, 10);
            ee = RL(ee + F3(aa, bb, cc) + this.X[8] + unchecked((int)0x6d703ef3), 13) + dd; bb = RL(bb, 10);
            dd = RL(dd + F3(ee, aa, bb) + this.X[12] + unchecked((int)0x6d703ef3), 5) + cc; aa = RL(aa, 10);
            cc = RL(cc + F3(dd, ee, aa) + this.X[2] + unchecked((int)0x6d703ef3), 14) + bb; ee = RL(ee, 10);
            bb = RL(bb + F3(cc, dd, ee) + this.X[10] + unchecked((int)0x6d703ef3), 13) + aa; dd = RL(dd, 10);
            aa = RL(aa + F3(bb, cc, dd) + this.X[0] + unchecked((int)0x6d703ef3), 13) + ee; cc = RL(cc, 10);
            ee = RL(ee + F3(aa, bb, cc) + this.X[4] + unchecked((int)0x6d703ef3), 7) + dd; bb = RL(bb, 10);
            dd = RL(dd + F3(ee, aa, bb) + this.X[13] + unchecked((int)0x6d703ef3), 5) + cc; aa = RL(aa, 10);

            //
            // Rounds 48-63
            //
            // left
            c = RL(c + F4(d, e, a) + this.X[1] + unchecked((int)0x8f1bbcdc), 11) + b; e = RL(e, 10);
            b = RL(b + F4(c, d, e) + this.X[9] + unchecked((int)0x8f1bbcdc), 12) + a; d = RL(d, 10);
            a = RL(a + F4(b, c, d) + this.X[11] + unchecked((int)0x8f1bbcdc), 14) + e; c = RL(c, 10);
            e = RL(e + F4(a, b, c) + this.X[10] + unchecked((int)0x8f1bbcdc), 15) + d; b = RL(b, 10);
            d = RL(d + F4(e, a, b) + this.X[0] + unchecked((int)0x8f1bbcdc), 14) + c; a = RL(a, 10);
            c = RL(c + F4(d, e, a) + this.X[8] + unchecked((int)0x8f1bbcdc), 15) + b; e = RL(e, 10);
            b = RL(b + F4(c, d, e) + this.X[12] + unchecked((int)0x8f1bbcdc), 9) + a; d = RL(d, 10);
            a = RL(a + F4(b, c, d) + this.X[4] + unchecked((int)0x8f1bbcdc), 8) + e; c = RL(c, 10);
            e = RL(e + F4(a, b, c) + this.X[13] + unchecked((int)0x8f1bbcdc), 9) + d; b = RL(b, 10);
            d = RL(d + F4(e, a, b) + this.X[3] + unchecked((int)0x8f1bbcdc), 14) + c; a = RL(a, 10);
            c = RL(c + F4(d, e, a) + this.X[7] + unchecked((int)0x8f1bbcdc), 5) + b; e = RL(e, 10);
            b = RL(b + F4(c, d, e) + this.X[15] + unchecked((int)0x8f1bbcdc), 6) + a; d = RL(d, 10);
            a = RL(a + F4(b, c, d) + this.X[14] + unchecked((int)0x8f1bbcdc), 8) + e; c = RL(c, 10);
            e = RL(e + F4(a, b, c) + this.X[5] + unchecked((int)0x8f1bbcdc), 6) + d; b = RL(b, 10);
            d = RL(d + F4(e, a, b) + this.X[6] + unchecked((int)0x8f1bbcdc), 5) + c; a = RL(a, 10);
            c = RL(c + F4(d, e, a) + this.X[2] + unchecked((int)0x8f1bbcdc), 12) + b; e = RL(e, 10);

            // right
            cc = RL(cc + F2(dd, ee, aa) + this.X[8] + unchecked((int)0x7a6d76e9), 15) + bb; ee = RL(ee, 10);
            bb = RL(bb + F2(cc, dd, ee) + this.X[6] + unchecked((int)0x7a6d76e9), 5) + aa; dd = RL(dd, 10);
            aa = RL(aa + F2(bb, cc, dd) + this.X[4] + unchecked((int)0x7a6d76e9), 8) + ee; cc = RL(cc, 10);
            ee = RL(ee + F2(aa, bb, cc) + this.X[1] + unchecked((int)0x7a6d76e9), 11) + dd; bb = RL(bb, 10);
            dd = RL(dd + F2(ee, aa, bb) + this.X[3] + unchecked((int)0x7a6d76e9), 14) + cc; aa = RL(aa, 10);
            cc = RL(cc + F2(dd, ee, aa) + this.X[11] + unchecked((int)0x7a6d76e9), 14) + bb; ee = RL(ee, 10);
            bb = RL(bb + F2(cc, dd, ee) + this.X[15] + unchecked((int)0x7a6d76e9), 6) + aa; dd = RL(dd, 10);
            aa = RL(aa + F2(bb, cc, dd) + this.X[0] + unchecked((int)0x7a6d76e9), 14) + ee; cc = RL(cc, 10);
            ee = RL(ee + F2(aa, bb, cc) + this.X[5] + unchecked((int)0x7a6d76e9), 6) + dd; bb = RL(bb, 10);
            dd = RL(dd + F2(ee, aa, bb) + this.X[12] + unchecked((int)0x7a6d76e9), 9) + cc; aa = RL(aa, 10);
            cc = RL(cc + F2(dd, ee, aa) + this.X[2] + unchecked((int)0x7a6d76e9), 12) + bb; ee = RL(ee, 10);
            bb = RL(bb + F2(cc, dd, ee) + this.X[13] + unchecked((int)0x7a6d76e9), 9) + aa; dd = RL(dd, 10);
            aa = RL(aa + F2(bb, cc, dd) + this.X[9] + unchecked((int)0x7a6d76e9), 12) + ee; cc = RL(cc, 10);
            ee = RL(ee + F2(aa, bb, cc) + this.X[7] + unchecked((int)0x7a6d76e9), 5) + dd; bb = RL(bb, 10);
            dd = RL(dd + F2(ee, aa, bb) + this.X[10] + unchecked((int)0x7a6d76e9), 15) + cc; aa = RL(aa, 10);
            cc = RL(cc + F2(dd, ee, aa) + this.X[14] + unchecked((int)0x7a6d76e9), 8) + bb; ee = RL(ee, 10);

            //
            // Rounds 64-79
            //
            // left
            b = RL(b + F5(c, d, e) + this.X[4] + unchecked((int)0xa953fd4e), 9) + a; d = RL(d, 10);
            a = RL(a + F5(b, c, d) + this.X[0] + unchecked((int)0xa953fd4e), 15) + e; c = RL(c, 10);
            e = RL(e + F5(a, b, c) + this.X[5] + unchecked((int)0xa953fd4e), 5) + d; b = RL(b, 10);
            d = RL(d + F5(e, a, b) + this.X[9] + unchecked((int)0xa953fd4e), 11) + c; a = RL(a, 10);
            c = RL(c + F5(d, e, a) + this.X[7] + unchecked((int)0xa953fd4e), 6) + b; e = RL(e, 10);
            b = RL(b + F5(c, d, e) + this.X[12] + unchecked((int)0xa953fd4e), 8) + a; d = RL(d, 10);
            a = RL(a + F5(b, c, d) + this.X[2] + unchecked((int)0xa953fd4e), 13) + e; c = RL(c, 10);
            e = RL(e + F5(a, b, c) + this.X[10] + unchecked((int)0xa953fd4e), 12) + d; b = RL(b, 10);
            d = RL(d + F5(e, a, b) + this.X[14] + unchecked((int)0xa953fd4e), 5) + c; a = RL(a, 10);
            c = RL(c + F5(d, e, a) + this.X[1] + unchecked((int)0xa953fd4e), 12) + b; e = RL(e, 10);
            b = RL(b + F5(c, d, e) + this.X[3] + unchecked((int)0xa953fd4e), 13) + a; d = RL(d, 10);
            a = RL(a + F5(b, c, d) + this.X[8] + unchecked((int)0xa953fd4e), 14) + e; c = RL(c, 10);
            e = RL(e + F5(a, b, c) + this.X[11] + unchecked((int)0xa953fd4e), 11) + d; b = RL(b, 10);
            d = RL(d + F5(e, a, b) + this.X[6] + unchecked((int)0xa953fd4e), 8) + c; a = RL(a, 10);
            c = RL(c + F5(d, e, a) + this.X[15] + unchecked((int)0xa953fd4e), 5) + b; e = RL(e, 10);
            b = RL(b + F5(c, d, e) + this.X[13] + unchecked((int)0xa953fd4e), 6) + a; d = RL(d, 10);

            // right
            bb = RL(bb + F1(cc, dd, ee) + this.X[12], 8) + aa; dd = RL(dd, 10);
            aa = RL(aa + F1(bb, cc, dd) + this.X[15], 5) + ee; cc = RL(cc, 10);
            ee = RL(ee + F1(aa, bb, cc) + this.X[10], 12) + dd; bb = RL(bb, 10);
            dd = RL(dd + F1(ee, aa, bb) + this.X[4], 9) + cc; aa = RL(aa, 10);
            cc = RL(cc + F1(dd, ee, aa) + this.X[1], 12) + bb; ee = RL(ee, 10);
            bb = RL(bb + F1(cc, dd, ee) + this.X[5], 5) + aa; dd = RL(dd, 10);
            aa = RL(aa + F1(bb, cc, dd) + this.X[8], 14) + ee; cc = RL(cc, 10);
            ee = RL(ee + F1(aa, bb, cc) + this.X[7], 6) + dd; bb = RL(bb, 10);
            dd = RL(dd + F1(ee, aa, bb) + this.X[6], 8) + cc; aa = RL(aa, 10);
            cc = RL(cc + F1(dd, ee, aa) + this.X[2], 13) + bb; ee = RL(ee, 10);
            bb = RL(bb + F1(cc, dd, ee) + this.X[13], 6) + aa; dd = RL(dd, 10);
            aa = RL(aa + F1(bb, cc, dd) + this.X[14], 5) + ee; cc = RL(cc, 10);
            ee = RL(ee + F1(aa, bb, cc) + this.X[0], 15) + dd; bb = RL(bb, 10);
            dd = RL(dd + F1(ee, aa, bb) + this.X[3], 13) + cc; aa = RL(aa, 10);
            cc = RL(cc + F1(dd, ee, aa) + this.X[9], 11) + bb; ee = RL(ee, 10);
            bb = RL(bb + F1(cc, dd, ee) + this.X[11], 11) + aa; dd = RL(dd, 10);

            dd += c + H1;
            H1 = H2 + d + ee;
            H2 = H3 + e + aa;
            H3 = H4 + a + bb;
            H4 = H0 + b + cc;
            H0 = dd;

            //
            // reset the offset and clean out the word buffer.
            //
            this._offset = 0;
            for (int i = 0; i < X.Length; i++)
            {
                this.X[i] = 0;
            }
        }
    }
}
#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Hashes\SHA1Hash.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography
{
	/// <summary>
	/// SHA1 algorithm implementation
	/// </summary>
	public sealed class SHA1Hash : HashAlgorithm
	{
		private const int DIGEST_SIZE = 20;

		private const uint Y1 = 0x5a827999;

		private const uint Y2 = 0x6ed9eba1;

		private const uint Y3 = 0x8f1bbcdc;

		private const uint Y4 = 0xca62c1d6;

		private uint H1, H2, H3, H4, H5;
		
		private readonly uint[] _hashValue = new uint[80];
		
		private int _offset;

		private readonly byte[] _buffer;

		private int _bufferOffset;

		private long _byteCount;

		/// <summary>
		/// Gets the size, in bits, of the computed hash code.
		/// </summary>
		/// <returns>The size, in bits, of the computed hash code.</returns>
		public override int HashSize
		{
			get
			{
				return DIGEST_SIZE * 8;
			}
		}

		/// <summary>
		/// Gets the input block size.
		/// </summary>
		/// <returns>The input block size.</returns>
		public override int InputBlockSize
		{
			get
			{
				return 64;
			}
		}

		/// <summary>
		/// Gets the output block size.
		/// </summary>
		/// <returns>The output block size.</returns>
		public override int OutputBlockSize
		{
			get
			{
				return 64;
			}
		}

		/// <summary>
		/// Gets a value indicating whether the current transform can be reused.
		/// </summary>
		/// <returns>Always true.</returns>
		public override bool CanReuseTransform
		{
			get
			{
				return true;
			}
		}

		/// <summary>
		/// Gets a value indicating whether multiple blocks can be transformed.
		/// </summary>
		/// <returns>true if multiple blocks can be transformed; otherwise, false.</returns>
		public override bool CanTransformMultipleBlocks
		{
			get
			{
				return true;
			}
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="SHA1Hash"/> class.
		/// </summary>
		public SHA1Hash()
		{
			this._buffer = new byte[4];
            this.InternalInitialize();
        }

		/// <summary>
		/// Routes data written to the object into the hash algorithm for computing the hash.
		/// </summary>
		/// <param name="array">The input to compute the hash code for.</param>
		/// <param name="ibStart">The offset into the byte array from which to begin using data.</param>
		/// <param name="cbSize">The number of bytes in the byte array to use as data.</param>
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			//  Fill the current word
			while ((this._bufferOffset != 0) && (cbSize > 0))
			{
				this.Update(array[ibStart]);
				ibStart++;
				cbSize--;
			}

			//  Process whole words.
			while (cbSize > this._buffer.Length)
			{
				this.ProcessWord(array, ibStart);

				ibStart += this._buffer.Length;
				cbSize -= this._buffer.Length;
				this._byteCount += this._buffer.Length;
			}

			//  Load in the remainder.
			while (cbSize > 0)
			{
				this.Update(array[ibStart]);

				ibStart++;
				cbSize--;
			}
		}

		/// <summary>
		/// Finalizes the hash computation after the last data is processed by the cryptographic stream object.
		/// </summary>
		/// <returns>
		/// The computed hash code.
		/// </returns>
		protected override byte[] HashFinal()
		{
			var output = new byte[DIGEST_SIZE];
			long bitLength = (this._byteCount << 3);

			//
			// add the pad bytes.
			//
			this.Update((byte)128);

			while (this._bufferOffset != 0) 
				this.Update((byte)0);

			if (this._offset > 14)
			{
				this.ProcessBlock();
			}

			this._hashValue[14] = (uint)((ulong)bitLength >> 32);
            this._hashValue[15] = (uint)((ulong)bitLength);


			this.ProcessBlock();

            UInt32ToBigEndian(H1, output, 0);
            UInt32ToBigEndian(H2, output, 4);
            UInt32ToBigEndian(H3, output, 8);
            UInt32ToBigEndian(H4, output, 12);
            UInt32ToBigEndian(H5, output, 16);

            this.Initialize();

			return output;
		}

		/// <summary>
		/// Initializes an implementation of the <see cref="T:System.Security.Cryptography.HashAlgorithm"/> class.
		/// </summary>
		public override void Initialize()
		{
            this.InternalInitialize();
		}

        private void InternalInitialize()
        {
            this._byteCount = 0;
            this._bufferOffset = 0;
            for (var i = 0; i < 4; i++)
            {
                this._buffer[i] = 0;
            }

            H1 = 0x67452301;
            H2 = 0xefcdab89;
            H3 = 0x98badcfe;
            H4 = 0x10325476;
            H5 = 0xc3d2e1f0;

            this._offset = 0;
            for (var i = 0; i != this._hashValue.Length; i++)
            {
                this._hashValue[i] = 0;
            }
        }

		private void Update(byte input)
		{
			this._buffer[this._bufferOffset++] = input;

			if (this._bufferOffset == this._buffer.Length)
			{
				this.ProcessWord(this._buffer, 0);
				this._bufferOffset = 0;
			}

			this._byteCount++;
		}

		private void ProcessWord(byte[] input, int inOff)
		{
            this._hashValue[this._offset] = BigEndianToUInt32(input, inOff);

			if (++this._offset == 16)
			{
				this.ProcessBlock();
			}
		}

		private static uint F(uint u, uint v, uint w)
		{
			return (u & v) | (~u & w);
		}

		private static uint H(uint u, uint v, uint w)
		{
			return u ^ v ^ w;
		}

		private static uint G(uint u, uint v, uint w)
		{
			return (u & v) | (u & w) | (v & w);
		}

		private void ProcessBlock()
		{
			//
			// expand 16 word block into 80 word block.
			//
			for (int i = 16; i < 80; i++)
			{
				uint t = _hashValue[i - 3] ^ _hashValue[i - 8] ^ _hashValue[i - 14] ^ _hashValue[i - 16];
				_hashValue[i] = t << 1 | t >> 31;
			}

			//
			// set up working variables.
			//
			uint A = H1;
			uint B = H2;
			uint C = H3;
			uint D = H4;
			uint E = H5;

			//
			// round 1
			//
			int idx = 0;

            // E = rotateLeft(A, 5) + F(B, C, D) + E + X[idx++] + Y1
            // B = rotateLeft(B, 30)
            E += (A << 5 | (A >> 27)) + F(B, C, D) + _hashValue[idx++] + Y1;
            B = B << 30 | (B >> 2);

            D += (E << 5 | (E >> 27)) + F(A, B, C) + _hashValue[idx++] + Y1;
            A = A << 30 | (A >> 2);

            C += (D << 5 | (D >> 27)) + F(E, A, B) + _hashValue[idx++] + Y1;
            E = E << 30 | (E >> 2);

            B += (C << 5 | (C >> 27)) + F(D, E, A) + _hashValue[idx++] + Y1;
            D = D << 30 | (D >> 2);

            A += (B << 5 | (B >> 27)) + F(C, D, E) + _hashValue[idx++] + Y1;
            C = C << 30 | (C >> 2);
            // E = rotateLeft(A, 5) + F(B, C, D) + E + X[idx++] + Y1
            // B = rotateLeft(B, 30)
            E += (A << 5 | (A >> 27)) + F(B, C, D) + _hashValue[idx++] + Y1;
            B = B << 30 | (B >> 2);

            D += (E << 5 | (E >> 27)) + F(A, B, C) + _hashValue[idx++] + Y1;
            A = A << 30 | (A >> 2);

            C += (D << 5 | (D >> 27)) + F(E, A, B) + _hashValue[idx++] + Y1;
            E = E << 30 | (E >> 2);

            B += (C << 5 | (C >> 27)) + F(D, E, A) + _hashValue[idx++] + Y1;
            D = D << 30 | (D >> 2);

            A += (B << 5 | (B >> 27)) + F(C, D, E) + _hashValue[idx++] + Y1;
            C = C << 30 | (C >> 2);
            // E = rotateLeft(A, 5) + F(B, C, D) + E + X[idx++] + Y1
            // B = rotateLeft(B, 30)
            E += (A << 5 | (A >> 27)) + F(B, C, D) + _hashValue[idx++] + Y1;
            B = B << 30 | (B >> 2);

            D += (E << 5 | (E >> 27)) + F(A, B, C) + _hashValue[idx++] + Y1;
            A = A << 30 | (A >> 2);

            C += (D << 5 | (D >> 27)) + F(E, A, B) + _hashValue[idx++] + Y1;
            E = E << 30 | (E >> 2);

            B += (C << 5 | (C >> 27)) + F(D, E, A) + _hashValue[idx++] + Y1;
            D = D << 30 | (D >> 2);

            A += (B << 5 | (B >> 27)) + F(C, D, E) + _hashValue[idx++] + Y1;
            C = C << 30 | (C >> 2);
            // E = rotateLeft(A, 5) + F(B, C, D) + E + X[idx++] + Y1
            // B = rotateLeft(B, 30)
            E += (A << 5 | (A >> 27)) + F(B, C, D) + _hashValue[idx++] + Y1;
            B = B << 30 | (B >> 2);

            D += (E << 5 | (E >> 27)) + F(A, B, C) + _hashValue[idx++] + Y1;
            A = A << 30 | (A >> 2);

            C += (D << 5 | (D >> 27)) + F(E, A, B) + _hashValue[idx++] + Y1;
            E = E << 30 | (E >> 2);

            B += (C << 5 | (C >> 27)) + F(D, E, A) + _hashValue[idx++] + Y1;
            D = D << 30 | (D >> 2);

            A += (B << 5 | (B >> 27)) + F(C, D, E) + _hashValue[idx++] + Y1;
            C = C << 30 | (C >> 2);
			//
			// round 2
			//
            // E = rotateLeft(A, 5) + H(B, C, D) + E + X[idx++] + Y2
            // B = rotateLeft(B, 30)
            E += (A << 5 | (A >> 27)) + H(B, C, D) + _hashValue[idx++] + Y2;
            B = B << 30 | (B >> 2);

            D += (E << 5 | (E >> 27)) + H(A, B, C) + _hashValue[idx++] + Y2;
            A = A << 30 | (A >> 2);

            C += (D << 5 | (D >> 27)) + H(E, A, B) + _hashValue[idx++] + Y2;
            E = E << 30 | (E >> 2);

            B += (C << 5 | (C >> 27)) + H(D, E, A) + _hashValue[idx++] + Y2;
            D = D << 30 | (D >> 2);

            A += (B << 5 | (B >> 27)) + H(C, D, E) + _hashValue[idx++] + Y2;
            C = C << 30 | (C >> 2);
            // E = rotateLeft(A, 5) + H(B, C, D) + E + X[idx++] + Y2
            // B = rotateLeft(B, 30)
            E += (A << 5 | (A >> 27)) + H(B, C, D) + _hashValue[idx++] + Y2;
            B = B << 30 | (B >> 2);

            D += (E << 5 | (E >> 27)) + H(A, B, C) + _hashValue[idx++] + Y2;
            A = A << 30 | (A >> 2);

            C += (D << 5 | (D >> 27)) + H(E, A, B) + _hashValue[idx++] + Y2;
            E = E << 30 | (E >> 2);

            B += (C << 5 | (C >> 27)) + H(D, E, A) + _hashValue[idx++] + Y2;
            D = D << 30 | (D >> 2);

            A += (B << 5 | (B >> 27)) + H(C, D, E) + _hashValue[idx++] + Y2;
            C = C << 30 | (C >> 2);
            // E = rotateLeft(A, 5) + H(B, C, D) + E + X[idx++] + Y2
            // B = rotateLeft(B, 30)
            E += (A << 5 | (A >> 27)) + H(B, C, D) + _hashValue[idx++] + Y2;
            B = B << 30 | (B >> 2);

            D += (E << 5 | (E >> 27)) + H(A, B, C) + _hashValue[idx++] + Y2;
            A = A << 30 | (A >> 2);

            C += (D << 5 | (D >> 27)) + H(E, A, B) + _hashValue[idx++] + Y2;
            E = E << 30 | (E >> 2);

            B += (C << 5 | (C >> 27)) + H(D, E, A) + _hashValue[idx++] + Y2;
            D = D << 30 | (D >> 2);

            A += (B << 5 | (B >> 27)) + H(C, D, E) + _hashValue[idx++] + Y2;
            C = C << 30 | (C >> 2);
            // E = rotateLeft(A, 5) + H(B, C, D) + E + X[idx++] + Y2
            // B = rotateLeft(B, 30)
            E += (A << 5 | (A >> 27)) + H(B, C, D) + _hashValue[idx++] + Y2;
            B = B << 30 | (B >> 2);

            D += (E << 5 | (E >> 27)) + H(A, B, C) + _hashValue[idx++] + Y2;
            A = A << 30 | (A >> 2);

            C += (D << 5 | (D >> 27)) + H(E, A, B) + _hashValue[idx++] + Y2;
            E = E << 30 | (E >> 2);

            B += (C << 5 | (C >> 27)) + H(D, E, A) + _hashValue[idx++] + Y2;
            D = D << 30 | (D >> 2);

            A += (B << 5 | (B >> 27)) + H(C, D, E) + _hashValue[idx++] + Y2;
            C = C << 30 | (C >> 2);

			//
			// round 3
            // E = rotateLeft(A, 5) + G(B, C, D) + E + X[idx++] + Y3
            // B = rotateLeft(B, 30)
            E += (A << 5 | (A >> 27)) + G(B, C, D) + _hashValue[idx++] + Y3;
            B = B << 30 | (B >> 2);

            D += (E << 5 | (E >> 27)) + G(A, B, C) + _hashValue[idx++] + Y3;
            A = A << 30 | (A >> 2);

            C += (D << 5 | (D >> 27)) + G(E, A, B) + _hashValue[idx++] + Y3;
            E = E << 30 | (E >> 2);

            B += (C << 5 | (C >> 27)) + G(D, E, A) + _hashValue[idx++] + Y3;
            D = D << 30 | (D >> 2);

            A += (B << 5 | (B >> 27)) + G(C, D, E) + _hashValue[idx++] + Y3;
            C = C << 30 | (C >> 2);
            // E = rotateLeft(A, 5) + G(B, C, D) + E + X[idx++] + Y3
            // B = rotateLeft(B, 30)
            E += (A << 5 | (A >> 27)) + G(B, C, D) + _hashValue[idx++] + Y3;
            B = B << 30 | (B >> 2);

            D += (E << 5 | (E >> 27)) + G(A, B, C) + _hashValue[idx++] + Y3;
            A = A << 30 | (A >> 2);

            C += (D << 5 | (D >> 27)) + G(E, A, B) + _hashValue[idx++] + Y3;
            E = E << 30 | (E >> 2);

            B += (C << 5 | (C >> 27)) + G(D, E, A) + _hashValue[idx++] + Y3;
            D = D << 30 | (D >> 2);

            A += (B << 5 | (B >> 27)) + G(C, D, E) + _hashValue[idx++] + Y3;
            C = C << 30 | (C >> 2);
            // E = rotateLeft(A, 5) + G(B, C, D) + E + X[idx++] + Y3
            // B = rotateLeft(B, 30)
            E += (A << 5 | (A >> 27)) + G(B, C, D) + _hashValue[idx++] + Y3;
            B = B << 30 | (B >> 2);

            D += (E << 5 | (E >> 27)) + G(A, B, C) + _hashValue[idx++] + Y3;
            A = A << 30 | (A >> 2);

            C += (D << 5 | (D >> 27)) + G(E, A, B) + _hashValue[idx++] + Y3;
            E = E << 30 | (E >> 2);

            B += (C << 5 | (C >> 27)) + G(D, E, A) + _hashValue[idx++] + Y3;
            D = D << 30 | (D >> 2);

            A += (B << 5 | (B >> 27)) + G(C, D, E) + _hashValue[idx++] + Y3;
            C = C << 30 | (C >> 2);
            // E = rotateLeft(A, 5) + G(B, C, D) + E + X[idx++] + Y3
            // B = rotateLeft(B, 30)
            E += (A << 5 | (A >> 27)) + G(B, C, D) + _hashValue[idx++] + Y3;
            B = B << 30 | (B >> 2);

            D += (E << 5 | (E >> 27)) + G(A, B, C) + _hashValue[idx++] + Y3;
            A = A << 30 | (A >> 2);

            C += (D << 5 | (D >> 27)) + G(E, A, B) + _hashValue[idx++] + Y3;
            E = E << 30 | (E >> 2);

            B += (C << 5 | (C >> 27)) + G(D, E, A) + _hashValue[idx++] + Y3;
            D = D << 30 | (D >> 2);

            A += (B << 5 | (B >> 27)) + G(C, D, E) + _hashValue[idx++] + Y3;
            C = C << 30 | (C >> 2);

            //
			// round 4
			//
            // E = rotateLeft(A, 5) + H(B, C, D) + E + X[idx++] + Y4
            // B = rotateLeft(B, 30)
            E += (A << 5 | (A >> 27)) + H(B, C, D) + _hashValue[idx++] + Y4;
            B = B << 30 | (B >> 2);

            D += (E << 5 | (E >> 27)) + H(A, B, C) + _hashValue[idx++] + Y4;
            A = A << 30 | (A >> 2);

            C += (D << 5 | (D >> 27)) + H(E, A, B) + _hashValue[idx++] + Y4;
            E = E << 30 | (E >> 2);

            B += (C << 5 | (C >> 27)) + H(D, E, A) + _hashValue[idx++] + Y4;
            D = D << 30 | (D >> 2);

            A += (B << 5 | (B >> 27)) + H(C, D, E) + _hashValue[idx++] + Y4;
            C = C << 30 | (C >> 2);
            // E = rotateLeft(A, 5) + H(B, C, D) + E + X[idx++] + Y4
            // B = rotateLeft(B, 30)
            E += (A << 5 | (A >> 27)) + H(B, C, D) + _hashValue[idx++] + Y4;
            B = B << 30 | (B >> 2);

            D += (E << 5 | (E >> 27)) + H(A, B, C) + _hashValue[idx++] + Y4;
            A = A << 30 | (A >> 2);

            C += (D << 5 | (D >> 27)) + H(E, A, B) + _hashValue[idx++] + Y4;
            E = E << 30 | (E >> 2);

            B += (C << 5 | (C >> 27)) + H(D, E, A) + _hashValue[idx++] + Y4;
            D = D << 30 | (D >> 2);

            A += (B << 5 | (B >> 27)) + H(C, D, E) + _hashValue[idx++] + Y4;
            C = C << 30 | (C >> 2);
            // E = rotateLeft(A, 5) + H(B, C, D) + E + X[idx++] + Y4
            // B = rotateLeft(B, 30)
            E += (A << 5 | (A >> 27)) + H(B, C, D) + _hashValue[idx++] + Y4;
            B = B << 30 | (B >> 2);

            D += (E << 5 | (E >> 27)) + H(A, B, C) + _hashValue[idx++] + Y4;
            A = A << 30 | (A >> 2);

            C += (D << 5 | (D >> 27)) + H(E, A, B) + _hashValue[idx++] + Y4;
            E = E << 30 | (E >> 2);

            B += (C << 5 | (C >> 27)) + H(D, E, A) + _hashValue[idx++] + Y4;
            D = D << 30 | (D >> 2);

            A += (B << 5 | (B >> 27)) + H(C, D, E) + _hashValue[idx++] + Y4;
            C = C << 30 | (C >> 2);
            // E = rotateLeft(A, 5) + H(B, C, D) + E + X[idx++] + Y4
            // B = rotateLeft(B, 30)
            E += (A << 5 | (A >> 27)) + H(B, C, D) + _hashValue[idx++] + Y4;
            B = B << 30 | (B >> 2);

            D += (E << 5 | (E >> 27)) + H(A, B, C) + _hashValue[idx++] + Y4;
            A = A << 30 | (A >> 2);

            C += (D << 5 | (D >> 27)) + H(E, A, B) + _hashValue[idx++] + Y4;
            E = E << 30 | (E >> 2);

            B += (C << 5 | (C >> 27)) + H(D, E, A) + _hashValue[idx++] + Y4;
            D = D << 30 | (D >> 2);

            A += (B << 5 | (B >> 27)) + H(C, D, E) + _hashValue[idx++] + Y4;
            C = C << 30 | (C >> 2);

			H1 += A;
			H2 += B;
			H3 += C;
			H4 += D;
			H5 += E;

			//
			// reset start of the buffer.
			//
			this._offset = 0;
            for (int i = 0; i < this._hashValue.Length; i++)
            {
                this._hashValue[i] = 0;
            }
		}

        private static uint BigEndianToUInt32(byte[] bs, int off)
		{
			uint n = (uint)bs[off] << 24;
			n |= (uint)bs[++off] << 16;
			n |= (uint)bs[++off] << 8;
			n |= (uint)bs[++off];
			return n;
		}

        private static void UInt32ToBigEndian(uint n, byte[] bs, int off)
		{
			bs[off] = (byte)(n >> 24);
			bs[++off] = (byte)(n >> 16);
			bs[++off] = (byte)(n >> 8);
			bs[++off] = (byte)(n);
		}
	}
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Hashes\SHA256Hash.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography
{
	/// <summary>
	/// SHA256 algorithm implementation.
	/// </summary>
	public class SHA256Hash : HashAlgorithm
	{
		private const int DIGEST_SIZE = 32;

		private uint H1, H2, H3, H4, H5, H6, H7, H8;

		private readonly uint[] X = new uint[64];

		private int _offset;

		private readonly byte[] _buffer;

		private int _bufferOffset;

		private long _byteCount;

		/// <summary>
		/// Gets the size, in bits, of the computed hash code.
		/// </summary>
		/// <returns>The size, in bits, of the computed hash code.</returns>
		public override int HashSize
		{
			get
			{
				return DIGEST_SIZE * 8;
			}
		}

		/// <summary>
		/// Gets the input block size.
		/// </summary>
		/// <returns>The input block size.</returns>
		public override int InputBlockSize
		{
			get
			{
				return 64;
			}
		}

		/// <summary>
		/// Gets the output block size.
		/// </summary>
		/// <returns>The output block size.</returns>
		public override int OutputBlockSize
		{
			get
			{
				return 64;
			}
		}

		/// <summary>
		/// Gets a value indicating whether the current transform can be reused.
		/// </summary>
		/// <returns>Always true.</returns>
		public override bool CanReuseTransform
		{
			get
			{
				return true;
			}
		}

		/// <summary>
		/// Gets a value indicating whether multiple blocks can be transformed.
		/// </summary>
		/// <returns>true if multiple blocks can be transformed; otherwise, false.</returns>
		public override bool CanTransformMultipleBlocks
		{
			get
			{
				return true;
			}
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="SHA1"/> class.
		/// </summary>
		public SHA256Hash()
		{
			this._buffer = new byte[4];
            this.InternalInitialize();
		}

		/// <summary>
		/// Routes data written to the object into the hash algorithm for computing the hash.
		/// </summary>
		/// <param name="array">The input to compute the hash code for.</param>
		/// <param name="ibStart">The offset into the byte array from which to begin using data.</param>
		/// <param name="cbSize">The number of bytes in the byte array to use as data.</param>
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			//  Fill the current word
			while ((this._bufferOffset != 0) && (cbSize > 0))
			{
				this.Update(array[ibStart]);
				ibStart++;
				cbSize--;
			}

			//  Process whole words.
			while (cbSize > this._buffer.Length)
			{
				this.ProcessWord(array, ibStart);

				ibStart += this._buffer.Length;
				cbSize -= this._buffer.Length;
				this._byteCount += this._buffer.Length;
			}

			//  Load in the remainder.
			while (cbSize > 0)
			{
				this.Update(array[ibStart]);

				ibStart++;
				cbSize--;
			}
		}

		/// <summary>
		/// Finalizes the hash computation after the last data is processed by the cryptographic stream object.
		/// </summary>
		/// <returns>
		/// The computed hash code.
		/// </returns>
		protected override byte[] HashFinal()
		{
			var output = new byte[DIGEST_SIZE];
			long bitLength = (this._byteCount << 3);

			//
			// add the pad bytes.
			//
			this.Update((byte)128);

			while (this._bufferOffset != 0)
				this.Update((byte)0);

			if (this._offset > 14)
			{
				this.ProcessBlock();
			}

			X[14] = (uint)((ulong)bitLength >> 32);
			X[15] = (uint)((ulong)bitLength);


			this.ProcessBlock();

			UInt32_To_BE((uint)H1, output, 0);
			UInt32_To_BE((uint)H2, output, 0 + 4);
			UInt32_To_BE((uint)H3, output, 0 + 8);
			UInt32_To_BE((uint)H4, output, 0 + 12);
			UInt32_To_BE((uint)H5, output, 0 + 16);
			UInt32_To_BE((uint)H6, output, 0 + 20);
			UInt32_To_BE((uint)H7, output, 0 + 24);
			UInt32_To_BE((uint)H8, output, 0 + 28);

			this.Initialize();

			return output;
		}

		/// <summary>
		/// Initializes an implementation of the <see cref="T:System.Security.Cryptography.HashAlgorithm"/> class.
		/// </summary>
		public override void Initialize()
		{
            this.InternalInitialize();
		}

        private void InternalInitialize()
        {
            this._byteCount = 0;
            this._bufferOffset = 0;
            for (int i = 0; i < this._buffer.Length; i++)
            {
                this._buffer[i] = 0;
            }

            H1 = 0x6a09e667;
            H2 = 0xbb67ae85;
            H3 = 0x3c6ef372;
            H4 = 0xa54ff53a;
            H5 = 0x510e527f;
            H6 = 0x9b05688c;
            H7 = 0x1f83d9ab;
            H8 = 0x5be0cd19;

            this._offset = 0;
            for (int i = 0; i < this.X.Length; i++)
            {
                this.X[i] = 0;
            }
        }

		private void Update(byte input)
		{
			this._buffer[this._bufferOffset++] = input;

			if (this._bufferOffset == this._buffer.Length)
			{
				this.ProcessWord(this._buffer, 0);
				this._bufferOffset = 0;
			}

			this._byteCount++;
		}

		private static uint BE_To_UInt32(byte[] bs, int off)
		{
			uint n = (uint)bs[off] << 24;
			n |= (uint)bs[++off] << 16;
			n |= (uint)bs[++off] << 8;
			n |= (uint)bs[++off];
			return n;
		}

		private static void UInt32_To_BE(uint n, byte[] bs, int off)
		{
			bs[off] = (byte)(n >> 24);
			bs[++off] = (byte)(n >> 16);
			bs[++off] = (byte)(n >> 8);
			bs[++off] = (byte)(n);
		}

		private void ProcessWord(byte[] input, int inOff)
		{
			X[this._offset] = BE_To_UInt32(input, inOff);

			if (++this._offset == 16)
			{
				ProcessBlock();
			}
		}

		private void ProcessLength(long bitLength)
		{
			if (this._offset > 14)
			{
				ProcessBlock();
			}

			X[14] = (uint)((ulong)bitLength >> 32);
			X[15] = (uint)((ulong)bitLength);
		}

		private void ProcessBlock()
		{
			//
			// expand 16 word block into 64 word blocks.
			//
			for (int ti = 16; ti <= 63; ti++)
			{
				X[ti] = Theta1(X[ti - 2]) + X[ti - 7] + Theta0(X[ti - 15]) + X[ti - 16];
			}

			//
			// set up working variables.
			//
			uint a = H1;
			uint b = H2;
			uint c = H3;
			uint d = H4;
			uint e = H5;
			uint f = H6;
			uint g = H7;
			uint h = H8;

			int t = 0;
			for (int i = 0; i < 8; ++i)
			{
				// t = 8 * i
				h += Sum1Ch(e, f, g) + K[t] + X[t];
				d += h;
				h += Sum0Maj(a, b, c);
				++t;

				// t = 8 * i + 1
				g += Sum1Ch(d, e, f) + K[t] + X[t];
				c += g;
				g += Sum0Maj(h, a, b);
				++t;

				// t = 8 * i + 2
				f += Sum1Ch(c, d, e) + K[t] + X[t];
				b += f;
				f += Sum0Maj(g, h, a);
				++t;

				// t = 8 * i + 3
				e += Sum1Ch(b, c, d) + K[t] + X[t];
				a += e;
				e += Sum0Maj(f, g, h);
				++t;

				// t = 8 * i + 4
				d += Sum1Ch(a, b, c) + K[t] + X[t];
				h += d;
				d += Sum0Maj(e, f, g);
				++t;

				// t = 8 * i + 5
				c += Sum1Ch(h, a, b) + K[t] + X[t];
				g += c;
				c += Sum0Maj(d, e, f);
				++t;

				// t = 8 * i + 6
				b += Sum1Ch(g, h, a) + K[t] + X[t];
				f += b;
				b += Sum0Maj(c, d, e);
				++t;

				// t = 8 * i + 7
				a += Sum1Ch(f, g, h) + K[t] + X[t];
				e += a;
				a += Sum0Maj(b, c, d);
				++t;
			}

			H1 += a;
			H2 += b;
			H3 += c;
			H4 += d;
			H5 += e;
			H6 += f;
			H7 += g;
			H8 += h;

			//
			// reset the offset and clean out the word buffer.
			//
			this._offset = 0;
            for (int i = 0; i < this.X.Length; i++)
            {
                this.X[i] = 0;
            }
		}

		private static uint Sum1Ch(uint x, uint y, uint z)
		{
			//			return Sum1(x) + Ch(x, y, z);
			return (((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7)))
				+ ((x & y) ^ ((~x) & z));
		}

		private static uint Sum0Maj(uint x, uint y, uint z)
		{
			//			return Sum0(x) + Maj(x, y, z);
			return (((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10)))
				+ ((x & y) ^ (x & z) ^ (y & z));
		}

		private static uint Theta0(uint x)
		{
			return ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3);
		}

		private static uint Theta1(uint x)
		{
			return ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10);
		}

        /// <summary>
        /// The SHA-256 Constants (represent the first 32 bits of the fractional parts of the cube roots of the first sixty-four prime numbers)
        /// </summary>
		private static readonly uint[] K = {
			0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
			0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
			0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
			0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
			0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
			0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
			0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
			0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
			0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
			0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
			0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
			0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
			0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
			0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
			0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
			0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
		};
	}
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Hashes\SHA2HashBase.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Security.Cryptography
{
    /// <summary>
    /// SHA256 algorithm implementation.
    /// </summary>
    public abstract class SHA2HashBase : HashAlgorithm
    {
        protected ulong H1, H2, H3, H4, H5, H6, H7, H8;

        private readonly ulong[] X = new ulong[80];

        private int _offset;

        private readonly byte[] _buffer;

        private int _bufferOffset;

        private long _byteCount1;

        private long _byteCount2;

        /// <summary>
        /// Gets a value indicating whether the current transform can be reused.
        /// </summary>
        /// <returns>Always true.</returns>
        public override bool CanReuseTransform
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Gets a value indicating whether multiple blocks can be transformed.
        /// </summary>
        /// <returns>true if multiple blocks can be transformed; otherwise, false.</returns>
        public override bool CanTransformMultipleBlocks
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SHA512Hash" /> class.
        /// </summary>
        protected SHA2HashBase()
        {
            this._buffer = new byte[8];

            this.Initialize();
        }

        protected override void HashCore(byte[] array, int ibStart, int cbSize)
        {
            // Fill the current word
            while ((this._bufferOffset != 0) && (cbSize > 0))
            {
                this.Update(array[ibStart]);

                ibStart++;
                cbSize--;
            }

            // Process whole words.
            while (cbSize > this._buffer.Length)
            {
                ProcessWord(array, ibStart);

                ibStart += this._buffer.Length;
                cbSize -= this._buffer.Length;
                this._byteCount1 += this._buffer.Length;
            }

            // Load in the remainder.
            while (cbSize > 0)
            {
                this.Update(array[ibStart]);

                ibStart++;
                cbSize--;
            }
        }

        public override void Initialize()
        {
            this._byteCount1 = 0;
            this._byteCount2 = 0;

            this._bufferOffset = 0;
            for (int i = 0; i < this._buffer.Length; i++)
            {
                this._buffer[i] = 0;
            }

            this._offset = 0;
            for (int i = 0; i < this.X.Length; i++)
            {
                this.X[i] = 0;
            }
        }

        protected void Finish()
        {
            this.AdjustByteCounts();

            long lowBitLength = this._byteCount1 << 3;
            long hiBitLength = this._byteCount2;

            //
            // add the pad bytes.
            //
            this.Update((byte)128);

            while (this._bufferOffset != 0)
            {
                this.Update((byte)0);
            }

            this.ProcessLength(lowBitLength, hiBitLength);

            this.ProcessBlock();
        }

        private void Update(byte input)
        {
            this._buffer[_bufferOffset++] = input;

            if (this._bufferOffset == this._buffer.Length)
            {
                this.ProcessWord(this._buffer, 0);
                this._bufferOffset = 0;
            }

            this._byteCount1++;
        }

        private void ProcessWord(byte[] input, int inOff)
        {
            this.X[_offset] = SHA512Hash.BE_To_UInt64(input, inOff);

            if (++_offset == 16)
            {
                ProcessBlock();
            }
        }

        internal void ProcessLength(long lowW, long hiW)
        {
            if (_offset > 14)
            {
                this.ProcessBlock();
            }

            this.X[14] = (ulong)hiW;
            this.X[15] = (ulong)lowW;
        }

        private void ProcessBlock()
        {
            this.AdjustByteCounts();

            //
            // expand 16 word block into 80 word blocks.
            //
            for (int ti = 16; ti <= 79; ++ti)
            {
                X[ti] = Sigma1(X[ti - 2]) + X[ti - 7] + Sigma0(X[ti - 15]) + X[ti - 16];
            }

            //
            // set up working variables.
            //
            ulong a = H1;
            ulong b = H2;
            ulong c = H3;
            ulong d = H4;
            ulong e = H5;
            ulong f = H6;
            ulong g = H7;
            ulong h = H8;

            int t = 0;
            for (int i = 0; i < 10; i++)
            {
                // t = 8 * i
                h += Sum1(e) + Ch(e, f, g) + K[t] + X[t++];
                d += h;
                h += Sum0(a) + Maj(a, b, c);

                // t = 8 * i + 1
                g += Sum1(d) + Ch(d, e, f) + K[t] + X[t++];
                c += g;
                g += Sum0(h) + Maj(h, a, b);

                // t = 8 * i + 2
                f += Sum1(c) + Ch(c, d, e) + K[t] + X[t++];
                b += f;
                f += Sum0(g) + Maj(g, h, a);

                // t = 8 * i + 3
                e += Sum1(b) + Ch(b, c, d) + K[t] + X[t++];
                a += e;
                e += Sum0(f) + Maj(f, g, h);

                // t = 8 * i + 4
                d += Sum1(a) + Ch(a, b, c) + K[t] + X[t++];
                h += d;
                d += Sum0(e) + Maj(e, f, g);

                // t = 8 * i + 5
                c += Sum1(h) + Ch(h, a, b) + K[t] + X[t++];
                g += c;
                c += Sum0(d) + Maj(d, e, f);

                // t = 8 * i + 6
                b += Sum1(g) + Ch(g, h, a) + K[t] + X[t++];
                f += b;
                b += Sum0(c) + Maj(c, d, e);

                // t = 8 * i + 7
                a += Sum1(f) + Ch(f, g, h) + K[t] + X[t++];
                e += a;
                a += Sum0(b) + Maj(b, c, d);
            }

            H1 += a;
            H2 += b;
            H3 += c;
            H4 += d;
            H5 += e;
            H6 += f;
            H7 += g;
            H8 += h;

            //
            // reset the offset and clean out the word buffer.
            //
            this._offset = 0;
            for (int i = 0; i < this.X.Length; i++)
            {
                this.X[i] = 0;
            }
        }

        /// <summary>
        /// Adjust the byte counts so that byteCount2 represents the upper long (less 3 bits) word of the byte count.
        /// </summary>
        private void AdjustByteCounts()
        {
            if (this._byteCount1 > 0x1fffffffffffffffL)
            {
                this._byteCount2 += (long)((ulong)this._byteCount1 >> 61);
                this._byteCount1 &= 0x1fffffffffffffffL;
            }
        }

        /* SHA-384 and SHA-512 functions (as for SHA-256 but for longs) */
        private static ulong Ch(ulong x, ulong y, ulong z)
        {
            return (x & y) ^ (~x & z);
        }

        private static ulong Maj(ulong x, ulong y, ulong z)
        {
            return (x & y) ^ (x & z) ^ (y & z);
        }

        private static ulong Sum0(ulong x)
        {
            return ((x << 36) | (x >> 28)) ^ ((x << 30) | (x >> 34)) ^ ((x << 25) | (x >> 39));
        }

        private static ulong Sum1(ulong x)
        {
            return ((x << 50) | (x >> 14)) ^ ((x << 46) | (x >> 18)) ^ ((x << 23) | (x >> 41));
        }

        private static ulong Sigma0(ulong x)
        {
            return ((x << 63) | (x >> 1)) ^ ((x << 56) | (x >> 8)) ^ (x >> 7);
        }

        private static ulong Sigma1(ulong x)
        {
            return ((x << 45) | (x >> 19)) ^ ((x << 3) | (x >> 61)) ^ (x >> 6);
        }

        /* SHA-384 and SHA-512 Constants
         * (represent the first 64 bits of the fractional parts of the
         * cube roots of the first sixty-four prime numbers)
         */
        private static readonly ulong[] K =
		{
			0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
			0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
			0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
			0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
			0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
			0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
			0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
			0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
			0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
			0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
			0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
			0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
			0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
			0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
			0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
			0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
			0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
			0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
			0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
			0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817
		};

        protected static void UInt32_To_BE(uint n, byte[] bs, int off)
        {
            bs[off] = (byte)(n >> 24);
            bs[++off] = (byte)(n >> 16);
            bs[++off] = (byte)(n >> 8);
            bs[++off] = (byte)(n);
        }
        protected static void UInt64_To_BE(ulong n, byte[] bs, int off)
        {
            UInt32_To_BE((uint)(n >> 32), bs, off);
            UInt32_To_BE((uint)(n), bs, off + 4);
        }
        protected static ulong BE_To_UInt64(byte[] bs)
        {
            uint hi = BE_To_UInt32(bs);
            uint lo = BE_To_UInt32(bs, 4);
            return ((ulong)hi << 32) | (ulong)lo;
        }
        protected static ulong BE_To_UInt64(byte[] bs, int off)
        {
            uint hi = BE_To_UInt32(bs, off);
            uint lo = BE_To_UInt32(bs, off + 4);
            return ((ulong)hi << 32) | (ulong)lo;
        }
        protected static uint BE_To_UInt32(byte[] bs, int off)
        {
            uint n = (uint)bs[off] << 24;
            n |= (uint)bs[++off] << 16;
            n |= (uint)bs[++off] << 8;
            n |= (uint)bs[++off];
            return n;
        }
        protected static uint BE_To_UInt32(byte[] bs)
        {
            uint n = (uint)bs[0] << 24;
            n |= (uint)bs[1] << 16;
            n |= (uint)bs[2] << 8;
            n |= (uint)bs[3];
            return n;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Hashes\SHA384Hash.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Security.Cryptography
{
    public class SHA384Hash : SHA2HashBase
    {
        private const int DIGEST_SIZE = 48;

        /// <summary>
        /// Gets the size, in bits, of the computed hash code.
        /// </summary>
        /// <returns>The size, in bits, of the computed hash code.</returns>
        public override int HashSize
        {
            get
            {
                return DIGEST_SIZE * 8;
            }
        }

        /// <summary>
        /// When overridden in a derived class, gets the input block size.
        /// </summary>
        /// <returns>The input block size.</returns>
        public override int InputBlockSize
        {
            get
            {
                return DIGEST_SIZE * 2;
            }
        }

        /// <summary>
        /// When overridden in a derived class, gets the output block size.
        /// </summary>
        /// <returns>The output block size.</returns>
        public override int OutputBlockSize
        {
            get
            {
                return DIGEST_SIZE * 2;
            }
        }

        protected override byte[] HashFinal()
        {
            var output = new byte[DIGEST_SIZE];

            this.Finish();

            SHA2HashBase.UInt64_To_BE(H1, output, 0);
            SHA2HashBase.UInt64_To_BE(H2, output, 8);
            SHA2HashBase.UInt64_To_BE(H3, output, 16);
            SHA2HashBase.UInt64_To_BE(H4, output, 24);
            SHA2HashBase.UInt64_To_BE(H5, output, 32);
            SHA2HashBase.UInt64_To_BE(H6, output, 40);

            this.Initialize();

            return output;
        }

        public override void Initialize()
        {
            base.Initialize();

            /* SHA-384 initial hash value
                * The first 64 bits of the fractional parts of the square roots
                * of the 9th through 16th prime numbers
                */
            H1 = 0xcbbb9d5dc1059ed8;
            H2 = 0x629a292a367cd507;
            H3 = 0x9159015a3070dd17;
            H4 = 0x152fecd8f70e5939;
            H5 = 0x67332667ffc00b31;
            H6 = 0x8eb44a8768581511;
            H7 = 0xdb0c2e0d64f98fa7;
            H8 = 0x47b5481dbefa4fa4;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Security\Cryptography\Hashes\SHA512Hash.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Security.Cryptography
{
    public class SHA512Hash : SHA2HashBase
    {
        private const int DIGEST_SIZE = 64;

        /// <summary>
        /// Gets the size, in bits, of the computed hash code.
        /// </summary>
        /// <returns>The size, in bits, of the computed hash code.</returns>
        public override int HashSize
        {
            get
            {
                return DIGEST_SIZE * 8;
            }
        }

        /// <summary>
        /// When overridden in a derived class, gets the input block size.
        /// </summary>
        /// <returns>The input block size.</returns>
        public override int InputBlockSize
        {
            get
            {
                return DIGEST_SIZE * 2;
            }
        }

        /// <summary>
        /// When overridden in a derived class, gets the output block size.
        /// </summary>
        /// <returns>The output block size.</returns>
        public override int OutputBlockSize
        {
            get
            {
                return DIGEST_SIZE * 2;
            }
        }

        protected override byte[] HashFinal()
        {
            var output = new byte[DIGEST_SIZE];

            this.Finish();

            SHA2HashBase.UInt64_To_BE(H1, output, 0);
            SHA2HashBase.UInt64_To_BE(H2, output, 8);
            SHA2HashBase.UInt64_To_BE(H3, output, 16);
            SHA2HashBase.UInt64_To_BE(H4, output, 24);
            SHA2HashBase.UInt64_To_BE(H5, output, 32);
            SHA2HashBase.UInt64_To_BE(H6, output, 40);
            SHA2HashBase.UInt64_To_BE(H7, output, 48);
            SHA2HashBase.UInt64_To_BE(H8, output, 56);

            this.Initialize();

            return output;
        }

        public override void Initialize()
        {
            base.Initialize();

            /* SHA-512 initial hash value
             * The first 64 bits of the fractional parts of the square roots
             * of the first eight prime numbers
             */
            H1 = 0x6a09e667f3bcc908;
            H2 = 0xbb67ae8584caa73b;
            H3 = 0x3c6ef372fe94f82b;
            H4 = 0xa54ff53a5f1d36f1;
            H5 = 0x510e527fade682d1;
            H6 = 0x9b05688c2b3e6c1f;
            H7 = 0x1f83d9abfb41bd6b;
            H8 = 0x5be0cd19137e2179;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Flags.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp
{
    [Flags]
    public enum Flags
    {
        None = 0x00000000,
        /// <summary>
        /// SSH_FXF_READ
        /// </summary>
        Read = 0x00000001,
        /// <summary>
        /// SSH_FXF_WRITE
        /// </summary>
        Write = 0x00000002,
        /// <summary>
        /// SSH_FXF_APPEND
        /// </summary>
        Append = 0x00000004,
        /// <summary>
        /// SSH_FXF_CREAT
        /// </summary>
        CreateNewOrOpen = 0x00000008,
        /// <summary>
        /// SSH_FXF_TRUNC
        /// </summary>
        Truncate = 0x00000010,
        /// <summary>
        /// SSH_FXF_EXCL
        /// </summary>
        CreateNew = 0x00000028
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\ISftpSession.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp
{
    public interface ISftpSession : ISubsystemSession
    {
        /// <summary>
        /// Gets the SFTP protocol version.
        /// </summary>
        /// <value>
        /// The SFTP protocol version.
        /// </value>
        uint ProtocolVersion { get; }

        /// <summary>
        /// Gets the remote working directory.
        /// </summary>
        /// <value>
        /// The remote working directory.
        /// </value>
        string WorkingDirectory { get; }

        /// <summary>
        /// Changes the current working directory to the specified path.
        /// </summary>
        /// <param name="path">The new working directory.</param>
        void ChangeDirectory(string path);

        /// <summary>
        /// Resolves a given path into an absolute path on the server.
        /// </summary>
        /// <param name="path">The path to resolve.</param>
        /// <returns>
        /// The absolute path.
        /// </returns>
        string GetCanonicalPath(string path);

        /// <summary>
        /// Performs SSH_FXP_FSTAT request.
        /// </summary>
        /// <param name="handle">The handle.</param>
        /// <returns>
        /// File attributes
        /// </returns>
        SftpFileAttributes RequestFStat(byte[] handle);

        /// <summary>
        /// Performs SSH_FXP_LSTAT request.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <returns>
        /// File attributes
        /// </returns>
        SftpFileAttributes RequestLStat(string path);

        /// <summary>
        /// Performs SSH_FXP_MKDIR request.
        /// </summary>
        /// <param name="path">The path.</param>
        void RequestMkDir(string path);

        /// <summary>
        /// Performs SSH_FXP_OPEN request
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="flags">The flags.</param>
        /// <param name="nullOnError">if set to <c>true</c> returns <c>null</c> instead of throwing an exception.</param>
        /// <returns>File handle.</returns>
        byte[] RequestOpen(string path, Flags flags, bool nullOnError = false);

        /// <summary>
        /// Performs SSH_FXP_OPENDIR request
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="nullOnError">if set to <c>true</c> returns null instead of throwing an exception.</param>
        /// <returns>File handle.</returns>
        byte[] RequestOpenDir(string path, bool nullOnError = false);

        /// <summary>
        /// Performs posix-rename@openssh.com extended request.
        /// </summary>
        /// <param name="oldPath">The old path.</param>
        /// <param name="newPath">The new path.</param>
        void RequestPosixRename(string oldPath, string newPath);

        /// <summary>
        /// Performs SSH_FXP_READ request.
        /// </summary>
        /// <param name="handle">The handle.</param>
        /// <param name="offset">The offset.</param>
        /// <param name="length">The length.</param>
        /// <returns>data array; null if EOF</returns>
        byte[] RequestRead(byte[] handle, ulong offset, uint length);

        /// <summary>
        /// Performs SSH_FXP_READDIR request
        /// </summary>
        /// <param name="handle">The handle.</param>
        /// <returns></returns>
        KeyValuePair<string, SftpFileAttributes>[] RequestReadDir(byte[] handle);

        /// <summary>
        /// Performs SSH_FXP_REMOVE request.
        /// </summary>
        /// <param name="path">The path.</param>
        void RequestRemove(string path);

        /// <summary>
        /// Performs SSH_FXP_RENAME request.
        /// </summary>
        /// <param name="oldPath">The old path.</param>
        /// <param name="newPath">The new path.</param>
        void RequestRename(string oldPath, string newPath);

        /// <summary>
        /// Performs SSH_FXP_RMDIR request.
        /// </summary>
        /// <param name="path">The path.</param>
        void RequestRmDir(string path);

        /// <summary>
        /// Performs SSH_FXP_SETSTAT request.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="attributes">The attributes.</param>
        void RequestSetStat(string path, SftpFileAttributes attributes);

        /// <summary>
        /// Performs statvfs@openssh.com extended request.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="nullOnError">if set to <c>true</c> [null on error].</param>
        /// <returns></returns>
        SftpFileSytemInformation RequestStatVfs(string path, bool nullOnError = false);

        /// <summary>
        /// Performs SSH_FXP_SYMLINK request.
        /// </summary>
        /// <param name="linkpath">The linkpath.</param>
        /// <param name="targetpath">The targetpath.</param>
        void RequestSymLink(string linkpath, string targetpath);

        /// <summary>
        /// Performs SSH_FXP_FSETSTAT request.
        /// </summary>
        /// <param name="handle">The handle.</param>
        /// <param name="attributes">The attributes.</param>
        void RequestFSetStat(byte[] handle, SftpFileAttributes attributes);

        /// <summary>
        /// Performs SSH_FXP_WRITE request.
        /// </summary>
        /// <param name="handle">The handle.</param>
        /// <param name="offset">The offset.</param>
        /// <param name="data">The data to send.</param>
        /// <param name="wait">The wait event handle if needed.</param>
        /// <param name="writeCompleted">The callback to invoke when the write has completed.</param>
        void RequestWrite(byte[] handle, ulong offset, byte[] data, AutoResetEvent wait, Action<SftpStatusResponse> writeCompleted = null);

        /// <summary>
        /// Performs SSH_FXP_CLOSE request.
        /// </summary>
        /// <param name="handle">The handle.</param>
        void RequestClose(byte[] handle);

        /// <summary>
        /// Calculates the optimal size of the buffer to read data from the channel.
        /// </summary>
        /// <param name="bufferSize">The buffer size configured on the client.</param>
        /// <returns>
        /// The optimal size of the buffer to read data from the channel.
        /// </returns>
        uint CalculateOptimalReadLength(uint bufferSize);

        /// <summary>
        /// Calculates the optimal size of the buffer to write data on the channel.
        /// </summary>
        /// <param name="bufferSize">The buffer size configured on the client.</param>
        /// <param name="handle">The file handle.</param>
        /// <returns>
        /// The optimal size of the buffer to write data on the channel.
        /// </returns>
        /// <remarks>
        /// Currently, we do not take the remote window size into account.
        /// </remarks>
        uint CalculateOptimalWriteLength(uint bufferSize, byte[] handle);
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\SftpDataMessage.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp
{
    public class SftpDataMessage : ChannelDataMessage
    {
        public SftpDataMessage(uint localChannelNumber, SftpMessage sftpMessage)
        {
            this.LocalChannelNumber = localChannelNumber;

            var messageData = sftpMessage.GetBytes();

            var data = new byte[4 + messageData.Length];

            ((uint)messageData.Length).GetBytes().CopyTo(data, 0);
            messageData.CopyTo(data, 4);
            this.Data = data;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\SftpDownloadAsyncResult.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp
{
    /// <summary>
    /// Encapsulates the results of an asynchronous download operation.
    /// </summary>
    public class SftpDownloadAsyncResult :  AsyncResult
    {
        /// <summary>
        /// Gets or sets a value indicating whether to cancel asynchronous download operation.
        /// </summary>
        /// <value>
        /// <c>true</c> if download operation to be canceled; otherwise, <c>false</c>.
        /// </value>
        /// <remarks>
        /// Download operation will be canceled after finishing uploading current buffer.
        /// </remarks>
        public bool IsDownloadCanceled { get; set; }

        /// <summary>
        /// Gets the number of downloaded bytes.
        /// </summary>
        public ulong DownloadedBytes { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpDownloadAsyncResult"/> class.
        /// </summary>
        /// <param name="asyncCallback">The async callback.</param>
        /// <param name="state">The state.</param>
        public SftpDownloadAsyncResult(AsyncCallback asyncCallback, Object state)
            : base(asyncCallback, state)
        {
        }

        /// <summary>
        /// Updates asynchronous operation status information.
        /// </summary>
        /// <param name="downloadedBytes">Number of downloaded bytes.</param>
        internal void Update(ulong downloadedBytes)
        {
            this.DownloadedBytes = downloadedBytes;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\SftpFile.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp
{
    /// <summary>
    /// Represents SFTP file information
    /// </summary>
    public class SftpFile
    {
        private readonly ISftpSession _sftpSession;

        /// <summary>
        /// Gets the file attributes.
        /// </summary>
        public SftpFileAttributes Attributes { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpFile"/> class.
        /// </summary>
        /// <param name="sftpSession">The SFTP session.</param>
        /// <param name="fullName">Full path of the directory or file.</param>
        /// <param name="attributes">Attributes of the directory or file.</param>
        /// <exception cref="ArgumentNullException"><paramref name="sftpSession"/> or <paramref name="fullName"/> is null.</exception>
        internal SftpFile(ISftpSession sftpSession, string fullName, SftpFileAttributes attributes)
        {
            if (sftpSession == null)
                throw new SshConnectionException("Client not connected.");

            if (attributes == null)
                throw new ArgumentNullException("attributes");

            if (fullName == null)
                throw new ArgumentNullException("fullName");

            this._sftpSession = sftpSession;
            this.Attributes = attributes;

            this.Name = fullName.Substring(fullName.LastIndexOf('/') + 1);

            this.FullName = fullName;
        }

        /// <summary>
        /// Gets the full path of the directory or file.
        /// </summary>
        public string FullName { get; private set; }

        /// <summary>
        /// For files, gets the name of the file. For directories, gets the name of the last directory in the hierarchy if a hierarchy exists. 
        /// Otherwise, the Name property gets the name of the directory.
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        /// Gets or sets the time the current file or directory was last accessed.
        /// </summary>
        /// <value>
        /// The time that the current file or directory was last accessed.
        /// </value>
        public DateTime LastAccessTime
        {
            get
            {
                return this.Attributes.LastAccessTime;
            }
            set
            {
                this.Attributes.LastAccessTime = value;
            }
        }

        /// <summary>
        /// Gets or sets the time when the current file or directory was last written to.
        /// </summary>
        /// <value>
        /// The time the current file was last written.
        /// </value>
        public DateTime LastWriteTime
        {
            get
            {
                return this.Attributes.LastWriteTime;
            }
            set
            {
                this.Attributes.LastWriteTime = value;
            }
        }

        /// <summary>
        /// Gets or sets the time, in coordinated universal time (UTC), the current file or directory was last accessed.
        /// </summary>
        /// <value>
        /// The time that the current file or directory was last accessed.
        /// </value>
        public DateTime LastAccessTimeUtc
        {
            get
            {
                return this.Attributes.LastAccessTime.ToUniversalTime();
            }
            set
            {
                this.Attributes.LastAccessTime = value.ToLocalTime();
            }
        }

        /// <summary>
        /// Gets or sets the time, in coordinated universal time (UTC), when the current file or directory was last written to.
        /// </summary>
        /// <value>
        /// The time the current file was last written.
        /// </value>
        public DateTime LastWriteTimeUtc
        {
            get
            {
                return this.Attributes.LastWriteTime.ToUniversalTime();
            }
            set
            {
                this.Attributes.LastWriteTime = value.ToLocalTime();
            }
        }

        /// <summary>
        /// Gets or sets the size, in bytes, of the current file.
        /// </summary>
        /// <value>
        /// The size of the current file in bytes.
        /// </value>
        public long Length
        {
            get
            {
                return this.Attributes.Size;
            }
        }

        /// <summary>
        /// Gets or sets file user id.
        /// </summary>
        /// <value>
        /// File user id.
        /// </value>
        public int UserId
        {
            get
            {
                return this.Attributes.UserId;
            }
            set
            {
                this.Attributes.UserId = value;
            }
        }

        /// <summary>
        /// Gets or sets file group id.
        /// </summary>
        /// <value>
        /// File group id.
        /// </value>
        public int GroupId
        {
            get
            {
                return this.Attributes.GroupId;
            }
            set
            {
                this.Attributes.GroupId = value;
            }
        }

        /// <summary>
        /// Gets a value indicating whether file represents a socket.
        /// </summary>
        /// <value>
        ///   <c>true</c> if file represents a socket; otherwise, <c>false</c>.
        /// </value>
        public bool IsSocket
        {
            get
            {
                return this.Attributes.IsSocket;
            }
        }

        /// <summary>
        /// Gets a value indicating whether file represents a symbolic link.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if file represents a symbolic link; otherwise, <c>false</c>.
        /// </value>
        public bool IsSymbolicLink
        {
            get
            {
                return this.Attributes.IsSymbolicLink;
            }
        }

        /// <summary>
        /// Gets a value indicating whether file represents a regular file.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if file represents a regular file; otherwise, <c>false</c>.
        /// </value>
        public bool IsRegularFile
        {
            get
            {
                return this.Attributes.IsRegularFile;
            }
        }

        /// <summary>
        /// Gets a value indicating whether file represents a block device.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if file represents a block device; otherwise, <c>false</c>.
        /// </value>
        public bool IsBlockDevice
        {
            get
            {
                return this.Attributes.IsBlockDevice;
            }
        }

        /// <summary>
        /// Gets a value indicating whether file represents a directory.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if file represents a directory; otherwise, <c>false</c>.
        /// </value>
        public bool IsDirectory
        {
            get
            {
                return this.Attributes.IsDirectory;
            }
        }

        /// <summary>
        /// Gets a value indicating whether file represents a character device.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if file represents a character device; otherwise, <c>false</c>.
        /// </value>
        public bool IsCharacterDevice
        {
            get
            {
                return this.Attributes.IsCharacterDevice;
            }
        }

        /// <summary>
        /// Gets a value indicating whether file represents a named pipe.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if file represents a named pipe; otherwise, <c>false</c>.
        /// </value>
        public bool IsNamedPipe
        {
            get
            {
                return this.Attributes.IsNamedPipe;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the owner can read from this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if owner can read from this file; otherwise, <c>false</c>.
        /// </value>
        public bool OwnerCanRead
        {
            get
            {
                return this.Attributes.OwnerCanRead;
            }
            set
            {
                this.Attributes.OwnerCanRead = value;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the owner can write into this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if owner can write into this file; otherwise, <c>false</c>.
        /// </value>
        public bool OwnerCanWrite
        {
            get
            {
                return this.Attributes.OwnerCanWrite;
            }
            set
            {
                this.Attributes.OwnerCanWrite = value;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the owner can execute this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if owner can execute this file; otherwise, <c>false</c>.
        /// </value>
        public bool OwnerCanExecute
        {
            get
            {
                return this.Attributes.OwnerCanExecute;
            }
            set
            {
                this.Attributes.OwnerCanExecute = value;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the group members can read from this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if group members can read from this file; otherwise, <c>false</c>.
        /// </value>
        public bool GroupCanRead
        {
            get
            {
                return this.Attributes.GroupCanRead;
            }
            set
            {
                this.Attributes.GroupCanRead = value;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the group members can write into this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if group members can write into this file; otherwise, <c>false</c>.
        /// </value>
        public bool GroupCanWrite
        {
            get
            {
                return this.Attributes.GroupCanWrite;
            }
            set
            {
                this.Attributes.GroupCanWrite = value;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the group members can execute this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if group members can execute this file; otherwise, <c>false</c>.
        /// </value>
        public bool GroupCanExecute
        {
            get
            {
                return this.Attributes.GroupCanExecute;
            }
            set
            {
                this.Attributes.GroupCanExecute = value;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the others can read from this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if others can read from this file; otherwise, <c>false</c>.
        /// </value>
        public bool OthersCanRead
        {
            get
            {
                return this.Attributes.OthersCanRead;
            }
            set
            {
                this.Attributes.OthersCanRead = value;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the others can write into this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if others can write into this file; otherwise, <c>false</c>.
        /// </value>
        public bool OthersCanWrite
        {
            get
            {
                return this.Attributes.OthersCanWrite;
            }
            set
            {
                this.Attributes.OthersCanWrite = value;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the others can execute this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if others can execute this file; otherwise, <c>false</c>.
        /// </value>
        public bool OthersCanExecute
        {
            get
            {
                return this.Attributes.OthersCanExecute;
            }
            set
            {
                this.Attributes.OthersCanExecute = value;
            }
        }

        /// <summary>
        /// Gets the extension part of the file.
        /// </summary>
        /// <value>
        /// File extensions.
        /// </value>
        public IDictionary<string, string> Extensions { get; private set; }

        /// <summary>
        /// Sets file  permissions.
        /// </summary>
        /// <param name="mode">The mode.</param>
        public void SetPermissions(short mode)
        {
            this.Attributes.SetPermissions(mode);

            this.UpdateStatus();
        }

        /// <summary>
        /// Permanently deletes a file on remote machine.
        /// </summary>
        public void Delete()
        {
            if (this.IsDirectory)
            {
                this._sftpSession.RequestRmDir(this.FullName);
            }
            else
            {
                this._sftpSession.RequestRemove(this.FullName);
            }
        }

        /// <summary>
        /// Moves a specified file to a new location on remote machine, providing the option to specify a new file name.
        /// </summary>
        /// <param name="destFileName">The path to move the file to, which can specify a different file name.</param>
        /// <exception cref="ArgumentNullException"><paramref name="destFileName"/> is null.</exception>
        public void MoveTo(string destFileName)
        {
            if (destFileName == null)
                throw new ArgumentNullException("destFileName");
            this._sftpSession.RequestRename(this.FullName, destFileName);

            var fullPath = this._sftpSession.GetCanonicalPath(destFileName);

            this.Name = fullPath.Substring(fullPath.LastIndexOf('/') + 1);

            this.FullName = fullPath;
        }

        /// <summary>
        /// Updates file status on the server.
        /// </summary>
        public void UpdateStatus()
        {
            this._sftpSession.RequestSetStat(this.FullName, this.Attributes);
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return string.Format(CultureInfo.CurrentCulture, "Name {0}, Length {1}, User ID {2}, Group ID {3}, Accessed {4}, Modified {5}", this.Name, this.Length, this.UserId, this.GroupId, this.LastAccessTime, this.LastWriteTime);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\SftpFileAttributes.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp
{
    /// <summary>
    /// Contains SFTP file attributes.
    /// </summary>
    public class SftpFileAttributes
    {
        #region Bitmask constats

        private const UInt32 S_IFMT = 0xF000; //  bitmask for the file type bitfields

        private const UInt32 S_IFSOCK = 0xC000; //	socket

        private const UInt32 S_IFLNK = 0xA000; //	symbolic link

        private const UInt32 S_IFREG = 0x8000; //	regular file

        private const UInt32 S_IFBLK = 0x6000; //	block device

        private const UInt32 S_IFDIR = 0x4000; //	directory

        private const UInt32 S_IFCHR = 0x2000; //	character device

        private const UInt32 S_IFIFO = 0x1000; //	FIFO

        private const UInt32 S_ISUID = 0x0800; //	set UID bit

        private const UInt32 S_ISGID = 0x0400; //	set-group-ID bit (see below)

        private const UInt32 S_ISVTX = 0x0200; //	sticky bit (see below)

        private const UInt32 S_IRUSR = 0x0100; //	owner has read permission

        private const UInt32 S_IWUSR = 0x0080; //	owner has write permission

        private const UInt32 S_IXUSR = 0x0040; //	owner has execute permission

        private const UInt32 S_IRGRP = 0x0020; //	group has read permission

        private const UInt32 S_IWGRP = 0x0010; //	group has write permission

        private const UInt32 S_IXGRP = 0x0008; //	group has execute permission

        private const UInt32 S_IROTH = 0x0004; //	others have read permission

        private const UInt32 S_IWOTH = 0x0002; //	others have write permission

        private const UInt32 S_IXOTH = 0x0001; //	others have execute permission

        #endregion

        private bool _isBitFiledsBitSet;
        private bool _isUIDBitSet;
        private bool _isGroupIDBitSet;
        private bool _isStickyBitSet;

        private readonly DateTime _originalLastAccessTime;
        private readonly DateTime _originalLastWriteTime;
        private readonly long _originalSize;
        private readonly int _originalUserId;
        private readonly int _originalGroupId;
        private readonly uint _originalPermissions;
        private readonly IDictionary<string, string> _originalExtensions;

        internal bool IsLastAccessTimeChanged
        {
            get { return this._originalLastAccessTime != this.LastAccessTime; }
        }

        internal bool IsLastWriteTimeChanged
        {
            get { return this._originalLastWriteTime != this.LastWriteTime; }
        }

        internal bool IsSizeChanged
        {
            get { return this._originalSize != this.Size; }
        }

        internal bool IsUserIdChanged
        {
            get { return this._originalUserId != this.UserId; }
        }

        internal bool IsGroupIdChanged
        {
            get { return this._originalGroupId != this.GroupId; }
        }

        internal bool IsPermissionsChanged
        {
            get { return this._originalPermissions != this.Permissions; }
        }

        internal bool IsExtensionsChanged
        {
            get { return this._originalExtensions != null && this.Extensions != null && !this._originalExtensions.SequenceEqual(this.Extensions); }
        }

        /// <summary>
        /// Gets or sets the time the current file or directory was last accessed.
        /// </summary>
        /// <value>
        /// The time that the current file or directory was last accessed.
        /// </value>
        public DateTime LastAccessTime { get; set; }

        /// <summary>
        /// Gets or sets the time when the current file or directory was last written to.
        /// </summary>
        /// <value>
        /// The time the current file was last written.
        /// </value>
        public DateTime LastWriteTime { get; set; }

        /// <summary>
        /// Gets or sets the size, in bytes, of the current file.
        /// </summary>
        /// <value>
        /// The size of the current file in bytes.
        /// </value>
        public long Size { get; set; }

        /// <summary>
        /// Gets or sets file user id.
        /// </summary>
        /// <value>
        /// File user id.
        /// </value>
        public int UserId { get; set; }

        /// <summary>
        /// Gets or sets file group id.
        /// </summary>
        /// <value>
        /// File group id.
        /// </value>
        public int GroupId { get; set; }

        /// <summary>
        /// Gets a value indicating whether file represents a socket.
        /// </summary>
        /// <value>
        ///   <c>true</c> if file represents a socket; otherwise, <c>false</c>.
        /// </value>
        public bool IsSocket { get; private set; }

        /// <summary>
        /// Gets a value indicating whether file represents a symbolic link.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if file represents a symbolic link; otherwise, <c>false</c>.
        /// </value>
        public bool IsSymbolicLink { get; private set; }

        /// <summary>
        /// Gets a value indicating whether file represents a regular file.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if file represents a regular file; otherwise, <c>false</c>.
        /// </value>
        public bool IsRegularFile { get; private set; }

        /// <summary>
        /// Gets a value indicating whether file represents a block device.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if file represents a block device; otherwise, <c>false</c>.
        /// </value>
        public bool IsBlockDevice { get; private set; }

        /// <summary>
        /// Gets a value indicating whether file represents a directory.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if file represents a directory; otherwise, <c>false</c>.
        /// </value>
        public bool IsDirectory { get; private set; }

        /// <summary>
        /// Gets a value indicating whether file represents a character device.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if file represents a character device; otherwise, <c>false</c>.
        /// </value>
        public bool IsCharacterDevice { get; private set; }

        /// <summary>
        /// Gets a value indicating whether file represents a named pipe.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if file represents a named pipe; otherwise, <c>false</c>.
        /// </value>
        public bool IsNamedPipe { get; private set; }

        /// <summary>
        /// Gets a value indicating whether the owner can read from this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if owner can read from this file; otherwise, <c>false</c>.
        /// </value>
        public bool OwnerCanRead { get; set; }

        /// <summary>
        /// Gets a value indicating whether the owner can write into this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if owner can write into this file; otherwise, <c>false</c>.
        /// </value>
        public bool OwnerCanWrite { get; set; }

        /// <summary>
        /// Gets a value indicating whether the owner can execute this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if owner can execute this file; otherwise, <c>false</c>.
        /// </value>
        public bool OwnerCanExecute { get; set; }

        /// <summary>
        /// Gets a value indicating whether the group members can read from this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if group members can read from this file; otherwise, <c>false</c>.
        /// </value>
        public bool GroupCanRead { get; set; }

        /// <summary>
        /// Gets a value indicating whether the group members can write into this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if group members can write into this file; otherwise, <c>false</c>.
        /// </value>
        public bool GroupCanWrite { get; set; }

        /// <summary>
        /// Gets a value indicating whether the group members can execute this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if group members can execute this file; otherwise, <c>false</c>.
        /// </value>
        public bool GroupCanExecute { get; set; }

        /// <summary>
        /// Gets a value indicating whether the others can read from this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if others can read from this file; otherwise, <c>false</c>.
        /// </value>
        public bool OthersCanRead { get; set; }

        /// <summary>
        /// Gets a value indicating whether the others can write into this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if others can write into this file; otherwise, <c>false</c>.
        /// </value>
        public bool OthersCanWrite { get; set; }

        /// <summary>
        /// Gets a value indicating whether the others can execute this file.
        /// </summary>
        /// <value>
        ///   <c>true</c> if others can execute this file; otherwise, <c>false</c>.
        /// </value>
        public bool OthersCanExecute { get; set; }

        /// <summary>
        /// Gets or sets the extensions.
        /// </summary>
        /// <value>
        /// The extensions.
        /// </value>
        public IDictionary<string, string> Extensions { get; private set; }

        internal uint Permissions
        {
            get
            {
                uint permission = 0;

                if (this._isBitFiledsBitSet)
                    permission = permission | S_IFMT;

                if (this.IsSocket)
                    permission = permission | S_IFSOCK;

                if (this.IsSymbolicLink)
                    permission = permission | S_IFLNK;

                if (this.IsRegularFile)
                    permission = permission | S_IFREG;

                if (this.IsBlockDevice)
                    permission = permission | S_IFBLK;

                if (this.IsDirectory)
                    permission = permission | S_IFDIR;

                if (this.IsCharacterDevice)
                    permission = permission | S_IFCHR;

                if (this.IsNamedPipe)
                    permission = permission | S_IFIFO;

                if (this._isUIDBitSet)
                    permission = permission | S_ISUID;

                if (this._isGroupIDBitSet)
                    permission = permission | S_ISGID;

                if (this._isStickyBitSet)
                    permission = permission | S_ISVTX;

                if (this.OwnerCanRead)
                    permission = permission | S_IRUSR;

                if (this.OwnerCanWrite)
                    permission = permission | S_IWUSR;

                if (this.OwnerCanExecute)
                    permission = permission | S_IXUSR;

                if (this.GroupCanRead)
                    permission = permission | S_IRGRP;

                if (this.GroupCanWrite)
                    permission = permission | S_IWGRP;

                if (this.GroupCanExecute)
                    permission = permission | S_IXGRP;

                if (this.OthersCanRead)
                    permission = permission | S_IROTH;

                if (this.OthersCanWrite)
                    permission = permission | S_IWOTH;

                if (this.OthersCanExecute)
                    permission = permission | S_IXOTH;

                return permission;
            }
            private set
            {
                this._isBitFiledsBitSet = ((value & S_IFMT) == S_IFMT);

                this.IsSocket = ((value & S_IFSOCK) == S_IFSOCK);

                this.IsSymbolicLink = ((value & S_IFLNK) == S_IFLNK);

                this.IsRegularFile = ((value & S_IFREG) == S_IFREG);

                this.IsBlockDevice = ((value & S_IFBLK) == S_IFBLK);

                this.IsDirectory = ((value & S_IFDIR) == S_IFDIR);

                this.IsCharacterDevice = ((value & S_IFCHR) == S_IFCHR);

                this.IsNamedPipe = ((value & S_IFIFO) == S_IFIFO);

                this._isUIDBitSet = ((value & S_ISUID) == S_ISUID);

                this._isGroupIDBitSet = ((value & S_ISGID) == S_ISGID);

                this._isStickyBitSet = ((value & S_ISVTX) == S_ISVTX);

                this.OwnerCanRead = ((value & S_IRUSR) == S_IRUSR);

                this.OwnerCanWrite = ((value & S_IWUSR) == S_IWUSR);

                this.OwnerCanExecute = ((value & S_IXUSR) == S_IXUSR);

                this.GroupCanRead = ((value & S_IRGRP) == S_IRGRP);

                this.GroupCanWrite = ((value & S_IWGRP) == S_IWGRP);

                this.GroupCanExecute = ((value & S_IXGRP) == S_IXGRP);

                this.OthersCanRead = ((value & S_IROTH) == S_IROTH);

                this.OthersCanWrite = ((value & S_IWOTH) == S_IWOTH);

                this.OthersCanExecute = ((value & S_IXOTH) == S_IXOTH);
            }
        }

        internal SftpFileAttributes()
        {
        }

        internal SftpFileAttributes(DateTime lastAccessTime, DateTime lastWriteTime, long size, int userId, int groupId, uint permissions, IDictionary<string, string> extensions)
        {
            this.LastAccessTime = this._originalLastAccessTime = lastAccessTime;
            this.LastWriteTime = this._originalLastWriteTime = lastWriteTime;
            this.Size = this._originalSize = size;
            this.UserId = this._originalUserId = userId;
            this.GroupId = this._originalGroupId = groupId;
            this.Permissions = this._originalPermissions = permissions;
            this.Extensions = this._originalExtensions = extensions;
        }

        /// <summary>
        /// Sets the permissions.
        /// </summary>
        /// <param name="mode">The mode.</param>
        public void SetPermissions(short mode)
        {
            if (mode < 0 || mode > 999)
            {
                throw new ArgumentOutOfRangeException("mode");
            }

            var modeBytes = mode.ToString(CultureInfo.InvariantCulture).PadLeft(3, '0').ToArray();

            var permission = (modeBytes[0] & 0x0F) * 8 * 8 + (modeBytes[1] & 0x0F) * 8 + (modeBytes[2] & 0x0F);

            this.OwnerCanRead = (permission & S_IRUSR) == S_IRUSR;
            this.OwnerCanWrite = (permission & S_IWUSR) == S_IWUSR;
            this.OwnerCanExecute = (permission & S_IXUSR) == S_IXUSR;

            this.GroupCanRead = (permission & S_IRGRP) == S_IRGRP;
            this.GroupCanWrite = (permission & S_IWGRP) == S_IWGRP;
            this.GroupCanExecute = (permission & S_IXGRP) == S_IXGRP;

            this.OthersCanRead = (permission & S_IROTH) == S_IROTH;
            this.OthersCanWrite = (permission & S_IWOTH) == S_IWOTH;
            this.OthersCanExecute = (permission & S_IXOTH) == S_IXOTH;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\SftpFileStream.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp
{
    /// <summary>
    /// Exposes a System.IO.Stream around a remote SFTP file, supporting both synchronous and asynchronous read and write operations.
    /// </summary>
    public class SftpFileStream : Stream
    {
        //OneCodeTODO:   Add security method to set userid, groupid and other permission settings
        // Internal state.
        private byte[] _handle;
        private readonly bool _ownsHandle;
        private readonly bool _isAsync;
        private ISftpSession _session;

        // Buffer information.
        private readonly int _readBufferSize;
        private readonly byte[] _readBuffer;
        private readonly int _writeBufferSize;
        private readonly byte[] _writeBuffer;
        private int _bufferPosition;
        private int _bufferLen;
        private long _position;
        private bool _bufferOwnedByWrite;
        private bool _canRead;
        private bool _canSeek;
        private bool _canWrite;
        private ulong _serverFilePosition;

        private SftpFileAttributes _attributes;

        private readonly object _lock = new object();

        /// <summary>
        /// Gets a value indicating whether the current stream supports reading.
        /// </summary>
        /// <returns>true if the stream supports reading; otherwise, false.</returns>
        public override bool CanRead
        {
            get { return _canRead; }
        }

        /// <summary>
        /// Gets a value indicating whether the current stream supports seeking.
        /// </summary>
        /// <returns>true if the stream supports seeking; otherwise, false.</returns>
        public override bool CanSeek
        {
            get { return _canSeek; }
        }

        /// <summary>
        /// Gets a value indicating whether the current stream supports writing.
        /// </summary>
        /// <returns>true if the stream supports writing; otherwise, false.</returns>
        public override bool CanWrite
        {
            get { return _canWrite; }
        }

        /// <summary>
        /// Indicates whether timeout properties are usable for <see cref="SftpFileStream"/>.
        /// </summary>
        /// <value>
        /// <c>true</c> in all cases.
        /// </value>
        public override bool CanTimeout
        {
            get { return true; }
        }

        /// <summary>
        /// Gets the length in bytes of the stream.
        /// </summary>
        /// <returns>A long value representing the length of the stream in bytes.</returns>
        /// <exception cref="T:System.NotSupportedException">A class derived from Stream does not support seeking. </exception>
        /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
        /// <exception cref="T:System.IO.IOException">IO operation failed. </exception>
        [SuppressMessage("Microsoft.Design", "CA1065:DoNotRaiseExceptionsInUnexpectedLocations", Justification = "Be design this is the exception that stream need to throw.")]
        public override long Length
        {
            get
            {
                // Lock down the file stream while we do this.
                lock (_lock)
                {
                    CheckSessionIsOpen();

                    if (!CanSeek)
                        throw new NotSupportedException("Seek operation is not supported.");

                    // Flush the write buffer, because it may
                    // affect the length of the stream.
                    if (_bufferOwnedByWrite)
                    {
                        FlushWriteBuffer();
                    }

                    //  Update file attributes
                    _attributes = _session.RequestFStat(_handle);

                    if (_attributes != null && _attributes.Size > -1)
                    {
                        return _attributes.Size;
                    }
                    throw new IOException("Seek operation failed.");
                }
            }
        }

        /// <summary>
        /// Gets or sets the position within the current stream.
        /// </summary>
        /// <returns>The current position within the stream.</returns>
        ///   
        /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        ///   
        /// <exception cref="T:System.NotSupportedException">The stream does not support seeking. </exception>
        ///   
        /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
        public override long Position
        {
            get
            {
                CheckSessionIsOpen();
                if (!CanSeek)
                    throw new NotSupportedException("Seek operation not supported.");
                return _position;
            }
            set
            {
                Seek(value, SeekOrigin.Begin);
            }
        }

        /// <summary>
        /// Gets a value indicating whether the FileStream was opened asynchronously or synchronously.
        /// </summary>
        /// <value>
        ///   <c>true</c> if this instance is async; otherwise, <c>false</c>.
        /// </value>
        public virtual bool IsAsync
        {
            get
            {
                return _isAsync;
            }
        }

        /// <summary>
        /// Gets the name of the FileStream that was passed to the constructor.
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        /// Gets the operating system file handle for the file that the current SftpFileStream object encapsulates.
        /// </summary>
        public virtual byte[] Handle
        {
            get
            {
                Flush();
                return _handle;
            }
        }

        /// <summary>
        /// Gets or sets the operation timeout.
        /// </summary>
        /// <value>
        /// The timeout.
        /// </value>
        public TimeSpan Timeout { get; set; }

        internal SftpFileStream(ISftpSession session, string path, FileMode mode, FileAccess access, int bufferSize)
            : this(session, path, mode, access, bufferSize, false)
        {
        }

        internal SftpFileStream(ISftpSession session, string path, FileMode mode, FileAccess access, int bufferSize, bool useAsync)
        {
            // Validate the parameters.
            if (session == null)
                throw new SshConnectionException("Client not connected.");

            if (path == null)
            {
                throw new ArgumentNullException("path");
            }
            if (bufferSize <= 0)
            {
                throw new ArgumentOutOfRangeException("bufferSize");
            }
            if (access < FileAccess.Read || access > FileAccess.ReadWrite)
            {
                throw new ArgumentOutOfRangeException("access");
            }
            if (mode < FileMode.CreateNew || mode > FileMode.Append)
            {
                throw new ArgumentOutOfRangeException("mode");
            }

            Timeout = TimeSpan.FromSeconds(30);
            Name = path;

            // Initialize the object state.
            _session = session;
            _ownsHandle = true;
            _isAsync = useAsync;
            _bufferPosition = 0;
            _bufferLen = 0;
            _bufferOwnedByWrite = false;
            _canRead = ((access & FileAccess.Read) != 0);
            _canSeek = true;
            _canWrite = ((access & FileAccess.Write) != 0);
            _position = 0;
            _serverFilePosition = 0;

            var flags = Flags.None;

            switch (access)
            {
                case FileAccess.Read:
                    flags |= Flags.Read;
                    break;
                case FileAccess.Write:
                    flags |= Flags.Write;
                    break;
                case FileAccess.ReadWrite:
                    flags |= Flags.Read;
                    flags |= Flags.Write;
                    break;
            }

            switch (mode)
            {
                case FileMode.Append:
                    flags |= Flags.Append;
                    break;
                case FileMode.Create:
                    _handle = _session.RequestOpen(path, flags | Flags.Truncate, true);
                    if (_handle == null)
                    {
                        flags |= Flags.CreateNew;
                    }
                    else
                    {
                        flags |= Flags.Truncate;
                    }
                    break;
                case FileMode.CreateNew:
                    flags |= Flags.CreateNew;
                    break;
                case FileMode.Open:
                    break;
                case FileMode.OpenOrCreate:
                    flags |= Flags.CreateNewOrOpen;
                    break;
                case FileMode.Truncate:
                    flags |= Flags.Truncate;
                    break;
            }

            if (_handle == null)
                _handle = _session.RequestOpen(path, flags);

            _attributes = _session.RequestFStat(_handle);

            _readBufferSize = (int)session.CalculateOptimalReadLength((uint)bufferSize);
            _readBuffer = new byte[_readBufferSize];
            _writeBufferSize = (int)session.CalculateOptimalWriteLength((uint)bufferSize, _handle);
            _writeBuffer = new byte[_writeBufferSize];

            if (mode == FileMode.Append)
            {
                _position = _attributes.Size;
                _serverFilePosition = (ulong)_attributes.Size;
            }
        }

        /// <summary>
        /// Releases unmanaged resources and performs other cleanup operations before the
        /// <see cref="SftpFileStream"/> is reclaimed by garbage collection.
        /// </summary>
        ~SftpFileStream()
        {
            Dispose(false);
        }

        /// <summary>
        /// Closes the current stream and releases any resources (such as sockets and file handles) associated with the current stream.
        /// </summary>
        public override void Close()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Clears all buffers for this stream and causes any buffered data to be written to the file.
        /// </summary>
        /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        /// <exception cref="ObjectDisposedException">Stream is closed.</exception>
        public override void Flush()
        {
            lock (_lock)
            {
                CheckSessionIsOpen();

                if (_bufferOwnedByWrite)
                {
                    FlushWriteBuffer();
                }
                else
                {
                    FlushReadBuffer();
                }
            }
        }

        /// <summary>
        /// Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
        /// </summary>
        /// <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset"/> and (<paramref name="offset"/> + <paramref name="count"/> - 1) replaced by the bytes read from the current source.</param>
        /// <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin storing the data read from the current stream.</param>
        /// <param name="count">The maximum number of bytes to be read from the current stream.</param>
        /// <returns>
        /// The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
        /// </returns>
        /// <exception cref="T:System.ArgumentException">The sum of <paramref name="offset"/> and <paramref name="count"/> is larger than the buffer length. </exception>
        /// <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null. </exception>
        /// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> or <paramref name="count"/> is negative.</exception>
        /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        /// <exception cref="T:System.NotSupportedException">The stream does not support reading. </exception>
        /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
        public override int Read(byte[] buffer, int offset, int count)
        {
            int readLen = 0;

            if (buffer == null)
                throw new ArgumentNullException("buffer");
            if (offset < 0)
                throw new ArgumentOutOfRangeException("offset");
            if (count < 0)
                throw new ArgumentOutOfRangeException("count");
            if ((buffer.Length - offset) < count)
                throw new ArgumentException("Invalid array range.");

            // Lock down the file stream while we do this.
            lock (_lock)
            {
                CheckSessionIsOpen();

                // Set up for the read operation.
                SetupRead();

                // Read data into the caller's buffer.
                while (count > 0)
                {
                    // How much data do we have available in the buffer?
                    var tempLen = _bufferLen - _bufferPosition;
                    if (tempLen <= 0)
                    {
                        _bufferPosition = 0;

                        var data = _session.RequestRead(_handle, (ulong)_position, (uint)_readBufferSize);

                        _bufferLen = data.Length;

                        Buffer.BlockCopy(data, 0, _readBuffer, 0, _bufferLen);
                        _serverFilePosition = (ulong)_position;

                        if (_bufferLen < 0)
                        {
                            _bufferLen = 0;
                            //OneCodeTODO:   Add SFTP error code or message if possible
                            throw new IOException("Read operation failed.");
                        }
                        if (_bufferLen == 0)
                        {
                            break;
                        }
                        tempLen = _bufferLen;
                    }

                    // Don't read more than the caller wants.
                    if (tempLen > count)
                    {
                        tempLen = count;
                    }

                    // Copy stream data to the caller's buffer.
                    Buffer.BlockCopy(_readBuffer, _bufferPosition, buffer, offset, tempLen);

                    // Advance to the next buffer positions.
                    readLen += tempLen;
                    offset += tempLen;
                    count -= tempLen;
                    _bufferPosition += tempLen;
                    _position += tempLen;
                }
            }

            // Return the number of bytes that were read to the caller.
            return readLen;
        }

        /// <summary>
        /// Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.
        /// </summary>
        /// <returns>
        /// The unsigned byte cast to an Int32, or -1 if at the end of the stream.
        /// </returns>
        /// <exception cref="T:System.NotSupportedException">The stream does not support reading. </exception>
        /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
        /// <exception cref="System.IO.IOException">Read operation failed.</exception>
        public override int ReadByte()
        {
            // Lock down the file stream while we do this.
            lock (_lock)
            {
                CheckSessionIsOpen();

                // Setup the object for reading.
                SetupRead();

                // Read more data into the internal buffer if necessary.
                if (_bufferPosition >= _bufferLen)
                {
                    _bufferPosition = 0;

                    var data = _session.RequestRead(_handle, (ulong)_position, (uint)_readBufferSize);

                    _bufferLen = data.Length;
                    Buffer.BlockCopy(data, 0, _readBuffer, 0, _readBufferSize);
                    _serverFilePosition = (ulong)_position;

                    if (_bufferLen < 0)
                    {
                        _bufferLen = 0;
                        //OneCodeTODO:   Add SFTP error code or message if possible
                        throw new IOException("Read operation failed.");
                    }
                    if (_bufferLen == 0)
                    {
                        // We've reached EOF.
                        return -1;
                    }
                }

                // Extract the next byte from the buffer.
                ++_position;
                return _readBuffer[_bufferPosition++];
            }
        }

        /// <summary>
        /// Sets the position within the current stream.
        /// </summary>
        /// <param name="offset">A byte offset relative to the <paramref name="origin"/> parameter.</param>
        /// <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"/> indicating the reference point used to obtain the new position.</param>
        /// <returns>
        /// The new position within the current stream.
        /// </returns>
        /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        /// <exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output. </exception>
        /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
        public override long Seek(long offset, SeekOrigin origin)
        {
            long newPosn = -1;

            // Lock down the file stream while we do this.
            lock (_lock)
            {
                CheckSessionIsOpen();

                if (!CanSeek)
                    throw new NotSupportedException("Seek is not supported.");

                // Don't do anything if the position won't be moving.
                if (origin == SeekOrigin.Begin && offset == _position)
                {
                    return offset;
                }
                if (origin == SeekOrigin.Current && offset == 0)
                {
                    return _position;
                }

                _attributes = _session.RequestFStat(_handle);

                // The behaviour depends upon the read/write mode.
                if (_bufferOwnedByWrite)
                {
                    // Flush the write buffer and then seek.
                    FlushWriteBuffer();

                    switch (origin)
                    {
                        case SeekOrigin.Begin:
                            newPosn = offset;
                            break;
                        case SeekOrigin.Current:
                            newPosn = _position + offset;
                            break;
                        case SeekOrigin.End:
                            newPosn = _attributes.Size - offset;
                            break;
                    }

                    if (newPosn == -1)
                    {
                        throw new EndOfStreamException("End of stream.");
                    }
                    _position = newPosn;
                    _serverFilePosition = (ulong)newPosn;
                }
                else
                {
                    // Determine if the seek is to somewhere inside
                    // the current read buffer bounds.
                    if (origin == SeekOrigin.Begin)
                    {
                        newPosn = _position - _bufferPosition;
                        if (offset >= newPosn && offset <
                                (newPosn + _bufferLen))
                        {
                            _bufferPosition = (int)(offset - newPosn);
                            _position = offset;
                            return _position;
                        }
                    }
                    else if (origin == SeekOrigin.Current)
                    {
                        newPosn = _position + offset;
                        if (newPosn >= (_position - _bufferPosition) &&
                           newPosn < (_position - _bufferPosition + _bufferLen))
                        {
                            _bufferPosition =
                                (int)(newPosn - (_position - _bufferPosition));
                            _position = newPosn;
                            return _position;
                        }
                    }

                    // Abandon the read buffer.
                    _bufferPosition = 0;
                    _bufferLen = 0;

                    // Seek to the new position.
                    switch (origin)
                    {
                        case SeekOrigin.Begin:
                            newPosn = offset;
                            break;
                        case SeekOrigin.Current:
                            newPosn = _position + offset;
                            break;
                        case SeekOrigin.End:
                            newPosn = _attributes.Size - offset;
                            break;
                    }

                    if (newPosn < 0)
                    {
                        throw new EndOfStreamException();
                    }

                    _position = newPosn;
                }
                return _position;
            }
        }

        /// <summary>
        /// When overridden in a derived class, sets the length of the current stream.
        /// </summary>
        /// <param name="value">The desired length of the current stream in bytes.</param>
        /// <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        /// <exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output.</exception>
        /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="value"/> must be greater than zero.</exception>
        public override void SetLength(long value)
        {
            if (value < 0)
                throw new ArgumentOutOfRangeException("value");

            // Lock down the file stream while we do this.
            lock (_lock)
            {
                CheckSessionIsOpen();

                if (!CanSeek)
                    throw new NotSupportedException("Seek is not supported.");

                SetupWrite();
                _attributes.Size = value;
                _session.RequestFSetStat(_handle, _attributes);
            }
        }

        /// <summary>
        /// Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
        /// </summary>
        /// <param name="buffer">An array of bytes. This method copies <paramref name="count"/> bytes from <paramref name="buffer"/> to the current stream.</param>
        /// <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin copying bytes to the current stream.</param>
        /// <param name="count">The number of bytes to be written to the current stream.</param>
        /// <exception cref="T:System.ArgumentException">The sum of <paramref name="offset"/> and <paramref name="count"/> is greater than the buffer length.</exception>
        /// <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null.</exception>
        /// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> or <paramref name="count"/> is negative.</exception>
        /// <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        /// <exception cref="T:System.NotSupportedException">The stream does not support writing.</exception>
        /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        public override void Write(byte[] buffer, int offset, int count)
        {
            if (buffer == null)
                throw new ArgumentNullException("buffer");
            if (offset < 0)
                throw new ArgumentOutOfRangeException("offset");
            if (count < 0)
                throw new ArgumentOutOfRangeException("count");
            if ((buffer.Length - offset) < count)
                throw new ArgumentException("Invalid array range.");

            // Lock down the file stream while we do this.
            lock (_lock)
            {
                CheckSessionIsOpen();

                // Setup this object for writing.
                SetupWrite();

                // Write data to the file stream.
                while (count > 0)
                {
                    // Determine how many bytes we can write to the buffer.
                    var tempLen = _writeBufferSize - _bufferPosition;
                    if (tempLen <= 0)
                    {
                        var data = new byte[_bufferPosition];

                        Buffer.BlockCopy(_writeBuffer, 0, data, 0, _bufferPosition);

                        using (var wait = new AutoResetEvent(false))
                        {
                            _session.RequestWrite(_handle, _serverFilePosition, data, wait);
                            _serverFilePosition += (ulong)data.Length;
                        }

                        _bufferPosition = 0;
                        tempLen = _writeBufferSize;
                    }
                    if (tempLen > count)
                    {
                        tempLen = count;
                    }

                    // Can we short-cut the internal buffer?
                    if (_bufferPosition == 0 && tempLen == _writeBufferSize)
                    {
                        // Yes: write the data directly to the file.
                        var data = new byte[tempLen];

                        Buffer.BlockCopy(buffer, offset, data, 0, tempLen);

                        using (var wait = new AutoResetEvent(false))
                        {
                            _session.RequestWrite(_handle, _serverFilePosition, data, wait);
                            _serverFilePosition += (ulong)data.Length;
                        }
                    }
                    else
                    {
                        // No: copy the data to the write buffer first.
                        Buffer.BlockCopy(buffer, offset, _writeBuffer, _bufferPosition, tempLen);
                        _bufferPosition += tempLen;
                    }

                    // Advance the buffer and stream positions.
                    _position += tempLen;
                    offset += tempLen;
                    count -= tempLen;
                }

                // If the buffer is full, then do a speculative flush now,
                // rather than waiting for the next call to this method.
                if (_bufferPosition >= _writeBufferSize)
                {
                    var data = new byte[_bufferPosition];

                    Buffer.BlockCopy(_writeBuffer, 0, data, 0, _bufferPosition);

                    using (var wait = new AutoResetEvent(false))
                    {
                        _session.RequestWrite(_handle, _serverFilePosition, data, wait);
                        _serverFilePosition += (ulong)data.Length;
                    }

                    _bufferPosition = 0;
                }
            }
        }

        /// <summary>
        /// Writes a byte to the current position in the stream and advances the position within the stream by one byte.
        /// </summary>
        /// <param name="value">The byte to write to the stream.</param>
        /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        /// <exception cref="T:System.NotSupportedException">The stream does not support writing, or the stream is already closed. </exception>
        /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
        public override void WriteByte(byte value)
        {
            // Lock down the file stream while we do this.
            lock (_lock)
            {
                CheckSessionIsOpen();

                // Setup the object for writing.
                SetupWrite();

                // Flush the current buffer if it is full.
                if (_bufferPosition >= _writeBufferSize)
                {
                    var data = new byte[_bufferPosition];

                    Buffer.BlockCopy(_writeBuffer, 0, data, 0, _bufferPosition);

                    using (var wait = new AutoResetEvent(false))
                    {
                        _session.RequestWrite(_handle, _serverFilePosition, data, wait);
                        _serverFilePosition += (ulong)data.Length;
                    }

                    _bufferPosition = 0;
                }

                // Write the byte into the buffer and advance the posn.
                _writeBuffer[_bufferPosition++] = value;
                ++_position;
            }
        }

        /// <summary>
        /// Releases the unmanaged resources used by the <see cref="T:System.IO.Stream"/> and optionally releases the managed resources.
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);

            if (_session != null)
            {
                if (disposing)
                {
                    lock (_lock)
                    {
                        if (_session != null)
                        {
                            _canRead = false;
                            _canSeek = false;
                            _canWrite = false;

                            if (_handle != null)
                            {
                                if (_session.IsOpen)
                                {
                                    if (_bufferOwnedByWrite)
                                    {
                                        FlushWriteBuffer();
                                    }

                                    if (_ownsHandle)
                                    {
                                        _session.RequestClose(_handle);
                                    }
                                }

                                _handle = null;
                            }

                            _session = null;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Flushes the read data from the buffer.
        /// </summary>
        private void FlushReadBuffer()
        {
            if (_canSeek)
            {
                if (_bufferPosition < _bufferLen)
                {
                    _position -= _bufferPosition;
                }
                _bufferPosition = 0;
                _bufferLen = 0;
            }
        }

        /// <summary>
        /// Flush any buffered write data to the file.
        /// </summary>
        private void FlushWriteBuffer()
        {
            if (_bufferPosition > 0)
            {
                var data = new byte[_bufferPosition];

                Buffer.BlockCopy(_writeBuffer, 0, data, 0, _bufferPosition);

                using (var wait = new AutoResetEvent(false))
                {
                    _session.RequestWrite(_handle, _serverFilePosition, data, wait);
                    _serverFilePosition += (ulong)data.Length;
                }

                _bufferPosition = 0;
            }
        }

        /// <summary>
        /// Setups the read.
        /// </summary>
        private void SetupRead()
        {
            if (!CanRead)
                throw new NotSupportedException("Read not supported.");

            if (_bufferOwnedByWrite)
            {
                FlushWriteBuffer();
                _bufferOwnedByWrite = false;
            }
        }

        /// <summary>
        /// Setups the write.
        /// </summary>
        private void SetupWrite()
        {
            if ((!CanWrite))
                throw new NotSupportedException("Write not supported.");

            if (!_bufferOwnedByWrite)
            {
                FlushReadBuffer();
                _bufferOwnedByWrite = true;
            }
        }

        private void CheckSessionIsOpen()
        {
            if (_session == null)
                throw new ObjectDisposedException(GetType().FullName);
            if (!_session.IsOpen)
                throw new ObjectDisposedException(GetType().FullName, "Cannot access a closed SFTP session.");
        }
    }
}
#endif
// file ...\X\Renci.SshNet\Sftp\SftpFileSystemInformation.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Sftp
{
    /// <summary>
    /// Contains File system information exposed by statvfs@openssh.com request.
    /// </summary>
    public class SftpFileSytemInformation
    {
        private readonly ulong _flag;

        private const ulong SSH_FXE_STATVFS_ST_RDONLY = 0x1;

        private const ulong SSH_FXE_STATVFS_ST_NOSUID = 0x2;

        /// <summary>
        /// Gets the size of the block.
        /// </summary>
        /// <value>
        /// The size of the block.
        /// </value>
        public ulong BlockSize { get; private set; }

        /// <summary>
        /// Gets the total blocks.
        /// </summary>
        /// <value>
        /// The total blocks.
        /// </value>
        public ulong TotalBlocks { get; private set; }

        /// <summary>
        /// Gets the free blocks.
        /// </summary>
        /// <value>
        /// The free blocks.
        /// </value>
        public ulong FreeBlocks { get; private set; }

        /// <summary>
        /// Gets the available blocks.
        /// </summary>
        /// <value>
        /// The available blocks.
        /// </value>
        public ulong AvailableBlocks { get; private set; }

        /// <summary>
        /// Gets the total nodes.
        /// </summary>
        /// <value>
        /// The total nodes.
        /// </value>
        public ulong TotalNodes { get; private set; }

        /// <summary>
        /// Gets the free nodes.
        /// </summary>
        /// <value>
        /// The free nodes.
        /// </value>
        public ulong FreeNodes { get; private set; }

        /// <summary>
        /// Gets the available nodes.
        /// </summary>
        /// <value>
        /// The available nodes.
        /// </value>
        public ulong AvailableNodes { get; private set; }

        /// <summary>
        /// Gets the sid.
        /// </summary>
        /// <value>
        /// The sid.
        /// </value>
        public ulong Sid { get; private set; }

        /// <summary>
        /// Gets a value indicating whether this instance is read only.
        /// </summary>
        /// <value>
        /// <c>true</c> if this instance is read only; otherwise, <c>false</c>.
        /// </value>
        public bool IsReadOnly
        {
            get { return (_flag & SSH_FXE_STATVFS_ST_RDONLY) == SSH_FXE_STATVFS_ST_RDONLY; }
        }

        /// <summary>
        /// Gets a value indicating whether [supports set uid].
        /// </summary>
        /// <value>
        ///   <c>true</c> if [supports set uid]; otherwise, <c>false</c>.
        /// </value>
        public bool SupportsSetUid
        {
            get { return (_flag & SSH_FXE_STATVFS_ST_NOSUID) == 0; }
        }

        /// <summary>
        /// Gets the max name lenght.
        /// </summary>
        /// <value>
        /// The max name lenght.
        /// </value>
        public ulong MaxNameLenght { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpFileSytemInformation" /> class.
        /// </summary>
        /// <param name="bsize">The bsize.</param>
        /// <param name="frsize">The frsize.</param>
        /// <param name="blocks">The blocks.</param>
        /// <param name="bfree">The bfree.</param>
        /// <param name="bavail">The bavail.</param>
        /// <param name="files">The files.</param>
        /// <param name="ffree">The ffree.</param>
        /// <param name="favail">The favail.</param>
        /// <param name="sid">The sid.</param>
        /// <param name="flag">The flag.</param>
        /// <param name="namemax">The namemax.</param>
        internal SftpFileSytemInformation(ulong bsize, ulong frsize, ulong blocks, ulong bfree, ulong bavail, ulong files, ulong ffree, ulong favail, ulong sid, ulong flag, ulong namemax)
        {
            this.BlockSize = frsize;
            this.TotalBlocks = blocks;
            this.FreeBlocks = bfree;
            this.AvailableBlocks = bavail;
            this.TotalNodes = files;
            this.FreeNodes = ffree;
            this.AvailableNodes = favail;
            this.Sid = sid;
            this._flag = flag;
            this.MaxNameLenght = namemax;
        }
    }
}
#endif
// file ...\X\Renci.SshNet\Sftp\SftpListDirectoryAsyncResult.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp
{
    /// <summary>
    /// Encapsulates the results of an asynchronous directory list operation.
    /// </summary>
    public class SftpListDirectoryAsyncResult : AsyncResult<IEnumerable<SftpFile>>
    {
        /// <summary>
        /// Gets the number of files read so far.
        /// </summary>
        public int FilesRead { get; private set; }
        
        /// <summary>
        /// Initializes a new instance of the <see cref="SftpListDirectoryAsyncResult"/> class.
        /// </summary>
        /// <param name="asyncCallback">The async callback.</param>
        /// <param name="state">The state.</param>
        public SftpListDirectoryAsyncResult(AsyncCallback asyncCallback, Object state)
            : base(asyncCallback, state)
        {

        }

        /// <summary>
        /// Updates asynchronous operation status information.
        /// </summary>
        /// <param name="filesRead">The files read.</param>
        internal void Update(int filesRead)
        {
            this.FilesRead = filesRead;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\SftpMessage.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp
{
    public abstract class SftpMessage : SshData
    {
        public static SftpMessage Load(uint protocolVersion, byte[] data, Encoding encoding)
        {
            var messageType = (SftpMessageTypes)data.FirstOrDefault();

            return Load(protocolVersion, data, messageType, encoding);
        }

        protected override int ZeroReaderIndex
        {
            get
            {
                return 1;
            }
        }

        public abstract SftpMessageTypes SftpMessageType { get; }

        protected override void LoadData()
        {
        }

        protected override void SaveData()
        {
            this.Write((byte)this.SftpMessageType);
        }

        protected SftpFileAttributes ReadAttributes()
        {

            var flag = this.ReadUInt32();

            long size = -1;
            int userId = -1;
            int groupId = -1;
            uint permissions = 0;
            var accessTime = DateTime.MinValue;
            var modifyTime = DateTime.MinValue;
            IDictionary<string, string> extensions = null;

            if ((flag & 0x00000001) == 0x00000001)   //  SSH_FILEXFER_ATTR_SIZE
            {
                size = (long)this.ReadUInt64();
            }

            if ((flag & 0x00000002) == 0x00000002)   //  SSH_FILEXFER_ATTR_UIDGID
            {
                userId = (int)this.ReadUInt32();

                groupId = (int)this.ReadUInt32();
            }

            if ((flag & 0x00000004) == 0x00000004)   //  SSH_FILEXFER_ATTR_PERMISSIONS
            {
                permissions = this.ReadUInt32();
            }

            if ((flag & 0x00000008) == 0x00000008)   //  SSH_FILEXFER_ATTR_ACMODTIME
            {
                var time = this.ReadUInt32();
                accessTime = DateTime.FromFileTime((time + 11644473600) * 10000000);
                time = this.ReadUInt32();
                modifyTime = DateTime.FromFileTime((time + 11644473600) * 10000000);
            }

            if ((flag & 0x80000000) == 0x80000000)   //  SSH_FILEXFER_ATTR_ACMODTIME
            {
                var extendedCount = this.ReadUInt32();
                extensions = this.ReadExtensionPair();
            }
            var attributes = new SftpFileAttributes(accessTime, modifyTime, size, userId, groupId, permissions, extensions);

            return attributes;
        }

        protected void Write(SftpFileAttributes attributes)
        {
            if (attributes == null)
            {
                this.Write((uint)0);
                return;
            }

            UInt32 flag = 0;

            if (attributes.IsSizeChanged && attributes.IsRegularFile)
            {
                flag |= 0x00000001;
            }

            if (attributes.IsUserIdChanged|| attributes.IsGroupIdChanged)
            {
                flag |= 0x00000002;
            }

            if (attributes.IsPermissionsChanged)
            {
                flag |= 0x00000004;
            }

            if (attributes.IsLastAccessTimeChanged || attributes.IsLastWriteTimeChanged)
            {
                flag |= 0x00000008;
            }

            if (attributes.IsExtensionsChanged)
            {
                flag |= 0x80000000;
            }

            this.Write(flag);

            if (attributes.IsSizeChanged && attributes.IsRegularFile)
            {
                this.Write((UInt64)attributes.Size);
            }

            if (attributes.IsUserIdChanged|| attributes.IsGroupIdChanged)
            {
                this.Write((UInt32)attributes.UserId);
                this.Write((UInt32)attributes.GroupId);
            }

            if (attributes.IsPermissionsChanged)
            {
                this.Write(attributes.Permissions);
            }

            if (attributes.IsLastAccessTimeChanged || attributes.IsLastWriteTimeChanged)
            {
                var time = (uint)(attributes.LastAccessTime.ToFileTime() / 10000000 - 11644473600);
                this.Write(time);
                time = (uint)(attributes.LastWriteTime.ToFileTime() / 10000000 - 11644473600);
                this.Write(time);
            }

            if (attributes.IsExtensionsChanged)
            {
                this.Write(attributes.Extensions);
            }
        }

        private static SftpMessage Load(uint protocolVersion, byte[] data, SftpMessageTypes messageType, Encoding encoding)
        {
            SftpMessage message;

            switch (messageType)
            {
                case SftpMessageTypes.Version:
                    message = new SftpVersionResponse();
                    break;
                case SftpMessageTypes.Status:
                    message = new SftpStatusResponse(protocolVersion);
                    break;
                case SftpMessageTypes.Data:
                    message = new SftpDataResponse(protocolVersion);
                    break;
                case SftpMessageTypes.Handle:
                    message = new SftpHandleResponse(protocolVersion);
                    break;
                case SftpMessageTypes.Name:
                    message = new SftpNameResponse(protocolVersion, encoding);
                    break;
                case SftpMessageTypes.Attrs:
                    message = new SftpAttrsResponse(protocolVersion);
                    break;
                case SftpMessageTypes.ExtendedReply:
                    message = new SftpExtendedReplyResponse(protocolVersion);
                    break;
                default:
                    throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "Message type '{0}' is not supported.", messageType));
            }

            message.LoadBytes(data);

            message.ResetReader();

            message.LoadData();

            return message;
        }

        public override string ToString()
        {
            return string.Format(CultureInfo.CurrentCulture, "SFTP Message : {0}", this.SftpMessageType);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\SftpMessageTypes.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp
{
    public enum SftpMessageTypes : byte
    {
        /// <summary>
        /// SSH_FXP_INIT
        /// </summary>
        Init = 1,
        /// <summary>
        /// SSH_FXP_VERSION
        /// </summary>
        Version = 2,
        /// <summary>
        /// SSH_FXP_OPEN
        /// </summary>
        Open = 3,
        /// <summary>
        /// SSH_FXP_CLOSE
        /// </summary>
        Close = 4,
        /// <summary>
        /// SSH_FXP_READ
        /// </summary>
        Read = 5,
        /// <summary>
        /// SSH_FXP_WRITE
        /// </summary>
        Write = 6,
        /// <summary>
        /// SSH_FXP_LSTAT
        /// </summary>
        LStat = 7,
        /// <summary>
        /// SSH_FXP_FSTAT
        /// </summary>
        FStat = 8,
        /// <summary>
        /// SSH_FXP_SETSTAT
        /// </summary>
        SetStat = 9,
        /// <summary>
        /// SSH_FXP_FSETSTAT
        /// </summary>
        FSetStat = 10,
        /// <summary>
        /// SSH_FXP_OPENDIR
        /// </summary>
        OpenDir = 11,
        /// <summary>
        /// SSH_FXP_READDIR
        /// </summary>
        ReadDir = 12,
        /// <summary>
        /// SSH_FXP_REMOVE
        /// </summary>
        Remove = 13,
        /// <summary>
        /// SSH_FXP_MKDIR
        /// </summary>
        MkDir = 14,
        /// <summary>
        /// SSH_FXP_RMDIR
        /// </summary>
        RmDir = 15,
        /// <summary>
        /// SSH_FXP_REALPATH
        /// </summary>
        RealPath = 16,
        /// <summary>
        /// SSH_FXP_STAT
        /// </summary>
        Stat = 17,
        /// <summary>
        /// SSH_FXP_RENAME
        /// </summary>
        Rename = 18,
        /// <summary>
        /// SSH_FXP_READLINK
        /// </summary>
        ReadLink = 19,
        /// <summary>
        /// SSH_FXP_SYMLINK
        /// </summary>
        SymLink = 20,
        /// <summary>
        /// SSH_FXP_LINK
        /// </summary>
        Link = 21,
        /// <summary>
        /// SSH_FXP_BLOCK
        /// </summary>
        Block = 22,
        /// <summary>
        /// SSH_FXP_UNBLOCK
        /// </summary>
        Unblock = 23,

        /// <summary>
        /// SSH_FXP_STATUS
        /// </summary>
        Status = 101,
        /// <summary>
        /// SSH_FXP_HANDLE
        /// </summary>
        Handle = 102,
        /// <summary>
        /// SSH_FXP_DATA
        /// </summary>
        Data = 103,
        /// <summary>
        /// SSH_FXP_NAME
        /// </summary>
        Name = 104,
        /// <summary>
        /// SSH_FXP_ATTRS
        /// </summary>
        Attrs = 105,

        /// <summary>
        /// SSH_FXP_EXTENDED
        /// </summary>
        Extended = 200,
        /// <summary>
        /// SSH_FXP_EXTENDED_REPLY
        /// </summary>
        ExtendedReply = 201

    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\SftpSession.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp
{
    public class SftpSession : SubsystemSession, ISftpSession
    {
        private const int MaximumSupportedVersion = 3;

        private const int MinimumSupportedVersion = 0;

        private readonly Dictionary<uint, SftpRequest> _requests = new Dictionary<uint, SftpRequest>();

        private readonly List<byte> _data = new List<byte>(16 * 1024);

        private EventWaitHandle _sftpVersionConfirmed = new AutoResetEvent(false);

        private IDictionary<string, string> _supportedExtensions;

        /// <summary>
        /// Gets the remote working directory.
        /// </summary>
        /// <value>
        /// The remote working directory.
        /// </value>
        public string WorkingDirectory { get; private set; }

        /// <summary>
        /// Gets the SFTP protocol version.
        /// </summary>
        /// <value>
        /// The SFTP protocol version.
        /// </value>
        public uint ProtocolVersion { get; private set; }

        private long _requestId;
        /// <summary>
        /// Gets the next request id for sftp session.
        /// </summary>
        public uint NextRequestId
        {
            get
            {
#if WINDOWS_PHONE
                lock (this)
                {
                    this._requestId++;
                }

                return (uint)this._requestId;
#else
                return ((uint)Interlocked.Increment(ref _requestId));
#endif
            }
        }

        public SftpSession(ISession session, TimeSpan operationTimeout, Encoding encoding)
            : base(session, "sftp", operationTimeout, encoding)
        {
        }

        /// <summary>
        /// Changes the current working directory to the specified path.
        /// </summary>
        /// <param name="path">The new working directory.</param>
        public void ChangeDirectory(string path)
        {
            var fullPath = GetCanonicalPath(path);

            var handle = RequestOpenDir(fullPath);

            RequestClose(handle);

            WorkingDirectory = fullPath;
        }

        internal void SendMessage(SftpMessage sftpMessage)
        {
            var messageData = sftpMessage.GetBytes();

            var data = new byte[4 + messageData.Length];

            ((uint)messageData.Length).GetBytes().CopyTo(data, 0);
            messageData.CopyTo(data, 4);

            SendData(data);
        }

        /// <summary>
        /// Resolves a given path into an absolute path on the server.
        /// </summary>
        /// <param name="path">The path to resolve.</param>
        /// <returns>
        /// The absolute path.
        /// </returns>
        public string GetCanonicalPath(string path)
        {
            var fullPath = GetFullRemotePath(path);

            var canonizedPath = string.Empty;

            var realPathFiles = RequestRealPath(fullPath, true);

            if (realPathFiles != null)
            {
                canonizedPath = realPathFiles.First().Key;
            }

            if (!string.IsNullOrEmpty(canonizedPath))
                return canonizedPath;

            //  Check for special cases
            if (fullPath.EndsWith("/.", StringComparison.InvariantCultureIgnoreCase) ||
                fullPath.EndsWith("/..", StringComparison.InvariantCultureIgnoreCase) ||
                fullPath.Equals("/", StringComparison.InvariantCultureIgnoreCase) ||
                fullPath.IndexOf('/') < 0)
                return fullPath;

            var pathParts = fullPath.Split(new[] { '/' });

            var partialFullPath = string.Join("/", pathParts, 0, pathParts.Length - 1);

            if (string.IsNullOrEmpty(partialFullPath))
                partialFullPath = "/";

            realPathFiles = RequestRealPath(partialFullPath, true);

            if (realPathFiles != null)
            {
                canonizedPath = realPathFiles.First().Key;
            }

            if (string.IsNullOrEmpty(canonizedPath))
            {
                return fullPath;
            }

            var slash = string.Empty;
            if (canonizedPath[canonizedPath.Length - 1] != '/')
                slash = "/";
            return string.Format(CultureInfo.InvariantCulture, "{0}{1}{2}", canonizedPath, slash, pathParts[pathParts.Length - 1]);
        }

        internal string GetFullRemotePath(string path)
        {
            var fullPath = path;

            if (!string.IsNullOrEmpty(path) && path[0] != '/' && WorkingDirectory != null)
            {
                if (WorkingDirectory[WorkingDirectory.Length - 1] == '/')
                {
                    fullPath = string.Format(CultureInfo.InvariantCulture, "{0}{1}", WorkingDirectory, path);
                }
                else
                {
                    fullPath = string.Format(CultureInfo.InvariantCulture, "{0}/{1}", WorkingDirectory, path);
                }
            }
            return fullPath;
        }

        protected override void OnChannelOpen()
        {
            SendMessage(new SftpInitRequest(MaximumSupportedVersion));

            WaitOnHandle(_sftpVersionConfirmed, OperationTimeout);

            if (ProtocolVersion > MaximumSupportedVersion || ProtocolVersion < MinimumSupportedVersion)
            {
                throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "Server SFTP version {0} is not supported.", ProtocolVersion));
            }

            //  Resolve current directory
            WorkingDirectory = RequestRealPath(".").First().Key;
        }

        protected override void OnDataReceived(uint dataTypeCode, byte[] data)
        {
            //  Add channel data to internal data holder
            _data.AddRange(data);

            while (_data.Count > 4 + 1)
            {
                //  Extract packet length
                var packetLength = (_data[0] << 24 | _data[1] << 16 | _data[2] << 8 | _data[3]);

                //  Check if complete packet data is available
                if (_data.Count < packetLength + 4)
                {
                    //  Wait for complete message to arrive first
                    break;
                }
                _data.RemoveRange(0, 4);

                //  Create buffer to hold packet data
                var packetData = new byte[packetLength];

                //  Cope packet data to array
                _data.CopyTo(0, packetData, 0, packetLength);

                //  Remove loaded data from _data holder
                _data.RemoveRange(0, packetLength);

                //  Load SFTP Message and handle it
                var response = SftpMessage.Load(ProtocolVersion, packetData, Encoding);

                try
                {
                    var versionResponse = response as SftpVersionResponse;
                    if (versionResponse != null)
                    {
                        ProtocolVersion = versionResponse.Version;
                        _supportedExtensions = versionResponse.Extentions;

                        _sftpVersionConfirmed.Set();
                    }
                    else
                    {
                        HandleResponse(response as SftpResponse);
                    }
                }
                catch (Exception exp)
                {
                    RaiseError(exp);
                    break;
                }
            }
        }

        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);

            if (disposing)
            {
                if (_sftpVersionConfirmed != null)
                {
                    _sftpVersionConfirmed.Dispose();
                    _sftpVersionConfirmed = null;
                }
            }
        }

        private void SendRequest(SftpRequest request)
        {
            lock (_requests)
            {
                _requests.Add(request.RequestId, request);
            }

            SendMessage(request);
        }

        #region SFTP API functions

        /// <summary>
        /// Performs SSH_FXP_OPEN request
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="flags">The flags.</param>
        /// <param name="nullOnError">if set to <c>true</c> returns <c>null</c> instead of throwing an exception.</param>
        /// <returns>File handle.</returns>
        public byte[] RequestOpen(string path, Flags flags, bool nullOnError = false)
        {
            byte[] handle = null;
            SshException exception = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new SftpOpenRequest(ProtocolVersion, NextRequestId, path, Encoding, flags,
                    response =>
                        {
                            handle = response.Handle;
                            wait.Set();
                        },
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (!nullOnError && exception != null)
            {
                throw exception;
            }

            return handle;
        }

        /// <summary>
        /// Performs SSH_FXP_CLOSE request.
        /// </summary>
        /// <param name="handle">The handle.</param>
        public void RequestClose(byte[] handle)
        {
            SshException exception = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new SftpCloseRequest(ProtocolVersion, NextRequestId, handle,
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (exception != null)
            {
                throw exception;
            }
        }

        /// <summary>
        /// Performs SSH_FXP_READ request.
        /// </summary>
        /// <param name="handle">The handle.</param>
        /// <param name="offset">The offset.</param>
        /// <param name="length">The length.</param>
        /// <returns>data array; null if EOF</returns>
        public byte[] RequestRead(byte[] handle, ulong offset, uint length)
        {
            SshException exception = null;

            var data = new byte[0];

            using (var wait = new AutoResetEvent(false))
            {
                var request = new SftpReadRequest(ProtocolVersion, NextRequestId, handle, offset, length,
                    response =>
                        {
                            data = response.Data;
                            wait.Set();
                        },
                    response =>
                        {
                            if (response.StatusCode != StatusCodes.Eof)
                            {
                                exception = GetSftpException(response);
                            }
                            wait.Set();
                        });

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (exception != null)
            {
                throw exception;
            }

            return data;
        }

        /// <summary>
        /// Performs SSH_FXP_WRITE request.
        /// </summary>
        /// <param name="handle">The handle.</param>
        /// <param name="offset">The offset.</param>
        /// <param name="data">The data to send.</param>
        /// <param name="wait">The wait event handle if needed.</param>
        /// <param name="writeCompleted">The callback to invoke when the write has completed.</param>
        public void RequestWrite(byte[] handle, ulong offset, byte[] data, AutoResetEvent wait, Action<SftpStatusResponse> writeCompleted = null)
        {
            SshException exception = null;

            var request = new SftpWriteRequest(ProtocolVersion, NextRequestId, handle, offset, data,
                response =>
                    {
                        if (writeCompleted != null)
                        {
                            writeCompleted(response);
                        }

                        exception = GetSftpException(response);
                        if (wait != null)
                            wait.Set();
                    });

            SendRequest(request);

            if (wait != null)
                WaitOnHandle(wait, OperationTimeout);

            if (exception != null)
            {
                throw exception;
            }
        }

        /// <summary>
        /// Performs SSH_FXP_LSTAT request.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <returns>
        /// File attributes
        /// </returns>
        public SftpFileAttributes RequestLStat(string path)
        {
            SshException exception = null;

            SftpFileAttributes attributes = null;
            using (var wait = new AutoResetEvent(false))
            {
                var request = new SftpLStatRequest(ProtocolVersion, NextRequestId, path, Encoding,
                    response =>
                        {
                            attributes = response.Attributes;
                            wait.Set();
                        },
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (exception != null)
            {
                throw exception;
            }

            return attributes;
        }

        /// <summary>
        /// Performs SSH_FXP_FSTAT request.
        /// </summary>
        /// <param name="handle">The handle.</param>
        /// <returns>
        /// File attributes
        /// </returns>
        public SftpFileAttributes RequestFStat(byte[] handle)
        {
            SshException exception = null;
            SftpFileAttributes attributes = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new SftpFStatRequest(ProtocolVersion, NextRequestId, handle,
                    response =>
                        {
                            attributes = response.Attributes;
                            wait.Set();
                        },
                    (response) =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (exception != null)
            {
                throw exception;
            }

            return attributes;
        }

        /// <summary>
        /// Performs SSH_FXP_SETSTAT request.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="attributes">The attributes.</param>
        public void RequestSetStat(string path, SftpFileAttributes attributes)
        {
            SshException exception = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new SftpSetStatRequest(ProtocolVersion, NextRequestId, path, Encoding, attributes,
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (exception != null)
            {
                throw exception;
            }
        }

        /// <summary>
        /// Performs SSH_FXP_FSETSTAT request.
        /// </summary>
        /// <param name="handle">The handle.</param>
        /// <param name="attributes">The attributes.</param>
        public void RequestFSetStat(byte[] handle, SftpFileAttributes attributes)
        {
            SshException exception = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new SftpFSetStatRequest(ProtocolVersion, NextRequestId, handle, attributes,
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (exception != null)
            {
                throw exception;
            }
        }

        /// <summary>
        /// Performs SSH_FXP_OPENDIR request
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="nullOnError">if set to <c>true</c> returns null instead of throwing an exception.</param>
        /// <returns>File handle.</returns>
        public byte[] RequestOpenDir(string path, bool nullOnError = false)
        {
            SshException exception = null;

            byte[] handle = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new SftpOpenDirRequest(ProtocolVersion, NextRequestId, path, Encoding,
                    response =>
                        {
                            handle = response.Handle;
                            wait.Set();
                        },
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (!nullOnError && exception != null)
            {
                throw exception;
            }

            return handle;
        }

        /// <summary>
        /// Performs SSH_FXP_READDIR request
        /// </summary>
        /// <param name="handle">The handle.</param>
        /// <returns></returns>
        public KeyValuePair<string, SftpFileAttributes>[] RequestReadDir(byte[] handle)
        {
            SshException exception = null;

            KeyValuePair<string, SftpFileAttributes>[] result = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new SftpReadDirRequest(ProtocolVersion, NextRequestId, handle,
                    response =>
                        {
                            result = response.Files;
                            wait.Set();
                        },
                    response =>
                        {
                            if (response.StatusCode != StatusCodes.Eof)
                            {
                                exception = GetSftpException(response);
                            }
                            wait.Set();
                        });

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (exception != null)
            {
                throw exception;
            }

            return result;
        }

        /// <summary>
        /// Performs SSH_FXP_REMOVE request.
        /// </summary>
        /// <param name="path">The path.</param>
        public void RequestRemove(string path)
        {
            SshException exception = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new SftpRemoveRequest(ProtocolVersion, NextRequestId, path, Encoding,
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (exception != null)
            {
                throw exception;
            }
        }

        /// <summary>
        /// Performs SSH_FXP_MKDIR request.
        /// </summary>
        /// <param name="path">The path.</param>
        public void RequestMkDir(string path)
        {
            SshException exception = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new SftpMkDirRequest(ProtocolVersion, NextRequestId, path, Encoding,
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (exception != null)
            {
                throw exception;
            }
        }

        /// <summary>
        /// Performs SSH_FXP_RMDIR request.
        /// </summary>
        /// <param name="path">The path.</param>
        public void RequestRmDir(string path)
        {
            SshException exception = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new SftpRmDirRequest(ProtocolVersion, NextRequestId, path, Encoding,
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (exception != null)
            {
                throw exception;
            }
        }

        /// <summary>
        /// Performs SSH_FXP_REALPATH request
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="nullOnError">if set to <c>true</c> returns null instead of throwing an exception.</param>
        /// <returns></returns>
        internal KeyValuePair<string, SftpFileAttributes>[] RequestRealPath(string path, bool nullOnError = false)
        {
            SshException exception = null;

            KeyValuePair<string, SftpFileAttributes>[] result = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new SftpRealPathRequest(ProtocolVersion, NextRequestId, path, Encoding,
                    response =>
                        {
                            result = response.Files;
                            wait.Set();
                        },
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (!nullOnError && exception != null)
            {
                throw exception;
            }
            
            return result;
        }

        /// <summary>
        /// Performs SSH_FXP_STAT request.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="nullOnError">if set to <c>true</c> returns null instead of throwing an exception.</param>
        /// <returns>
        /// File attributes
        /// </returns>
        internal SftpFileAttributes RequestStat(string path, bool nullOnError = false)
        {
            SshException exception = null;

            SftpFileAttributes attributes = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new SftpStatRequest(ProtocolVersion, NextRequestId, path, Encoding,
                    response =>
                        {
                            attributes = response.Attributes;
                            wait.Set();
                        },
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (!nullOnError && exception != null)
            {
                throw exception;
            }

            return attributes;
        }

        /// <summary>
        /// Performs SSH_FXP_RENAME request.
        /// </summary>
        /// <param name="oldPath">The old path.</param>
        /// <param name="newPath">The new path.</param>
        public void RequestRename(string oldPath, string newPath)
        {
            if (ProtocolVersion < 2)
            {
                throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "SSH_FXP_RENAME operation is not supported in {0} version that server operates in.", ProtocolVersion));
            }

            SshException exception = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new SftpRenameRequest(ProtocolVersion, NextRequestId, oldPath, newPath, Encoding,
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (exception != null)
            {
                throw exception;
            }
        }

        /// <summary>
        /// Performs SSH_FXP_READLINK request.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="nullOnError">if set to <c>true</c> returns null instead of throwing an exception.</param>
        /// <returns></returns>
        internal KeyValuePair<string, SftpFileAttributes>[] RequestReadLink(string path, bool nullOnError = false)
        {
            if (ProtocolVersion < 3)
            {
                throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "SSH_FXP_READLINK operation is not supported in {0} version that server operates in.", ProtocolVersion));
            }

            SshException exception = null;

            KeyValuePair<string, SftpFileAttributes>[] result = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new SftpReadLinkRequest(ProtocolVersion, NextRequestId, path, Encoding,
                    response =>
                        {
                            result = response.Files;
                            wait.Set();
                        },
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (!nullOnError && exception != null)
            {
                throw exception;
            }

            return result;
        }

        /// <summary>
        /// Performs SSH_FXP_SYMLINK request.
        /// </summary>
        /// <param name="linkpath">The linkpath.</param>
        /// <param name="targetpath">The targetpath.</param>
        public void RequestSymLink(string linkpath, string targetpath)
        {
            if (ProtocolVersion < 3)
            {
                throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "SSH_FXP_SYMLINK operation is not supported in {0} version that server operates in.", ProtocolVersion));
            }

            SshException exception = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new SftpSymLinkRequest(ProtocolVersion, NextRequestId, linkpath, targetpath, Encoding,
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (exception != null)
            {
                throw exception;
            }
        }

        #endregion

        #region SFTP Extended API functions

        /// <summary>
        /// Performs posix-rename@openssh.com extended request.
        /// </summary>
        /// <param name="oldPath">The old path.</param>
        /// <param name="newPath">The new path.</param>
        public void RequestPosixRename(string oldPath, string newPath)
        {
            if (ProtocolVersion < 3)
            {
                throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "SSH_FXP_EXTENDED operation is not supported in {0} version that server operates in.", ProtocolVersion));
            }

            SshException exception = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new PosixRenameRequest(ProtocolVersion, NextRequestId, oldPath, newPath, Encoding,
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                if (!_supportedExtensions.ContainsKey(request.Name))
                    throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "Extension method {0} currently not supported by the server.", request.Name));

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (exception != null)
            {
                throw exception;
            }
        }

        /// <summary>
        /// Performs statvfs@openssh.com extended request.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="nullOnError">if set to <c>true</c> [null on error].</param>
        /// <returns></returns>
        public SftpFileSytemInformation RequestStatVfs(string path, bool nullOnError = false)
        {
            if (ProtocolVersion < 3)
            {
                throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "SSH_FXP_EXTENDED operation is not supported in {0} version that server operates in.", ProtocolVersion));
            }

            SshException exception = null;

            SftpFileSytemInformation information = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new StatVfsRequest(ProtocolVersion, NextRequestId, path, Encoding,
                    response =>
                        {
                            information = response.GetReply<StatVfsReplyInfo>().Information;
                            wait.Set();
                        },
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                if (!_supportedExtensions.ContainsKey(request.Name))
                    throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "Extension method {0} currently not supported by the server.", request.Name));

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (!nullOnError && exception != null)
            {
                throw exception;
            }

            return information;
        }

        /// <summary>
        /// Performs fstatvfs@openssh.com extended request.
        /// </summary>
        /// <param name="handle">The file handle.</param>
        /// <param name="nullOnError">if set to <c>true</c> [null on error].</param>
        /// <returns></returns>
        /// <exception cref="System.NotSupportedException"></exception>
        internal SftpFileSytemInformation RequestFStatVfs(byte[] handle, bool nullOnError = false)
        {
            if (ProtocolVersion < 3)
            {
                throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "SSH_FXP_EXTENDED operation is not supported in {0} version that server operates in.", ProtocolVersion));
            }

            SshException exception = null;

            SftpFileSytemInformation information = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new FStatVfsRequest(ProtocolVersion, NextRequestId, handle,
                    response =>
                        {
                            information = response.GetReply<StatVfsReplyInfo>().Information;
                            wait.Set();
                        },
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                if (!_supportedExtensions.ContainsKey(request.Name))
                    throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "Extension method {0} currently not supported by the server.", request.Name));

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }
            
            if (!nullOnError && exception != null)
            {
                throw exception;
            }

            return information;
        }

        /// <summary>
        /// Performs hardlink@openssh.com extended request.
        /// </summary>
        /// <param name="oldPath">The old path.</param>
        /// <param name="newPath">The new path.</param>
        internal void HardLink(string oldPath, string newPath)
        {
            if (ProtocolVersion < 3)
            {
                throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "SSH_FXP_EXTENDED operation is not supported in {0} version that server operates in.", ProtocolVersion));
            }

            SshException exception = null;

            using (var wait = new AutoResetEvent(false))
            {
                var request = new HardLinkRequest(ProtocolVersion, NextRequestId, oldPath, newPath,
                    response =>
                        {
                            exception = GetSftpException(response);
                            wait.Set();
                        });

                if (!_supportedExtensions.ContainsKey(request.Name))
                    throw new NotSupportedException(string.Format(CultureInfo.CurrentCulture, "Extension method {0} currently not supported by the server.", request.Name));

                SendRequest(request);

                WaitOnHandle(wait, OperationTimeout);
            }

            if (exception != null)
            {
                throw exception;
            }
        }

        #endregion

        /// <summary>
        /// Calculates the optimal size of the buffer to read data from the channel.
        /// </summary>
        /// <param name="bufferSize">The buffer size configured on the client.</param>
        /// <returns>
        /// The optimal size of the buffer to read data from the channel.
        /// </returns>
        public uint CalculateOptimalReadLength(uint bufferSize)
        {
            // a SSH_FXP_DATA message has 13 bytes of protocol fields:
            // bytes 1 to 4: packet length
            // byte 5: message type
            // bytes 6 to 9: response id
            // bytes 10 to 13: length of payload‏
            //
            // most ssh servers limit the size of the payload of a SSH_MSG_CHANNEL_DATA
            // response to 16 KB; if we requested 16 KB of data, then the SSH_FXP_DATA
            // payload of the SSH_MSG_CHANNEL_DATA message would be too big (16 KB + 13 bytes), and
            // as a result, the ssh server would split this into two responses:
            // one containing 16384 bytes (13 bytes header, and 16371 bytes file data)
            // and one with the remaining 13 bytes of file data
            const uint lengthOfNonDataProtocolFields = 13u;
            var maximumPacketSize = Channel.LocalPacketSize;
            return Math.Min(bufferSize, maximumPacketSize) - lengthOfNonDataProtocolFields;
        }

        /// <summary>
        /// Calculates the optimal size of the buffer to write data on the channel.
        /// </summary>
        /// <param name="bufferSize">The buffer size configured on the client.</param>
        /// <param name="handle">The file handle.</param>
        /// <returns>
        /// The optimal size of the buffer to write data on the channel.
        /// </returns>
        /// <remarks>
        /// Currently, we do not take the remote window size into account.
        /// </remarks>
        public uint CalculateOptimalWriteLength(uint bufferSize, byte[] handle)
        {
            // 1-4: package length of SSH_FXP_WRITE message
            // 5: message type
            // 6-9: request id
            // 10-13: handle length
            // <handle>
            // 14-21: offset
            // 22-25: data length
            var lengthOfNonDataProtocolFields = 25u + (uint)handle.Length;
            var maximumPacketSize = Channel.RemotePacketSize;
            return Math.Min(bufferSize, maximumPacketSize) - lengthOfNonDataProtocolFields;
        }

        private SshException GetSftpException(SftpStatusResponse response)
        {
            if (response.StatusCode == StatusCodes.Ok)
            {
                return null;
            }
            if (response.StatusCode == StatusCodes.PermissionDenied)
            {
                return new SftpPermissionDeniedException(response.ErrorMessage);
            }
            if (response.StatusCode == StatusCodes.NoSuchFile)
            {
                return new SftpPathNotFoundException(response.ErrorMessage);
            }
            return new SshException(response.ErrorMessage);
        }

        private void HandleResponse(SftpResponse response)
        {
            SftpRequest request;
            lock (_requests)
            {
                _requests.TryGetValue(response.ResponseId, out request);
                if (request != null)
                {
                    _requests.Remove(response.ResponseId);
                }
            }

            if (request == null)
                throw new InvalidOperationException("Invalid response.");

            request.Complete(response);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\SftpSynchronizeDirectoriesAsyncResult.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp
{
    /// <summary>
    /// Encapsulates the results of an asynchronous directory synchronization operation.
    /// </summary>
    public class SftpSynchronizeDirectoriesAsyncResult : AsyncResult<IEnumerable<FileInfo>>
    {
        /// <summary>
        /// Gets the number of files read so far.
        /// </summary>
        public int FilesRead { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpListDirectoryAsyncResult" /> class.
        /// </summary>
        /// <param name="asyncCallback">The async callback.</param>
        /// <param name="state">The state.</param>
        public SftpSynchronizeDirectoriesAsyncResult(AsyncCallback asyncCallback, Object state)
            : base(asyncCallback, state)
        {
        }

        /// <summary>
        /// Updates asynchronous operation status information.
        /// </summary>
        /// <param name="filesRead">The files read.</param>
        internal void Update(int filesRead)
        {
            this.FilesRead = filesRead;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\SftpUploadAsyncResult.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp
{
    /// <summary>
    /// Encapsulates the results of an asynchronous upload operation.
    /// </summary>
    public class SftpUploadAsyncResult : AsyncResult
    {
        /// <summary>
        /// Gets or sets a value indicating whether to cancel asynchronous upload operation
        /// </summary>
        /// <value>
        /// <c>true</c> if upload operation to be canceled; otherwise, <c>false</c>.
        /// </value>
        /// <remarks>
        /// Upload operation will be canceled after finishing uploading current buffer.
        /// </remarks>
        public bool IsUploadCanceled { get; set; }

        /// <summary>
        /// Gets the number of uploaded bytes.
        /// </summary>
        public ulong UploadedBytes { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpUploadAsyncResult"/> class.
        /// </summary>
        /// <param name="asyncCallback">The async callback.</param>
        /// <param name="state">The state.</param>
        public SftpUploadAsyncResult(AsyncCallback asyncCallback, Object state)
            : base(asyncCallback, state)
        {
        }

        /// <summary>
        /// Updates asynchronous operation status information.
        /// </summary>
        /// <param name="uploadedBytes">Number of uploaded bytes.</param>
        internal void Update(ulong uploadedBytes)
        {
            this.UploadedBytes = uploadedBytes;
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\StatusCodes.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp
{
    public enum StatusCodes : uint
    {
        /// <summary>
        /// SSH_FX_OK
        /// </summary>
        Ok = 0,
        /// <summary>
        /// SSH_FX_EOF
        /// </summary>
        Eof = 1,
        /// <summary>
        /// SSH_FX_NO_SUCH_FILE
        /// </summary>
        NoSuchFile = 2,
        /// <summary>
        /// SSH_FX_PERMISSION_DENIED
        /// </summary>
        PermissionDenied = 3,
        /// <summary>
        /// SSH_FX_FAILURE
        /// </summary>
        Failure = 4,
        /// <summary>
        /// SSH_FX_BAD_MESSAGE
        /// </summary>
        BadMessage = 5,
        /// <summary>
        /// SSH_FX_NO_CONNECTION
        /// </summary>
        NoConnection = 6,
        /// <summary>
        /// SSH_FX_CONNECTION_LOST
        /// </summary>
        ConnectionLost = 7,
        /// <summary>
        /// SSH_FX_OP_UNSUPPORTED
        /// </summary>
        OperationUnsupported = 8,
        /// <summary>
        /// SSH_FX_INVALID_HANDLE
        /// </summary>
        InvalidHandle = 9,
        /// <summary>
        /// SSH_FX_NO_SUCH_PATH
        /// </summary>
        NoSuchPath = 10,
        /// <summary>
        /// SSH_FX_FILE_ALREADY_EXISTS
        /// </summary>
        FileAlreadyExists = 11,
        /// <summary>
        /// SSH_FX_WRITE_PROTECT
        /// </summary>
        WriteProtect = 12,
        /// <summary>
        /// SSH_FX_NO_MEDIA
        /// </summary>
        NoMedia = 13,
        /// <summary>
        /// SSH_FX_NO_SPACE_ON_FILESYSTEM
        /// </summary>
        NoSpaceOnFilesystem = 14,
        /// <summary>
        /// SSH_FX_QUOTA_EXCEEDED
        /// </summary>
        QuotaExceeded = 15,
        /// <summary>
        /// SSH_FX_UNKNOWN_PRINCIPAL
        /// </summary>
        UnknownPrincipal = 16,
        /// <summary>
        /// SSH_FX_LOCK_CONFLICT
        /// </summary>
        LockConflict = 17,
        /// <summary>
        /// SSH_FX_DIR_NOT_EMPTY
        /// </summary>
        DirNotEmpty = 18,
        /// <summary>
        /// SSH_FX_NOT_A_DIRECTORY
        /// </summary>
        NotDirectory = 19,
        /// <summary>
        /// SSH_FX_INVALID_FILENAME
        /// </summary>
        InvalidFilename = 20,
        /// <summary>
        /// SSH_FX_LINK_LOOP
        /// </summary>
        LinkLoop = 21,
        /// <summary>
        /// SSH_FX_CANNOT_DELETE
        /// </summary>
        CannotDelete = 22,
        /// <summary>
        /// SSH_FX_INVALID_PARAMETER
        /// </summary>
        InvalidParameter = 23,
        /// <summary>
        /// SSH_FX_FILE_IS_A_DIRECTORY
        /// </summary>
        FileIsADirectory = 24,
        /// <summary>
        /// SSH_FX_BYTE_RANGE_LOCK_CONFLICT
        /// </summary>
        ByteRangeLockConflict = 25,
        /// <summary>
        /// SSH_FX_BYTE_RANGE_LOCK_REFUSED
        /// </summary>
        ByteRangeLockRefused = 26,
        /// <summary>
        /// SSH_FX_DELETE_PENDING
        /// </summary>
        DeletePending = 27,
        /// <summary>
        /// SSH_FX_FILE_CORRUPT
        /// </summary>
        FileCorrupt = 28,
        /// <summary>
        /// SSH_FX_OWNER_INVALID
        /// </summary>
        OwnerInvalid = 29,
        /// <summary>
        /// SSH_FX_GROUP_INVALID
        /// </summary>
        GroupInvalid = 30,
        /// <summary>
        /// SSH_FX_NO_MATCHING_BYTE_RANGE_LOCK
        /// </summary>
        NoMatchingByteRangeLock = 31,
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpBlockRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpBlockRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Block; }
        }

        public byte[] Handle { get; private set; }

        public UInt64 Offset { get; private set; }

        public UInt64 Length { get; private set; }

        public UInt32 LockMask { get; private set; }

        public SftpBlockRequest(uint protocolVersion, uint requestId, byte[] handle, UInt64 offset, UInt64 length, UInt32 lockMask, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Handle = handle;
            this.Offset = offset;
            this.Length = length;
            this.LockMask = lockMask;
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Handle = this.ReadBinaryString();
            this.Offset = this.ReadUInt64();
            this.Length = this.ReadUInt64();
            this.LockMask = this.ReadUInt32();
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.WriteBinaryString(this.Handle);
            this.Write(this.Offset);
            this.Write(this.Length);
            this.Write(this.LockMask);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpCloseRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpCloseRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Close; }
        }

        public byte[] Handle { get; private set; }

        public SftpCloseRequest(uint protocolVersion, uint requestId, byte[] handle, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Handle = handle;
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Handle = this.ReadBinaryString();
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.WriteBinaryString(this.Handle);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpExtendedRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public abstract class SftpExtendedRequest : SftpRequest
    {
        public const string NAME = "posix-rename@openssh.com";

        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Extended; }
        }

        public abstract string Name { get; }

        public SftpExtendedRequest(uint protocolVersion, uint requestId, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.Name);
        }
    }
}
#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpFSetStatRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpFSetStatRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.FSetStat; }
        }

        public byte[] Handle { get; private set; }

        public SftpFileAttributes Attributes { get; private set; }

        public SftpFSetStatRequest(uint protocolVersion, uint requestId, byte[] handle, SftpFileAttributes attributes, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Handle = handle;
            this.Attributes = attributes;
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Handle = this.ReadBinaryString();
            this.Attributes = this.ReadAttributes();
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.WriteBinaryString(this.Handle);
            this.Write(this.Attributes);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpFStatRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpFStatRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.FStat; }
        }

        public byte[] Handle { get; private set; }

        public SftpFStatRequest(uint protocolVersion, uint requestId, byte[] handle, Action<SftpAttrsResponse> attrsAction, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Handle = handle;
            this.SetAction(attrsAction);
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Handle = this.ReadBinaryString();
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.WriteBinaryString(this.Handle);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpInitRequest.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Sftp.Requests
{
    public class SftpInitRequest : SftpMessage
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Init; }
        }

        public uint Version { get; private set; }

        public SftpInitRequest(uint version)
        {
            this.Version = version;
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Version = this.ReadUInt32();
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.Version);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpLinkRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpLinkRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Link; }
        }

        public string NewLinkPath { get; private set; }

        public string ExistingPath { get; private set; }

        public bool IsSymLink { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SftpLinkRequest" /> class.
        /// </summary>
        /// <param name="protocolVersion">The protocol version.</param>
        /// <param name="requestId">The request id.</param>
        /// <param name="newLinkPath">Specifies the path name of the new link to create.</param>
        /// <param name="existingPath">Specifies the path of a target object to which the newly created link will refer.  In the case of a symbolic link, this path may not exist.</param>
        /// <param name="isSymLink">if set to <c>false</c> the link should be a hard link, or a second directory entry referring to the same file or directory object.</param>
        /// <param name="statusAction">The status action.</param>
        public SftpLinkRequest(uint protocolVersion, uint requestId, string newLinkPath, string existingPath, bool isSymLink, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.NewLinkPath = newLinkPath;
            this.ExistingPath = existingPath;
            this.IsSymLink = isSymLink;
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.NewLinkPath = this.ReadString();
            this.ExistingPath = this.ReadString();
            this.IsSymLink = this.ReadBoolean();
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.NewLinkPath);
            this.Write(this.ExistingPath);
            this.Write(this.IsSymLink);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpLStatRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpLStatRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.LStat; }
        }

        public string Path { get; private set; }

        public Encoding Encoding { get; private set; }

        public SftpLStatRequest(uint protocolVersion, uint requestId, string path, Encoding encoding, Action<SftpAttrsResponse> attrsAction, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Path = path;
            this.Encoding = encoding;
            this.SetAction(attrsAction);
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Path = this.ReadString(this.Encoding);
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.Path, this.Encoding);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpMkDirRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpMkDirRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.MkDir; }
        }

        public string Path { get; private set; }

        public Encoding Encoding { get; private set; }

        public SftpFileAttributes Attributes { get; private set; }

        public SftpMkDirRequest(uint protocolVersion, uint requestId, string path, Encoding encoding, Action<SftpStatusResponse> statusAction)
            : this(protocolVersion, requestId, path, encoding, null, statusAction)
        {
        }

        public SftpMkDirRequest(uint protocolVersion, uint requestId, string path, Encoding encoding, SftpFileAttributes attributes, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Path = path;
            this.Encoding = encoding;
            this.Attributes = attributes;
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Path = this.ReadString(this.Encoding);
            this.Attributes = this.ReadAttributes();
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.Path, this.Encoding);
            this.Write(this.Attributes);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpOpenDirRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpOpenDirRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.OpenDir; }
        }

        public string Path { get; private set; }

        public Encoding Encoding { get; private set; }

        public SftpOpenDirRequest(uint protocolVersion, uint requestId, string path, Encoding encoding, Action<SftpHandleResponse> handleAction, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Path = path;
            this.Encoding = encoding;
            this.SetAction(handleAction);
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Path = this.ReadString(this.Encoding);
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.Path, this.Encoding);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpOpenRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpOpenRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Open; }
        }

        public string Filename { get; private set; }

        public Flags Flags { get; private set; }

        public SftpFileAttributes Attributes { get; private set; }

        public Encoding Encoding { get; private set; }

        public SftpOpenRequest(uint protocolVersion, uint requestId, string fileName, Encoding encoding, Flags flags, Action<SftpHandleResponse> handleAction, Action<SftpStatusResponse> statusAction)
            : this(protocolVersion, requestId, fileName, encoding, flags, new SftpFileAttributes(), handleAction, statusAction)
        {
        }

        public SftpOpenRequest(uint protocolVersion, uint requestId, string fileName, Encoding encoding, Flags flags, SftpFileAttributes attributes, Action<SftpHandleResponse> handleAction, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Filename = fileName;
            this.Flags = flags;
            this.Attributes = attributes;
            this.Encoding = encoding;

            this.SetAction(handleAction);
        }

        protected override void LoadData()
        {
            base.LoadData();
            throw new NotSupportedException();
        }

        protected override void SaveData()
        {
            base.SaveData();

            this.Write(this.Filename, this.Encoding);
            this.Write((uint)this.Flags);
            this.Write(this.Attributes);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpReadDirRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpReadDirRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.ReadDir; }
        }

        public byte[] Handle { get; private set; }

        public SftpReadDirRequest(uint protocolVersion, uint requestId, byte[] handle, Action<SftpNameResponse> nameAction, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Handle = handle;
            this.SetAction(nameAction);
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Handle = this.ReadBinaryString();
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.WriteBinaryString(this.Handle);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpReadLinkRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpReadLinkRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.ReadLink; }
        }

        public string Path { get; private set; }

        public Encoding Encoding { get; private set; }

        public SftpReadLinkRequest(uint protocolVersion, uint requestId, string path, Encoding encoding, Action<SftpNameResponse> nameAction, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Path = path;
            this.Encoding = encoding;
            this.SetAction(nameAction);
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Path = this.ReadString(this.Encoding);
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.Path, this.Encoding);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpReadRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpReadRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Read; }
        }

        public byte[] Handle { get; private set; }

        public UInt64 Offset { get; private set; }

        public UInt32 Length { get; private set; }

        public SftpReadRequest(uint protocolVersion, uint requestId, byte[] handle, UInt64 offset, UInt32 length, Action<SftpDataResponse> dataAction, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Handle = handle;
            this.Offset = offset;
            this.Length = length;
            this.SetAction(dataAction);
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Handle = this.ReadBinaryString();
            this.Offset = this.ReadUInt64();
            this.Length = this.ReadUInt32();
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.WriteBinaryString(this.Handle);
            this.Write(this.Offset);
            this.Write(this.Length);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpRealPathRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpRealPathRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.RealPath; }
        }

        public string Path { get; private set; }

        public Encoding Encoding { get; private set; }

        public SftpRealPathRequest(uint protocolVersion, uint requestId, string path, Encoding encoding, Action<SftpNameResponse> nameAction, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            if (nameAction == null)
                throw new ArgumentNullException("nameAction");
            if (statusAction == null)
                throw new ArgumentNullException("statusAction");

            this.Path = path;
            this.Encoding = encoding;
            this.SetAction(nameAction);
            
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.Path, this.Encoding);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpRemoveRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpRemoveRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Remove; }
        }

        public string Filename { get; private set; }

        public Encoding Encoding { get; private set; }

        public SftpRemoveRequest(uint protocolVersion, uint requestId, string filename, Encoding encoding, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Filename = filename;
            this.Encoding = encoding;
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Filename = this.ReadString(this.Encoding);
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.Filename, this.Encoding);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpRenameRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpRenameRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Rename; }
        }

        public string OldPath { get; private set; }

        public string NewPath { get; private set; }

        public Encoding Encoding { get; private set; }

        public SftpRenameRequest(uint protocolVersion, uint requestId, string oldPath, string newPath, Encoding encoding, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.OldPath = oldPath;
            this.NewPath = newPath;
            this.Encoding = encoding;
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.OldPath = this.ReadString(this.Encoding);
            this.NewPath = this.ReadString(this.Encoding);
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.OldPath, this.Encoding);
            this.Write(this.NewPath, this.Encoding);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public abstract class SftpRequest : SftpMessage
    {
        private readonly Action<SftpStatusResponse> _statusAction;
        private Action<SftpAttrsResponse> _attrsAction;
        private Action<SftpDataResponse> _dataAction;
        private Action<SftpExtendedReplyResponse> _extendedReplyAction;
        private Action<SftpHandleResponse> _handleAction;
        private Action<SftpNameResponse> _nameAction;

        public uint RequestId { get; private set; }
        
        public uint ProtocolVersion { get; private set; }

        public SftpRequest(uint protocolVersion, uint requestId, Action<SftpStatusResponse> statusAction)
        {
            this.RequestId = requestId;
            this.ProtocolVersion = protocolVersion;
            this._statusAction = statusAction;
        }

        public void Complete(SftpResponse response)
        {
            if (response is SftpStatusResponse)
            {
                this._statusAction(response as SftpStatusResponse);
            }
            else if (response is SftpAttrsResponse)
            {
                this._attrsAction(response as SftpAttrsResponse);
            }
            else if (response is SftpDataResponse)
            {
                this._dataAction(response as SftpDataResponse);
            }
            else if (response is SftpExtendedReplyResponse)
            {
                this._extendedReplyAction(response as SftpExtendedReplyResponse);
            }
            else if (response is SftpHandleResponse)
            {
                this._handleAction(response as SftpHandleResponse);
            }
            else if (response is SftpNameResponse)
            {
                this._nameAction(response as SftpNameResponse);
            }
            else
            {
                throw new InvalidOperationException(string.Format("Response of type '{0}' is not expected.", response.GetType().Name));
            }
        }

        protected void SetAction(Action<SftpAttrsResponse> action)
        {
            this._attrsAction = action;
        }

        protected void SetAction(Action<SftpDataResponse> action)
        {
            this._dataAction = action;
        }

        protected void SetAction(Action<SftpExtendedReplyResponse> action)
        {
            this._extendedReplyAction = action;
        }

        protected void SetAction(Action<SftpHandleResponse> action)
        {
            this._handleAction = action;
        }

        protected void SetAction(Action<SftpNameResponse> action)
        {
            this._nameAction = action;
        }

        protected override void LoadData()
        {
            throw new InvalidOperationException("Request cannot be saved.");
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.RequestId);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpRmDirRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpRmDirRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.RmDir; }
        }

        public string Path { get; private set; }

        public Encoding Encoding { get; private set; }

        public SftpRmDirRequest(uint protocolVersion, uint requestId, string path, Encoding encoding, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Path = path;
            this.Encoding = encoding;
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Path = this.ReadString(this.Encoding);
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.Path, this.Encoding);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpSetStatRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpSetStatRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.SetStat; }
        }

        public string Path { get; private set; }

        public Encoding Encoding { get; private set; }

        public SftpFileAttributes Attributes { get; private set; }

        public SftpSetStatRequest(uint protocolVersion, uint requestId, string path, Encoding encoding, SftpFileAttributes attributes, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Path = path;
            this.Encoding = encoding;
            this.Attributes = attributes;
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Path = this.ReadString(this.Encoding);
            this.Attributes = this.ReadAttributes();
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.Path, this.Encoding);
            this.Write(this.Attributes);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpStatRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpStatRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Stat; }
        }

        public string Path { get; private set; }

        public Encoding Encoding { get; private set; }

        public SftpStatRequest(uint protocolVersion, uint requestId, string path, Encoding encoding, Action<SftpAttrsResponse> attrsAction, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Path = path;
            this.Encoding = encoding;
            this.SetAction(attrsAction);
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Path = this.ReadString(this.Encoding);
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.Path, this.Encoding);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpSymLinkRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpSymLinkRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.SymLink; }
        }

        public string NewLinkPath { get; set; }

        public string ExistingPath { get; set; }

        public Encoding Encoding { get; set; }

        public SftpSymLinkRequest(uint protocolVersion, uint requestId, string newLinkPath, string existingPath, Encoding encoding, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.NewLinkPath = newLinkPath;
            this.ExistingPath = existingPath;
            this.Encoding = encoding;
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.NewLinkPath = this.ReadString(this.Encoding);
            this.ExistingPath = this.ReadString(this.Encoding);
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.NewLinkPath, this.Encoding);
            this.Write(this.ExistingPath, this.Encoding);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpUnblockRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpUnblockRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Block; }
        }

        public byte[] Handle { get; private set; }

        public UInt64 Offset { get; private set; }

        public UInt64 Length { get; private set; }

        public SftpUnblockRequest(uint protocolVersion, uint requestId, byte[] handle, UInt64 offset, UInt64 length, UInt32 lockMask, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Handle = handle;
            this.Offset = offset;
            this.Length = length;
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Handle = this.ReadBinaryString();
            this.Offset = this.ReadUInt64();
            this.Length = this.ReadUInt64();
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.WriteBinaryString(this.Handle);
            this.Write(this.Offset);
            this.Write(this.Length);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\SftpWriteRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class SftpWriteRequest : SftpRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Write; }
        }

        public byte[] Handle { get; private set; }

        public UInt64 Offset { get; private set; }

        public byte[] Data { get; private set; }

        public SftpWriteRequest(uint protocolVersion, uint requestId, byte[] handle, UInt64 offset, byte[] data, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Handle = handle;
            this.Offset = offset;
            this.Data = data;
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Handle = this.ReadBinaryString();
            this.Offset = this.ReadUInt64();
            this.Data = this.ReadBinaryString();
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.WriteBinaryString(this.Handle);
            this.Write(this.Offset);
            this.WriteBinaryString(this.Data);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\ExtendedRequests\FStatVfsRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class FStatVfsRequest : SftpExtendedRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Extended; }
        }

        public override string Name
        {
            get { return "fstatvfs@openssh.com"; }
        }

        public byte[] Handle { get; private set; }

        public FStatVfsRequest(uint protocolVersion, uint requestId, byte[] handle, Action<SftpExtendedReplyResponse> extendedAction, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Handle = handle;
            this.SetAction(extendedAction);
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.WriteBinaryString(this.Handle);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Requests\ExtendedRequests\HardLinkRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class HardLinkRequest : SftpExtendedRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Extended; }
        }
        
        public override string Name
        {
            get { return "hardlink@openssh.com"; }
        }

        public string OldPath { get; private set; }

        public string NewPath { get; private set; }

        public HardLinkRequest(uint protocolVersion, uint requestId, string oldPath, string newPath, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.OldPath = oldPath;
            this.NewPath = newPath;
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.OldPath);
            this.Write(this.NewPath);
        }
    }
}
#endif
// file ...\X\Renci.SshNet\Sftp\Requests\ExtendedRequests\PosixRenameRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class PosixRenameRequest : SftpExtendedRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Extended; }
        }
        
        public override string Name
        {
            get { return "posix-rename@openssh.com"; }
        }

        public string OldPath { get; private set; }

        public string NewPath { get; private set; }

        public Encoding Encoding { get; private set; }

        public PosixRenameRequest(uint protocolVersion, uint requestId, string oldPath, string newPath, Encoding encoding, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.OldPath = oldPath;
            this.NewPath = newPath;
            this.Encoding = encoding;
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.OldPath, this.Encoding);
            this.Write(this.NewPath, this.Encoding);
        }
    }
}
#endif
// file ...\X\Renci.SshNet\Sftp\Requests\ExtendedRequests\StatVfsRequest.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Requests
{
    public class StatVfsRequest : SftpExtendedRequest
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Extended; }
        }

        public override string Name
        {
            get { return "statvfs@openssh.com"; }
        }

        public string Path { get; private set; }

        public Encoding Encoding { get; private set; }

        public StatVfsRequest(uint protocolVersion, uint requestId, string path, Encoding encoding, Action<SftpExtendedReplyResponse> extendedAction, Action<SftpStatusResponse> statusAction)
            : base(protocolVersion, requestId, statusAction)
        {
            this.Path = path;
            this.Encoding = encoding;
            this.SetAction(extendedAction);
        }

        protected override void SaveData()
        {
            base.SaveData();
            this.Write(this.Path, this.Encoding);
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Responses\SftpAttrsResponse.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Sftp.Responses
{
    public class SftpAttrsResponse : SftpResponse
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Attrs; }
        }

        public SftpFileAttributes Attributes { get; private set; }

        public SftpAttrsResponse(uint protocolVersion)
            : base(protocolVersion)
        {
        }

        protected override void LoadData()
        {
            base.LoadData();
            this.Attributes = this.ReadAttributes();
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Responses\SftpDataResponse.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Sftp.Responses
{
    public class SftpDataResponse : SftpResponse
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Data; }
        }

        public byte[] Data { get; set; }

        public bool IsEof { get; set; }

        public SftpDataResponse(uint protocolVersion)
            : base(protocolVersion)
        {
        }

        protected override void LoadData()
        {
            base.LoadData();
            
            this.Data = this.ReadBinaryString();

            if (!this.IsEndOfData)
            {
                this.IsEof = this.ReadBoolean();
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Responses\SftpExtendedReplyResponse.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Responses
{
    public class SftpExtendedReplyResponse : SftpResponse
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.ExtendedReply; }
        }

        public SftpExtendedReplyResponse(uint protocolVersion)
            : base(protocolVersion)
        {
        }

        public T GetReply<T>() where T : SshData, new()
        {
            return this.OfType<T>();
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Responses\SftpHandleResponse.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Sftp.Responses
{
    public class SftpHandleResponse : SftpResponse
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Handle; }
        }

        public byte[] Handle { get; private set; }

        public SftpHandleResponse(uint protocolVersion)
            : base(protocolVersion)
        {
        }

        protected override void LoadData()
        {
            base.LoadData();
            
            this.Handle = this.ReadBinaryString();
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Responses\SftpNameResponse.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Responses
{
    public class SftpNameResponse : SftpResponse
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Name; }
        }

        public uint Count { get; private set; }

        public Encoding Encoding { get; private set; }

        public KeyValuePair<string, SftpFileAttributes>[] Files { get; private set; }

        public SftpNameResponse(uint protocolVersion, Encoding encoding)
            : base(protocolVersion)
        {
            this.Files = new KeyValuePair<string, SftpFileAttributes>[0];
            this.Encoding = encoding;
        }

        protected override void LoadData()
        {
            base.LoadData();
            
            this.Count = this.ReadUInt32();
            this.Files = new KeyValuePair<string, SftpFileAttributes>[this.Count];
            
            for (int i = 0; i < this.Count; i++)
            {
                var fileName = this.ReadString(this.Encoding);
                this.ReadString();   //  This field value has meaningless information
                var attributes = this.ReadAttributes();
                this.Files[i] = new KeyValuePair<string, SftpFileAttributes>(fileName, attributes);
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Responses\SftpResponse.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Responses
{
    public abstract class SftpResponse : SftpMessage
    {
        public uint ResponseId { get; private set; }

        public uint ProtocolVersion { get; private set; }

        public SftpResponse(uint protocolVersion)
        {
            this.ProtocolVersion = protocolVersion;
        }

        protected override void LoadData()
        {
            base.LoadData();
            
            this.ResponseId = this.ReadUInt32();
        }

        protected override void SaveData()
        {
            throw new InvalidOperationException("Response cannot be saved.");
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Responses\SftpStatusResponse.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Sftp.Responses
{
    public class SftpStatusResponse : SftpResponse
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Status; }
        }

        public SftpStatusResponse(uint protocolVersion)
            : base(protocolVersion)
        {
        }

        public StatusCodes StatusCode { get; private set; }

        public string ErrorMessage { get; private set; }

        public string Language { get; private set; }

        protected override void LoadData()
        {
            base.LoadData();

            this.StatusCode = (StatusCodes)this.ReadUInt32();

            if (this.ProtocolVersion < 3)
            {
                return;
            }

            if (!this.IsEndOfData)
            {
                this.ErrorMessage = this.ReadString();
                this.Language = this.ReadString();
            }
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Responses\SftpVersionResponse.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Responses
{
    public class SftpVersionResponse : SftpMessage
    {
        public override SftpMessageTypes SftpMessageType
        {
            get { return SftpMessageTypes.Version; }
        }

        public uint Version { get; private set; }

        public IDictionary<string, string> Extentions { get; private set; }

        protected override void LoadData()
        {
            base.LoadData();
            this.Version = this.ReadUInt32();
            this.Extentions = this.ReadExtensionPair();
        }

        protected override void SaveData()
        {
            throw new InvalidOperationException();
        }

    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Responses\StatVfsResponse.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Sftp.Responses
{
    public class StatVfsResponse : SftpExtendedReplyResponse
    {
        public SftpFileSytemInformation Information { get; private set; }

        public StatVfsResponse()
            : base(0)
        {
        }

        protected override void LoadData()
        {
            base.LoadData();

            this.Information = new SftpFileSytemInformation(this.ReadUInt64(), this.ReadUInt64(),
                                                                     this.ReadUInt64(), this.ReadUInt64(),
                                                                     this.ReadUInt64(), this.ReadUInt64(),
                                                                     this.ReadUInt64(), this.ReadUInt64(),
                                                                     this.ReadUInt64(), this.ReadUInt64(),
                                                                     this.ReadUInt64());
        }
    }
}
#endif
// file ...\X\Renci.SshNet\Sftp\Responses\ExtendedReplies\ExtendedReplyInfo.cs
#if !MOBILE && !CORE

namespace Renci.SshNet.Sftp.Responses
{
    public abstract class ExtendedReplyInfo : SshData
    {
        protected override void LoadData()
        {
            //  Read Message Type
            var messageType = this.ReadByte();

            //  Read Response ID
            var responseId = this.ReadUInt32();
        }

        protected override void SaveData()
        {
            throw new NotImplementedException();
        }
    }
}

#endif
// file ...\X\Renci.SshNet\Sftp\Responses\ExtendedReplies\StatVfsReplyInfo.cs
#if !MOBILE && !CORE
namespace Renci.SshNet.Sftp.Responses
{
    public class StatVfsReplyInfo : ExtendedReplyInfo
    {
        public SftpFileSytemInformation Information { get; private set; }

        protected override void LoadData()
        {
            base.LoadData();

            this.Information = new SftpFileSytemInformation(this.ReadUInt64(), this.ReadUInt64(),
                                                                     this.ReadUInt64(), this.ReadUInt64(),
                                                                     this.ReadUInt64(), this.ReadUInt64(),
                                                                     this.ReadUInt64(), this.ReadUInt64(),
                                                                     this.ReadUInt64(), this.ReadUInt64(),
                                                                     this.ReadUInt64());
        }

        protected override void SaveData()
        {
            throw new System.NotImplementedException();
        }
    }
}
#endif
